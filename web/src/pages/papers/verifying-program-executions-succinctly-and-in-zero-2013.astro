---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2013/507';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'SNARKs for C: Verifying Program Executions Succinctly and in Zero Knowledge';
const AUTHORS_HTML = 'Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, Madars Virza';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">An argument system for NP is a proof system that allows efficient verification of NP statements, given proofs produced by an untrusted yet computationally-bounded prover. Such a system is non-interactive and publicly-verifiable if, after a trusted party publishes a proving key and a verification key, anyone can use the proving key to generate non-interactive proofs for adaptively-chosen NP statements, and proofs can be verified by anyone by using the verification key.

We present an implementation of a publicly-verifiable non-interactive argument system for NP. The system, moreover, is a zero-knowledge proof-of-knowledge. It directly proves correct executions of programs on TinyRAM, a random-access machine tailored for efficient verification of nondeterministic computations. Given a program $P$ and time bound T, the system allows for proving correct execution of $P$, on any input $x$, for up to T steps, after a one-time setup requiring $\\tilde{O}(|P| T)$ cryptographic operations. An honest prover requires $\\tilde{O}(|P| \\cdot T)$ cryptographic operations to generate such a proof, while proof verification can be performed with only $O(|x|)$ cryptographic operations. This system can be used to prove the correct execution of C programs, using our TinyRAM port of the GCC compiler.

This yields a zero-knowledge Succinct Non-interactive ARgument of Knowledge (zk-SNARK) for program executions in the preprocessing model -- a powerful solution for delegating NP computations, with several features not achieved by previously-implemented primitives.

Our approach builds on recent theoretical progress in the area. We present efficiency improvements and implementations of two main ingredients:

* Given a C program, we produce a circuit whose satisfiability encodes the correctness of execution of the program. Leveraging nondeterminism, the generated circuit&#x27;s size is merely quasilinear in the size of the computation. In particular, we efficiently handle arbitrary and data-dependent loops, control flow, and memory accesses. This is in contrast with existing \`\`circuit generators&#x27;&#x27;, which in the general case produce circuits of quadratic size.

* Given a linear PCP for verifying satisfiability of circuits, we produce a corresponding SNARK. We construct such a linear PCP (which, moreover, is zero-knowledge and very efficient) by building on and improving on recent work on quadratic arithmetic programs.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> computationally-sound proofs &middot; succinct arguments &middot; zero-knowledge &middot; delegation of computation</p>
    </section>

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8">1.2 Approach Motivation</h3>

    <p class="text-gray-300">It would be wonderful to have efficient and generic implementations of SNARGs without any expensive preprocessing. (I.e., have the generator G run in  <span class="math">\\operatorname{poly}(\\lambda)</span>  instead of  <span class="math">\\operatorname{poly}(|C|)</span>  cryptographic operations). The two known approaches to constructing such SNARGs are Micali's &quot;computationally-sound proofs&quot; [Mic00], and the bootstrapping techniques of Bitansky et al. [BCCT13]. Algorithmically, both are complex constructions: the former requires probabilistically-checkable proofs (PCPs) [BFLS91] (which remain concretely expensive despite recent advances [BGH+05, BS08, Din07, MR08, BCGT13b]), and the latter uses recursive proof-composition which adds a (quasilinear yet) concretely large overhead.<sup>4</sup></p>

    <p class="text-gray-300">Thus, it seems wise to first investigate efficient implementations of SNARGs in the preprocessing model, which is a less demanding model because it allows G to conduct a one-time expensive computation &quot;as a setup phase&quot;. Despite the expensive preprocessing, this model is potentially useful for many applications: while the generator G does require a lot of work to set up the system's public parameters (which only depend on the given circuit G but not the input to G), this work can be subsequently amortized over many succinct proof verifications (where each proof is with respect to a new, adaptively-chosen, input to G).</p>

    <p class="text-gray-300">In this work we focus on the preprocessing model, due to the simpler and tighter constructions known in it. Recent works [Gro10a, Lip12, GGPR13, BCI <span class="math">^+</span> 13] constructed zk-SNARKs based on knowledge-of-exponent assumptions [Dam92, HT98, BP04] in bilinear groups, and all of these constructions achieved the attractive feature of having proofs consisting of only O(1) group elements and of having verification via simple arithmetic circuits that are linear in the size of the input for the circuit.</p>

    <p class="text-gray-300">In this vein, Bitansky et al. [BCI<sup>+</sup>13] gave a general technique for constructing zk-SNARKs. First, they define a <em>linear PCP</em> to be one where the honest proof oracle is a linear function (over an underlying field), and soundness is required to hold <em>only</em> for linear proof oracles. Then, they show a transformation (also based</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;4</sup>Moreover, giving up public verifiability does not seem to allow for significantly simpler constructions. Concretely, known constructions of privately-verifiable SNARGs (without preprocessing) [BCCT12, DFH12, GLR11, BC12] rely, not only on PCPs, but also on private-information retrieval or fully-homomorphic encryption, both of which are expensive in practice.</p>

    <p class="text-gray-300">on knowledge-of-exponent assumptions) from any linear PCP with a <em>low-degree verifier</em> to a SNARK; also, if the linear PCP is honest-verifier zero-knowledge (HVZK), then the resulting SNARK is zero knowledge.</p>

    <p class="text-gray-300">Efficient HVZK linear PCPs for circuit satisfiability, with low-degree verifiers, are implied by the work of Gennaro et al. [GGPR13] on <em>quadratic-span programs</em> (QSPs) and <em>quadratic arithmetic programs</em> (QAPs). Moreover, the work of Ben-Sasson et al. [BCGT13a] implies that random-access machine computations can be efficiently reduced to circuit satisfiability. Combining these ingredients, one obtains a theoretically simple and attractive route for constructing zk-SNARKs. As always, bringing theory to practice requires significant additional insights and improvements, and tackling these is the goal of our work.</p>

      <h3 id="sec-1.3" class="text-xl font-semibold mt-8">1.3 Contributions</h3>

    <p class="text-gray-300">In this work we present an implementation of a zk-SNARK (i.e., a non-interactive argument system for NP with the properties of zero knowledge, proof of knowledge, and succinct verification in the preprocessing model). Moreover, our implementation efficiently supports NP statements expressed as the correct execution of a program on a random-access machine or (via a compiler we wrote) expressed as the correct execution of a C program. Our contributions can be summarized as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verifying circuit satisfiability via linear PCPs. We obtain an implementation of zk-SNARKs for (arithmetic) circuit satisfiability with essentially-optimal asymptotic efficiency: linear-time generator, quasilinear-time prover, and linear-time verifier. Moreover, proofs consist of only 12 group elements (a total of 2576 bits for 80-bit security), independently of the circuit C or the input x to C.</li>
    </ol>

    <p class="text-gray-300">Our approach consists of two steps. First, we optimized and implemented the transformation of Bitansky et al. [BCI<sup>+</sup>13]; our optimizations rely on multi-exponentiation algorithms (see [Ber02] and references therein) and on a specialized choice of elliptic curve. Second, by building on the work on quadratic arithmetic programs (QAPs) of Gennaro et al. [GGPR13] and by leveraging algebraic structure of a carefully-chosen field, we give an efficient implementation of a linear PCP with a low-degree verifier. When verifying that  <span class="math">x \\in \\mathcal{L}_C</span> , our linear PCP has 5 queries of 2|C| field elements each; each query can be generated in linear time; the prover can compute the linear proof oracle via an arithmetic circuit of size  <span class="math">O(|C|\\log|C|)</span>  and depth  <span class="math">O(\\log|C|)</span> ; the answers to the 5 queries can be verified with O(|x|) field operations.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>From correctness of program execution to circuit satisfiability. The SNARKs generated by the previous transformation are for proving the satisfiability of a given (arithmetic) circuit. However, programs are easier to write using high-level programming languages, like C, and it is often not realistic to require an arbitrary application to already provide a circuit encoding the NP statement of interest. We address this problem by providing a &quot;circuit generator&quot; that differs significantly and qualitatively from all previous implementations of circuit generators (e.g., Fairplay [MNPS04, BDNP08]): it leverages nondeterminism to reduce the size of the output circuit. Specifically, previous circuit generators produce circuits of  <span class="math">O(T^2)</span>  size for T-step computations in the worst case, whereas our generator produces circuits of only  <span class="math">O(T \\log T)</span>  size.<sup>5</sup> In more detail, our solution to the circuit generation problem is as follows:</li>
    </ol></li>
      <li>(i) We design a minimalistic random-access machine, called TinyRAM. It supports nondeterministic witnesses, which are supplied via a designated auxiliary-input tape.</li>
      <li>(ii) We obtain a transformation that takes as input a TinyRAM program  <span class="math">\\mathbf{P}</span>  and a time bound T and outputs a circuit whose satisfiability encodes the correct execution of  <span class="math">\\mathbf{P}</span>  for up to T steps. Building on the approach of Ben-Sasson et al. [BCGT13a], our transformation greatly improves efficiency by leveraging field operations and nondeterminism in order to verify several types of crucial (boolean) computations via smaller arithmetic circuits. We implemented our transformation.</li>
    </ul>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;5</sup>See Appendix C (especially C.2) for an extended discussion of previous circuit generators.</p>

    <p class="text-gray-300">(iii) We complement the above transformation with a GCC backend, for compiling programs written in a subset of C into TinyRAM assembly. This compiler provides a convenient way to obtain TinyRAM programs for problems of interest. Crucially, we can efficiently support arbitrary and data-dependent loops, control flow, and memory accesses.</p>

    <p class="text-gray-300">Our choice of architecture for TinyRAM strikes a balance between allowing for efficient compilation of programs into assembly code, and the need to design small circuits for verifying correctness of the transition function of the machine.</p>

    <p class="text-gray-300">Delegation for NP programs. Combined, our contributions yield a system for verifying program executions succinctly and in zero knowledge. (See Figures <a href="#page-6-0">1</a> to <a href="#page-6-1">2</a> on the next page for a high-level system overview.)</p>

    <p class="text-gray-300">In particular, our contributions provide a solution for non-interactively delegating arbitrary NP computations, also in a way that does not compromise the privacy of any input that the untrusted worker contributes to the computation. Previous implementation work did not achieve many of the features enjoyed by our implementation. (See Appendix <a href="#page-37-0">C</a> for a comparison with prior implementation work.)</p>

    <p class="text-gray-300">Reusable components. Our contributions are independent in that each can be useful without the others:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If one designed a linear PCP for circuits that is more efficient than ours, it could be plugged into our transformation to SNARKs. Moreover, such a linear PCP would also benefit from our circuit generator for TinyRAM programs, and our compiler from C programs to TinyRAM assembly.</li>
      <li>If one had an NP problem already represented via arithmetic circuit satisfiability (for instance, this is simple to achieve when considering &quot;structured&quot; computational problems such as evaluating FFTs) then there is no need to reduce from C (or TinyRAM) programs, so one could directly invoke our zk-SNARK.</li>
      <li>Our reduction from C programs to circuit satisfiability can be used in conjunction with other proof systems built for circuit satisfiability (or other related algebraic satisfaction problems). For instance, it can be used with many recent constructions of non-interactive zero-knowledge proofs <a href="#page-50-6">[GOS06a,</a> <a href="#page-50-7">GOS06b,</a> <a href="#page-48-12">AF07,</a> <a href="#page-51-10">Gro09,</a> <a href="#page-51-6">Gro10a,</a> <a href="#page-51-11">Gro10b]</a>.</li>
    </ul>

    <p class="text-gray-300">On asymptotic vs. concrete efficiency. In our discussion, we describe both the <em>asymptotic complexity</em> of abstract <em>algorithms</em>, and the <em>concrete complexity</em> (measured in seconds or CPU cycles) of concrete <em>implementations</em>. Concrete implementations are upper-bounded by computer memory size (and ultimately, the computational capacity of the universe), and thus their asymptotic behavior is ill-defined. Nonetheless, for conciseness, we will at times refer to the asymptotic complexity (e.g., &quot;quasilinear&quot;) of an implementation, by which we mean the asymptotic complexity of the implemented algorithm. Since the constants involved are (in our case) small, the asymptotic behavior indeed &quot;kicks in&quot; early enough for this to be a useful aid for understanding concrete complexity.</p>

      <h3 id="sec-1.4" class="text-xl font-semibold mt-8">1.4 Roadmap</h3>

    <p class="text-gray-300">In Section <a href="#page-7-0">2</a> we discuss in more detail how we reduce correctness of program execution to circuit satisfiability. In Section <a href="#page-20-0">3</a> we discuss in more detail how we verify circuit satisfiability via linear PCPs. In Section <a href="#page-27-0">4</a> we provide a combined system evaluation. Definitions and other details appear in the appendices, and appropriate pointers will be given throughout the paper.</p>

    <p class="text-gray-300">    <img src="_page_6_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 1: Offline phase (once). The key generator computes a (long) proving key and a (short) verification key, respectively for proving and verifying correct (nondeterministic) computations of a given TinyRAM program, for at most a given number of time steps on primary inputs of a given size. Our compiler can be used to obtain TinyRAM programs from C programs.</p>

    <p class="text-gray-300">    <img src="_page_6_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 2: Online phase (any number of times). The prover sends a non-interactive publiclyverifiable proof to a verifier, who can check the proof with only a linear number of cryptographic operations in the primary input size. This phase can be repeated any number of times, each time for a different input to the program.</p>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 From Correctness of Program Execution to Circuit Satisfiability</h2>

    <p class="text-gray-300">As summarized in Section <a href="#page-4-0">1.3,</a> we implemented an <em>efficient</em> transformation that reduces correctness of program execution to circuit satisfiabiliy. The following gives further design and performance details about this transformation. Concretely, in Section <a href="#page-7-1">2.1</a> we motivate and discuss our choice of architecture, TinyRAM. Then, in Section <a href="#page-9-0">2.2,</a> we discuss implementation and performance of our compiler from C to TinyRAM assembly. Finally, in Section <a href="#page-13-0">2.3,</a> we discuss implementation and performance of our reduction from the correctness of TinyRAM assembly to circuit satisfiability.</p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 The TinyRAM Architecture</h3>

    <p class="text-gray-300">To reason about correctness of program executions, we first need to fix a specific random-access machine. An attractive choice is to pick the instruction set architecture (ISA) of some existing, well-supported family of CPUs (e.g., x86 or ARM). We could then reuse existing tools and software written for those CPUs. This is possible in principle.</p>

    <p class="text-gray-300">However, the design of CPUs typically focuses on efficient ways of getting data and code, at the right time, to the different executions units of the CPU, with the goal of maximizing utilization of these units. This is achieved by complex mechanisms whose size can dwarf the <em>functional core</em> circuitry (execution units, register file, instruction decoding, and so on). Thus, modern CPUs afford, and employ, large and rich instruction sets. As explained next, the efficiency considerations are very different in our context.</p>

    <p class="text-gray-300">Executing vs. verifying. CPUs and their ISAs are optimized for fast <em>execution</em> of programs. However, we are interested in fast <em>verification</em> of (alleged) past executions. In our setting, the computation <em>has already been executed</em> and we possess a trace of this execution, giving the state of the processor (registers and flags) at every time step. Our goal is to efficiently verify the correctness of the trace: that every state in the trace follows from the preceding one.</p>

    <p class="text-gray-300">This means that values that are expensive to produce during the execution become readily available for verification in the trace. For example, in real CPUs, reading from external memory is relatively slow and a large fraction of the circuitry is dedicated to caching data. However, in the trace, the result of a load from memory is readily seen in the processor state at the end of the instruction's execution; thus the need for caches is moot. Similarly, modern CPUs use complicated speculative-execution and branch-prediction mechanisms to keep their execution pipelines full; but a trace verifier going down the trace can &quot;peek into the future&quot; and readily observe control flow.</p>

    <p class="text-gray-300">The elimination of the above mechanisms, and many others, affects the ISA. In particular, it means that the aforementioned functional core circuitry dominates cost. This leads to the next consideration.</p>

    <p class="text-gray-300">Transition function complexity. We are ultimately interested in carrying out the verification of a trace via a circuit, so we wish to optimize the circuit complexity of the <em>transition function</em> of the ISA: the size of the smallest circuit that, given two adjacent states in the trace, verifies that the transition between the two indeed respects the ISA specification.<a href="#page-7-2">6</a></p>

    <p class="text-gray-300">We thus seek an ISA that strikes a balance between two opposing requirements: (1) the need for a transition function of small circuit complexity and (2) the need to produce small and fast machine code, in particular when compiling from high-level programming languages. Rich architectures allow for smaller code and shorter execution trace but have transition functions of higher circuit complexity, while minimalistic architectures require longer machine code and longer execution traces, but enjoy transition functions with smaller circuit complexity.</p>

    <p class="text-gray-300"><sup>6</sup>This does not include the (crucial) task of checking the correctness of values loaded from random-access memory. Memory consistency is efficiently handled separately; see Section <a href="#page-13-0">2.3.</a></p>

    <p class="text-gray-300">Modern ISAs designed for general purpose CPUs (such as x86) are complex instruction set computer (CISC) machines: they support many elaborate instructions (e.g., a round of AES [Gue12]) and addressing modes. Less rich ISAs are reduced instruction set computer (RISC) machines designed for devices like smartphones (ARM) and embedded microcontrollers (Atmel AVR). Yet, even these &quot;simple&quot; ISAs are quite rich: they support many addressing modes, many conditional branches, floating point arithmetic, instructions for parallel execution, and so on. For example, the ARM architecture has more than 35 SIMD instructions for addition and subtraction alone [ARM12]; also, even 8-bit versions of the Atmel AVR family support as much as 25 different conditional branch instructions alone [ATM10].</p>

    <p class="text-gray-300">In sum, we seek a minimal ISA that enables us to design a transition function with small circuit complexity, and yet allows reasonable overheads in code size and execution time (relative to richer ISAs).</p>

    <p class="text-gray-300"><strong>A custom ISA.</strong> In light of the above, we designed an instruction set architecture, named TinyRAM, that is tailored for our setting. TinyRAM is a minimalistic RISC random-access machine with a Harvard architecture and word-addressable random-access memory. It has two parameters: the <em>word size</em>, denoted W, and the <em>number of registers</em>, denoted K. (When we wish to make this explicit, we write TinyRAM <span class="math">_{W,K}</span> .) The global state of the machine at any time consists of:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\bullet</span>  the program counter, denoted pc; it consists of W bits;</li>
      <li>K general-purpose registers, denoted  <span class="math">r0, r1, \\ldots, r(K-1)</span> , each consisting of W bits;</li>
      <li>the (condition) flag, denoted flag; it consists of a single bit; and</li>
      <li>memory, which is a linear array of  <span class="math">2^W</span>  words of W bits each.</li>
    </ul>

    <p class="text-gray-300">In addition, the machine has two <em>input tapes</em>, each containing a string of W-bit words. Each tape can be read sequentially in one direction only. The first input tape is for the <em>primary input</em>, denoted x; the second input tape is for the <em>auxiliary input</em>, denoted w. We treat the primary input as given, and the auxiliary input as nondeterministic advice. (See Definition 2.1 below.)</p>

    <p class="text-gray-300">We carefully selected the instructions of TinyRAM so to support relatively efficient compilation from high-level programming languages (like C), as discussed in Section 2.2, and, furthermore, allow for small circuits implementing its transition function (and other checks), as discussed in Section 2.3. Briefly, the instruction set of TinyRAM includes simple load and store instructions for accessing random-access memory, as well as simple integer, shift, logical, compare, move, and jump instructions. TinyRAM can efficiently implement complex control flow, loops, subroutines, recursion, and so on. Complicated instructions, such as floating-point arithmetic, are not directly supported and can be implemented &quot;in software&quot; by TinyRAM programs. Supporting only fairly simple load and store operations is important for efficiently verifying consistency of random-access memory; see Section 2.3.</p>

    <p class="text-gray-300">In keeping with the setting of verifying computation, the only input to TinyRAM programs is via its two input tapes, and the only output is via an accept instruction, which also terminates execution.<sup>7</sup></p>

    <p class="text-gray-300">So far we have only informally discussed &quot;correctness of TinyRAM program execution&quot;. This notion is formalized by defining a TinyRAM universal language.</p>

    <p class="text-gray-300"><strong>Definition 2.1.</strong> Fix the word size W and number of registers K. Let  <span class="math">\\mathbf{P}</span>  be a TinyRAM <span class="math">_{W,K}</span>  program, let x and w be strings of W-bit words. We say that  <span class="math">\\mathbf{P}(x,w)</span>  accepts in T steps if  <span class="math">\\mathbf{P}</span> , with x as primary input and w as auxiliary input, executes the instruction accept in step T.</p>

    <p class="text-gray-300">The TinyRAM universal language is  <span class="math">\\mathcal{L}_U = \\bigcup_{W,K} \\mathcal{L}_{W,K}</span> , where  <span class="math">\\mathcal{L}_{W,K}</span>  consists of the triples  <span class="math">(\\mathbf{P}, x, T)</span>  where  <span class="math">\\mathbf{P}</span>  is a TinyRAM<sub>W,K</sub> program, x is a string of W-bit words, and T is a time bound, such that there exists a string w of W-bit words for which  <span class="math">\\mathbf{P}(x, w)</span>  accepts in T steps.</p>

    <p class="text-gray-300">A specification for the TinyRAM architecture can be found in [BCG<sup>+</sup>13].</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;7</sup>For ease of development, the TinyRAM simulator also supports debugging instructions that produce additional outputs. These are excluded from the execution trace and not verified.</p>

    <pre><code class="language-text">_sumarray:
                             cmpe r4, r5
                             cjmp _end
                             load r6, r1
                             load r7, r2
                             add r8, r7, r5
                             store r3, r8
                             add r1, r1, 1
                             add r2, r2, 1
                             add r3, r3, 1
                             add r4, r4, 1
                             jmp _sumarray
                            _end:
void sumarray(int size,
 int* A,
 int* B,
 int* C)
{
 int i;
 for (i=0; i&lt;size; i++) {
 C[i] = A[i] + B[i];
 }
}
</code></pre>

    <p class="text-gray-300">Figure 3: Illustrative example of transforming a C program into TinyRAM assembly language.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 A Compiler from C to TinyRAM</h3>

    <p class="text-gray-300">The GCC compiler <a href="#page-52-1">[StGDC]</a> is a versatile framework supporting many source languages (e.g., C and Java) and many target languages (e.g., x86 and ARM assembly). Internally, the GCC compiler is partitioned into two main modules <a href="#page-52-2">[StGDC13]</a>. The <em>frontend</em> is responsible for converting a program written in a high-level programming language like C or Java into an intermediate representation language called <em>Register Transfer Language</em> (RTL). The <em>backend</em> is responsible for optimizing and converting RTL code into corresponding assembly code for a given architecture.</p>

    <p class="text-gray-300">In order to automatically generate TinyRAM assembly for problems of interest, we have implemented a prototype of a GCC backend for converting RTL code to TinyRAM assembly code. Our prototype backend works with the C frontend, and can be extended to other programming languages by combining it with suitable GCC frontends (and providing the requisite standard libraries). Concretely, we have a prototype that can compile a subset<a href="#page-9-1">8</a> of C to TinyRAM, with word size <sup>W</sup> &isin; {8, <sup>16</sup>} and number of registers <sup>K</sup> <sup>&ge;</sup> <sup>16</sup>. See Figure <a href="#page-9-2">3</a> for an illustrative example.</p>

    <p class="text-gray-300">Because TinyRAM's instruction set is quite minimal, any operation not directly supported by TinyRAM &quot;hardware&quot; (i.e., by a TinyRAM instruction) needs to be implemented in &quot;software&quot;. This incurs overheads in both the <em>code size</em> (the number of lines in an assembly code) and <em>execution time</em> (the number of instructions required to execute a piece of code). Initial experiments indicate that both of these overheads are not large, as discussed next.</p>

    <p class="text-gray-300">Code size overhead. We first evaluate the code size produced when compiling C code examples<a href="#page-9-3">9</a> into TinyRAM assembly using our GCC port, compared to the code produced by standard GCC for some common architectures: x86, ARM and AVR. Figure <a href="#page-11-0">4 on page 12</a> presents the results of compiling these examples. The results show that, compared to the RISC architectures (ARM and AVR), the resulting TinyRAM code is at most three times larger than ARM and significantly smaller than AVR. Compared to x86, which is a very rich CISC architecture, TinyRAM code is up to four times bigger. We deduce that, at least for the program styles represented by these examples, the TinyRAM architecture allows for compilation into compact programs.</p>

    <p class="text-gray-300"><sup>8</sup> Floating-point arithmetic and static data are not yet implemented, but pose no fundamental difficulty. Most of the C standard library is not yet implemented; see discussion below.</p>

    <p class="text-gray-300"><sup>9</sup> The examples, described in Appendix <a href="#page-47-0">F,</a> are simple, natural C functions we wrote to demonstrate various program styles. They exercise memory accesses (pointer chasing and the RC4 stream cipher), integer arithmetic (matrix multiplication and polynomial evaluation), and logical calculations (single-source shortest paths and Game of Life).</p>

    <p class="text-gray-300">Execution time overhead. The circuits ultimately produced by our reduction have O(T log T) gates, where T is the execution time (measured in machine steps). This execution time depends on the choice of architecture, and we wish to ensure that TinyRAM does not necessitate very long execution times due to deficiencies in the instruction set.</p>

    <p class="text-gray-300">To evaluate this, we compiled examples of C code into both TinyRAM machine code and x86 machine code. In the examples depicted in Figure <a href="#page-12-0">5 on page 13,</a> we observe that, in terms of execution time measured in number of executed instructions, TinyRAM is slower than x86 by a factor of merely 2 to 6, for examples that represent some realistic computations. This is despite x86 being a very rich CISC architecture, heavily optimized for minimizing instruction count, which is typically implemented using many millions of gates. (Recall the difference of executing vs. verifying, discussed in Section <a href="#page-7-1">2.1.</a>)</p>

    <p class="text-gray-300">These small overheads are more than compensated by the fact that TinyRAM has a very compact circuit that verifies the correctness of the transition function. For instance, for a word size W = 16 and number of registers K = 16, and for a program with 100 instructions, we obtain a 785-gate circuit for verifying the transition function.</p>

    <p class="text-gray-300">In summary, our experiments show that, even when working with a minimalistic architecture such as TinyRAM, we do not incur large overheads in code size or number of instructions executed. In Section <a href="#page-13-0">2.3,</a> we discuss the circuit complexity of TinyRAM's transition function and how to efficiently verify TinyRAM execution traces.</p>

    <p class="text-gray-300">Looking ahead. The C specification provides a standard library, which C programs liberally rely on. Our TinyRAM compiler at the moment does not provide support for this library and we are working on extending its functionality to include it. The two main challenges are implementing those functions that must be written directly in the underlying machine language, and supporting (or reasonably approximating) functionality that extends into the program runtime environment, such as file I/O, process management, inter-process communication (IPC), and other system services.</p>

    <p class="text-gray-300">    <img src="_page_11_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 4: Ratio of the number of instructions in the compiled program in TinyRAM to the number of instructions in the compiled program in other architectures (x86, ARM, AVR).</p>

    <p class="text-gray-300">    <img src="_page_12_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 5: Ratio of the number of executed instructions in TinyRAM to the number of executed instructions in x86.</p>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 An Efficient Reduction from TinyRAM to Circuit Satisfiability</h3>

    <p class="text-gray-300">The following describes our efficient reduction from the correctness of TinyRAM executions to  <span class="math">\\mathbb{F}</span> -arithmetic circuit satisfiability, for any prime field  <span class="math">\\mathbb{F}</span>  of sufficiently large size.</p>

      <h4 id="sec-2.3.1" class="text-lg font-semibold mt-6">2.3.1 The reduction notion</h4>

    <p class="text-gray-300">In our setting, a <em>(circuit) reduction</em> is a triple of functions (circ, wit, wit<sup>-1</sup>) working as follows. The <em>circuit generator</em> function  <span class="math">\\operatorname{circ}(\\mathbf{P},T,n)</span> , given a TinyRAM program  <span class="math">\\mathbf{P}</span> , time bound T, and primary input size n, outputs a corresponding  <span class="math">\\mathbb{F}</span> -arithmetic circuit C that encodes the correct computation of  <span class="math">\\mathbf{P}</span>  for at most T steps on primary inputs of n words. The <em>witness map</em> function,  <span class="math">\\operatorname{wit}(\\mathbf{P},T,x,w)</span> , given a pair of primary and auxiliary inputs (x,w) that make  <span class="math">\\mathbf{P}</span>  accept in T steps, outputs a satisfying assignment a for  <span class="math">C(x,\\cdot)</span> . The <em>inverse witness map</em> function,  <span class="math">\\operatorname{wit}^{-1}(\\mathbf{P},T,x,a)</span> , given a satisfying assignment a for  <span class="math">C(x,\\cdot)</span> , outputs w with the property that (x,w) makes  <span class="math">\\mathbf{P}</span>  accept in T steps.</p>

    <p class="text-gray-300"><strong>Definition 2.2.</strong> A <strong>reduction</strong> from TinyRAM (for a word size W and number of registers K) to  <span class="math">\\mathbb{F}</span> -arithmetic circuit satisfiability is a triple of functions (circ, wit, wit<sup>-1</sup>) such that, for every TinyRAM program  <span class="math">\\mathbf{P}</span> , time bound T, and primary input size n, the following hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">C := \\operatorname{circ}(\\mathbf{P}, T, n)</span>  is an  <span class="math">\\mathbb{F}</span> -arithmetic circuit from  <span class="math">\\mathbb{F}^{W \\cdot n} \\times \\mathbb{F}^h</span>  to  <span class="math">\\mathbb{F}^l</span>  for some h, l; C's gates are bilinear;  <span class="math">\\mathbb{F}^{10}</span></li>
      <li>for every (x, w) such that  <span class="math">\\mathbf{P}(x, w)</span>  accepts in T steps,  <span class="math">C(x, \\text{wit}(\\mathbf{P}, T, x, w)) = 0^l</span> ;</li>
      <li>for every (x, a) such that  <span class="math">C(x, a) = 0^l</span> ,  <span class="math">\\mathbf{P}(x, \\mathsf{wit}^{-1}(\\mathbf{P}, T, x, a))</span>  accepts in T steps.</li>
    </ul>

    <p class="text-gray-300">The work on fast reductions of Ben-Sasson et al. [BCGT13a] implies a reduction (circ, wit, wit <span class="math">^{-1}</span> ) where |C| (the number of gates in C) is  <span class="math">O(T(\\log T)^2)</span>  and circ, wit, wit <span class="math">^{-1}</span>  all run in  <span class="math">O(T(\\log T)^2)</span>  time. <sup>11</sup> In our work, we optimize and implement a reduction that builds on the theoretical approach of [BCGT13a]. We focus our attention only on the efficiency of the circuit and witness maps (i.e., circ and wit), because these need to be run in practice. <sup>12</sup> Before discussing our work, however, we briefly review the approach of [BCGT13a].</p>

      <h4 id="sec-2.3.2" class="text-lg font-semibold mt-6">2.3.2 The reduction in [BCGT13a]</h4>

    <p class="text-gray-300">We begin with necessary basic definitions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A (local) state of TinyRAM, denoted S, is a string of (W + KW + 1) bits, encoding the values of the program counter, K registers, and condition flag at a given time step.</li>
      <li>The transition function of TinyRAM, denoted  <span class="math">\\Pi_{TF}</span> , is the predicate that, given a TinyRAM program  <span class="math">\\mathbf{P}</span>  and two states S and S', outputs 1 if and only if the machine in state S can transition (for <em>some</em> choice of values in random-access memory) to the state S' in the next step, according to the program  <span class="math">\\mathbf{P}^{13}</span> .</li>
    </ul>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;\\&lt;/sup&gt;overline{\\phantom{aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span></p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;11</sup>Given a space bound S on the computation of  <span class="math">\\mathbf{P}</span>  on (x, w), Ben-Sasson et al. also present a reduction where |C| is only  <span class="math">O(T \\log T \\log S)</span> . We have so far not considered this additional, significantly more complex, optimization.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;12</sup>Concretely, the key generator runs circ while the prover runs wit; see Figure 10 and Figure 11 on page 28. In contrast, wit<sup>-1</sup> ensures that &quot;proof of knowledge is preserved&quot; (i.e., wit<sup>-1</sup> only appears as part of a proof of security). We are thus not particularly interested in optimizing wit<sup>-1</sup>, especially because (just as in [BCGT13a]) it can be computed in time that is only  <span class="math">O(T(\\log T)^2)</span> .</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{13}&lt;/sup&gt;</span> Traditionally, the transition function is the function that, given the global state of a machine as input, outputs the next state. We abuse this terminology, and use it for the function that, given two local states S, S', decides whether the second can follow the first (cf. discussion of executing vs. verifying in Section 2.1).</p>

    <p class="text-gray-300">&bull; An execution trace<sup>14</sup> for a TinyRAM program P, time bound T, and primary input x is a sequence of states  <span class="math">tr = (S_1, \\ldots, S_T)</span> . An execution trace tr is valid if there exists an auxiliary input w such that the sequence of states induced by P running with input tapes (x, w) is tr.</p>

    <p class="text-gray-300">The goal is to design an  <span class="math">\\mathbb{F}</span> -arithmetic circuit C for verifying that tr is valid that is as small as possible. This is done in three steps, as follows.</p>

    <p class="text-gray-300">Step 1: code consistency. Let  <span class="math">C_{\\mathsf{TF}}</span>  be a circuit that implements the transition function  <span class="math">\\Pi_{\\mathsf{TF}}</span>  of TinyRAM: namely,  <span class="math">C_{\\mathsf{TF}}(\\mathbf{P}, S, S&#x27;) = 1</span>  if and only if  <span class="math">\\Pi_{\\mathsf{TF}}(\\mathbf{P}, S, S&#x27;) = 1</span> . By invoking  <span class="math">C_{\\mathsf{TF}}</span>  on each pair of successive states of tr, we can verify every state transition in the trace tr, i.e., ensure that  <span class="math">\\Pi_{\\mathsf{TF}}(\\mathbf{P}, S_i, S_{i+1}) = 1</span>  for  <span class="math">i = 1, \\ldots, T-1</span> . Doing so gives rise to a sub-circuit of C, consisting of T copies of  <span class="math">C_{\\mathsf{TF}}</span> , that, when given as input tr, checks that tr is code-consistent.</p>

    <p class="text-gray-300"><strong>Step 2: memory consistency.</strong> The global state of a random-access machine also includes memory. In particular, in order to verify that tr is valid, we <em>also</em> need to verify that tr is <em>memory-consistent</em>: namely, that every load operation from an address in memory actually retrieves the value of the last store to that address.</p>

    <p class="text-gray-300">But the accesses to memory of a program  <span class="math">\\mathbf{P}</span>  depend on the inputs x and w. Hence, in general, at each time step i any of the addresses in memory could be accessed by the program. The naive solution of designing the verification circuit C to maintain a snapshot of the entire machine state (which includes registers and memory) for each time step is <em>not</em> efficient: such a circuit has size  <span class="math">\\Omega(T^2)</span> . (As discussed in Appendix C, all previous circuit generators either adopt the naive solution or restrict a program's memory accesses to be known at compile time.)</p>

    <p class="text-gray-300">Ben-Sasson et al. [BCGT13a] take a more efficient approach, building on classical results on quasilinear-time nondeterministic reductions [Sch78, GS89, Rob91]. The high-level idea in [BCGT13a] is that memory consistency would be easier to verify if the circuit C were to also have, as additional input, the <em>same</em> trace tr but sorted according to accessed memory addresses (and breaking ties via timestamps); let us denote this sorted trace by MemSort(tr). Concretely, one can define another &quot;local&quot; predicate  <span class="math">\\Pi_{MC}</span>  such that, if  <span class="math">\\Pi_{MC}</span>  is satisfied by each pair of adjacent states in MemSort(tr) (and, in addition, tr is codeconsistent) then tr is valid. We can then augment C with T copies of a sub-circuit  <span class="math">C_{MC}</span>  that verifies the predicate  <span class="math">\\Pi_{MC}</span>  on MemSort(tr). The circuit C is thus left to verify that the auxiliary input MemSort(tr) is the result of sorting tr.</p>

    <p class="text-gray-300">Step 3: routing network. The circuit C can efficiently perform this check if it is given yet another additional input: (alleged) routing decisions for a routing network which permutes tr into MemSort(tr). A T-packet routing network is a directed graph with T sources, T sinks, and inner nodes (switches) such that, for any permutation  <span class="math">\\pi\\colon [T]\\to [T]</span> , there are routing decisions for the switches that cause T packets at the sources to travel to the T sinks, according to the permutation  <span class="math">\\pi</span> , and without using a switch twice (i.e., with no congestion). One such a network is the Bene&scaron; network [Ben65], which has  <span class="math">O(\\log T)</span>  layers of T nodes each, and each node in a layer is connected to two nodes in the next layer. The idea is to interpret the switch settings in a routing network as a coloring on the routing network. Crucially, verifying that the given switch settings (i.e., a coloring of the network) implement some permutation from the input nodes to the output nodes can be done via simple and local routing constraints; furthermore, given that the switches implement some permutation, verifying that they implement the sorting permutation is easy to verify too. Overall we obtain a certain graph-coloring problem all of whose constraints can be evaluated by a circuit of size  <span class="math">T \\cdot O((\\log T)^2)</span> , which we add to C.</p>

    <p class="text-gray-300">In sum. The approach from [BCGT13a] described in the above paragraphs yields a circuit C of size  <span class="math">T \\cdot (|C_{\\mathsf{TF}}| + |C_{\\mathsf{MC}}| + O((\\log T)^2))</span>  for verifying the validity of a T-step trace. (See Figure 6 below.)</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;14</sup>An execution trace is also at times known as a <em>computation transcript</em> [BCGT13a].</p>

    <p class="text-gray-300">    <img src="_page_15_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 6: Verifying the correct execution of a given piece of TinyRAM code (left) is reduced to satisfiability of a certain constraint-satisfaction problem on a routing network (middle). Then, an arithmetic circuit (right), given an assignment as input, verifies all the constraints of the constraint-satisfaction problem.</p>

      <h4 id="sec-2.3.3" class="text-lg font-semibold mt-6">2.3.3 Optimized reduction</h4>

    <p class="text-gray-300">As mentioned, in our work we optimize and implement the theoretical approach of Ben-Sasson et al. [BCGT13a]. Despite the excellent asymptotic efficiency of the approach, getting to the point in which the verification circuit C has a manageable size in practice proved quite challenging, both theoretically and programmatically. For instance: while (as discussed in Section 2.1) we devised TinyRAM to facilitate the design of a small circuit  <span class="math">C_{\\mathsf{TF}}</span>  for the transition function  <span class="math">\\Pi_{\\mathsf{TF}}</span> , how small of a circuit can we actually design? And how well does its size scale with, say, the word size W, number of registers K, and program size  <span class="math">|\\mathbf{P}|</span> ?</p>

    <p class="text-gray-300">Our circuit generator. At high level, our main technical contribution is leveraging</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) &quot;native&quot; arithmetic in the field  <span class="math">\\mathbb{F}</span> , which for us is a prime field of large characteristic, 15 and</li>
      <li>(2) nondeterministic advice</li>
    </ul>

    <p class="text-gray-300">to achieve highly-optimized implementations of  <span class="math">C_{\\mathsf{TF}}</span> ,  <span class="math">C_{\\mathsf{MC}}</span> , and routing constraints, and ultimately obtain drastic improvements in the size of the verification circuit C output by our circuit generator circ.</p>

    <p class="text-gray-300">To illustrate the use of (1) and (2), consider the basic task of <em>multiplexing bit vectors</em>, used numerous times in C. Given n vectors  <span class="math">\\mathbf{a}_1,\\ldots,\\mathbf{a}_n</span>  of  <span class="math">\\ell</span>  bits each, and a  <span class="math">\\lceil \\log n \\rceil</span> -bit index  <span class="math">\\mathbf{i}</span> , we seek a small  <span class="math">\\mathbb F</span> -arithmetic circuit that computes the vector selected by the index. A naive multiplexer circuit requires  <span class="math">\\Theta(n(\\ell+\\log n))</span>  bilinear gates. In contrast, by relying on (1) and (2), we design a multiplexer circuit that needs only  <span class="math">O(n\\lceil \\frac{\\ell}{|\\mathbb F|} \\rceil)</span>  bilinear gates. The efficiency improvement is significant because we ultimately need to work with cryptographically-large fields; for instance, in our setting where  <span class="math">\\mathbb F = \\mathbb F_r</span>  and r is an 181-bit prime, if  <span class="math">n=\\ell=16</span> , the naive implementation uses 320 gates while we only use 51.</p>

    <p class="text-gray-300">The idea of our multiplexer construction is as follows. Suppose, first, that every input vector  <span class="math">\\mathbf{a}_i</span> , as well as the index i, were represented as integers, and we only had to design a Z-arithmetic circuit to output the integer representing the selected bit vector. In this case, we could easily construct a nondeterministic  <span class="math">\\mathbb{Z}</span> -arithmetic circuit of size O(n) (with bilinear gates of unbounded fan-in): guess variables  <span class="math">b_1, \\ldots, b_n</span>  such that  <span class="math">\\sum_{i=1}^n b_i = 1</span>  and  <span class="math">\\{b_i \\cdot (\\mathbf{i} - i) = 0\\}_{i=1}^n</span> , and then output the inner product of the vector  <span class="math">(b_1, \\dots, b_n)</span>  and the vector  <span class="math">(\\mathbf{a}_1, \\dots, \\mathbf{a}_n)</span> . However, the  <span class="math">\\mathbf{a}_i</span>  and  <span class="math">\\mathbf{i}</span>  are only given to us as strings of bits, and we need to work with F-arithmetic circuits. This gap motivates two fundamental operations: packing and unpacking of bit vectors. Packing denotes mapping a bit vector (using one field element per bit) into a shorter sequence of field elements that represent those bits using a denser encoding; unpacking denotes the inverse operation. The packing operation is very efficient: in the prime field  <span class="math">\\mathbb{F}_r</span>  with  <span class="math">r \\geq 2^{\\ell}</span> , a single gate suffices to compute  <span class="math">\\sum_{i=1}^{\\ell} 2^{i-1} a_i</span>  from the input  <span class="math">a_1, \\ldots, a_{\\ell}</span> . The inverse operation is much more expensive to compute directly, but we can nondeterministically guess the answer and verify it using a single gate. In general,  <span class="math">r \\geq 2^{\\ell}</span> need not hold, so we use  <span class="math">\\lceil \\frac{\\ell}{|\\mathbb{F}|} \\rceil</span>  field elements to store an  <span class="math">\\ell</span> -bit vector. Given the aforementioned efficient packing operations, our multiplexer construction works as follows: it guesses the selected  <span class="math">\\ell</span> -bit vector, then computes the integers corresponding to the input  <span class="math">\\ell</span> -bit vectors as well as the index, and then verifies the guess by selecting the correct integer according to the (integer) index.</p>

    <p class="text-gray-300">More generally, we have found that, throughout our circuit generator, it is often advantageous to maintain, alongside certain vectors  <span class="math">\\mathbf{a}</span> , also the corresponding (densely-packed) integer  <span class="math">\\sum_i 2^{i-1} a_i</span> .</p>

    <p class="text-gray-300">With these techniques in mind, we proceed to describe the circuit generator.</p>

    <p class="text-gray-300">&bull; Designing the transition function circuit  <span class="math">C_{\\mathsf{TF}}</span> . The circuit  <span class="math">C_{\\mathsf{TF}}</span>  is the most complex sub-circuit of C. The size of  <span class="math">C_{\\mathsf{TF}}</span>  is dominated by the size of sub-circuits for multiplexing bit strings (for instruction fetch,</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;15</sup>As required by the underlying zk-SNARK for circuit satisfiability; see Section 3.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;16</sup> For example: for each i = 1, ..., n, multiply  <span class="math">\\mathbf{a}_i</span>  by 1 if  <span class="math">\\mathbf{i}</span>  represents i, and by 0 otherwise, using  <span class="math">\\Theta(\\log n + \\ell)</span>  gates per i; then for  <span class="math">j = 1, ..., \\ell</span> , produce the j-th output bit using one fan-in-n adder per j.</p>

    <p class="text-gray-300">register fetch, and so on) and of the arithmetic logic unit (ALU), which executes the architecture's non-memory operations.</p>

    <p class="text-gray-300">To obtain an efficient implementation of the ALU (or, more precisely, a circuit verifying its operation), we again make use of field arithmetic and nondeterministic advice. Since we work over a prime field of large characteristic, field arithmetic looks like integer arithmetic whenever there is no &quot;wrap around&quot;. Thus, after fetching the arguments of an operation, we make sure to have both the binary and integer representation for each argument. Then, each operation in the ALU uses whichever representation is more efficient to use. For instance, bitwise AND, OR, XOR, and NOT are computed using binary representations. In contrast, we use integer representations to compute result and overflow information for addition, subtraction, and multiplication with only 2W, 2W, and 3W bilinear gates, respectively. For division, we nondeterministically guess the result and verify it with a multiplication. Each time an operation uses integer representations, the output integer can be &quot;unpacked&quot; into its binary representation, via nondeterministic advice. By carefully studying each operation, we obtain a (nondeterministic) circuit for verifying the ALU that, with word size W=16, has merely 343 gates.</p>

    <p class="text-gray-300">Given efficient implementations of multiplexing and the ALU, it is possible to obtain an efficient implementation of  <span class="math">C_{\\mathsf{TF}}</span> . Table 1 below shows the number of gates in our implementation of  <span class="math">C_{\\mathsf{TF}}</span>  for  <span class="math">|\\mathbf{P}| \\in \\{10, 10^2, 10^3\\}</span> ,  <span class="math">W \\in \\{8, 16, 32\\}</span>  and  <span class="math">K \\in \\{8, 16, 32\\}</span> .</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">$ \\mathbf{P}  = 10/100/1000$</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">W = 8</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">W = 16</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">W = 32</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">W = 64</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">K = 8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">482 / 572 / 1472</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">619 / 709 / 1609</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">892 / 982 / 1882</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1437 / 1527 / 2427</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">K = 16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">558 / 648 / 1548</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">695 / 785 / 1685</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">968 / 1058 / 1958</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1513 / 1603 / 2503</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">K = 32</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">706 / 796 / 1696</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">843 / 933 / 1833</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1116 / 1206 / 2106</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1661 / 1751 / 2651</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">K = 64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">998 / 1088 / 1988</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1135 / 1225 / 2125</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1408 / 1498 / 2398</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1953 / 2043 / 2943</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 1: Number of gates in  <span class="math">C_{\\mathsf{TF}}</span>  as a function of W and K, for different sizes of program P.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Designing the memory consistency circuit  <span class="math">C_{\\text{MC}}</span> . The predicate  <span class="math">\\Pi_{\\text{MC}}</span>  is not as complex as the transition function  <span class="math">\\Pi_{\\text{TF}}</span> , but it is still important to design a small circuit  <span class="math">C_{\\text{MC}}</span>  for it. A crucial optimization is afforded by the fact that  <span class="math">\\Pi_{\\text{MC}}</span>  only cares about the memory address being accessed, and the value loaded/stored, in each state. Deriving these values from the state requires instruction parsing and register-file multiplexing, but it turns out they have already been computed on &quot;the other side&quot; of the routing network, by  <span class="math">C_{\\text{TF}}</span> , when verifying code consistency. Thus, we change the routing network (discussed below) to route only such pairs of address and value; there remains for  <span class="math">\\Pi_{\\text{MC}}</span>  merely to check a simple ordering condition on this. We thereby obtain a circuit  <span class="math">C_{\\text{MC}}</span>  that only contains two integer comparisons and few other logical operations. For instance, when W=16,  <span class="math">C_{\\text{MC}}</span>  consists of just 64 gates.</li>
      <li>Checking routing constraints. Asymptotically, the routing constraints on the routing network are the most expensive sub-circuit of C: there are  <span class="math">\\Theta(T \\log T)</span>  nodes in the routing network, compared to T copies of  <span class="math">C_{\\mathsf{TF}}</span>  and  <span class="math">C_{\\mathsf{MC}}</span>  each. It is thus crucial to check these constraints as efficiently as possible. As discussed for  <span class="math">\\Pi_{\\mathsf{MC}}</span> , it suffices to route packets consisting of just 2W bits (obtained from intermediate computations of  <span class="math">C_{\\mathsf{TF}}</span> ), instead of whole TinyRAM states. This leads to another important optimization: now that a packet is small, we can pack a whole packet into a single field element (in our typical parameters,  <span class="math">|\\mathbb{F}| \\geq 2^{2W}</span> ); then, because the packets consist of single field elements, computing the routing constraints becomes particularly simple: only one bilinear gate per vertex. Concretely, the gate at a given vertex checks whether the vertex's packet is equal to at least one of the packets at the two neighbor vertices in the next layer. Overall, when T is a power of 2, all routing constraints can be verified with only  <span class="math">2 \\cdot T \\cdot \\log T</span>  gates.</li>
    </ul>

    <p class="text-gray-300">We thus also obtain an asymptotic improvement, by a  <span class="math">\\log T</span>  factor, over the circuit size in [BCGT13a], where routing constraints required  <span class="math">O(T(\\log T)^2)</span>  gates. This holds since the size of  <span class="math">\\mathbb F</span>  must be  <span class="math">\\omega(T)</span>  for cryptographic reasons.</p>

    <p class="text-gray-300">There are numerous additional details that go into our final construction of the verification circuit C. (For instance, another asymptotically-significant component, contributing an additional  <span class="math">2 \\cdot T \\cdot \\log T</span>  gates, originates from 2T integer comparisons on  <span class="math">\\log T</span> -bit integers.) The eventual circuit sizes are as follows, fixing for concreteness a word size W=16, number of registers K=16, and a program length  <span class="math">|\\mathbf{P}|</span>  of 100 instructions. The size of C grows with T (when T is a power of 2) as follows:</p>

    <p class="text-gray-300"><span class="math">$|C| = 4 \\cdot T \\cdot \\log T + 892 \\cdot T + 37.</span>$</p>

    <p class="text-gray-300">In particular, for  <span class="math">\\log T &lt; 20</span> , every cycle of TinyRAM computation costs  <span class="math">\\leq 972</span>  gates to verify. Note that, while the gate count per cycle increases as T increases (since the number of routing constraints grows as  <span class="math">O(T\\log T)</span> ), the growth rate is slow: doubling T costs only 4+o(1) additional gates per cycle. See Table 2 for values of |C|/T for  <span class="math">\\log T = \\{10, \\ldots, 20\\}</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">T</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">C /T</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{10}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">932.04</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{11}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">936.02</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{12}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">940.01</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{13}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">944.00</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{14}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">948.00</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{15}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">952.00</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{16}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">956.00</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{17}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">960.00</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{18}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">964.00</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{19}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">968.00</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{20}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">972.00</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 2: Number of gates per TinyRAM cycle, with  <span class="math">|\\mathbf{P}| = 100</span> , W = 16, and K = 16.</p>

    <p class="text-gray-300">From a software engineering point of view, we tackled the construction of the verification circuit C by developing a library of  <span class="math">circuit\\ gadgets</span> , along with functions for composing these gadgets in a clean and modular way. This simplifies future modifications to our circuit generator for application-dependent extensions and customizations, such as supporting other instruction sets, other memory addressing modes, and so on.</p>

    <p class="text-gray-300">Witness map. Thus far, we have focused on achieving <em>soundness</em>: verifying the validity of an execution trace of a TinyRAM program  <span class="math">\\mathbf{P}</span>  by using the circuit  <span class="math">C := \\operatorname{circ}(\\mathbf{P}, T, n)</span>  output by the circuit generator circ. The circuit generator is run by the key generator when computing the public parameters. (See Figure 10 on page 28.) Let us now turn to <em>completeness</em>: we need to implement a witness map wit( <span class="math">\\mathbf{P}, T, x, w</span> ) that computes a satisfying assignment a for  <span class="math">C(x, \\cdot)</span> , whenever  <span class="math">\\mathbf{P}(x, w)</span>  accepts in T steps. The witness map is run by the prover when generating a proof. (See Figure 11 on page 28.)</p>

    <p class="text-gray-300">The witness map wit consists of two main steps.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>From inputs to execution trace. We implemented a TinyRAM simulator, denoted Simulate, that, given as input  <span class="math">(\\mathbf{P}, T, x, w)</span> , outputs the T-step execution trace tr of  <span class="math">\\mathbf{P}</span>  on inputs (x, w). This step is conceptually straightforward: it is implemented as a fetch-and-execute loop written in a high-level language, C++. Unlike the subsequent steps, it does not involve circuit representation. Performance of the simulation inessential, since, in the full prover, running time is dominated by subsequent steps.</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>From execution trace to satisfying assignment.</em> We implemented a function, denoted ExtendAndRoute, that, given a valid T-step trace tr for P(x, w), outputs a satisfying assignment a for C(x, &middot;). Computing a involves several sub-steps, corresponding to finding suitable satisfying assignments to the different sub-circuits of C, as we now describe.</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The first task is to deduce from tr a satisfying assignment for each copy of CTF in C. In order to satisfy the i-th copy of CTF, it is <em>not</em> enough to provide the i-th and (i + 1)-th line in the trace tr as input to the i-th copy of CTF. Indeed, each copy of CTF also expects nondeterministic advice. (For instance, each multiplexer in CTF expects auxiliary advice; and so do many sub-circuits of the ALU, such as the sub-circuit responsible for verifying a division's result.) Thus, in this step we compute the necessary auxiliary advice for each copy of CTF.</li>
      <li>The second task is to deduce from tr a satisfying assignment for each copy of CMC in C. We do so by first stable-sorting the trace tr, by address accessed, in order to obtain MemSort(tr). Then, we provide the i-th and (i + 1)-th line in the trace MemSort(tr) as input to the i-th copy of CMC. Similarly as before, each copy of CMC also requires various nondeterministic advice, mostly consisting of internal wire values of computations of the corresponding copy of CTF.</li>
      <li>The third and final task is to deduce a satisfying assignment to the sub-circuit of C responsible for checking that MemSort(tr) is a suitable sorting of tr. To do so, we deduce from tr and MemSort(tr) the permutation &pi; that we need to route on the Benes network; we then compute the switch settings &#711; for the network by using a standard routing algorithm <a href="#page-49-14">[Ben65,</a> <a href="#page-52-5">Wak68,</a> <a href="#page-52-6">OTW71,</a> <a href="#page-51-14">Lei92,</a> <a href="#page-52-7">NS82]</a>; from these switch settings and tr, we can then deduce the satisfying assignment. Asymptotically, this is the most expensive part of the witness map.</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">The above concludes the description of our witness map wit.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Verifying Circuit Satisfiability via Linear PCPs</h2>

    <p class="text-gray-300">As summarized in Section 1.3, we have implemented a zk-SNARK for (arithmetic) circuit satisfiability; see Section 1.1 for an informal definition of this cryptographic primitive, or Appendix A for a formal one. In this section we describe the design and performance of this part of our system.</p>

    <p class="text-gray-300">Our high-level approach to obtain the zk-SNARK is as follows. First, as shall be discussed in Section 3.1, we optimized and implemented the transformation of Bitansky et al. [BCI<sup>+</sup>13]; the transformation takes as input any honest-verifier zero-knowledge (HVZK) linear PCP and outputs a zk-SNARK.<sup>17</sup> (More precisely, the linear PCP needs to be one where (i) queries are random evaluations of low-degree polynomials, and (ii) answers to the queries can be verified via a collection of degree-2 polynomials.) Second, as shall be discussed in Section 3.2, we provide an efficient implementation of a HVZK linear PCP for circuit satisfiability.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 A Transformation from Any Linear PCP</h3>

    <p class="text-gray-300">We begin by discussing efficiency aspects of the transformation from a linear PCP to a corresponding SNARK. To do so, we first recall (at high level) the transformation itself.</p>

    <p class="text-gray-300"><strong>Constructing a SNARK from a linear PCP.</strong> The transformation of Bitansky et al. [BCI<sup>+</sup>13] consists of an information-theoretic step followed by cryptographic step.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>Step 1 (information-theoretic):</em> compile the linear PCP into a 2-message <em>linear interactive proof</em> (linear IP), i.e., one where the prover is restricted to only apply linear functions to the verifier's message.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>This is achieved by adding a <em>consistency-check query</em>, which is a random linear combination of the linear PCP queries. In more detail, if the linear PCP has k queries each with m elements from a field  <span class="math">\\mathbb F</span> , in the resulting linear IP the verifier sends to the prover a single message q consisting of m' = (k+1)m elements in  <span class="math">\\mathbb F</span> ; the message q is the concatenation of the k linear PCP queries and the consistency-check query. A (potentially malicious) prover is restricted to only apply linear functions to q, i.e., reply with a vector  <span class="math">\\mathbf{a}^* \\in \\mathbb F^{k+1}</span>  such that  <span class="math">\\mathbf{a}^* = \\Pi^* \\mathbf{q} + \\mathbf{b}^*</span>  for some  <span class="math">\\Pi^* \\in \\mathbb F^{(k+1)\\times m&#x27;}</span>  and  <span class="math">\\mathbf{b}^* \\in \\mathbb F^{k+1}</span> . The honest prover simply returns the vector  <span class="math">\\mathbf{a} = (a_1, \\ldots, a_{k+1})</span>  where  <span class="math">a_i = \\langle \\mathbf{\\pi}, \\mathbf{q}_i \\rangle</span> ,  <span class="math">q_i</span>  is the i-th m-element block of q, and  <span class="math">\\pi</span>  is the linear PCP proof. A prover's message  <span class="math">\\mathbf{a}^*</span>  is verified by checking consistency of  <span class="math">a_{k+1}^*</span>  with  <span class="math">a_1^*, \\ldots, a_k^*</span>  and then invoking the linear PCP decision predicate on  <span class="math">a_1^*, \\ldots, a_k^*</span> ; the consistency check ensures that  <span class="math">a_i^* = \\langle \\mathbf{\\pi}^*, \\mathbf{q}_i \\rangle</span>  for <em>some</em> linear PCP  <span class="math">\\mathbf{\\pi}^*</span> .</li>
    </ul></li>
      <li>Step 2 (cryptographic): compile the linear IP into a SNARK, by forcing any polynomial-size malicious prover to act as if it were a linear function.</li>
    </ul>

    <p class="text-gray-300">This is achieved using a cryptographic encoding  <span class="math">Enc(\\cdot)</span>  with the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(i) It allows public testing of quadratic predicates on encoded elements.</li>
      <li>(ii) It provides a certain notion of one-way security to encoded elements.</li>
      <li>(iii) It ensures that any polynomial-size prover can only perform linear operations on the encoded elements, &quot;up to&quot; information leaked by the encoding. 18</li>
    </ul>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{17}&lt;/sup&gt;</span> As mentioned in Section 1.2, a linear PCP is a PCP where the honest proof oracle is a linear function over an underlying finite field  <span class="math">\\mathbb{F}</span> , and soundness is required to hold only for linear proof oracles. The HVZK property is the same as in a standard PCP. See Appendix D for definitions.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;18</sup>Since the encoding cannot provide semantic security (due to the functionality requirement of allowing for evaluation of quadratic predicates on encoded elements) but only a notion of one-way security, a limited amount of information about the underlying elements is necessarily leaked.</p>

    <p class="text-gray-300">Given  <span class="math">\\operatorname{Enc}(\\cdot)</span> , the compilation is then conceptually simple. The SNARK generator  <span class="math">G(1^\\lambda,C)</span>  samples a verifier message  <span class="math">q\\in\\mathbb{F}^{m&#x27;}</span>  (which depends on the circuit C but not its input) for the linear IP, and outputs, as a proving key, the encoding  <span class="math">\\operatorname{Enc}(q)=(\\operatorname{Enc}(q_i))_{i=1}^{m&#x27;}</span> . (We omit here the discussion of how the short verification key is generated.) Starting from  <span class="math">\\operatorname{Enc}(q)</span>  and a linear PCP proof  <span class="math">\\pi</span> , the honest SNARK prover P homomorphically evaluates the inner products  <span class="math">\\langle \\pi, q_i \\rangle</span>  and returns as a proof the resulting encoded answers. The SNARK verifier checks a proof by running the linear IP decision predicate (which is a collection of quadratic predicates) on the encoded answers.</p>

    <p class="text-gray-300">The encoding  <span class="math">Enc(\\cdot)</span>  needed for Step 2 can be based on knowledge-of-exponent assumptions [Dam92, HT98, BP04], and requires us to fix  <span class="math">\\mathbb{F} = \\mathbb{F}_r</span>  for some prime r. Also, from the discussion above it is not clear why the elements in q need to be random evaluations of low-degree polynomials; this requirement arises, for security reasons, in Step 2. For definitions and details, see [BCI<sup>+</sup>13].</p>

    <p class="text-gray-300"><strong>Computational overheads.</strong> The transformation from a linear PCP to a SNARK introduces several computational overheads. In Step 1, the only overhead is due to the consistency-check query, and is minor. However, the cryptographic overheads in Step 2 are significant, and require optimizations for practical use. Specifically:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The SNARK generator G, after sampling  <span class="math">q \\in \\mathbb{F}^{m&#x27;}</span> , must compute  <span class="math">\\operatorname{Enc}(q) = (\\operatorname{Enc}(q_i))_{i=1}^{m&#x27;}</span> . In other words G has to compute the encoding of m' = (k+1)m field elements.</li>
      <li>The honest SNARK prover P must compute  <span class="math">\\text{Enc}(\\langle \\boldsymbol{\\pi}, \\boldsymbol{q}_i \\rangle)</span>  for  <span class="math">i = 1, \\dots, k+1</span> , starting from  <span class="math">\\text{Enc}(\\boldsymbol{q})</span>  and the linear PCP proof  <span class="math">\\boldsymbol{\\pi} \\in \\mathbb{F}^m</span> . In other words, P has to homomorphically evaluate k+1 inner products.</li>
    </ul>

    <p class="text-gray-300">In our case, the linear PCP we use (see Section 3.2) is over the field  <span class="math">\\mathbb{F} = \\mathbb{F}_r</span> , where r is a 181-bit prime; the linear PCP has k=5 queries and  <span class="math">m=\\Theta(|C|)</span>  field elements per query. Furthermore, the encoding we use is  <span class="math">\\operatorname{Enc}(\\gamma)=(g^\\gamma,h^\\gamma)</span>  where g,h are, respectively, generators of groups  <span class="math">\\mathbb{G}_1,\\mathbb{G}_2</span>  of order r. The linear homomorphism is  <span class="math">\\operatorname{Enc}(a\\gamma+b\\delta)=\\operatorname{Enc}(\\gamma)^a\\operatorname{Enc}(\\delta)^b</span>  with coordinate-wise multiplication and exponentiation.</p>

    <p class="text-gray-300">Therefore, G and P must compute a large number of exponentiations in  <span class="math">\\mathbb{G}_1</span> ,  <span class="math">\\mathbb{G}_2</span> . These dominate the the complexity of G and P, and thus their efficiency is essential.</p>

    <p class="text-gray-300"><strong>Efficiency optimizations.</strong> We address the aforementioned cryptographic bottlenecks as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Reducing the number of group operations in P. The SNARK prover P faces several large instances of a multi-exponentiation problem, a well-studied computational problem in applied cryptography [Ber02]. The problem is as follows: given group elements  <span class="math">g_1, \\ldots, g_m \\in \\mathbb{G}</span>  (here,  <span class="math">\\mathbb{G} = \\mathbb{G}_1</span>  or  <span class="math">\\mathbb{G} = \\mathbb{G}_2</span> ) and 181-bit integers  <span class="math">a_1, \\ldots, a_m</span> , compute  <span class="math">\\prod_{i=1}^m g_i^{a_i}</span> . In order to reduce the number of group operations required to compute this product, we implemented a suitable choice of multi-exponentiation algorithm [BC89]. Compared to the naive approach of &quot;exponentiate and then multiply&quot;, we save a multiplicative factor of 25 already for  <span class="math">m=10^6</span>  (and the savings increase with m).</li>
      <li>(b) Reducing the number of group operations in G. The SNARK generator G is instead faced with several large instances of the following exponentiation problem: given a group element  <span class="math">g \\in \\mathbb{G}</span>  and 181-bit integers  <span class="math">a_1, \\ldots, a_m</span> , compute the tuple  <span class="math">(g^{a_1}, \\ldots, g^{a_m})</span> . We reduce the number of required group operations by using the standard technique of pre-computing a table of powers of g, and then reusing these values in each subsequent exponentiation. We thus save a multiplicative factor of 23 in the number of group operations (over the naive approach of performing a &quot;fresh&quot; exponentiation for each term). Precomputing more powers of g provides even greater savings, at the expense of more space usage.</li>
      <li>(c) <strong>Reducing the cost of group operations.</strong> We sought instantiations of the groups  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  that offer particularly efficient group operations.</li>
    </ul>

    <p class="text-gray-300">A crucial requirement is that  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  must admit an efficient <em>pairing</em> (non-degenerate bilinear map)  <span class="math">e \\colon \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span> , where  <span class="math">\\mathbb{G}_T</span>  is a &quot;target&quot; group (also of order r); indeed, the pairing e provides the necessary functionality to publicly test quadratic predicates on encoded elements. We focus on asymmetric pairings (where  <span class="math">\\mathbb{G}_1 \\neq \\mathbb{G}_2</span> ), because of the extra flexibility in group choices at a given security level. Concretely, we work with the (reduced) Tate pairing [FR94, FMR06].</p>

    <p class="text-gray-300">Thus, we need to find a suitable pairing-friendly elliptic curve E, defined over  <span class="math">\\mathbb{F}_q</span>  for a prime q, and set  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T</span>  equal to suitable subgroups of  <span class="math">E(\\mathbb{F}_q), E(\\mathbb{F}_{q^k}), \\mathbb{F}_{q^k}^*</span> , respectively. (For a field extension K of  <span class="math">\\mathbb{F}_q, E(K)</span>  is the group of K-rational points on the curve E; and k is known as E's embedding degree.)</p>

    <p class="text-gray-300">Concretely, in order to optimize the efficiency of multiplication and squaring in  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span> , we need to:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(i) minimize the number of operations in  <span class="math">\\mathbb{F}_q</span>  needed for carrying out group multiplication and squaring; and</li>
      <li>(ii) do so without making q much larger than r, that is, without making the value  <span class="math">\\rho := \\frac{\\log q}{\\log r}</span>  too large. Furthermore, to allow for an efficient implementation of the underlying linear PCP (via suitable FFTs in  <span class="math">\\mathbb{F}_r</span> ; see Section 3.2), we require <em>smoothness</em>: r-1 should be divisible by a &quot;large enough&quot; power of 2. Thus, we seek a pairing-friendly elliptic curve E that <em>simultaneously</em> addresses all of these requirements. Our strategy for finding a suitable curve E is as follows. <sup>19</sup>    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>To address (i), we focus our attention to elliptic curves in which 4 divides the group order. Any such curve is birationally equivalent to an Edwards curve [Edw07], and group operations are particularly efficiency for Edwards curves [BL07] and, more generally, twisted Edwards curves [BBJ+08].</li>
      <li>To address (ii), we consider parametrizations of Galbraith et al. [GMV07], which generalize the approach of Miyaji et al. [MNT01] to include known cofactors in the group order. Specifically, we use a parametrized family specified by a quadratic polynomial q(x) and a linear polynomial t(x) such that, for any integer a such that q(a) is prime and  <span class="math">|t(a)| \\leq 2\\sqrt{q(a)}</span> , there is an elliptic curve E over  <span class="math">\\mathbb{F}_q</span>  with order n(a) := q(a) t(a) + 1, embedding degree k = 6 (which makes the curve pairing friendly), and n(a) divisible by 4 (which makes the curve birationally equivalent to an Edwards curve). If the square-free part of  <span class="math">|4q(a) t(a)^2|</span>  is not large, E can be constructed via the method of complex multiplication [AM93]. Next, letting r(a) be the largest prime divisor of n(a), we set  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  to be subgroups of order r = r(a) of  <span class="math">E(\\mathbb{F}_q)</span>  and  <span class="math">E(\\mathbb{F}_{q^6})</span>  respectively. By selecting e0 so that e1 is sufficiently large, we can ensure that the value e2 log e3 is e4. For security, we take e4 log e6, and get at least 80 bits of security [FST10].</li>
      <li>To address the smoothness requirement (i.e., r-1 being divisible by a large power of 2) we proceed as follows. For any fundamental discriminant D&lt;0, the quadratic equation  <span class="math">4q(x)-t(x)^2=y^2D</span>  in the variables x,y can be transformed, via a linear map on x, to a generalized Pell equation  <span class="math">x^2-Ay^2=B</span>  (where A&gt;0 and B are integers). Integer solutions to the Pell equation &quot;often&quot; correspond to &quot;good&quot; integer solutions to the original equation. Thus, we iterate over fundamental discriminants in order of increasing magnitude and, for each fundamental discriminant D, we try to derive good solutions to  <span class="math">4q(x)-t(x)^2=y^2D</span>  by relying on a Pell-equation solver [Sma99] invoked on the corresponding equation  <span class="math">x^2-Ay^2=B</span> . Heuristically, we need to &quot;see&quot;  <span class="math">\\Omega(2^\\ell)</span>  Pell-equation solutions before finding a good solution, for some sufficiently small D. Crucially, the values of  <span class="math">\\ell</span>  that we are interested in practice are such that finding  <span class="math">\\Omega(2^\\ell)</span>  solutions is a tractable problem, though one that requires significant computing resources (see Section 3.3).</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;19</sup>The authors are grateful to Andrew Sutherland for generous guidance here.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;20</sup>More precisely, due to optimizations having to do with computing the (reduced Tate) pairing e,  <span class="math">\\mathbb{G}_2</span>  is subgroup of  <span class="math">E&#x27;(\\mathbb{F}_{q^3})</span> , where E' is a quadratic twist of E [ALNR11].</p>

    <p class="text-gray-300">We carried out the above strategy, and the resulting algebraic setup is given in Section 3.3.</p>

    <p class="text-gray-300">(d) Reducing the number of  <span class="math">\\mathbb{G}_2</span>  group operations in G and P. Working with an asymmetric pairing causes  <span class="math">\\mathbb{G}_2</span>  operations to be about three times more expensive than  <span class="math">\\mathbb{G}_1</span>  operations. We modify the cryptographic transformation of  <span class="math">[BCI^+13]</span> , for the specific case of our linear IP construction, so that only a  <span class="math">\\approx \\frac{1}{10}</span>  fraction of the generator's and prover's group operations have to be carried out in  <span class="math">\\mathbb{G}_2</span> , while for the rest it suffices to carry them in  <span class="math">\\mathbb{G}_1</span> .</p>

    <p class="text-gray-300">We conclude the discussion about efficiency optimizations by noting that the cryptographic computations in both the key generator and prover are highly-parallelizable; thus, their latency can be greatly improved. Our prototype implementation does not seek to reduce latency or exploit parallelism. (See Section 4.4.)</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 An Efficient Linear PCP</h3>

    <p class="text-gray-300">In the previous section we discussed how to ensure that the transformation from a linear PCP to a corresponding SNARK adds as little computational overhead as possible. In this section, we discuss the problem of implementing a linear PCP for arithmetic circuit satisfiability that is as efficient as possible. First, let us recall that the <em>circuit satisfaction problem</em> of a circuit  <span class="math">C: \\mathbb{F}^n \\times \\mathbb{F}^h \\to \\mathbb{F}^l</span>  is the relation  <span class="math">\\mathcal{R}_C = \\{(x,a) \\in \\mathbb{F}^n \\times \\mathbb{F}^h : C(x,a) = 0^l\\}</span> ; its language is  <span class="math">\\mathcal{L}_C = \\{x \\in \\mathbb{F}^n : \\exists a \\in \\mathbb{F}^h, C(x,a) = 0^l\\}</span> .</p>

    <p class="text-gray-300"><strong>Our linear PCP.</strong> Our technical starting point for constructing a linear PCP for  <span class="math">\\mathcal{R}_C</span>  is the work on <em>quadratic-span programs</em> (QSPs) and <em>quadratic-arithmetic programs</em> (QAPs) of Gennaro et al. [GGPR13]. Indeed, Bitansky et al. [BCI<sup>+</sup>13] observed that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\bullet</span>  any QSP for a relation  <span class="math">\\mathcal R</span>  yields a corresponding 3-query linear PCP for  <span class="math">\\mathcal R</span> , and</li>
      <li>any QAP for a relation  <span class="math">\\mathcal{R}</span>  yields a corresponding 4-query linear PCP for  <span class="math">\\mathcal{R}</span> .</li>
    </ul>

    <p class="text-gray-300">By following the QAP approach of [GGPR13], we design a linear PCP for the relation  <span class="math">\\mathcal{R}_C</span>  that trades an increased number of 5 queries for a construction that, while keeping essentially-optimal asymptotics, enjoys excellent efficiency in practice.</p>

    <p class="text-gray-300">Concretely, for checking membership in the language  <span class="math">\\mathcal{L}_C</span>  for a circuit C, our linear PCP has only 5 queries of 2|C| field elements each (and sampling the 5 queries needs only a single random field element); generating the queries can be done in linear time. The 5 answers of the queries can be verified via 2 quadratic polynomials using only 2n+9 field operations, where n is the input size. The soundness error is  <span class="math">2|C|/|\\mathbb{F}|</span> . Using suitable FFTs, the honest prover can compute the linear proof oracle via an arithmetic circuit of size  <span class="math">O(|C|\\log|C|)</span>  and depth  <span class="math">O(\\log|C|)</span> . (In particular, the prover is highly parallelizable.)</p>

    <p class="text-gray-300"><strong>Efficiency optimizations.</strong> While there exists a variety of FFT algorithms, the most efficient ones are tailored to fields with special structure. With this in mind, we choose the prime r, which determines the field  <span class="math">\\mathbb{F}_r</span>  for the linear PCP, so that  <span class="math">r-1=2^\\ell m</span>  for a &quot;large enough&quot; integer  <span class="math">\\ell</span> . Then,  <span class="math">\\mathbb{F}_r</span>  contains a primitive  <span class="math">2^\\ell</span> -th root of unity, so multi-point evaluation/interpolation over domains consisting of roots of unity (or their multiplicative cosets) can be performed via a simple and efficient radix-2 FFT algorithm. This results in the aforementioned complexity for the honest prover. Furthermore, working over such  <span class="math">\\mathbb{F}_r</span>  simplifies the linear-time algorithm for sampling queries.</p>

    <p class="text-gray-300">More precisely, when working with the language  <span class="math">\\mathcal{L}_C</span> , we need  <span class="math">2^{\\ell} &gt; |C|</span>  to hold. In practice,  <span class="math">\\ell \\geq 30</span>  seems adequate for the problem sizes of interest, so we chose  <span class="math">\\ell = 30</span>  in our implementation. Larger values of  <span class="math">\\ell</span>  can be substituted to support circuits C with  <span class="math">|C| &gt; 2^{30}</span>  (see Section 3.3).<sup>21</sup></p>

    <p class="text-gray-300"><strong>Zero knowledge.</strong> The transformation from a linear PCP to a SNARK is such that if the linear PCP is honest-verifier zero-knowledge (HVZK) then the SNARK is zero knowledge. (See Appendix D for a definition of</p>

    <p class="text-gray-300">While requiring that r-1 be smooth complicates the search for an elliptic curve satisfying all of our requirements and the search's complexity grows with  <span class="math">2^{\\ell}</span>  (see Section 3.1), smoothness is crucial for leveraging tailored FFT algorithms in the prover.</p>

    <p class="text-gray-300">HVZK.) Thus, we need to ensure that our linear PCP is HVZK. Bitansky et al. [BCI<sup>+</sup>13] showed a general transformation from a linear PCP to a HVZK linear PCP of similar efficiency. We do not rely on their general transformation. Instead, our linear PCP is made HVZK with essentially no computational overhead, via a simple modification analogous to the one used in [GGPR13] to achieve zero knowledge. Thus, the SNARK obtained from our linear PCP has (statistical) zero knowledge.</p>

    <p class="text-gray-300">For more details on our linear PCP construction, see Appendix E.</p>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">3.3 Performance</h3>

    <p class="text-gray-300">Plugging our linear PCP for arithmetic circuits (Section 3.2) into the transformation (Section 3.1), we obtain an implementation of zk-SNARKs for arithmetic circuit satisfiability with essentially-optimal asymptotic efficiency: linear-time key generator, quasilinear-time prover, and linear-time verifier. In this section, we discuss concrete performance of our implementation.</p>

    <p class="text-gray-300">Instantiation of  <span class="math">\\mathbb{G}_1</span> ,  <span class="math">\\mathbb{G}_2</span> ,  <span class="math">\\mathbb{G}_T</span>  and pairing. We begin by describing the algebraic setup that provides a concrete instantiation of the prime-order groups  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span> . We consider an Edwards curve E defined over the field  <span class="math">\\mathbb{F}_q</span>  where q is a prime of 183 bits. The curve group  <span class="math">E(\\mathbb{F}_q)</span>  has order 4r where r is a prime of 181 bits. In particular, the value  <span class="math">\\rho = \\frac{\\log q}{\\log r}</span>  is approximately 1.011. Moreover, r-1 is divisible by  <span class="math">2^{30}</span> .</p>

    <p class="text-gray-300">The group  <span class="math">\\mathbb{G}_1</span>  is a cyclic subgroup of  <span class="math">E(\\mathbb{F}_q)</span>  of order r, and  <span class="math">\\mathbb{G}_2</span>  is a cyclic subgroup of  <span class="math">E&#x27;(\\mathbb{F}_{q^3})</span>  of order r where E' is a quadratic twist of E (thus E' is a twisted Edwards curve [BBJ+08]); this instantiation provides 80 bits of security [FST10]. (In particular, the security parameter is now implicit and we thus omit it as an explicit input to the SNARK key generator in the discussion below.) Thus, each  <span class="math">\\mathbb{G}_1</span>  group element (when compressed) is 184 bits; each  <span class="math">\\mathbb{G}_2</span>  group element (when compressed) is 550 bits.</p>

    <p class="text-gray-300">The curve E was found, after  <span class="math">\\approx 2^{38}</span>  trials, by following the strategy outlined in Section 3.1. The same strategy can be used, with more trials, to find curves where r-1 is divisible by a larger power of 2: roughly  <span class="math">\\Omega(2^{\\ell})</span>  trials are needed to find a choice of parameters where  <span class="math">2^{\\ell}</span>  divides r-1.</p>

    <p class="text-gray-300">Taking the &quot;target&quot; group  <span class="math">\\mathbb{G}_T</span>  to be a suitable subgroup of  <span class="math">\\mathbb{F}_{q^6}^*</span>  (since the embedding degree of E is 6), we choose the non-degenerate bilinear map  <span class="math">e \\colon \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span>  to be the (reduced) Tate pairing [FR94, FMR06]. Next, we discuss the concrete performance of the generator, prover, and verifier. Our experiments were running as single-threaded code on a 2.4 GHz Intel E7-8870 CPU with 256 GB of RAM. (While our prototype does not exploit parallelism, our algorithms are highly parallelizable, so that latency can be greatly improved, as discussed in Section 4.4.)</p>

    <p class="text-gray-300"><strong>Performance of key generation.</strong> Given an arithmetic circuit  <span class="math">C: \\mathbb{F}^n \\times \\mathbb{F}^h \\to \\mathbb{F}^l</span>  as input (where  <span class="math">\\mathbb{F} = \\mathbb{F}_r</span> ), the SNARK key generator G outputs:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>a proving key  <span class="math">\\sigma</span> , consisting of  <span class="math">\\approx (11|C|+2n)</span>  group elements from  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\approx |C|</span>  from  <span class="math">\\mathbb{G}_2</span> ; and</li>
      <li>a verification key  <span class="math">\\tau</span> , consisting of (n+2) group elements from  <span class="math">\\mathbb{G}_1</span>  and 6 from  <span class="math">\\mathbb{G}_2</span> .</li>
    </ul>

    <p class="text-gray-300">Only 8 random field elements need to be sampled for this computation. A small set of <em>public parameters</em> provides information, to both the prover and verifier, about the choice of field and elliptic-curve groups; storing these public parameters requires under 4000 bits. Figure 7 shows the measured number of operations (in  <span class="math">\\mathbb{F}_r</span> ,  <span class="math">\\mathbb{G}_1</span> ,  <span class="math">\\mathbb{G}_2</span> ) and running time of G(C) as a function of |C| (for some fixed value of n). For instance, when  <span class="math">|C| \\approx 2 \\cdot 10^6</span> , G terminates in less than 20 minutes.</p>

    <p class="text-gray-300"><strong>Performance of proving.</strong> Given  <span class="math">\\sigma</span>  and (x,a) in the relation  <span class="math">\\mathcal{R}_C</span> , the SNARK prover outputs a proof consisting of 12 group elements (11 in  <span class="math">\\mathbb{G}_1</span>  and 1 in  <span class="math">\\mathbb{G}_2</span> ). The proof length is 2576 bits (322 bytes). For comparison, we can fit 4 proofs into a single TCP packet, which is 1460 bytes. Figure 8 shows the measured number of operations (in  <span class="math">\\mathbb{F}_r, \\mathbb{G}_1, \\mathbb{G}_2</span> ) and running time of  <span class="math">P(\\sigma, x, a)</span>  as a function of |C| (for some fixed value of n). For instance, when  <span class="math">|C| \\approx 2 \\cdot 10^6</span> , P terminates in less than 22 minutes.</p>

    <p class="text-gray-300"><strong>Performance of verifying.</strong> Given  <span class="math">\\tau</span> , an input x, and a proof  <span class="math">\\pi</span> , the SNARK verifier computes the decision bit. To do so, the verifier evaluates 21 pairings and solves a multi-exponentiation problem of size |x|. Figure 9 shows the measured running time of  <span class="math">V(\\tau, x, \\pi)</span>  as a function of |x|. For instance:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>when  <span class="math">|x| \\le 2^6</span> , V terminates in less than 103 milliseconds;</li>
      <li>when  <span class="math">|x| \\le 2^{17}</span> , V terminates in less than 4.68 seconds.</li>
    </ul>

    <p class="text-gray-300">We emphasize that the above performance holds no matter how large is the circuit C.</p>

    <p class="text-gray-300">    <img src="_page_25_Figure_4.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">    <img src="_page_25_Figure_5.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 7: Number of operations in  <span class="math">\\mathbb{F}_r</span> ,  <span class="math">\\mathbb{G}_1</span> ,  <span class="math">\\mathbb{G}_2</span>  (left) and running time (right) of the SNARK key generator G(C) as a function of |C|, the number of gates in C. Also shown (right) is the time spent by G just for sampling linear queries; the difference is spent on cryptographic operations for encoding these queries. As expected, the asymptotic dependence on C is O(|C|). In both graphs, the knees are due to cost of building multi-exponentiation tables for  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span> .</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;22</sup> If x is a vector of field elements in  <span class="math">\\mathbb{F}_r</span> , then |x| is the number of elements in the vector. If x is a bit string, then we can take |x| to be the number of bits in x divided by 181, because we can &quot;pack&quot; 181 bits into a single field element of  <span class="math">\\mathbb{F}_r</span> .</p>

    <p class="text-gray-300">    <img src="_page_26_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">    <img src="_page_26_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 8: Number of operations  <span class="math">\\mathbb{F}_r</span> ,  <span class="math">\\mathbb{G}_1</span> ,  <span class="math">\\mathbb{G}_2</span>  (left) and running time (right) of the SNARK prover  <span class="math">P(\\sigma,x,a)</span>  as a function of |C|, the number of gates in C. Also shown (right) is the (quasilinear) time spent by P just for computing the linear PCP proof; the difference is the (linear) time spent on cryptographic operations for homomorphically evaluating query answers. As expected, the asymptotic dependence on C is  <span class="math">O(|C|\\log|C|)</span> . Moreover, for small values of |C| the (linear) cryptographic overhead dominates; as |C| increases, the (quasilinear) computation of the linear PCP proof eventually will dominate.</p>

    <p class="text-gray-300">    <img src="_page_26_Figure_3.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 9: Running time of the SNARK verifier  <span class="math">V(\\tau,x,\\pi)</span>  as a function of the number of bits in the input x. Also shown is the (linear) time spent by V just for the checking input consistency; the difference is for computing a constant number of pairings (21 in total). Recall that the input to a circuit is generally  <span class="math">\\mathit{much}</span>  smaller than the circuit's size, so the input size should be thought of as relatively small. As expected, the dependence on |x| is O(|x|).</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 System Evaluation</h2>

    <p class="text-gray-300">In Section <a href="#page-7-0">2</a> we discussed our reduction from the correctness of program execution to circuit satisfiability, and then in Section <a href="#page-20-0">3</a> we discussed our zk-SNARK for circuit satisfiability. In this section, we discuss the performance of the system obtained by combining these two components: an implementation of a zk-SNARK for the correctness of program executions. This system provides a solution for non-interactively delegating arbitrary NP computations, also in a way that does not compromise the privacy of any input that the untrusted worker contributes to the computation. Previous implementation work did not achieve many of the features enjoyed by our system. (See Appendix <a href="#page-37-0">C</a> for a comparison with prior implementation work.)</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 System Overview</h3>

    <p class="text-gray-300">The zk-SNARK for the correctness of program executions consists of three algorithms (G? , P? , V ? ):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The key generator <sup>G</sup>? , given a TinyRAM program P, input size n, and time bound T, outputs a proving key &sigma; and a verification key &tau; that can be used to (respectively) prove and verify T-step computations of P on primary inputs of n words. (The auxiliary input may be longer than n words.)</li>
      <li>The prover P ? , given the proving key &sigma;, the TinyRAM program P, a n-word primary input x, time bound T, and auxiliary input w, outputs a proof &pi;, attesting to the fact that P(x, w) accepts in T steps.</li>
      <li>The verifier V ? , given the verification key &tau; , a n-word primary input x, and proof &pi;, checks whether P(x, w) accepts in T steps for some choice of auxiliary input w.</li>
    </ul>

    <p class="text-gray-300">Our GCC-based compiler can be used to obtain TinyRAM programs from C programs. See Figure <a href="#page-27-2">10</a> and Figure <a href="#page-27-2">11</a> below for an overview of how the three algorithms(G? , P? , V ? ) are obtained from (circ,wit,wit&minus;<sup>1</sup> ), which is our circuit reduction, and (G, P, V ), which is our zk-SNARK for circuit satisfiability.</p>

    <p class="text-gray-300">    <img src="_page_27_Figure_8.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 10: Overview of offline phase.</p>

    <p class="text-gray-300">Figure 11: Overview of online phase.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 System Performance</h3>

    <p class="text-gray-300">We now discuss the performance of our system, starting with the efficiency of compilation.<sup>23</sup></p>

    <p class="text-gray-300">&bull; Compiling. The important efficiency measures of compiling from C code to TinyRAM assembly are code size (the number of instructions in the generated assembly code) and execution time (the number of machine steps needed to execute the assembly code). As discussed in Section 2.2, initial experiments indicate that both code size and execution time for our compiler are only a small multiplicative factor greater than those incurred when compiling to other architectures (such as x86, ARM, or AVR) by relying on existing compilers.</p>

    <p class="text-gray-300">Next, we discuss the performance of our implementation of  <span class="math">(G^*, P^*, V^*)</span> . For concreteness, we fix word size W = 16 and number of registers K = 16.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Key generation. The efficiency of the key generator  <span class="math">G^*(\\mathbf{P}, n, T)</span>  essentially only depends on the number of instructions in the program  <span class="math">\\mathbf{P}</span> , the input size n, and the time bound T. Fixing any 100-instruction program  <span class="math">\\mathbf{P}</span> , and input size n = 100, we study the efficiency of  <span class="math">G^*(\\mathbf{P}, n, T)</span>  as the time bound T grows. Specifically, the graphs in Figure 12 on the next page show, as a function of T, the running time of  <span class="math">G^*</span> , the number of gates in the circuit C (generated by  <span class="math">G^*</span>  as an intermediate value), and the number of group elements in the proving key  <span class="math">\\sigma</span>  output by  <span class="math">G^*</span> . (We do not plot the number of group elements in the verification key  <span class="math">\\tau</span>  output by  <span class="math">\\tau</span> 0 output by  <span class="math">\\tau</span> 1.)</li>
      <li>Proving. The efficiency of the prover  <span class="math">P^*(\\sigma, \\mathbf{P}, x, T, w)</span>  essentially only depends on the number of instructions in the program  <span class="math">\\mathbf{P}</span> , the input size n (i.e., the number of words in x), and the time bound T. Fixing any 100-instruction program  <span class="math">\\mathbf{P}</span> , primary input x with n=100 words, and auxiliary input w, we study the efficiency of  <span class="math">P^*(\\sigma, \\mathbf{P}, x, T, w)</span>  as the time bound T grows. Specifically, in Figure 13 on page 30, we plot the running time of  <span class="math">P^*</span>  as a function of T. Recall that the proof generated by P always consist of 12 group elements (regardless of the value of T, or other inputs)</li>
      <li>Verifying. The efficiency of the verifier  <span class="math">V^*(\\tau, x, x)</span>  essentially only depends on the input size n (i.e., the number of words in x). Indeed, the verifier  <span class="math">V^*</span>  receives a verification key  <span class="math">\\tau</span> , primary input x, and proof  <span class="math">\\pi</span> , and then invokes V on these inputs. More precisely,  <span class="math">V^*(\\tau, x, \\pi)</span>  actually coincides with  <span class="math">V(\\tau, x&#x27;, \\pi)</span>  where  <span class="math">x&#x27; \\neq x</span>  is a string of 2W(n+1)+1 bits obtained via a deterministic mapping applied to x. (Note that a primary input x of with n words contains Wn bits.) The mapping from x to x' arises from a technicality for correctly performing input consistency. Note that the circuit reduction was already performed by  <span class="math">G^*</span>  and is implicit in the verification key  <span class="math">\\tau</span> ; thus  <span class="math">V^*</span>  itself is oblivious to the circuit reduction (up to the already mentioned technicality about mapping x to x').</li>
    </ul>

    <p class="text-gray-300">The performance of V as a function of the number of bits in the input was discussed in Section 3.3, and specifically Figure 9 on page 27. So we do not produce any new graphs for  <span class="math">V^*</span> .</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;23</sup>As in Section 3.3, we conducted these experiments using single-threaded code running on a 2.4 GHz Intel E7-8870 CPU with 256 GB of RAM.</p>

    <p class="text-gray-300">    <img src="_page_29_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 12: On the left: running time of G? as a function of the time bound T; also shown is the running time of the circuit generator circ, while the remaining time is spent running G. (As T increases, the running time of G dominates the running time of G? .) In the center: number of gates in the circuit C, output by the circuit generator circ, as a function of T. On the right: number of G<sup>1</sup> and G<sup>2</sup> group elements in the proving key output by G? as a function of T.</p>

    <p class="text-gray-300">    <img src="_page_29_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 13: Running time of P ? as a function of the time bound T. Also shown is the running time of the witness map wit; the remaining time is spent running P. As T increases, the running time of P dominates the running time of P ? .</p>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8">4.3 Performance for Rectilinear TSP Example</h3>

    <p class="text-gray-300">We now report the system's performance when used for an illustrative example. The example proves and verifies claims of membership in the rectilinear Traveling Salesman Problem (<em>rectilinear TSP</em>) language, defined as follows.</p>

    <p class="text-gray-300">A complete weighted graph G is specified by a list  <span class="math">((x_1, y_1), \\ldots, (x_n, y_n))</span>  where  <span class="math">x_i, y_i \\in \\mathbb{Z}</span> ; the <em>i</em>-th pair  <span class="math">(x_i, y_i)</span>  specifies the coordinates in  <span class="math">\\mathbb{Z} \\times \\mathbb{Z}</span>  of the <em>i</em>-th vertex  <span class="math">v_i</span> ; any two vertices  <span class="math">v_i</span>  and  <span class="math">v_j</span>  have weight  <span class="math">\\Delta(v_i, v_j)</span>  given by the Manhattan distance (in  <span class="math">\\mathbb{Z} \\times \\mathbb{Z}</span> ) between  <span class="math">v_i</span>  and  <span class="math">v_j</span> .</p>

    <p class="text-gray-300">Given a complete weighted graph G, the <em>rectilinear TSP language</em>,  <span class="math">\\mathcal{L}_G</span> , is the language of pairs (s,B), where s is a source vertex in G and  <span class="math">B \\in \\mathbb{Z}_+</span>  is a weight bound, such that there exists a Hamiltonian path p in G starting at s and with total weight at most B.</p>

    <p class="text-gray-300">We chose above rectilinear TSP language in order to exercise various features of our system:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Rectilinear TSP is NP-complete (when considered across all graphs G), so the proof-of-knowledge property gives a non-trivial guarantee. Namely, proving knowledge of a Hamiltonian path of low weight &mdash;when such a path is supposedly hard to find&mdash; is quite meaningful. (While proof of knowledge does tend to be more useful in cryptographic examples, we opted for a more familiar &quot;classical&quot; NP example.)</li>
      <li>Valid witnesses are often not unique, so that the zero-knowledge property gives a non-trivial guarantee.</li>
      <li>It is easy to write a linear-time C program that decides the relation for  <span class="math">\\mathcal{L}_G</span> : given an instance (s,B) and a candidate witness p, the program checks that p is a valid path in G and that its total weight is at most B. In contrast, there may not exist a linear-size <em>circuit</em> for this task: even a quasilinear-size circuit seems to require routing/sorting techniques (similar to those used in our circuit generator; cf. Section 2.3). Thus, while simple, deciding  <span class="math">\\mathcal{L}_G</span>  efficiently makes crucial use of random access to memory.</li>
      <li>Instances in the language  <span class="math">\\mathcal{L}_G</span>  are much smaller than witnesses: a single vertex and an integer bound, vs. a Hamiltonian path. Hence, the time to verify a proof (which is linear in the instance size) will be much smaller than simply running the aforementioned program to decide the language (given the full witness).</li>
    </ul>

    <p class="text-gray-300">Fixing a 200-node graph G, we obtained the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Compiling. We wrote a simple C implementation of an NP decider for  <span class="math">\\mathcal{L}_{\\mathsf{G}}</span>  (so that the description of  <span class="math">\\mathsf{G}</span>  is hardcoded in the decider), and compiled it to TinyRAM using our GCC-based compiler. The resulting TinyRAM program  <span class="math">\\mathbf{P}</span>  consists of 1105 instructions. When running  <span class="math">\\mathbf{P}</span>  on a primary input  <span class="math">x = (\\mathsf{s}, \\mathsf{B})</span>  and auxiliary input  <span class="math">y = \\mathsf{p}</span>  (specified as a list of vertices), where  <span class="math">\\mathsf{s} = v_0</span>  and  <span class="math">\\mathsf{p}</span>  is a specific Hamiltonian path in  <span class="math">\\mathsf{G}</span>  of total weight at most  <span class="math">\\mathsf{B}</span> ,  <span class="math">\\mathsf{P}</span>  accepts after  <span class="math">11\\,001</span>  steps.</li>
      <li>Key generation. Running the key generator  <span class="math">G^*</span>  took 247 minutes. The generator  <span class="math">G^*</span>  produced a proving key with 392 153 579 group elements in  <span class="math">\\mathbb{G}_1</span>  and 36 847 976 group elements in  <span class="math">\\mathbb{G}_2</span> ; and a verification key with 9 group elements in  <span class="math">\\mathbb{G}_1</span>  and 6 group elements in  <span class="math">\\mathbb{G}_2</span> . Of the total time, 307 seconds were spent in evaluating the circuit generator circ to compute C and the remaining time was spent in running G on C. The circuit C (which is an intermediate value of  <span class="math">G^*</span> 's computation) consisted of 32 047 142 gates.</li>
      <li>Proving. Running the prover  <span class="math">P^*</span>  took 155 minutes, and produced a proof of 12 group elements (11 in  <span class="math">\\mathbb{G}_1</span>  and 1 in  <span class="math">\\mathbb{G}_2</span> ). Of the total time, 318 seconds were spent in evaluating the witness map wit, which outputs a satisfying assignment a for C, and the remaining time was spent in running P on  <span class="math">(\\sigma, x, a)</span>  to compute the proof.</li>
      <li>Verifying. Running the verifier  <span class="math">V^*</span>  took 0.11 seconds. Essentially this entire time was spent running V. Straightforward optimizations will significantly improve the above running times, as discussed next.</li>
    </ul>

      <h3 id="sec-4.4" class="text-xl font-semibold mt-8">4.4 Further Optimizations</h3>

    <p class="text-gray-300">Our system is a <em>proof-of-concept prototype</em>, not an industrial-grade implementation. In particular, we did not put effort into any &quot;second-order&quot; optimizations that are standard and well-understood, but instead have focused our effort on optimizations that are novel to our work (and are thus less understood). Nonetheless, for completeness, we briefly mention several standard optimizations that will significantly improve the efficiency and scalability of our prototype.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>Parallelization.</em> Essentially all the computations required of the generator, prover, and verifier can be parallelized.<a href="#page-31-1">24</a> In particular, routing on Benes networks, sorting, polynomial interpolation/evaluation, &#711; multi-exponentiation, and others &mdash; all of these are highly-parallelizable (i.e., have polylogarithmic-depth circuits). Parallel implementations of all of these computational tasks are well-studied, and it should not be difficult to make our prototype leverage all available cores so to significantly reduce latency.</li>
      <li><em>Computing in blocks.</em> Most of the computational problems mentioned in the previous paragraph achieve excellent time complexity at the cost of large space complexity. The large space complexity poses a serious obstacle to the scalability of the zk-SNARK to lengthy TinyRAM computations.</li>
    </ul>

    <p class="text-gray-300">For example, the FFT algorithm improves over naive interpolation/evaluation, but does so at the cost of requiring random-linear space (with random access). As long as this fits into available RAM, (quasilinear) FFT is faster than native (quadratic) interpolation/evaluation . But for large problem sizes (e.g., such as those arising when proving correctness of lengthy computations), RAM becomes a bottleneck. This problem is traditionally mitigated by adopting a hybrid approach: the interpolation/evaluation problem is divided into smaller sub-problems (the &quot;blocks&quot;), the FFT algorithm is used to solve (separately) each smaller subproblem, and the solutions to the subproblems are combined using a naive algorithm. Doing so increases time complexity, but decreases space complexity. The choice of the block size allows one to tailor the resulting computational problem to the hardware carrying out the computation.</p>

    <p class="text-gray-300">Similar ideas apply to mitigating the space complexity of routing on Benes networks, multi-exponentiation, &#711; etc. Applying these will improve scalability of the implementation, by removing the memory bottleneck.</p>

    <p class="text-gray-300">&bull; <em>Optimized field arithmetic.</em> Essentially all of the computations of the algorithms of (G, P, V ) &mdash; the zk-SNARK for circuit satisfiability &mdash; consist of field operations over a large prime field. In particular, tightly optimizing arithmetic for such fields (by taking into account the specific architecture at hand, the specific field that is used, etc.) has a significant impact on the efficiency of these three algorithms. Of course, optimizing arithmetic for large prime fields is a well-studied problem (e.g., it arises in many cryptographic applications). Thus, it should not be difficult to improve the running times that we measured in Section <a href="#page-24-0">3.3.</a> (For this reason the number of field operations is arguably a more important measure of efficiency, and in Section <a href="#page-24-0">3.3</a> we do report the number of field operations alongside running times.)</p>

    <p class="text-gray-300"><sup>24</sup>With one exception: the actual execution of the TinyRAM program by the prover, in order to generate the execution trace, cannot of course be parallelized (in the general case).</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Extensions</h2>

    <p class="text-gray-300">For simplicity, throughout the paper we have ignored several (orthogonal) extensions of our approach that provide additional functionality or efficiency. We now describe each of these extensions.</p>

    <p class="text-gray-300">Program-independent offline phase. As discussed in Section <a href="#page-27-0">4,</a> the key generator G? takes as input a TinyRAM program P, input size n, and time bound T; then G? outputs a proving key &sigma; and verification key &tau; that can be used to (respectively) prove and verify T-step computations of P on primary inputs of n words.</p>

    <p class="text-gray-300">But what if one does not want to commit in advance, in the offline phase, to a specific program P?</p>

    <p class="text-gray-300">It is possible to modify G? so that, in the offline phase, one only has to commit to the program size but not the program itself: G? can take as input a <em>program size</em> <code>, rather than an </code>-instruction program P, so that the output keys can work for <em>any</em> program with \` instructions. (In such a case, the verifier V ? will receive P as an additional input.) The modification only incurs a minor overhead in the number of gates in the circuit C output by the circuit generator circ.</p>

    <p class="text-gray-300">Primary inputs and programs of different sizes. As recalled in the previous paragraph, G? takes as input a primary input size n; the output keys then work for computations on primary inputs of n words.</p>

    <p class="text-gray-300">But what if one does not want to commit in advance to a specific input size?</p>

    <p class="text-gray-300">It is possible to modify G? so that the output keys work for computations on primary inputs of <em>at most</em> n words. This modification again only incurs a minor overhead in the number of gates.</p>

    <p class="text-gray-300">Furthermore, if one does not want to commit in advance to a specific program size in the programindependent offline phase described above, it is possible to carry out an analogous modification to G? so that the output keys work for programs with <em>at most</em> <code>instructions (rather than only *exactly*</code> instructions).</p>

    <p class="text-gray-300">In either of the above cases, if V ? has oracle access to the verification key, the running time is linear in the size of the primary input or program, rather than the respective (potentially much larger) bounds.</p>

    <p class="text-gray-300">von Neumann architecture and self-modifying code. As discussed in Section <a href="#page-7-1">2.1,</a> TinyRAM follows the Harvard architecture paradigm: the program to be executed is stored in a separate, read-only, address space (i.e., different from the read-write data address space). It is straightforward to define a <em>von Neumann variant</em> of TinyRAM, where the code to be executed sits in the same, read-write, address space as data. In particular, such an architecture allows for programs that access, and <em>modify</em>, their own code, and allows for applications such as <em>just-in-time compilation</em> <a href="#page-50-13">[GES</a>+09].</p>

    <p class="text-gray-300">It is possible to modify G? , with essentially no efficiency overhead, to work for the &quot;von Neumann variant&quot; of TinyRAM. In particular, our approach can thus be extended to verify correctness of nondeterministic computations expressed via self-modifying programs.</p>

    </section>

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">The authors gratefully thank the members of the programming team: Ohad Barta, Lior Greenblatt, Shaul Kfir, Lev Pachmanov, Michael Riabzev, Gil Timnat, and Arnon Yogev. We also thank Andrey Vihrov for helpful technical discussions; Dan Bernstein, Tanja Lange, Peter Schwabe, and Andrew Sutherland for discussions about elliptic curves; and Ron Rivest and Nickolai Zeldovich for helpful comments and discussions. We thank Nickolai Zeldovich for the use of his group's compute nodes.</p>

    <p class="text-gray-300">The research leading to these results, and in particular the aforementioned programming team, has received funding from the European Community's Seventh Framework Programme (FP7/2007-2013) under grant agreement number 240258. This work was also supported by the Center for Science of Information (CSoI), an NSF Science and Technology Center, under grant agreement CCF-0939370; by the Check Point Institute for Information Security; by the Israeli Ministry of Science and Technology, and by the Israeli Centers of Research Excellence I-CORE program (center 4/11).</p>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A Definition of Zero-Knowledge SNARKs</h2>

    <p class="text-gray-300">In Section 1.1 we informally introduced (publicly-verifiable preprocessing) <em>zero-knowledge SNARKs</em> for boolean circuit satisfiability. For completeness, we give here formal definitions. The extension of the definition to <em>arithmetic</em> circuit satisfiability (as defined in Section 3.2) is straightforward, so we omit it.<sup>25</sup></p>

    <p class="text-gray-300"><strong>Definition A.1.</strong> A triple of algorithms (G, P, V) is a <strong>publicly-verifiable preprocessing SNARG</strong> (or, for brevity in this paper, simply SNARG) for boolean circuit satisfiability if the following conditions are satisfied.</p>

    <h2 id="sec-misc-1" class="text-2xl font-bold">1. Completeness</h2>

    <p class="text-gray-300">For every large enough security parameter  <span class="math">\\lambda \\in \\mathbb{N}</span> , every circuit  <span class="math">C \\colon \\{0,1\\}^n \\times \\{0,1\\}^h \\to \\{0,1\\}</span> , every input  <span class="math">x \\in \\{0,1\\}^n</span> , and every assignment  <span class="math">a \\in \\{0,1\\}^h</span>  with  <span class="math">(x,a) \\in \\mathcal{R}_C</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[V(\\tau, x, \\pi) = 1 \\middle| \\begin{array}{c} (\\sigma, \\tau) \\leftarrow G(1^{\\lambda}, C) \\\\ \\pi \\leftarrow P(\\sigma, x, a) \\end{array} \\right] = 1.</span>$</p>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6">2. Soundness</h4>

    <p class="text-gray-300">For every polynomial-size prover  <span class="math">P^*</span> , constant c &gt; 0, every large enough security parameter  <span class="math">\\lambda \\in \\mathbb{N}</span> , and every circuit  <span class="math">C \\colon \\{0,1\\}^n \\times \\{0,1\\}^h \\to \\{0,1\\}</span>  of size  <span class="math">\\lambda^c</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\begin{array}{c|c} V(\\tau,x,\\pi) = 1 \\\\ \\nexists \\ a \\ s.t. \\ (x,a) \\in \\mathcal{R}_C \\end{array} \\right| \\begin{array}{c} (\\sigma,\\tau) \\leftarrow G(1^{\\lambda},C) \\\\ (x,\\pi) \\leftarrow P^*(\\sigma,\\tau) \\end{array} \\right] \\leq \\mathsf{negl}(\\lambda) \\ .</span>$</p>

    <h2 id="sec-misc-3" class="text-2xl font-bold">3. Efficiency</h2>

    <p class="text-gray-300">There is a universal polynomial p such that, for every large enough security parameter  <span class="math">\\lambda \\in \\mathbb{N}</span> , every circuit  <span class="math">C: \\{0,1\\}^n \\times \\{0,1\\}^h \\to \\{0,1\\}</span> , input  <span class="math">x \\in \\{0,1\\}^n</span> , and assignment  <span class="math">a \\in \\{0,1\\}^h</span>  with  <span class="math">(x,a) \\in \\mathcal{R}_C</span> ,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the key generator G runs in time  <span class="math">p(\\lambda + |C|)</span> ;</li>
      <li>the prover P runs in time  <span class="math">p(\\lambda + |C|)</span> ;</li>
      <li>the verifier V runs in time  <span class="math">p(\\lambda + |x|)</span> ;</li>
      <li>an honestly generated proof has size  <span class="math">p(\\lambda)</span> .</li>
    </ul>

    <p class="text-gray-300">    <img src="_page_34_Figure_15.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 14: Overview of offline phase.</p>

    <p class="text-gray-300">Figure 15: Overview of online phase.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;25</sup>In particular, we do not define here zero-knowledge SNARKs relative to a <em>universal relation</em> [BG08]. For details, see [BCI<sup>+</sup>13].</p>

    <p class="text-gray-300">A SNARG of knowledge (SNARK) is a SNARG where soundness is strengthened as follows:</p>

    <p class="text-gray-300"><strong>Definition A.2.</strong> A triple of algorithms (G, P, V) is a <strong>SNARK</strong> (for circuit satisfiability) if it is a SNARG (for circuit satisfiability) where soundness is replaced by the following stronger requirement:</p>

    <h3 id="sec-misc-4" class="text-xl font-semibold mt-8"><span class="math">Proof\\ of\\ knowledge</span></h3>

    <p class="text-gray-300">For every polynomial-size prover  <span class="math">P^*</span>  there exists a polynomial-size extractor E such that for every constant c&gt;0, large enough security parameter  <span class="math">\\lambda\\in\\mathbb{N}</span> , every auxiliary input  <span class="math">z\\in\\{0,1\\}^{\\mathrm{poly}(\\lambda)}</span> , and every circuit  <span class="math">C:\\{0,1\\}^n\\times\\{0,1\\}^h\\to\\{0,1\\}</span>  of size  <span class="math">\\lambda^c</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\begin{array}{c|c} V(\\tau,x,\\pi) = 1 \\\\ (x,a) \\notin \\mathcal{R} \\end{array} \\middle| \\begin{array}{c} (\\sigma,\\tau) \\leftarrow G(1^{\\lambda},C) \\\\ (x,\\pi) \\leftarrow P^{*}(z,\\sigma,\\tau) \\\\ a \\leftarrow E(z,\\sigma,\\tau) \\end{array} \\right] \\leq \\mathsf{negl}(\\lambda) \\enspace .</span>$</p>

    <p class="text-gray-300">A zero-knowledge SNARK (or &quot;succinct NIZK of knowledge&quot;) is a SNARK satisfying a zero-knowledge property. Namely, zero knowledge ensures that the honest prover can generate valid proofs for true theorems without leaking any information about the theorem beyond the fact that the theorem is true (in particular, without leaking any information about the assignment that he used to generate the proof). Of course, when considering zero-knowledge SNARKs, the prover must trust the generation of the proving key  <span class="math">\\sigma</span> . (Thus, combined with the fact that the verifier must trust the generation of the verification key  <span class="math">\\tau</span> , the key generator G must be run by a party that is trusted by both the prover and verifier.)</p>

    <p class="text-gray-300"><strong>Definition A.3.</strong> A triple of algorithms (G, P, V) is a (perfect) zero-knowledge SNARK (for circuit satisfiability) if it is a SNARK (for circuit satisfiability) and, moreover, satisfies the following property:</p>

    <h4 id="sec-misc-5" class="text-lg font-semibold mt-6">Zero Knowledge</h4>

    <p class="text-gray-300">There exists a stateful interactive polynomial-size simulator S such that for all stateful interactive polynomial-size distinguishers  <span class="math">\\mathcal{D}</span> , constant c, large enough security parameter  <span class="math">\\lambda \\in \\mathbb{N}</span> , every auxiliary input  <span class="math">z \\in \\{0,1\\}^{\\operatorname{poly}(\\lambda)}</span> , and every circuit  <span class="math">C:\\{0,1\\}^n \\times \\{0,1\\}^h \\to \\{0,1\\}</span>  of size  <span class="math">\\lambda^c</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\begin{array}{c|c} (x,a) \\in \\mathcal{R}_C \\\\ \\mathcal{D}(\\pi) = 1 \\end{array} \\middle| \\begin{array}{c} (\\sigma,\\tau) \\leftarrow G(1^\\lambda,C) \\\\ (x,a) \\leftarrow \\mathcal{D}(z,\\sigma,\\tau) \\\\ \\pi \\leftarrow P(\\sigma,x,a) \\end{array}\\right] = \\Pr\\left[\\begin{array}{c|c} (x,a) \\in \\mathcal{R}_C \\\\ \\mathcal{D}(\\pi) = 1 \\end{array} \\middle| \\begin{array}{c} (\\sigma,\\tau,\\mathsf{trap}) \\leftarrow S(1^\\lambda,C) \\\\ (x,a) \\leftarrow \\mathcal{D}(z,\\sigma,\\tau) \\\\ \\pi \\leftarrow S(z,\\sigma,x,\\mathsf{trap}) \\end{array}\\right] \\ .</span>$</p>

    <p class="text-gray-300">As usual, Definition A.3 can be relaxed to consider the case in which the distributions are only <em>statistically</em> or <em>computationally</em> close.</p>

    <p class="text-gray-300"><strong>Multiple theorems.</strong> A desirable property (especially when the SNARK requires an expensive preprocessing phase!) is the ability to generate the system's parameters  <span class="math">(\\sigma, \\tau)</span>  once and for all and then reuse them in polynomially-many proofs (potentially generated by different provers). Doing so requires security also against provers that <em>have access to a proof-verification oracle</em>. In the case of public verifiability (which is the one considered in this paper) this <em>multi-theorem proof of knowledge</em> property is automatically guaranteed. (See [BCI<sup>+</sup>13] for more details.)</p>

    </section>

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold">B Summary of Theoretical Work on Succinct Verification</h2>

    <p class="text-gray-300">In Table <a href="#page-36-1">3</a> we provide a summary of theoretical work on proof systems and argument systems with succinct verification. For more details, we refer the reader to the cited works. In the table, lightly-shaded rows are works obtaining succinct <em>non-interactive</em> arguments (SNARGs); darkly-shaded rows are works obtaining SNARGs in the preprocessing model, which is the model considered in this work.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The column &quot;<em>supported statements</em>&quot; denotes what types of computations can be succinctly verified.</li>
      <li>The column &quot;<em># online messages</em>&quot; denotes how many statement-dependent messages are needed for the prover to convince the verifier. (All of the constructions require also a single offline message to set up the system's parameters.)</li>
      <li>The column &quot;<em>offline work</em>&quot; denotes whether the offline generation of system parameters is as expensive as conducting the computation, or much cheaper (namely, only a fixed polynomial in the security parameter).</li>
      <li>The column &quot;<em>secure with verifier oracle?</em>&quot; denotes whether the construction is secure even against provers that have access to a proof-verification oracle. (If not, then the construction has the so-called verifierrejection problem.)</li>
      <li>The column &quot;<em>publicly verifiable?</em>&quot; denotes whether anyone can recognize an accepting proof. When there is more than 1 online message, public verifiability guarantees soundness only when the party verifying the proof trusts the generation of the verifier's online messages (besides that of the system's parameters).</li>
      <li>The column &quot;<em>main tools</em>&quot; provides keywords for the main ingredients of the construction.</li>
    </ul>

    <p class="text-gray-300">From a theoretical point of view, the (preprocessing) SNARG implementation presented in this work is an optimized variant of the asymptotically-efficient construction in <a href="#page-48-8">[BCI</a>+13]. (See Table <a href="#page-36-1">3</a> below.)</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">supported</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"># online</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">offline</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">secure with</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">publicly</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">references</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">statements</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">messages</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">work</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">verifier oracle?</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">verifiable?</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">main tools</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[Kil92]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">cheap</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">yes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">yes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">PCP, CRH</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[AIK10]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">P</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">expensive</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">no</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">no</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FHE, RE, MAC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[GGP10]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">P</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">expensive</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">no</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">no</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FHE, Yao GC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[CKV10]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">P</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">expensive</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">no</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">no</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FHE, cut-and-choose</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[GKR08]+[KR09]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">cheap</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">no</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">no</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">IP for Muggles, PIR</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[CRR12]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">non-uniform NC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">expensive</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">yes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">IP for Muggles, PIR, CRH</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[KRR13]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SPACE(logc<br>)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">cheap</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">no</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">no</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">no-signaling MIP, FHE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[PRV12]+[GVW13]+[GKP+13]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">expensive</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">yes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">yes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FHE, FE, Yao GC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[GLR11]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">cheap</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">no</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">no</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">PCP, PIR, extractable CRH</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BCCT12]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">cheap</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">no</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">no</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">PCP, PIR, extractable CRH</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[DFH12]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">cheap</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">no</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">no</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">PCP, PIR, extractable CRH</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BC12]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">cheap</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">no<br>no</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MIP, extractable FHE</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[Gro10a]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">expensive</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">yes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">yes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">knowledge of exponent</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[Lip12]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">expensive</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">yes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">yes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">knowledge of exponent</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[GGPR13]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">expensive</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">yes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">yes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">QSP, knowledge of exponent</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BCI+13]<br>(we follow this work)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">expensive</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">yes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">yes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">linear PCP, linear targeted mall.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BCCT13]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">cheap</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">yes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">yes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">any publicly-verifiable SNARK</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 3: Summary of work on argument systems with succinct verification.</p>

    </section>

    <section id="app-c" class="mb-10">
      <h2 class="text-2xl font-bold">C Prior Implementation Work</h2>

    <p class="text-gray-300">Implementations of arguments systems for NP with succinct verification have not been achieved by prior work. (Not even in the preprocessing model, nor with interaction between the prover and verifier, nor for NP-complete languages that are less convenient than the correctness of RAM computations.) In Section C.1, we discuss prior work about implementations of delegation protocols of various flavors. We also discuss an independent work of Parno et al. [PGHR13] that, like this work, studies succinct verification in the preprocessing model. Then, in Section C.2, we discuss how previous work has addressed the problem of reducing the correctness of program executions to low-level representations such as circuits.</p>

      <h3 id="app-c.1" class="text-xl font-semibold mt-8">C.1 Prior Implementations of Proof Systems for Verifiably Delegating Computation</h3>

    <p class="text-gray-300">Interactive proofs for low-depth circuits. Goldwasser et al. [GKR08] obtained an interactive proof for delegating computations of low-depth circuits: given an input of length n, a verifier can check that a  <span class="math">O(\\log S(n))</span> -space uniform circuit of fan-in 2, size S(n), and depth D(n) is correctly evaluated on the input, while running only in time  <span class="math">(n+D(n)) \\cdot \\operatorname{polylog} S(n)</span> ; the honest prover runs in time  <span class="math">\\operatorname{poly}(S(n))</span>  and requires  <span class="math">D(n) \\cdot \\operatorname{polylog} S(n)</span>  rounds of interaction with the verifier. A set of works [CMT12, TRMP12, Tha13] has optimized and implemented the protocol of Goldwasser et al. [GKR08]; for instance, it improved the running time of the prover to  <span class="math">O(S(n) \\log S(n))</span> , provided a GPU implementation, and carefully optimized the protocol for circuits with &quot;sufficiently regular&quot; wiring patterns.</p>

    <p class="text-gray-300">The protocol of [GKR08] can be reduced to a two-message argument system [KR09, KRR13]. Canetti et al. [CRR12] showed how to extend the techniques in [GKR08] to also handle non-uniform circuits, with a two-message protocol having an expensive offline preprocessing phase.</p>

    <p class="text-gray-300"><strong>Batching arguments.</strong> Ishai et al. [IKO07] constructed a 4-message argument system for NP in which the prover-to-verifier communication is short (i.e., an argument with a <em>laconic</em> prover [GVW02]) by combining a <em>strong</em> linear PCP and linear homomorphic encryption. While their construction does not grant the verifier savings in computation, Ishai et al. noted that their protocol yields a <em>batching argument</em>: an argument in which, to simultaneously verify that  <span class="math">\\ell</span>  circuits of size S are satisfiable, the verifier runs in time  <span class="math">\\max\\{S^2,\\ell\\}</span>  poly( <span class="math">\\lambda</span> ), where  <span class="math">\\lambda</span>  is a security parameter. (Thus, the verifier runs in time  <span class="math">(S^2/\\ell)</span>  poly( <span class="math">\\lambda</span> ) per circuit.)</p>

    <p class="text-gray-300">A set of works [SBW11, SMBW12, SVP<sup>+</sup>12, SBV<sup>+</sup>13] has improved, optimized, and implemented the batching argument of Ishai et al. [IKO07] for the purpose of outsourcing computation. In particular, by relying on quadratic arithmetic programs (QAPs) of [GGPR13], Setty et al. [SBV<sup>+</sup>13] have improved the running time of the verifier and prover to  <span class="math">\\max\\{S,\\ell\\} \\cdot \\operatorname{poly}(\\lambda)</span>  and  <span class="math">\\tilde{O}(S) \\cdot \\operatorname{poly}(\\lambda)</span>  respectively.<sup>28</sup></p>

    <p class="text-gray-300">Vu et al. [VSBW13] provide a system that incorporates (along with optimizations) both the batching arguments of [SBW11, SMBW12, SVP<sup>+</sup>12, SBV<sup>+</sup>13] as well as the interactive proofs of [CMT12, TRMP12, Tha13]. The system decides, for any given instance, which of the two approaches is more efficient to use.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;26</sup> While all prior works only achieve solutions formally weaker than a succinct argument for NP, they rely on more standard cryptographic assumptions than those used in constructions of non-interactive succinct arguments for NP. (Or no assumptions at all in the case of information-theoretic constructions.) In our work, like other works on non-interactive arguments for NP, we rely on less standard cryptographic assumptions; Gentry and Wichs [GW11] have provided evidence that doing so might be inherent.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;27</sup>A <em>strong</em> linear PCP is a PCP in which the honest proof oracle is guaranteed to be a linear function, and soundness is required to hold for <em>all</em> (including non-linear) proof oracles. In this paper we rely on the work of Bitansky et al. [BCI<sup>+</sup>13], who work with a (<em>weak</em>) linear PCP, which is a PCP in which the honest proof oracle is guaranteed to be a linear function, and soundness is required to hold <em>only</em> for linear proof oracles. See [BCI<sup>+</sup>13] for a more detailed discussion on the differences between the two.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;28</sup>A brief technical comparison is of order here. Setty et al. [SBV<sup>+</sup>13] use QAPs within the framework of [IKO07], while in our work we do so within the framework of Bitansky et al. [BCI<sup>+</sup>13]. This implies significant differences in terms of cryptographic assumptions, efficiency, and functionality. See [BCI<sup>+</sup>13] for more details.</p>

    <p class="text-gray-300">Arguments with competing provers. Canetti et al. <a href="#page-49-20">[CRR11]</a> use collision-resistant hashes to get a protocol for verifying any deterministic T(n)-time computation, in time only O(n + &lambda; log T(n)), in a model where the verifier interacts with two computationally-bounded provers at least one of which is assumed to be honest <a href="#page-50-17">[FK97]</a>. Remarkably, the protocol in <a href="#page-49-20">[CRR11]</a> can be made to work <em>directly</em> for random-access machines, and therefore does not require reducing random-access machines to any &quot;lower-level&quot; representation (such as circuits). Canetti et al. implement their protocol for (deterministic) x86 programs and obtain very good efficiency. In order to support arbitrary C programs, Canetti et al. use GCC and a special deterministic implementation of key C standard-library functions such as malloc and free.</p>

    <p class="text-gray-300">Independent work on preprocessing SNARKs. Parno et al. <a href="#page-52-10">[PGHR13]</a> optimize and implement the preprocessing SNARK based on quadratic arithmetic programs (QAPs) of Gennaro et al. <a href="#page-50-4">[GGPR13]</a>; their proof system supports proving satisfiability of arithmetic circuits. For comparison, in our work, we also implement a preprocessing SNARK based on QAPs for arithmetic circuit satisfiability, but we do so via the (in our eyes) simpler framework of Bitansky et al. <a href="#page-48-8">[BCI</a>+13] for constructing SNARKs from linear PCPs.</p>

    <p class="text-gray-300">The major difference between our work and that of Parno et al. is the approach to the representation problem: namely, how to obtain an efficient low-level (in this case, arithmetic circuit) representation for the correctness of arbitrary program executions. As we shall discuss next, the approach of Parno et al. (unlike ours) incurs at least a quadratic blow-up in the worst-case, like all other prior works.</p>

      <h3 id="app-c.2" class="text-xl font-semibold mt-8">C.2 Prior Implementations of Circuit Generators</h3>

    <p class="text-gray-300">All previous implementation work (except the work of Canetti et al. <a href="#page-49-20">[CRR11]</a> on competing provers) requires an instance to be represented as a circuit, or other similar &quot;low-level&quot; representations.</p>

    <p class="text-gray-300">While <a href="#page-52-13">[SBW11,</a> <a href="#page-52-14">SMBW12,</a> <a href="#page-49-19">CMT12,</a> <a href="#page-52-11">TRMP12]</a> do not address the problem of converting arbitrary programs to a circuit representation, <a href="#page-52-15">[SVP</a>+12, <a href="#page-52-16">SBV</a>+13] do consider the problem of programming arithmetic circuits. Specifically, they present a solution, based on the Fairplay compiler <a href="#page-51-9">[MNPS04,</a> <a href="#page-49-13">BDNP08]</a>, for compiling programs written in a special language called SFDL. Next, both <a href="#page-52-15">[SVP</a>+12, <a href="#page-52-16">SBV</a>+13] convert the output of the FairPlay compiler to the constraints required by their respective protocols.</p>

    <p class="text-gray-300">Compared with high-level programming languages like C, SFDL is quite limited in the sense that it does not support important primitives and has inefficient support for others. For example, SFDL does not support loops with a non-constant number of iterations; also, it does not support recursions. Furthermore, each array access of the form A[i], where A is an array and i is an index, is implemented via a multiplexer circuit over the <em>entire</em> array. In particular, relying on a compiler such as FairPlay has a severe drawback: the circuits it generates have size that is <em>quadratic</em> in the time bound T in the worst case, due to inefficient support of memory accesses. So, e.g., the prover in all previous works runs in time that is &Omega;(T 2 ) in the worst case.</p>

    <p class="text-gray-300">Parno et al. <a href="#page-52-10">[PGHR13]</a> do not rely on the Fairplay compiler, but also rely on an approach with a blowup that is at least quadratic in the worst case. Indeed, they provide a compiler for a basic subset of C that, like SFDL, is very restrictive: memory accesses are static constants, loops are unrolled up to a static bound, both branches of a conditional are executed, and so on. In particular, accesses to memory are inefficiently supported.</p>

    <p class="text-gray-300">The quadratic blowup in previous work is not accidental but is due to a fundamental difficulty: how is consistency of random-access memory achieved? As discussed (see Section <a href="#page-13-5">2.3.2)</a>, the naive solution of multiplexing from memory at each time step is inefficient. Instead, in this work (see Section <a href="#page-13-0">2.3)</a> we implement an <em>efficient</em> circuit generator: by leveraging nondeterminism and routing <a href="#page-48-11">[BCGT13a]</a>, we generate an arithmetic circuit whose size is only O(T log T). The bound holds even when a program makes use of datadependent loops, control flow, recursions, and memory accesses. (Indeed, the bound holds for all TinyRAM programs.) Because most prior works support circuit satisfiability, all these prior works directly benefit from our circuit generator in the sense that their circuit generators can be replaced with our more efficient one. (E.g., doing so in <a href="#page-52-16">[SBV</a>+13] or <a href="#page-52-10">[PGHR13]</a> ensures the prover runs in quasilinear instead of quadratic time.)</p>

    </section>

    <section id="app-d" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>D</strong> Definition of Linear PCPs</h2>

    <p class="text-gray-300">In Section 1.2 we informally introduced a linear PCP to be a PCP where the honest proof oracle is a linear function (over some underlying field), and soundness is required to hold <em>only</em> for linear proof oracles. For completeness, we give here formal definitions. For more details, see [BCI<sup>+</sup>13].</p>

    <p class="text-gray-300"><strong>Definition D.1.</strong> We say that a multivariate polynomial  <span class="math">f: \\mathbb{F}^m \\to \\mathbb{F}</span>  has <strong>degree</strong> d if the total degree of f is at most d. A <strong>multivalued multivariate polynomial</strong>  <span class="math">f: \\mathbb{F}^m \\to \\mathbb{F}^{\\mu}</span>  is a vector of polynomials  <span class="math">(f_1, \\ldots, f_{\\mu})</span>  where each  <span class="math">f_i: \\mathbb{F}^m \\to \\mathbb{F}</span>  is a (single-valued) multivariate polynomial.</p>

    <p class="text-gray-300">A <em>linear</em> probabilistically-checkable proof (linear PCP) system for a relation  <span class="math">\\mathcal{R}</span>  over a field  <span class="math">\\mathbb{F}</span>  is one where the PCP oracle is restricted to compute a linear function  <span class="math">\\pi \\colon \\mathbb{F}^m \\to \\mathbb{F}</span>  of the verifier's queries. Viewed as a traditional PCP,  <span class="math">\\pi</span>  has length  <span class="math">|\\mathbb{F}|^m</span>  (and alphabet  <span class="math">\\mathbb{F}</span> ). For simplicity, we ignore the computational complexity issues in the following definition, and refer to them when they are needed.</p>

    <p class="text-gray-300"><strong>Definition D.2.</strong> Let  <span class="math">\\mathcal{R}</span>  be a binary relation,  <span class="math">\\mathbb{F}</span>  a finite field,  <span class="math">P_{\\mathsf{LPCP}}</span>  a deterministic prover algorithm, and  <span class="math">V_{\\mathsf{LPCP}}</span>  a probabilistic oracle verifier algorithm. We say that the pair  <span class="math">(P_{\\mathsf{LPCP}}, V_{\\mathsf{LPCP}})</span>  is a (input-oblivious) k-query linear PCP for  <span class="math">\\mathcal{R}</span>  over  <span class="math">\\mathbb{F}</span>  with knowledge error  <span class="math">\\varepsilon</span>  and query length m if it satisfies the following requirements.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Syntax. On any input x and oracle  <span class="math">\\pi</span> , the verifier  <span class="math">V_{\\mathsf{LPCP}}^{\\pi}(x)</span>  makes k input-oblivious queries to  <span class="math">\\pi</span>  and then decides whether to accept or reject. More precisely,  <span class="math">V_{\\mathsf{LPCP}}</span>  consists of a probabilistic query algorithm  <span class="math">Q_{\\mathsf{LPCP}}</span>  and a deterministic decision algorithm  <span class="math">D_{\\mathsf{LPCP}}</span>  working as follows. Based on its internal randomness, and independently of x,  <span class="math">Q_{\\mathsf{LPCP}}</span>  generates k queries  <span class="math">q_1, \\ldots, q_k \\in \\mathbb{F}^m</span>  to  <span class="math">\\pi</span>  and state information  <span class="math">\\mathbf{u}</span> ; then, given x,  <span class="math">\\mathbf{u}</span> , and the k oracle answers  <span class="math">a_1 = \\langle \\pi, q_1 \\rangle, \\ldots, a_k = \\langle \\pi, q_k \\rangle</span> ,  <span class="math">D_{\\mathsf{LPCP}}</span>  accepts or rejects.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><u>Completeness.</u> For every  <span class="math">(x, w) \\in \\mathcal{R}</span> , the output of  <span class="math">P_{\\mathsf{LPCP}}(x, w)</span>  is a description of a linear function  <span class="math">\\pi \\colon \\mathbb{F}^m \\to \\mathbb{F}</span>  such that  <span class="math">V^{\\pi}_{\\mathsf{LPCP}}(x)</span>  accepts with probability 1.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><u>Knowledge.</u> There exists a knowledge extractor  <span class="math">E_{\\mathsf{LPCP}}</span>  such that for every linear function  <span class="math">\\pi^* \\colon \\mathbb{F}^m \\to \\mathbb{F}</span>  if the probability that  <span class="math">V_{\\mathsf{LPCP}}^{\\pi^*}(x)</span>  accepts is greater than  <span class="math">\\varepsilon</span>  then  <span class="math">E_{\\mathsf{LPCP}}^{\\pi^*}(x)</span>  outputs w such that  <span class="math">(x,w) \\in \\mathbb{R}</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">    <img src="_page_39_Figure_8.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 16: Diagram of a k-query linear PCP of length m.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;29</sup>In particular,  <span class="math">(P_{\\mathsf{LPCP}}, V_{\\mathsf{LPCP}})</span>  has soundness error  <span class="math">\\varepsilon</span> : for every x such that  <span class="math">(x, w) \\not\\in \\mathcal{R}</span>  for all w, and for every linear function  <span class="math">\\pi^* \\colon \\mathbb{F}^m \\to \\mathbb{F}</span> , the probability that  <span class="math">V_{\\mathsf{LPCP}}^{\\pi^*}(x)</span>  accepts is at most  <span class="math">\\varepsilon</span> .</p>

    <p class="text-gray-300">An important efficiency measure for a linear PCP is the (algebraic) degree of the verifier. Specifically, we say that  <span class="math">(P_{LPCP}, V_{LPCP})</span>  has <strong>degree</strong>  <span class="math">(d_O, d_D)</span>  if, additionally the following two requirements hold.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The query algorithm  <span class="math">Q_{\\text{LPCP}}</span>  has degree  <span class="math">d_Q</span> . Namely, there are k polynomials  <span class="math">p_1, \\ldots, p_k \\colon \\mathbb{F}^\\mu \\to \\mathbb{F}^m</span>  and state polynomial  <span class="math">p \\colon \\mathbb{F}^\\mu \\to \\mathbb{F}^{m&#x27;}</span> , all of degree  <span class="math">d_Q</span> , such that the linear PCP queries are  <span class="math">q_1 = p_1(r), \\ldots, q_k = p_k(r)</span>  and the state is  <span class="math">\\mathbf{u} = p(r)</span> , for a random  <span class="math">r \\in \\mathbb{F}^\\mu</span> .</li>
      <li>The decision algorithm  <span class="math">D_{LPCP}</span>  has degree  <span class="math">d_D</span> . Namely, for every input x there is a polynomial  <span class="math">\\boldsymbol{t}_x \\colon \\mathbb{F}^{m&#x27;+k} \\to \\mathbb{F}^{\\eta}</span>  of degree  <span class="math">d_D</span>  such that  <span class="math">\\boldsymbol{t}_x(\\mathbf{u}, a_1, \\dots, a_k) = 0^{\\eta}</span>  if and only if  <span class="math">D_{LPCP}(x, \\mathbf{u}, a_1, \\dots, a_k)</span>  accepts.</li>
    </ul>

    <p class="text-gray-300">In such a case, we call m', which is the number of field elements in the u, the <strong>state length</strong>.</p>

    <p class="text-gray-300"><strong>Honest-verifier zero-knowledge linear PCPs.</strong> We also consider <em>honest-verifier zero-knowledge</em> (HVZK) linear PCPs. In an HVZK linear PCP, soundness or knowledge is defined as in a usual linear PCP, and HVZK is defined as in a usual HVZK PCP. For convenience, let us recall the definition of a HVZK PCP:</p>

    <p class="text-gray-300"><strong>Definition D.3.</strong> A PCP system  <span class="math">(P_{PCP}, V_{PCP})</span>  for a relation  <span class="math">\\mathcal{R}</span> , where  <span class="math">P_{PCP}</span>  is also probabilistic, is  <span class="math">\\delta</span> -statistical <strong>HVZK</strong> if there exists a simulator  <span class="math">S_{PCP}</span> , running in expected polynomial time, for which the following two ensembles are  <span class="math">\\delta</span> -close ( <span class="math">\\delta</span>  can be a function of the field, input length, and so on):</p>

    <p class="text-gray-300"><span class="math">$\\left\\{S_{\\text{PCP}}(x)\\right\\}_{(x,w)\\in\\mathcal{R}} \\text{ and } \\left\\{\\operatorname{View}\\left(V_{\\text{PCP}}^{\\pi_{x,w}}(x)\\right)\\mid \\pi_{x,w}\\leftarrow P_{\\text{PCP}}(x,w)\\right\\}_{(x,w)\\in\\mathcal{R}} \\right.,</span>$</p>

    <p class="text-gray-300">where View represents the view of the verifier, including its coins and the induced answers according to  <span class="math">\\pi</span> . If the above two distributions are identically distributed then we say that  <span class="math">(P_{PCP}, V_{PCP})</span>  is <strong>perfect</strong> HVZK.</p>

    </section>

    <section id="app-e" class="mb-10">
      <h2 class="text-2xl font-bold">E An Efficient HVZK Linear PCP</h2>

    <p class="text-gray-300">We describe the HVZK linear PCP for circuit satisfiability that we designed and implemented. (See Appendix D for the definition of a linear PCP, the HVZK property, and other notions used in this section.) The basic design of our linear PCP builds on the <em>quadratic arithmetic programs</em> (QAPs) of Gennaro et al. [GGPR13]. (See Remark E.4 for a technical comparison.)</p>

    <p class="text-gray-300">Rather than directly constructing a linear PCP for circuit satisfiability, we first construct linear PCPs for a notationally more convenient language: satisfiability of systems of rank-1 quadratic equations over a finite field  <span class="math">\\mathbb{F}</span> . As discussed below, both boolean and arithmetic circuit satisfiability are reducible to this language essentially without any overheads.</p>

    <p class="text-gray-300"><strong>Definition E.1.</strong> A system of rank-1 quadratic equations over  <span class="math">\\mathbb{F}</span>  is a tuple  <span class="math">\\mathcal{S} = ((\\mathbf{a}_j, \\mathbf{b}_j, \\mathbf{c}_j)_{j=1}^{N_{\\mathsf{g}}}, n)</span>  where  <span class="math">\\mathbf{a}_j, \\mathbf{b}_j, \\mathbf{c}_j \\in \\mathbb{F}^{1+N_{\\mathsf{w}}}</span>  and  <span class="math">n \\leq N_{\\mathsf{w}}</span> . Such a system  <span class="math">\\mathcal{S}</span>  is satisfiable with an input  <span class="math">\\mathbf{x} \\in \\mathbb{F}^n</span>  if there is a witness  <span class="math">\\mathbf{w} \\in \\mathbb{F}^{N_{\\mathsf{w}}}</span>  such that:</p>

    <pre><code class="language-text">1. \\mathbf{x} = (w_1, \\dots, w_n), and
2. \\langle \\mathbf{a}_j, (1, \\mathbf{w}) \\rangle \\cdot \\langle \\mathbf{b}_j, (1, \\mathbf{w}) \\rangle = \\langle \\mathbf{c}_j, (1, \\mathbf{w}) \\rangle for all for j \\in [N_g].
In such a case, we write S(\\mathbf{x}, \\mathbf{w}) = 1.
</code></pre>

    <p class="text-gray-300">We call  <span class="math">N_{\\rm g}</span>  the number of constraints,  <span class="math">N_{\\rm w}</span>  the number of variables, and n the input size.</p>

    <p class="text-gray-300"><strong>Definition E.2.</strong> The satisfaction problem of a system (of rank-1 quadratic equations) S is the relation  <span class="math">\\mathcal{R}_{S} = \\{(\\mathbf{x}, \\mathbf{w}) \\in \\mathbb{F}^{n} \\times \\mathbb{F}^{N_{w}} : S(\\mathbf{x}, \\mathbf{w}) = 1\\}</span> ; its language is denoted  <span class="math">\\mathcal{L}_{S}</span> .</p>

    <p class="text-gray-300">A boolean circuit  <span class="math">C\\colon\\{0,1\\}^n\\times\\{0,1\\}^h\\to\\{0,1\\}</span>  with  <span class="math">\\alpha</span>  wires and  <span class="math">\\beta</span>  (bilinear) gates induces a corresponding system of quadratic equations  <span class="math">\\mathcal S</span>  with  <span class="math">N_{\\mathsf w}=\\alpha</span>  variables and  <span class="math">N_{\\mathsf g}=\\beta+h+1</span>  constraints. (The h+1 additional constraints are to ensure that the h variables corresponding to witness wires have boolean values, and that the output gate outputs 0.) Similarly, an arithmetic circuit  <span class="math">C\\colon\\mathbb F^n\\times\\mathbb F^h\\to\\mathbb F^l</span>  with  <span class="math">\\alpha</span>  wires and  <span class="math">\\beta</span>  (bilinear) gates induces a corresponding system of quadratic equations  <span class="math">\\mathcal S</span>  with  <span class="math">N_{\\mathsf w}=\\alpha</span>  variables and  <span class="math">N_{\\mathsf g}=\\beta+l</span>  constraints. Thus, we can focus on the relation  <span class="math">\\mathcal R_{\\mathcal S}</span>  without loss in generality or efficiency.</p>

    <p class="text-gray-300">We prove the following claim:</p>

    <p class="text-gray-300"><strong>Claim E.3.</strong> For any finite field  <span class="math">\\mathbb{F}</span> , there is a 5-query linear PCP  <span class="math">(P_{\\mathsf{LPCP}}, (Q_{\\mathsf{LPCP}}, D_{\\mathsf{LPCP}}))</span>  for  <span class="math">\\mathcal{R}_{\\mathcal{S}}</span>  over  <span class="math">\\mathbb{F}</span>  with knowledge error  <span class="math">\\frac{2N_{\\mathsf{g}}}{|\\mathbb{F}|}</span> , query length  <span class="math">5+N_{\\mathsf{w}}+N_{\\mathsf{g}}</span> , state length n+2, and degree  <span class="math">(d_Q, d_D)=(N_{\\mathsf{g}}, 2)</span> . Moreover,  <span class="math">Q_{\\mathsf{LPCP}}</span>  needs to sample only a single random element of  <span class="math">\\mathbb{F}</span>  to generate the output queries and state. Finally, the linear PCP is  <span class="math">\\frac{N_{\\mathsf{g}}}{|\\mathbb{F}|}</span> -statistical HVZK.</p>

    <p class="text-gray-300"><strong>Remark E.4</strong> (below 5 queries). As Bitansky et al. [BCI<sup>+</sup>13] observed, the work of Gennaro et al. [GGPR13] implies various constructions of efficient linear PCPs. Specifically, any quadratic span program (QSP) for a relation  <span class="math">\\mathcal R</span>  yields a corresponding 3-query linear PCP for  <span class="math">\\mathcal R</span> , and any quadratic arithmetic program (QAP) for a relation  <span class="math">\\mathcal R</span>  yields a corresponding 4-query linear PCP for  <span class="math">\\mathcal R</span> .</p>

    <p class="text-gray-300">Efficient constructions of both QSPs and QAPs have the same asymptotic efficiency, but in this work we build on the QAP approach. Indeed, while QAPs yield linear PCPs with 4 queries instead of 3 (a minor overhead), QAPs are significantly simpler to construct than QSPs, resulting in very small hidden constants. This property is crucial for practical applications. In fact, in our linear PCP construction we rely on an additional query (for a total of 5 queries) in order to further simplify our construction.</p>

      <h3 id="app-e.1" class="text-xl font-semibold mt-8"><strong>E.1</strong> The Construction</h3>

    <p class="text-gray-300">We now describe the construction for  <span class="math">(P_{\\text{LPCP}}, (Q_{\\text{LPCP}}, D_{\\text{LPCP}}))</span>  from Claim E.3. (Later, in Section E.2, we discuss how to implement these algorithms efficiently.) We begin by introducing some notation. Recall that we have fixed a system of quadratic equations  <span class="math">\\mathcal{S} = ((\\mathbf{a}_j, \\mathbf{b}_j, \\mathbf{c}_j)_{j=1}^{N_{\\mathsf{g}}}, n)</span> , where  <span class="math">\\mathbf{a}_j, \\mathbf{b}_j, \\mathbf{c}_j \\in \\mathbb{F}^{1+N_{\\mathsf{w}}}</span>  and  <span class="math">n \\leq N_{\\mathsf{w}}</span> , and we are interested in the relation  <span class="math">\\mathcal{R}_{\\mathcal{S}}</span> .</p>

    <p class="text-gray-300">Fix an arbitrary subset S of  <span class="math">\\mathbb{F}</span>  with  <span class="math">|S| = N_{\\mathsf{g}}</span> ; let  <span class="math">S = \\{\\alpha_1, \\ldots, \\alpha_{N_{\\mathsf{g}}}\\}</span> . For  <span class="math">i \\in \\{0, 1, \\ldots, N_{\\mathsf{w}}\\}</span> , define the three functions  <span class="math">A_i, B_i, C_i \\colon S \\to \\mathbb{F}</span>  as follows: for each  <span class="math">j \\in [N_{\\mathsf{g}}]</span> ,</p>

    <p class="text-gray-300"><span class="math">$A_i(\\alpha_j) := \\mathbf{a}_j(i) , B_i(\\alpha_j) := \\mathbf{b}_j(i) , C_i(\\alpha_j) := \\mathbf{c}_j(i) .</span>$</p>

    <p class="text-gray-300">Then extend each function  <span class="math">A_i, B_i, C_i</span>  into a degree- <span class="math">(N_g - 1)</span>  univariate polynomial over  <span class="math">\\mathbb{F}</span> , via interpolation. Also define  <span class="math">Z_S</span>  to be the  <span class="math">N_g</span> -degree univariate polynomial over  <span class="math">\\mathbb{F}</span>  that vanishes on S.</p>

    <p class="text-gray-300">The linear PCP prover  <span class="math">P_{\\text{LPCP}}</span>  (when given suitable inputs) generates a vector of field elements  <span class="math">\\pi</span>  that represents his choice of (honest) linear proof oracle; we now specify how  <span class="math">P_{\\text{LPCP}}</span>  constructs  <span class="math">\\pi</span> .</p>

    <p class="text-gray-300"><strong>Construction E.5</strong> (linear PCP prover algorithm). <em>Given an input</em>  <span class="math">\\mathbf{x} \\in \\mathbb{F}^n</span>  <em>and a witness</em>  <span class="math">\\mathbf{w} \\in \\mathbb{F}^{N_w}</span>  <em>such that</em>  <span class="math">(\\mathbf{x}, \\mathbf{w}) \\in \\mathcal{R}_{\\mathcal{S}}</span> , the prover  <span class="math">P_{\\mathsf{LPCP}}</span>  works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>draw  <span class="math">\\delta_1, \\delta_2, \\delta_3</span>  independently at random from  <span class="math">\\mathbb{F}</span> ;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>let  <span class="math">\\mathbf{h} = (h_0, h_1, \\dots, h_{N_g}) \\in \\mathbb{F}^{N_g+1}</span>  be the coefficients of the univariate polynomial</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">
<span class="math">$H(z) := \\frac{A(z)B(z) - C(z)}{Z_S(z)}</span>$
, (1)</p>

    <p class="text-gray-300">of degree  <span class="math">N_g</span> , where A, B, C are the univariate polynomials of degree  <span class="math">N_g</span>  that are defined as follows:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} A(z) &amp;:= A_0(z) + \\sum_{i=1}^{N_{\\rm w}} w_i A_i(z) + \\delta_1 Z_S(z) \\ , \\\\ B(z) &amp;:= B_0(z) + \\sum_{i=1}^{N_{\\rm w}} w_i B_i(z) + \\delta_2 Z_S(z) \\ , \\\\ C(z) &amp;:= C_0(z) + \\sum_{i=1}^{N_{\\rm w}} w_i C_i(z) + \\delta_3 Z_S(z) \\ ; \\end{split}</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>output the vector  <span class="math">\\pi \\in \\mathbb{F}^{3+(N_w+1)+(N_g+1)}</span>  given by  <span class="math">(\\delta_1, \\delta_2, \\delta_3, 1, \\mathbf{w}, \\mathbf{h})</span> .</li>
    </ol>

    <p class="text-gray-300">Note that H(z) is indeed a polynomial: one can verify that  <span class="math">(\\mathbf{x}, \\mathbf{w}) \\in \\mathcal{R}_{\\mathcal{S}}</span>  implies that  <span class="math">Z_S(z)</span>  divides A(z)B(z)-C(z). Next, we describe the linear PCP query generator  <span class="math">Q_{\\mathsf{LPCP}}</span> .</p>

    <p class="text-gray-300"><strong>Construction E.6</strong> (linear PCP query algorithm). The query generator  <span class="math">Q_{LPCP}</span>  works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>draw  <span class="math">\\tau</span>  at random from  <span class="math">\\mathbb{F}</span> ;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>output 5 queries  <span class="math">q_1, \\ldots, q_5</span>  (of  <span class="math">5 + N_w + N_g</span>  field elements each), constructed as follows:</li>
    </ol></li>
    </ul>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">field element contained at each query location, for each query</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">+1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">+2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">+n+1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">+n+2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">+N_{\\sf w} + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">+N_{\\sf w} + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">+N_{\\sf w} + 1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><br><span class="math">+N_{\\sf w} + 1</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">+1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">+2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">+N_{\\rm g}+1</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\boldsymbol{q}_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">Z_S(\\tau)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_0(\\tau)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_1(\\tau)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_n(\\tau)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{n+1}(\\tau)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">A_{N_{\\sf w}}(\\tau)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><br>0</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\boldsymbol{q}_2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">Z_S(\\tau)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">B_0(\\tau)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">B_1(\\tau)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">B_n(\\tau)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">B_{n+1}(\\tau)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">B_{N_{\\sf w}}(\\tau)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><br>0</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">q_3</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">Z_S(\\tau)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">C_0(\\tau)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">C_1(\\tau)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">C_n(\\tau)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">C_{n+1}(\\tau)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">C_{N_{w}}(\\tau)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><br>0</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\boldsymbol{q}_4</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\tau</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><br><span class="math">\\tau^{N_{g}}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\boldsymbol{q}_5</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\tau</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\tau^n</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><br>0</td>
          </tr>
        </tbody>
      </table>
    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>output the state  <span class="math">\\mathbf{u} = (u_1, \\dots, u_{n+2})</span>  where  <span class="math">u_i := \\tau^{i-1}</span>  for  <span class="math">i \\in \\{1, \\dots, n+1\\}</span>  and  <span class="math">u_{n+2} := Z_S(\\tau)</span> .</li>
    </ol>

    <p class="text-gray-300">Finally, the linear PCP decision algorithm  <span class="math">D_{\\text{LPCP}}</span> , given an input  <span class="math">\\mathbf{x}</span> , checks whether  <span class="math">\\mathbf{x} \\in \\mathcal{L}_{\\mathcal{S}}</span> , by relying on the state information  <span class="math">\\mathbf{u}</span>  produced by the query algorithm as well as the 5 field elements  <span class="math">a_1 = \\langle \\boldsymbol{\\pi}^*, \\boldsymbol{q}_1 \\rangle, \\ldots, a_5 = \\langle \\boldsymbol{\\pi}^*, \\boldsymbol{q}_5 \\rangle</span> , which are the answers when given a linear proof oracle  <span class="math">\\boldsymbol{\\pi}^*</span>  (potentially maliciously generated by a dishonest prover).</p>

    <p class="text-gray-300"><strong>Construction E.7</strong> (linear PCP decision algorithm). Given an input  <span class="math">\\mathbf{x} \\in \\mathbb{F}^n</span> , the state information  <span class="math">\\mathbf{u} = (u_1, \\dots, u_{n+2})</span> , and answers  <span class="math">(a_1, \\dots, a_5)</span> , the LPCP verifier  <span class="math">D_{\\mathsf{LPCP}}</span>  accepts if and only if</p>

    <p class="text-gray-300"><span class="math">$a_1a_2 - a_3 - a_4u_{n+2} = 0</span>$
and  <span class="math">a_5 - u_1 - \\sum_{i=1}^n x_iu_{i+1} = 0</span> .</p>

    <p class="text-gray-300">We only sketch the (simple) proof of Claim E.3.</p>

    <p class="text-gray-300">Proof sketch of Claim E.3. First, it is clear that the linear PCP we just described has 5 queries of  <span class="math">5+N_{\\rm w}+N_{\\rm g}</span>  elements each, and that the state information passed from  <span class="math">Q_{\\rm LPCP}</span>  to  <span class="math">D_{\\rm LPCP}</span>  contains n+2 field elements. Regarding the degree of  <span class="math">Q_{\\rm LPCP}</span> : each coordinate of any query generated by  <span class="math">Q_{\\rm LPCP}</span>  is the evaluation of a polynomial on the (random) field element  <span class="math">\\tau</span> ; each such polynomial (e.g.,  <span class="math">Z_S</span> , A, and so on) has degree at most  <span class="math">N_{\\rm g}</span> . Regarding the degree of  <span class="math">D_{\\rm LPCP}</span> , it is clear that  <span class="math">D_{\\rm LPCP}</span>  tests the zero of two polynomials of degree 2. Overall, we deduce that the linear PCP has degree  <span class="math">(d_Q, d_D) = (N_{\\rm g}, 2)</span> .</p>

    <p class="text-gray-300">The knowledge error can be argued as follows: suppose that, for some  <span class="math">\\mathbf{x}</span> , a cheating prover produces a vector  <span class="math">\\boldsymbol{\\pi}^* = (\\delta_1^*, \\delta_2^*, \\delta_3^*, \\rho^*, \\mathbf{w}^*, \\mathbf{h}^*) \\in \\mathbb{F}^{3+(N_{\\mathsf{w}}+1)+(N_{\\mathsf{g}}+1)}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\tau \\leftarrow \\mathbb{F}} \\left[ V_{\\text{LPCP}} \\big( \\mathbf{x}, \\mathbf{u}, \\langle \\pmb{\\pi}^*, \\pmb{q}_1 \\rangle, \\dots, \\langle \\pmb{\\pi}^*, \\pmb{q}_5 \\rangle \\, \\big) = 1 \\; \\Big| \\; (\\pmb{q}_1, \\dots, \\pmb{q}_5, \\mathbf{u}) \\leftarrow Q_{\\text{LPCP}}(\\tau) \\Big] &gt; \\frac{2N_{\\text{g}}}{|\\mathbb{F}|} \\; .</span>$</p>

    <p class="text-gray-300">By construction of  <span class="math">Q_{LPCP}</span>  and  <span class="math">D_{LPCP}</span> , we know the above equation is equivalent to:</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\tau \\leftarrow \\mathbb{F}} \\left[ \\begin{array}{c} A^*(\\tau)B^*(\\tau) - C^*(\\tau) = Z_S(\\tau) \\cdot \\left(\\sum_{i=0}^{N_{\\mathsf{g}}} h_i^* \\tau^{i-1}\\right) \\\\ \\text{and} \\\\ \\rho^* + \\sum_{i=1}^n w_i^* \\tau^i = 1 + \\sum_{i=1}^n x_i \\tau^i \\end{array} \\right] &gt; \\frac{2N_{\\mathsf{g}}}{|\\mathbb{F}|} \\enspace,</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} A^*(z) &amp;:= \\rho^* A_0(z) + \\sum_{i=1}^{N_{\\mathsf{w}}} w_i^* A_i(z) + \\delta_1^* Z_S(z) \\ , \\\\ B^*(z) &amp;:= \\rho^* B_0(z) + \\sum_{i=1}^{N_{\\mathsf{w}}} w_i^* B_i(z) + \\delta_2^* Z_S(z) \\ , \\\\ C^*(z) &amp;:= \\rho^* C_0(z) + \\sum_{i=1}^{N_{\\mathsf{w}}} w_i^* C_i(z) + \\delta_3^* Z_S(z) \\ . \\end{split}</span>$</p>

    <p class="text-gray-300">Thus, because the equalities involve polynomials of low-enough degree, we can deduce that they hold as polynomial identities (in the formal variable z). In particular, we deduce that  <span class="math">\\rho^*=1</span> , that  <span class="math">\\mathbf{x}=(w_1,\\ldots,w_n)</span> . We similarly deduce that  <span class="math">A^*(z)B^*(z)-C^*(z)</span>  vanishes everywhere on  <span class="math">S=\\{\\alpha_1,\\ldots,\\alpha_{N_{\\mathbf{g}}}\\}</span>  and thus, by</p>

    <p class="text-gray-300">expanding terms, that  <span class="math">\\left(A_0(z) + \\sum_{i=1}^{N_{\\rm w}} w_i^* A_i(z)\\right) \\cdot \\left(B_0(z) + \\sum_{i=1}^{N_{\\rm w}} w_i^* B_i(z)\\right) - \\left(C_0(z) + \\sum_{i=1}^{N_{\\rm w}} w_i^* C_i(z)\\right)</span>  also vanishes everywhere on S. By construction of the polynomials  <span class="math">A_i</span> ,  <span class="math">B_i</span> , and  <span class="math">C_i</span> , we conclude that  <span class="math">\\langle \\mathbf{a}_j, (1, \\mathbf{w}^*) \\rangle \\cdot \\langle \\mathbf{b}_j, (1, \\mathbf{w}^*) \\rangle = \\langle \\mathbf{c}_j, (1, \\mathbf{w}^*) \\rangle</span>  for each  <span class="math">j \\in [N_{\\rm g}]</span> , and thus that  <span class="math">(\\mathbf{x}, \\mathbf{w}^*) \\in \\mathcal{R}_{\\mathcal{S}}</span> , as desired. (In particular, the output of the knowledge extractor  <span class="math">E_{\\rm LPCP}^{\\pi^*}(x)</span>  is defined to be  <span class="math">\\mathbf{w}^*</span> .)</p>

    <p class="text-gray-300">Finally,  <span class="math">\\frac{N_{\\rm g}}{|\\mathbb{F}|}</span> -statistical HVZK for the honest prover  <span class="math">P_{\\rm LPCP}</span>  can be argued as follows. If  <span class="math">Z_S(\\tau) \\neq 0</span> , because  <span class="math">\\delta_1, \\delta_2, \\delta_3</span>  are selected uniformly and independently at random from  <span class="math">\\mathbb{F}</span> , it holds that  <span class="math">a_1, a_2, a_3</span>  are uniform and independent field elements in  <span class="math">\\mathbb{F}</span>  (and thus do not leak any information about  <span class="math">\\mathbf{w}</span> ); for a random  <span class="math">\\tau</span> , it holds that  <span class="math">Z_S(\\tau) \\neq 0</span>  with probability  <span class="math">1 - N_{\\rm g}/|\\mathbb{F}|</span> . Also,  <span class="math">a_4</span>  is determined by  <span class="math">a_1, a_2, a_3, u_{n+2}</span>  via the constraint  <span class="math">a_1a_2 - a_3 - a_4u_{n+2} = 0</span> , so that  <span class="math">a_4</span>  does not leak any additional information. As for  <span class="math">a_5</span> , it only contains information about the part of w that is equal to x, which is known to the verifier. Thus, overall,  <span class="math">(a_1, \\ldots, a_5, \\mathbf{u})</span>  is a distribution that is  <span class="math">\\frac{N_{\\rm g}}{|\\mathbb{F}|}</span> -far from one that is independent of  <span class="math">\\mathbf{w}</span> .</p>

      <h3 id="app-e.2" class="text-xl font-semibold mt-8"><strong>E.2</strong> Computational Complexity of the Construction</h3>

    <p class="text-gray-300">We discuss efficiency considerations for the linear PCP  <span class="math">(P_{\\mathsf{LPCP}}, (Q_{\\mathsf{LPCP}}, D_{\\mathsf{LPCP}}))</span>  for  <span class="math">\\mathcal{R}_{\\mathcal{S}}</span>  that we just presented. The decision algorithm  <span class="math">D_{\\mathsf{LPCP}}</span>  is only testing two simple quadratic equations, and computing its decision bit is already very efficient: it only involves 2n+9 field operations. Therefore, our discussion below focuses on minimizing the complexity of computing the query algorithm  <span class="math">Q_{\\mathsf{LPCP}}</span>  and the prover algorithm  <span class="math">P_{\\mathsf{LPCP}}</span> .</p>

    <p class="text-gray-300">We begin by ensuring that we work in a field  <span class="math">\\mathbb F</span>  with a nice algebraic structure. Specifically, we assume that  <span class="math">N_{\\mathbf g}</span>  is a power of 2 (this can be achieved by adding dummy constraints) and that  <span class="math">\\mathbb F</span>  has a  <span class="math">N_{\\mathbf g}</span> -th root of unity (as discussed in Section 3, ensuring that this is the case is not a problem in our application). So, in the sequel, we fix  <span class="math">\\omega</span>  to be a principal  <span class="math">N_{\\mathbf g}</span> -th root of unity, and we choose  <span class="math">S=\\{\\alpha_1,\\ldots,\\alpha_{N_{\\mathbf g}}\\}</span>  with  <span class="math">\\alpha_i=\\omega^{i-1}</span> .</p>

    <p class="text-gray-300">Computing the query algorithm. The complexity of computing  <span class="math">Q_{\\text{LPCP}}</span>  is dominated by the complexity of evaluating each  <span class="math">A_i, B_i, C_i</span>  at the (random) element  <span class="math">\\tau</span> .</p>

    <p class="text-gray-300">We first explain how to efficiently compute  <span class="math">A_0, \\ldots, A_{N_w}</span> ; a similar discussion holds for the  <span class="math">B_i</span>  and  <span class="math">C_i</span> . Recall the formula for Lagrange interpolation:</p>

    <p class="text-gray-300"><span class="math">$A_i(z) := \\sum_{j=1}^{N_{\\mathsf{g}}} \\mathbf{a}_j(i) \\cdot L_j(z) \\ , \\ \\text{where} \\quad L_j(z) := \\frac{\\prod_{k \\neq j} (z - \\alpha_k)}{\\prod_{k \\neq j} (\\alpha_j - \\alpha_k)} \\ .</span>$</p>

    <p class="text-gray-300">We can also write:</p>

    <p class="text-gray-300"><span class="math">$A_i(z) = \\sum_{j=1}^{N_{\\rm g}} \\mathbf{a}_j(i) \\cdot \\frac{L_j&#x27;(z)}{z - \\alpha_j} \\ \\ \\text{, \\ where} \\quad L_j&#x27;(z) := \\frac{Z_S(z)}{\\prod_{k \\neq j} (\\alpha_j - \\alpha_k)} \\ \\ .</span>$</p>

    <p class="text-gray-300">Because  <span class="math">S=\\{\\alpha_1,\\ldots,\\alpha_{N_{\\rm g}}\\}=\\{1,\\omega,\\ldots,\\omega^{N_{\\rm g}-1}\\}</span>  are the  <span class="math">N_{\\rm g}</span> -th roots of unity, computing the  <span class="math">L&#x27;_j</span>  is particularly easy. First,  <span class="math">Z_S(z)=z^{N_{\\rm g}}-1</span> . Moreover, when  <span class="math">\\alpha_k</span>  ranges over all roots of unity that are not equal to  <span class="math">\\alpha_j</span> , the expression  <span class="math">\\omega\\alpha_k</span>  ranges over all roots of unity that are not equal to  <span class="math">\\omega\\alpha_j=\\alpha_{j+1}</span> . Therefore,</p>

    <p class="text-gray-300"><span class="math">$\\frac{Z_S(z)}{L&#x27;_{j+1}(z)} = \\prod_{k \\neq j+1} (\\alpha_{j+1} - \\alpha_k) = \\omega^{N_g - 1} \\cdot \\prod_{k \\neq j} (\\alpha_j - \\alpha_k) = \\frac{1}{\\omega} \\cdot \\prod_{k \\neq j} (\\alpha_j - \\alpha_k) = \\frac{1}{\\omega} \\cdot \\frac{Z_S(z)}{L&#x27;_j(z)} ,</span>$</p>

    <p class="text-gray-300">and we deduce that  <span class="math">L&#x27;_{j+1}(z) = \\omega \\cdot L&#x27;_{j}(z)</span> . Thus, if we compute  <span class="math">L&#x27;_{1}(\\tau)</span> , then we can compute  <span class="math">L&#x27;_{2}(\\tau), \\ldots, L&#x27;_{N_{\\mathbf{g}}}(\\tau)</span>  with only  <span class="math">N_{\\mathbf{g}}-1</span>  additional multiplications.</p>

    <p class="text-gray-300">We claim that  <span class="math">L_1&#x27;(z) = Z_S(z)/N_{\\rm g}</span> ; this can be seen as follows. The polynomial  <span class="math">z^{N_{\\rm g}} - 1</span>  can be (always) factored as  <span class="math">(z-1)\\cdot(1+z+\\cdots+z^{N_{\\rm g}-1})</span>  or (in the field  <span class="math">\\mathbb F</span>  used here) as  <span class="math">(z-1)\\cdot(z-\\omega)\\cdot\\cdots\\cdot(z-\\omega^{N_{\\rm g}-1})</span> .</p>

    <p class="text-gray-300">We deduce that  <span class="math">1+z+\\cdots+z^{N_{\\rm g}-1}=(z-\\omega)\\cdot\\cdots\\cdot(z-\\omega^{N_{\\rm g}-1})</span> . By setting z=1, we conclude that  <span class="math">N_{\\rm g}=(1-\\omega)\\cdot\\cdots\\cdot(1-\\omega^{N_{\\rm g}-1})=Z_S(z)/L_1&#x27;(z)</span> , as claimed.</p>

    <p class="text-gray-300">Overall, we obtain an algorithm that, given  <span class="math">\\tau</span>  (as well as  <span class="math">\\omega</span>  and  <span class="math">N_g</span> ), outputs  <span class="math">L_j(\\tau) = \\frac{L&#x27;_j(\\tau)}{\\tau - \\alpha_j}</span>  for  <span class="math">j = 1, \\ldots, N_g</span>  by using only  <span class="math">4N_g + \\log N_g</span>  field operations. Specifically, the algorithm is as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\zeta \\leftarrow \\tau^{N_g} 1</span> ;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\lambda \\leftarrow \\zeta/N_{\\rm g}</span> ;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\rho \\leftarrow 1</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">L_1(\\tau) \\leftarrow \\lambda/(\\tau \\rho)</span></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>for  <span class="math">j \\in \\{2, \\dots, N_g\\}</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a)  <span class="math">\\lambda \\leftarrow \\omega \\lambda</span> ;</li>
      <li>(b)  <span class="math">\\rho \\leftarrow \\omega \\rho</span> ;</li>
      <li>(c)  <span class="math">L_i(\\tau) \\leftarrow \\lambda/(\\tau \\rho)</span> ;</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>output  <span class="math">L_1(\\tau), \\ldots, L_{N_g}(\\tau)</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Then, after computing  <span class="math">L_1(\\tau), \\ldots, L_{N_g}(\\tau)</span> , computing  <span class="math">A_0(\\tau), \\ldots, A_{N_w}(\\tau)</span>  only requires taking appropriate linear combinations of these, as determined by the coefficient vectors  <span class="math">\\mathbf{a}_1, \\ldots, \\mathbf{a}_{N_g}</span> . Specifically, the number of field operations to compute all the necessary linear combinations is  <span class="math">2\\sum_{j=1}^{N_g}||\\mathbf{a}_j||_0</span> , where  <span class="math">||\\mathbf{a}_j||_0</span>  denotes the number of non-zero coordinates in the vector  <span class="math">\\mathbf{a}_j</span> .</p>

    <p class="text-gray-300">Recalling the definition of  <span class="math">Q_{LPCP}</span>  (which involves evaluating each  <span class="math">A_i, B_i, C_i</span>  at a point  <span class="math">\\tau</span> , and a few other small computations on  <span class="math">\\tau</span> ), one can see that computing the outputs of  <span class="math">Q_{LPCP}</span>  requires only</p>

    <p class="text-gray-300"><span class="math">$4N_{\\mathsf{g}} + \\log N_{\\mathsf{g}} + 2\\sum_{j=1}^{N_{\\mathsf{g}}} \\left( ||\\mathbf{a}_{j}||_{0} + ||\\mathbf{b}_{j}||_{0} + ||\\mathbf{c}_{j}||_{0} \\right)</span>$</p>

    <p class="text-gray-300">field operations. When the quadratic system S is obtained, e.g., from a circuit C of fan-in 2, it holds that  <span class="math">||\\mathbf{a}_j||_0, ||\\mathbf{b}_j||_0, ||\\mathbf{c}_j||_0 = O(1)</span>  for each j so that computing  <span class="math">Q_{\\mathsf{LPCP}}</span>  requires only O(|C|) field operations.</p>

    <p class="text-gray-300"><strong>Computing the prover algorithm.</strong> The complexity of computing  <span class="math">P_{\\mathsf{LPCP}}</span>  is dominated by the complexity of computing the coefficients of the  <span class="math">N_{\\mathsf{g}}</span> -degree polynomial H (see Equation 1). A natural approach to efficiently compute the coefficients of H is via a suitable use of FFTs. We show how to do so &quot;generically&quot;, and then how to choose parameters so that we can leverage particularly simple and fast FFTs.</p>

    <p class="text-gray-300">So let us begin by introducing notation for multipoint evaluation and interpolation. Given a domain  <span class="math">D \\subseteq \\mathbb{F}</span>  and a polynomial A(z) of degree less than |D|, we use  <span class="math">\\mathrm{FFT}_D\\big(A(z)\\big)</span>  to denote a &quot;generic&quot; FFT that outputs the vector  <span class="math">(A(\\alpha))_{\\alpha \\in D}</span> . Similarly, we use  <span class="math">\\mathrm{FFT}_D^{-1}\\big((A(\\alpha))_{\\alpha \\in D}\\big)</span>  to denote the inverse operation (i.e., given |D| points, return the polynomial of degree less than |D| that interpolates between these points on D).</p>

    <p class="text-gray-300">We now describe how to compute  <span class="math">P_{\\mathsf{LPCP}}</span>  in terms of the above notation. Below, we let T be a subset of  <span class="math">\\mathbb{F}</span>  with  <span class="math">|T| = N_{\\mathsf{g}}</span>  and  <span class="math">S \\cap T = \\emptyset</span> ; let  <span class="math">T = \\{\\beta_1, \\dots, \\beta_{N_{\\mathsf{g}}}\\}</span> . Later we fix a convenient choice of T. The algorithm of  <span class="math">P_{\\mathsf{LPCP}}</span>  is as follows:</p>

    <p class="text-gray-300">1. For  <span class="math">j \\in \\{1, \\dots, N_g\\}</span> , compute:</p>

    <p class="text-gray-300"><span class="math">$A&#x27;(\\alpha_j) := A_0(\\alpha_j) + \\sum_{i=1}^{N_{w}} w_i A_i(\\alpha_j) = \\mathbf{a}_j(0) + \\sum_{i=1}^{N_{w}} w_i \\mathbf{a}_j(i) ,</span>$</p>

    <p class="text-gray-300"><span class="math">$B&#x27;(\\alpha_j) := B_0(\\alpha_j) + \\sum_{i=1}^{N_{w}} w_i B_i(\\alpha_j) = \\mathbf{b}_j(0) + \\sum_{i=1}^{N_{w}} w_i \\mathbf{b}_j(i) , \\text{ and}</span>$</p>

    <p class="text-gray-300"><span class="math">$C&#x27;(\\alpha_j) := C_0(\\alpha_j) + \\sum_{i=1}^{N_{\\mathsf{w}}} w_i C_i(\\alpha_j) = \\mathbf{c}_j(0) + \\sum_{i=1}^{N_{\\mathsf{w}}} w_i \\mathbf{c}_j(i)</span>$
.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>2. Compute the  <span class="math">(N_{\\rm g}-1)</span>  coefficients of A'(z) by invoking  <span class="math">{\\rm FFT}_S^{-1}\\big(A&#x27;(\\alpha_1),\\ldots,A&#x27;(\\alpha_{N_{\\rm g}})\\big)</span> . Compute the  <span class="math">(N_{\\rm g}-1)</span>  coefficients of B'(z) by invoking  <span class="math">{\\rm FFT}_S^{-1}\\big(B&#x27;(\\alpha_1),\\ldots,C&#x27;(\\alpha_{N_{\\rm g}})\\big)</span> . Compute the  <span class="math">(N_{\\rm g}-1)</span>  coefficients of C'(z) by invoking  <span class="math">{\\rm FFT}_S^{-1}\\big(C&#x27;(\\alpha_1),\\ldots,C&#x27;(\\alpha_{N_{\\rm g}})\\big)</span> .</li>
      <li>3. Compute the evaluation of A'(z) on T by invoking  <span class="math">\\mathrm{FFT}_T\\big(A&#x27;(z)\\big)</span> . Compute the evaluation of B'(z) on T by invoking  <span class="math">\\mathrm{FFT}_T\\big(B&#x27;(z)\\big)</span> . Compute the evaluation of C'(z) on T by invoking  <span class="math">\\mathrm{FFT}_T\\big(C&#x27;(z)\\big)</span> .</li>
      <li>4. Compute the evaluation of  <span class="math">H&#x27;(z) := (A&#x27;(z)B&#x27;(z) - C&#x27;(z))/Z_S(z)</span>  on T, point-by-point by using the evaluations of A'(z), B'(z), C'(z),  <span class="math">Z_S(z)</span>  on T.</li>
      <li>5. Compute the  <span class="math">(N_{\\mathsf{g}}-2)</span>  coefficients of H'(z) by invoking  <span class="math">\\mathrm{FFT}_T^{-1}(H&#x27;(\\beta_1),\\ldots,H&#x27;(\\beta_{N_{\\mathsf{g}}}))</span> .</li>
      <li>6. Compute the  <span class="math">N_{\\rm g}</span>  coefficients of  <span class="math">H(z):=H&#x27;(z)+\\delta_2A&#x27;(\\alpha)+\\delta_1B&#x27;(\\alpha)+\\delta_1\\delta_2Z_S(z)-\\delta_3</span> , by directly evaluating the sum.</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output the  <span class="math">N_{\\rm g}</span>  coefficients of H(z).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Step 1 can be performed with  <span class="math">2\\sum_{j=1}^{N_{\\rm g}}\\left(||\\mathbf{a}_j||_0+||\\mathbf{b}_j||_0+||\\mathbf{c}_j||_0\\right)</span>  field operations; Step 2, Step 3, and Step 5 all involve computing FFTs on a domain of size  <span class="math">N_{\\rm g}</span> , and we will discuss their efficiency shortly; Step 4 involves computing  <span class="math">Z_S(z)</span>  everywhere on T, whose complexity we also discuss shortly, and then performing  <span class="math">4N_{\\rm g}</span>  field operations; Step 6 requires  <span class="math">O(N_{\\rm g})</span>  because all the requisite coefficients have already been computed.</p>

    <p class="text-gray-300">We choose T to be a multiplicative coset of S: for some  <span class="math">\\xi \\in (\\mathbb{F} \\setminus S)</span> , we choose  <span class="math">T := \\xi S</span> . This choice greatly simplifies Step 2, Step 3, and Step 4, as follows.</p>

    <p class="text-gray-300">First,  <span class="math">Z_S(z)</span>  is equal to  <span class="math">\\xi^{N_g} - 1</span>  everywhere on T. Therefore, evaluating  <span class="math">Z_S(z)</span>  on T in Step 4 only requires  <span class="math">1 + \\log N_g</span>  field operations.</p>

    <p class="text-gray-300">Moreover,  <span class="math">FFT_S^{-1}</span>  (for Step 2),  <span class="math">FFT_T</span>  (for Step 3), and  <span class="math">FFT_T^{-1}</span>  (for Step 5) are all FFTs (or inverse FFTs) that take only require  <span class="math">O(N_{\\rm g}\\log N_{\\rm g})</span>  field operations, and have particularly nice algorithm for computing them. Specifically, letting  <span class="math">\\Xi</span>  be the diagonal matrix whose i-th diagonal entry is  <span class="math">\\xi^{i-1}</span>  and letting  <span class="math">S^{-1}=\\{1,\\omega^{-1},\\ldots,\\omega^{-N_{\\rm g}+1}\\}</span> , it holds that:</p>

    <p class="text-gray-300"><span class="math">$\\mathrm{FFT}_S^{-1}(\\cdot) = \\mathrm{FFT}_{S^{-1}}(\\cdot) \\ , \\ \\mathrm{FFT}_T(\\cdot) = (\\mathrm{FFT}_S \\circ \\Xi)(\\cdot) \\ , \\ \\mathrm{FFT}_T^{-1}(\\cdot) = (\\Xi^{-1} \\circ \\mathrm{FFT}_S^{-1})(\\cdot) \\ .</span>$</p>

    <p class="text-gray-300">As for  <span class="math">FFT_S</span> , it is the &quot;standard&quot; FFT algorithm for finite fields that relies on an  <span class="math">N_g</span> -th root of unity (where  <span class="math">N_g</span>  is a power of 2), and the main idea is to separately recurse on the even-power and odd-power coefficients of the polynomial and then suitably combine the answers.</p>

    <p class="text-gray-300">In sum,  <span class="math">P_{LPCP}</span>  can be computed with</p>

    <p class="text-gray-300"><span class="math">$2\\sum_{j=1}^{N_{\\mathsf{g}}} \\left( ||\\mathbf{a}_{j}||_{0} + ||\\mathbf{b}_{j}||_{0} + ||\\mathbf{c}_{j}||_{0} \\right) + O(N_{\\mathsf{g}} \\log N_{\\mathsf{g}})</span>$</p>

    <p class="text-gray-300">field operations. As before, when the quadratic system  <span class="math">\\mathcal{S}</span>  is obtained, e.g., from a circuit C of fan-in 2, it holds that  <span class="math">||\\mathbf{a}_j||_0, ||\\mathbf{b}_j||_0, ||\\mathbf{c}_j||_0 = O(1)</span>  for each j so that computing  <span class="math">P_{\\mathsf{LPCP}}</span>  requires only  <span class="math">O(N_{\\mathsf{g}} \\log N_{\\mathsf{g}})</span>  field operations.</p>

    </section>

    <section id="app-f" class="mb-10">
      <h2 class="text-2xl font-bold">F Examples Used in Section 2.2</h2>

    <p class="text-gray-300">The graphs in Figure 4 and Figure 5 refer to specific examples of C code that we wrote in order to obtain those benchmarks. We briefly describe the programs that we wrote. We selected a set of simple, natural examples that demonstrate various program styles in C; these examples exercise memory accesses, integer arithmetic, and logical calculations.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Pointer chasing.</strong> Our example takes as input a permutation  <span class="math">\\pi</span>  on a domain  <span class="math">\\{1,\\ldots,w\\}</span>  and an integer d (we use d=3), and computes  <span class="math">\\pi^d</span> , i.e., the composition of  <span class="math">\\pi</span>  with itself d times. This example exercises random accesses: while random access machines can compute  <span class="math">\\pi^d</span>  in  <span class="math">O(d \\cdot w)</span>  time, a (naive) arithmetic circuits for this function, using a w-to-1 multiplexer for choosing each element, has  <span class="math">\\tilde{O}(d \\cdot w^2)</span>  size.<sup>30</sup></li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Game of Life.</strong> Conway's <em>Game of Life</em> [Gar70] is a cellular automaton on an  <span class="math">m \\times m</span>  mesh where each cell is initialized as either <em>dead</em> or <em>alive</em>. The game transitions from a <em>generation</em> to the next; in every such transition, each cell either dies or become alive depending on the number of alive neighbors it has. Fixing m = 5, our example program checks whether, given an initial configuration, a target configuration, and a positive integer d, the target configuration is the result of simulating Game of Life for d generations starting from the initial configuration.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Matrix multiplication.</strong> Our example program takes as input two square integer matrices (of the same dimension), and multiplies them using the naive matrix-multiplication algorithm.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Polynomial evaluation.</strong> Our example program takes as input a polynomial of some degree d and k = d + 2 points, and evaluates the polynomial at each of the k points using the naive algorithm. Both the coefficients and points are 16-bit integers.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Single-source shortest paths. A single-source shortest path problem is specified by a weighted graph G = (V, E) and a source node  <span class="math">s \\in V</span> . The goal is to find the shortest path between s and every node in G. Our example takes as input a positively-weighted graph G (where nodes have in-degree 20) and a source s, and finds the shortest path from s to all the nodes in G using Dijkstra's algorithm [Dij59].</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>RC4</strong> stream cipher. The <em>RC4</em> stream cipher [Gol97] maintains a 256-byte state, which it repeatedly updates during the initial key scheduling algorithm (KSA) and, subsequently, during the repeated invocation of the pseudorandomness generation algorithm (PRGA). Every invocation of the PRGA produces a pseudorandom sequence. Our example program takes as input an RC4 secret key, a positive integer d, and a &quot;target&quot; 128-bit string t; then, the program initializes the KSA with the secret key, produces a stream of d pseudorandom bytes using the PRGA, and finally checks that the 128-bit suffix of the resulting stream equals to t.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{30}&lt;/sup&gt;</span>  A more efficient circuit implementation would represent the permutations using routing networks (with nondeterministically-chosen switch setting), and achieve a circuit of size  <span class="math">O(dw \\log w)</span> . The circuit generator that we implemented does this implicitly using its handling of random access to memory (following [BCGT13a]), which supports arbitrary read/write access patterns.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">[ABB<sup>+</sup>12] Jose Bacelar Almeida, Manuel Barbosa, Endre Bangerter, Gilles Barthe, Stephan Krenn, and Santiago Zanella &acute; Beguelin. Full proof cryptography: verifiable compilation of efficient zero-knowledge protocols. In &acute; <em>Proceedings of the 19th ACM Conference on Computer and Communications Security</em>, CCS '12, pages 488&ndash;500, 2012.</p></li>
      <li><p class="text-gray-300">[AF07] Masayuki Abe and Serge Fehr. Perfect NIZK with adaptive soundness. In <em>Proceedings of the 4th Theory of Cryptography Conference</em>, TCC '07, pages 118&ndash;136, 2007.</p></li>
      <li><p class="text-gray-300">[AIK10] Benny Applebaum, Yuval Ishai, and Eyal Kushilevitz. From secrecy to soundness: Efficient verification via secure computation. In <em>Proceedings of the 37th International Colloquium on Automata, Languages and Programming</em>, ICALP '10, pages 152&ndash;163, 2010.</p></li>
      <li><p class="text-gray-300">[ALNR11] Christophe Arene, Tanja Lange, Michael Naehrig, and Christophe Ritzenthaler. Faster computation of the Tate pair- \` ing. <em>Journal of Number Theory</em>, 131(5):842&ndash;857, 2011.</p></li>
      <li><p class="text-gray-300">[AM93] A. O. L. Atkin and F. Morain. Elliptic curves and primality proving. <em>Mathematics of Computation</em>, 61:29&ndash;68, 1993.</p></li>
      <li><p class="text-gray-300">[ARM12] ARM. ARMv7 architecture reference manual. <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0403c/index.html" target="_blank" rel="noopener noreferrer">http://infocenter.arm.com/help/index.jsp?topic=</a> <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0403c/index.html" target="_blank" rel="noopener noreferrer">/com.arm.doc.ddi0403c/index.html</a>, Feb 2012.</p></li>
      <li><p class="text-gray-300">[ATM10] ATMEL. 8-bit AVR instruction set. <a href="http://www.atmel.com/images/doc0856.pdf" target="_blank" rel="noopener noreferrer">http://www.atmel.com/images/doc0856.pdf</a>, Jul 2010.</p></li>
      <li><p class="text-gray-300">[AV77] Dana Angluin and Leslie G. Valiant. Fast probabilistic algorithms for hamiltonian circuits and matchings. In <em>Proceedings on 9th Annual ACM Symposium on Theory of Computing</em>, STOC '77, pages 30&ndash;41, 1977.</p></li>
      <li><p class="text-gray-300">[BBJ<sup>+</sup>08] Daniel J. Bernstein, Peter Birkner, Marc Joye, Tanja Lange, and Christiane Peters. Twisted Edwards curves. In <em>Proceedings of the 1st International Conference on Cryptology in Africa</em>, AFRICACRYPT' 08, pages 389&ndash;405, 2008.</p></li>
      <li><p class="text-gray-300">[BBK<sup>+</sup>09] Endre Bangerter, Stefania Barzan, Stephan Krenn, Ahmad-Reza Sadeghi, and Thomas Schneider. Bringing zeroknowledge proofs of knowledge to practice. In <em>Proceedings of the 17th International Workshop on Security Protocols</em>, pages 51&ndash;62, 2009.</p></li>
      <li><p class="text-gray-300">[BC89] Jurjen Bos and Matthijs Coster. Addition chain heuristics. In <em>Proceedings of the 9th Annual International Cryptology Conference</em>, CRYPTO '89, pages 400&ndash;407, 1989.</p></li>
      <li><p class="text-gray-300">[BC12] Nir Bitansky and Alessandro Chiesa. Succinct arguments from multi-prover interactive proofs and their efficiency benefits. In <em>Proceedings of the 32nd Annual International Cryptology Conference</em>, CRYPTO '12, pages 255&ndash;272, 2012.</p></li>
      <li><p class="text-gray-300">[BCC88] Gilles Brassard, David Chaum, and Claude Crepeau. Minimum disclosure proofs of knowledge. &acute; <em>Journal of Computer and System Sciences</em>, 37(2):156&ndash;189, 1988.</p></li>
      <li><p class="text-gray-300">[BCC<sup>+</sup>09] Mira Belenkiy, Jan Camenisch, Melissa Chase, Markulf Kohlweiss, Anna Lysyanskaya, and Hovav Shacham. Randomizable proofs and delegatable anonymous credentials. In <em>Proceedings of the 29th Annual International Cryptology Conference on Advances in Cryptology</em>, CRYPTO '09, pages 108&ndash;125, 2009.</p></li>
      <li><p class="text-gray-300">[BCCT12] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct noninteractive arguments of knowledge, and back again. In <em>Proceedings of the 3rd Innovations in Theoretical Computer Science Conference</em>, ITCS '12, pages 326&ndash;349, 2012.</p></li>
      <li><p class="text-gray-300">[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for SNARKs and proof-carrying data. In <em>Proceedings of the 45th ACM Symposium on the Theory of Computing</em>, STOC '13, pages 111&ndash;120, 2013.</p></li>
      <li><p class="text-gray-300">[BCG<sup>+</sup>13] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. TinyRAM architecture specification v1.00, 2013. URL: <a href="http://scipr-lab.org/tinyram" target="_blank" rel="noopener noreferrer">http://scipr-lab.org/tinyram</a>.</p></li>
      <li><p class="text-gray-300">[BCGT13a] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, and Eran Tromer. Fast reductions from RAMs to delegatable succinct constraint satisfaction problems. In <em>Proceedings of the 4th Innovations in Theoretical Computer Science Conference</em>, ITCS '13, pages 401&ndash;414, 2013.</p></li>
      <li><p class="text-gray-300">[BCGT13b] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, and Eran Tromer. On the concrete efficiency of probabilisticallycheckable proofs. In <em>Proceedings of the 45th ACM Symposium on the Theory of Computing</em>, STOC '13, pages 585&ndash;594, 2013.</p></li>
      <li><p class="text-gray-300">[BCI<sup>+</sup>13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct non-interactive arguments via linear interactive proofs. In <em>Proceedings of the 10th Theory of Cryptography Conference</em>, TCC '13, pages 315&ndash; 333, 2013.</p></li>
      <li><p class="text-gray-300">[BCKL08] Mira Belenkiy, Melissa Chase, Markulf Kohlweiss, and Anna Lysyanskaya. P-signatures and noninteractive anonymous credentials. In <em>Proceedings of the 5th Theory of Cryptography Conference</em>, TCC '08, pages 356&ndash;374, 2008.</p></li>
      <li><p class="text-gray-300">[BDNP08] Assaf Ben-David, Noam Nisan, and Benny Pinkas. FairplayMP: a system for secure multi-party computation. In <em>Proceedings of the 15th ACM Conference on Computer and Communications Security</em>, CCS '08, pages 257&ndash;266, 2008.</p></li>
      <li><p class="text-gray-300">[Ben65] Vaclav E. Bene &acute; s.&#711; <em>Mathematical theory of connecting networks and telephone traffic</em>. New York, Academic Press, 1965.</p></li>
      <li><p class="text-gray-300">[Ber02] Daniel J. Bernstein. Pippenger's exponentiation algorithm. <a href="http://cr.yp.to/papers/pippenger.pdf" target="_blank" rel="noopener noreferrer">http://cr.yp.to/papers/pippenger.pdf</a>, 2002.</p></li>
      <li><p class="text-gray-300">[BFLS91] Laszl &acute; o Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. Checking computations in polylogarithmic time. &acute; In <em>Proceedings of the 23rd Annual ACM Symposium on Theory of Computing</em>, STOC '91, pages 21&ndash;32, 1991.</p></li>
      <li><p class="text-gray-300">[BG08] Boaz Barak and Oded Goldreich. Universal arguments and their applications. <em>SIAM Journal on Computing</em>, 38(5):1661&ndash;1694, 2008. Preliminary version appeared in CCC '02.</p></li>
      <li><p class="text-gray-300">[BGH<sup>+</sup>05] Eli Ben-Sasson, Oded Goldreich, Prahladh Harsha, Madhu Sudan, and Salil Vadhan. Short PCPs verifiable in polylogarithmic time. In <em>Proceedings of the 20th Annual IEEE Conference on Computational Complexity</em>, CCC '05, pages 120&ndash;134, 2005.</p></li>
      <li><p class="text-gray-300">[BGW88] Michael Ben-Or, Shafi Goldwasser, and Avi Wigderson. Completeness theorems for non-cryptographic fault-tolerant distributed computation. In <em>Proceedings of the 20th Annual ACM Symposium on Theory of Computing</em>, STOC '88, pages 1&ndash;10, 1988.</p></li>
      <li><p class="text-gray-300">[BHZ87] Ravi B. Boppana, Johan Hastad, and Stathis Zachos. Does co-NP have short interactive proofs? &#730; <em>Information Processing Letters</em>, 25(2):127&ndash;132, 1987.</p></li>
      <li><p class="text-gray-300">[BL07] Daniel J. Bernstein and Tanja Lange. Faster addition and doubling on elliptic curves. In <em>Proceedings of the 13th International Conference on the Theory and Application of Cryptology and Information Security</em>, ASIACRYPT '07, pages 29&ndash;50, 2007.</p></li>
      <li><p class="text-gray-300">[BP04] Mihir Bellare and Adriana Palacio. The knowledge-of-exponent assumptions and 3-round zero-knowledge protocols. In <em>Proceedings of the 24th Annual International Cryptology Conference</em>, CRYPTO '04, pages 273&ndash;289, 2004.</p></li>
      <li><p class="text-gray-300">[BS08] Eli Ben-Sasson and Madhu Sudan. Short PCPs with polylog query complexity. <em>SIAM Journal on Computing</em>, 38(2):551&ndash;607, 2008. Preliminary version appeared in STOC '05.</p></li>
      <li><p class="text-gray-300">[BW06] Xavier Boyen and Brent Waters. Compact group signatures without random oracles. In <em>Proceedings of the 25th Annual International Conference on Theory and Application of Cryptographic Techniques</em>, EUROCRYPT '06, pages 427&ndash;444, 2006.</p></li>
      <li><p class="text-gray-300">[CKLM12] Melissa Chase, Markulf Kohlweiss, Anna Lysyanskaya, and Sarah Meiklejohn. Malleable proof systems and applications. In <em>Proceedings of the 31st Annual International Conference on Theory and Applications of Cryptographic Techniques</em>, EUROCRYPT '12, pages 281&ndash;300, 2012.</p></li>
      <li><p class="text-gray-300">[CKV10] Kai-Min Chung, Yael Kalai, and Salil Vadhan. Improved delegation of computation using fully homomorphic encryption. In <em>Proceedings of the 30th Annual International Cryptology Conference</em>, CRYPTO '10, pages 483&ndash;501, 2010.</p></li>
      <li><p class="text-gray-300">[CMT12] Graham Cormode, Michael Mitzenmacher, and Justin Thaler. Practical verified computation with streaming interactive proofs. In <em>Proceedings of the 4th Symposium on Innovations in Theoretical Computer Science</em>, ITCS '12, pages 90&ndash;112, 2012.</p></li>
      <li><p class="text-gray-300">[CR72] Stephen A. Cook and Robert A. Reckhow. Time-bounded random access machines. In <em>Proceedings of the 4th Annual ACM Symposium on Theory of Computing</em>, STOC '72, pages 73&ndash;80, 1972.</p></li>
      <li><p class="text-gray-300">[CRR11] Ran Canetti, Ben Riva, and Guy N. Rothblum. Practical delegation of computation using multiple servers. In <em>Proceedings of the 18th ACM Conference on Computer and Communications Security</em>, CCS '11, pages 445&ndash;454, 2011.</p></li>
      <li><p class="text-gray-300">[CRR12] Ran Canetti, Ben Riva, and Guy N. Rothblum. Two protocols for delegation of computation. In <em>Proceedings of the 6th International Conference on Information Theoretic Security</em>, ICITS 12, pages 37&ndash;61, 2012.</p></li>
      <li><p class="text-gray-300">[Dam92] Ivan Damgard. Towards practical public key systems secure against chosen ciphertext attacks. In &#730; <em>Proceedings of the 11th Annual International Cryptology Conference</em>, CRYPTO '92, pages 445&ndash;456, 1992.</p></li>
      <li><p class="text-gray-300">[DFH12] Ivan Damgard, Sebastian Faust, and Carmit Hazay. Secure two-party computation with low communication. In &#730; <em>Proceedings of the 9th Theory of Cryptography Conference</em>, TCC '12, pages 54&ndash;74, 2012.</p></li>
      <li><p class="text-gray-300">[Dij59] Edsger W. Dijkstra. A note on two problems in connexion with graphs. <em>Numerische Mathematik</em>, 1(1):269&ndash;271, 1959.</p></li>
      <li><p class="text-gray-300">[Din07] Irit Dinur. The PCP theorem by gap amplification. <em>Journal of the ACM</em>, 54(3):12, 2007.</p></li>
      <li><p class="text-gray-300">[Edw07] Harold M. Edwards. A normal form for elliptic curves. <em>Bulletin of the American Mathematical Society</em>, 44(3):393&ndash; 422, 2007.</p></li>
      <li><p class="text-gray-300">[FK97] Uriel Feige and Joe Kilian. Making games short. In <em>Proceedings of the 29th Annual ACM Symposium on Theory of Computing</em>, STOC '97, pages 506&ndash;516, 1997.</p></li>
      <li><p class="text-gray-300">[FMR06] Gerhard Frey, Michael Muller, and Hans-Georg R &uml; uck. The Tate pairing and the discrete logarithm applied to elliptic &uml; curve cryptosystems. <em>IEEE Transactions on Information Theory</em>, 45(5):1717&ndash;1719, 2006.</p></li>
      <li><p class="text-gray-300">[FR94] Gerhard Frey and Hans-Georg Ruck. A remark concerning m-divisibility and the discrete logarithm in the divisor &uml; class group of curves. <em>Mathematics of Computation</em>, 62(206):865&ndash;874, 1994.</p></li>
      <li><p class="text-gray-300">[FST10] David Freeman, Michael Scott, and Edlyn Teske. A taxonomy of pairing-friendly elliptic curves. <em>Journal of Cryptology</em>, 23(2):224&ndash;280, 2010.</p></li>
      <li><p class="text-gray-300">[Gar70] Martin Gardner. Mathematical games: The fantastic combinations of John Conway's new solitaire game 'Life'. <em>Scientific American</em>, 223(4):120&ndash;123, 1970.</p></li>
      <li><p class="text-gray-300">[GES<sup>+</sup>09] Andreas Gal, Brendan Eich, Mike Shaver, David Anderson, David Mandelin, Mohammad R. Haghighat, Blake Kaplan, Graydon Hoare, Boris Zbarsky, Jason Orendorff, Jesse Ruderman, Edwin W. Smith, Rick Reitmaier, Michael Bebenita, Mason Chang, and Michael Franz. Trace-based just-in-time type specialization for dynamic languages. In <em>Proceedings of the 2009 ACM SIGPLAN Conference on Programming Language Design and Implementation</em>, PLDI '09, pages 465&ndash;478, 2009.</p></li>
      <li><p class="text-gray-300">[GGP10] Rosario Gennaro, Craig Gentry, and Bryan Parno. Non-interactive verifiable computing: outsourcing computation to untrusted workers. In <em>Proceedings of the 30th Annual International Cryptology Conference</em>, CRYPTO '10, pages 465&ndash;482, 2010.</p></li>
      <li><p class="text-gray-300">[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In <em>Proceedings of the 32nd Annual International Conference on Theory and Application of Cryptographic Techniques</em>, EUROCRYPT '13, pages 626&ndash;645, 2013.</p></li>
      <li><p class="text-gray-300">[GH98] Oded Goldreich and Johan Hastad. On the complexity of interactive proofs with bounded communication. &#730; <em>Information Processing Letters</em>, 67(4):205&ndash;214, 1998.</p></li>
      <li><p class="text-gray-300">[GKP<sup>+</sup>13] Shafi Goldwasser, Yael Kalai, Raluca Ada Popa, Vinod Vaikuntanathan, and Nickolai Zeldovich. Reusable garbled circuits and succinct functional encryption. In <em>Proceedings of the 45th ACM Symposium on the Theory of Computing</em>, STOC '13, pages 555&ndash;564, 2013.</p></li>
      <li><p class="text-gray-300">[GKR08] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. Delegating computation: Interactive proofs for Muggles. In <em>Proceedings of the 40th Annual ACM Symposium on Theory of Computing</em>, STOC '08, pages 113&ndash;122, 2008.</p></li>
      <li><p class="text-gray-300">[GLR11] Shafi Goldwasser, Huijia Lin, and Aviad Rubinstein. Delegation of computation without rejection problem from designated verifier CS-proofs. Cryptology ePrint Archive, Report 2011/456, 2011.</p></li>
      <li><p class="text-gray-300">[GMV07] Steven D. Galbraith, J. F. Mckee, and P. C. Valenc&cedil;A. Ordinary abelian varieties having small embedding degree. <em>Finite Fields and Their Applications</em>, 13(4):800&ndash;814, 2007.</p></li>
      <li><p class="text-gray-300">[GMW87] Oded Goldreich, Silvio Micali, and Avi Wigderson. How to play any mental game or a completeness theorem for protocols with honest majority. In <em>Proceedings of the 19th Annual ACM Symposium on Theory of Computing</em>, STOC '87, pages 218&ndash;229, 1987.</p></li>
      <li><p class="text-gray-300">[Gol97] Jovan Dj. Golic. Linear statistical weakness of alleged RC4 keystream generator. In <em>Proceedings of the 16th Annual International Conference on Theory and Application of Cryptographic Techniques</em>, EUROCRYPT '97, pages 226&ndash; 238, 1997.</p></li>
      <li><p class="text-gray-300">[GOS06a] Jens Groth, Rafail Ostrovsky, and Amit Sahai. Non-interactive Zaps and new techniques for NIZK. In <em>Proceedings of the 26th Annual International Conference on Advances in Cryptology</em>, CRYPTO '06, pages 97&ndash;111, 2006.</p></li>
      <li><p class="text-gray-300">[GOS06b] Jens Groth, Rafail Ostrovsky, and Amit Sahai. Perfect non-interactive zero knowledge for NP. In <em>Proceedings of the 25th Annual International Conference on Advances in Cryptology</em>, EUROCRYPT '06, pages 339&ndash;358, 2006.</p></li>
      <li><p class="text-gray-300">[Gro05] Jens Groth. Non-interactive zero-knowledge arguments for voting. In <em>Proceedings of the 3rd International Conference on Applied Cryptography and Network Security</em>, ACNS '05, pages 467&ndash;482, 2005.</p></li>
      <li><p class="text-gray-300">[Gro06] Jens Groth. Simulation-sound NIZK proofs for a practical language and constant size group signatures. In <em>Proceedings of the 12th International Conference on Theory and Application of Cryptology and Information Security</em>, ASIACRYPT '06, pages 444&ndash;459, 2006.</p></li>
      <li><p class="text-gray-300">[Gro09] Jens Groth. Linear algebra with sub-linear zero-knowledge arguments. In <em>Proceedings of the 29th Annual International Cryptology Conference on Advances in Cryptology</em>, CRYPTO '09, pages 192&ndash;208, 2009.</p></li>
      <li><p class="text-gray-300">[Gro10a] Jens Groth. Short non-interactive zero-knowledge proofs. In <em>Proceedings of the 16th International Conference on the Theory and Application of Cryptology and Information Security</em>, ASIACRYPT '10, pages 341&ndash;358, 2010.</p></li>
      <li><p class="text-gray-300">[Gro10b] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In <em>Proceedings of the 16th International Conference on the Theory and Application of Cryptology and Information Security</em>, ASIACRYPT '10, pages 321&ndash;340, 2010.</p></li>
      <li><p class="text-gray-300">[GS89] Yuri Gurevich and Saharon Shelah. Nearly linear time. In <em>Logic at Botik '89, Symposium on Logical Foundations of Computer Science</em>, pages 108&ndash;118, 1989.</p></li>
      <li><p class="text-gray-300">[Gue12] Shay Gueron. Intel advanced encryption standard (AES) instructions set. <a href="http://software.intel.com/en-us/articles/intel-advanced-encryption-standard-aes-instructions-set" target="_blank" rel="noopener noreferrer">http://software.intel.</a> <a href="http://software.intel.com/en-us/articles/intel-advanced-encryption-standard-aes-instructions-set" target="_blank" rel="noopener noreferrer">com/en-us/articles/intel-advanced-encryption-standard-aes-instructions-set</a>, Feb 2012.</p></li>
      <li><p class="text-gray-300">[GVW02] Oded Goldreich, Salil Vadhan, and Avi Wigderson. On interactive proofs with a laconic prover. <em>Computational Complexity</em>, 11(1/2):1&ndash;53, 2002.</p></li>
      <li><p class="text-gray-300">[GVW13] Sergey Gorbunov, Vinod Vaikuntanathan, and Hoeteck Wee. Attribute-based encryption for circuits. In <em>Proceedings of the 45th ACM Symposium on the Theory of Computing</em>, STOC '13, pages 545&ndash;554, 2013.</p></li>
      <li><p class="text-gray-300">[GW11] Craig Gentry and Daniel Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In <em>Proceedings of the 43rd Annual ACM Symposium on Theory of Computing</em>, STOC '11, pages 99&ndash;108, 2011.</p></li>
      <li><p class="text-gray-300">[HT98] Satoshi Hada and Toshiaki Tanaka. On the existence of 3-round zero-knowledge protocols. In <em>Proceedings of the 18th Annual International Cryptology Conference</em>, CRYPTO '98, pages 408&ndash;423, 1998.</p></li>
      <li><p class="text-gray-300">[IKO07] Yuval Ishai, Eyal Kushilevitz, and Rafail Ostrovsky. Efficient arguments without short PCPs. In <em>Proceedings of the Twenty-Second Annual IEEE Conference on Computational Complexity</em>, CCC '07, pages 278&ndash;291, 2007.</p></li>
      <li><p class="text-gray-300">[Kil92] Joe Kilian. A note on efficient zero-knowledge proofs and arguments. In <em>Proceedings of the 24th Annual ACM Symposium on Theory of Computing</em>, STOC '92, pages 723&ndash;732, 1992.</p></li>
      <li><p class="text-gray-300">[KMO01] Jonathan Katz, Steven Myers, and Rafail Ostrovsky. Cryptographic counters and applications to electronic voting. In <em>Proceedings of the 20th Annual International Conference on Theory and Application of Cryptographic Techniques</em>, EUROCRYPT '01, pages 78&ndash;92, 2001.</p></li>
      <li><p class="text-gray-300">[KR09] Yael Tauman Kalai and Ran Raz. Probabilistically checkable arguments. In <em>Proceedings of the 29th Annual International Cryptology Conference</em>, CCC '09, pages 143&ndash;159, 2009.</p></li>
      <li><p class="text-gray-300">[KRR13] Yael Kalai, Ran Raz, and Ron Rothblum. Delegation for bounded space. In <em>Proceedings of the 45th ACM Symposium on the Theory of Computing</em>, STOC '13, pages 565&ndash;574, 2013.</p></li>
      <li><p class="text-gray-300">[Lei92] F. Thomson Leighton. <em>Introduction to parallel algorithms and architectures: array, trees, hypercubes</em>. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 1992.</p></li>
      <li><p class="text-gray-300">[Lip11] Helger Lipmaa. Two simple code-verification voting protocols. Cryptology ePrint Archive, Report 2011/317, 2011.</p></li>
      <li><p class="text-gray-300">[Lip12] Helger Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In <em>Proceedings of the 9th Theory of Cryptography Conference on Theory of Cryptography</em>, TCC '12, pages 169&ndash;189, 2012.</p></li>
      <li><p class="text-gray-300">[Mic00] Silvio Micali. Computationally sound proofs. <em>SIAM Journal on Computing</em>, 30(4):1253&ndash;1298, 2000. Preliminary version appeared in FOCS '94.</p></li>
      <li><p class="text-gray-300">[MNPS04] Dahlia Malkhi, Noam Nisan, Benny Pinkas, and Yaron Sella. Fairplay &mdash; a secure two-party computation system. In <em>Proceedings of the 13th USENIX Security Symposium</em>, SSYM '04, pages 20&ndash;20, 2004.</p></li>
      <li><p class="text-gray-300">[MNT01] Atsuko Miyaji, Masaki Nakabayashi, and Shunzo Takano. New explicit conditions of elliptic curve traces for FR-reduction. <em>IEICE Transactions on Fundamentals of Electronics, Communications and Computer Sciences</em>, 84(5):1234&ndash;1243, 2001.</p></li>
      <li><p class="text-gray-300">[MR08] Dana Moshkovitz and Ran Raz. Two-query PCP with subconstant error. <em>Journal of the ACM</em>, 57:1&ndash;29, June 2008. Preliminary version appeared in FOCS '08.</p></li>
      <li><p class="text-gray-300">[NS82] David Nassimi and Sartaj Sahni. Parallel algorithms to set up the Benes permutation network. &#711; <em>IEEE Transactions on Computers</em>, 31(2):148&ndash;154, 1982.</p></li>
      <li><p class="text-gray-300">[OTW71] D. C. Opferman and N. T. Tsao-Wu. On a class of rearrangeable switching networks - part i: Control algorithm. <em>Bell System Technical Journal</em>, 50(5):1579&ndash;1600, 1971.</p></li>
      <li><p class="text-gray-300">[PGHR13] Brian Parno, Craig Gentry, Jon Howell, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. In <em>Proceedings of the 34th IEEE Symposium on Security and Privacy</em>, Oakland '13, pages 238&ndash;252, 2013.</p></li>
      <li><p class="text-gray-300">[PRV12] Bryan Parno, Mariana Raykova, and Vinod Vaikuntanathan. How to delegate and verify in public: verifiable computation from attribute-based encryption. In <em>Proceedings of the 9th Theory of Cryptography Conference</em>, TCC '12, pages 422&ndash;439, 2012.</p></li>
      <li><p class="text-gray-300">[Rob91] J. M. Robson. An O(T log T) reduction from RAM computations to satisfiability. <em>Theoretical Computer Science</em>, 82(1):141&ndash;149, May 1991.</p></li>
      <li><p class="text-gray-300">[SBV<sup>+</sup>13] Srinath Setty, Benjamin Braun, Victor Vu, Andrew J. Blumberg, Bryan Parno, and Michael Walfish. Resolving the conflict between generality and plausibility in verified computation. In <em>Proceedings of the 8th EuoroSys Conference</em>, EuroSys '13, pages 71&ndash;84, 2013.</p></li>
      <li><p class="text-gray-300">[SBW11] Srinath Setty, Andrew J. Blumberg, and Michael Walfish. Toward practical and unconditional verification of remote computations. In <em>Proceedings of the 13th USENIX Conference on Hot Topics in Operating Systems</em>, HotOS '13, pages 29&ndash;29, 2011.</p></li>
      <li><p class="text-gray-300">[Sch78] Claus-Peter Schnorr. Satisfiability is quasilinear complete in NQL. <em>Journal of the ACM</em>, 25:136&ndash;145, January 1978.</p></li>
      <li><p class="text-gray-300">[Sma99] Nigel Smart. <em>The Algorithmic Resolution of Diophantine Equations</em>. Cambridge University Press, New York, NY, USA, 1999.</p></li>
      <li><p class="text-gray-300">[SMBW12] Srinath Setty, Michael McPherson, Andrew J. Blumberg, and Michael Walfish. Making argument systems for outsourced computation practical (sometimes). In <em>Proceedings of the 2012 Network and Distributed System Security Symposium</em>, NDSS '12, pages ???&ndash;???, 2012.</p></li>
      <li><p class="text-gray-300">[StGDC] Richard M. Stallman and the GCC Developer Community. GCC, the GNU compiler collection. URL: <a href="http://gcc.gnu.org" target="_blank" rel="noopener noreferrer">http:</a> <a href="http://gcc.gnu.org" target="_blank" rel="noopener noreferrer">//gcc.gnu.org</a>.</p></li>
      <li><p class="text-gray-300">[StGDC13] Richard M. Stallman and the GCC Developer Community. GNU compiler collection internals. <a href="http://gcc.gnu.org/onlinedocs/gccint.pdf" target="_blank" rel="noopener noreferrer">http://gcc.gnu.</a> <a href="http://gcc.gnu.org/onlinedocs/gccint.pdf" target="_blank" rel="noopener noreferrer">org/onlinedocs/gccint.pdf</a>, 2013.</p></li>
      <li><p class="text-gray-300">[SVP<sup>+</sup>12] Srinath Setty, Victor Vu, Nikhil Panpalia, Benjamin Braun, Andrew J. Blumberg, and Michael Walfish. Taking proofbased verified computation a few steps closer to practicality. In <em>Proceedings of the 21st USENIX Security Symposium</em>, Security '12, pages 253&ndash;268, 2012.</p></li>
      <li><p class="text-gray-300">[Tha13] Justin Thaler. Time-optimal interactive proofs for circuit evaluation. ArXiv, report 1304.3812, 2013.</p></li>
      <li><p class="text-gray-300">[TRMP12] Justin Thaler, Mike Roberts, Michael Mitzenmacher, and Hanspeter Pfister. Verifiable computation with massively parallel interactive proofs. <em>CoRR</em>, abs/1202.1350, 2012.</p></li>
      <li><p class="text-gray-300">[VSBW13] Victor Vu, Srinath Setty, Andrew J. Blumberg, and Michael Walfish. A hybrid architecture for interactive verifiable computation. In <em>Proceedings of the 34th IEEE Symposium on Security and Privacy</em>, Oakland '13, pages 223&ndash;237, 2013.</p></li>
      <li><p class="text-gray-300">[Wak68] Abraham Waksman. A permutation network. <em>Journal of the ACM</em>, 15(1):159&ndash;163, 1968.</p></li>
      <li><p class="text-gray-300">[Wee05] Hoeteck Wee. On round-efficient argument systems. In <em>Proceedings of the 32nd International Colloquium on Automata, Languages and Programming</em>, ICALP '05, pages 140&ndash;152, 2005.</p></li>
    </ul>

    </section>
`;
---

<BaseLayout title="SNARKs for C: Verifying Program Executions Succinctly and in... (2013/507)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2013 &middot; eprint 2013/507
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li>
          <a href="#sec-1" class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-1.1" class="hover:text-white">Succinct Verification in the Preprocessing Model</a></li>
            <li><a href="#sec-1.2" class="hover:text-white">Approach Motivation</a></li>
            <li><a href="#sec-1.3" class="hover:text-white">Contributions</a></li>
            <li><a href="#sec-1.4" class="hover:text-white">Roadmap</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-2" class="hover:text-white">From Correctness of Program Execution to Circuit Satisfiability</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">The TinyRAM Architecture</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">A Compiler from C to TinyRAM</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">An Efficient Reduction from TinyRAM to Circuit Satisfiability</a></li>
            <li><a href="#sec-2.3.1" class="hover:text-white">The reduction notion</a></li>
            <li><a href="#sec-2.3.2" class="hover:text-white">The reduction in [BCGT13a]</a></li>
            <li><a href="#sec-2.3.3" class="hover:text-white">Optimized reduction</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">Verifying Circuit Satisfiability via Linear PCPs</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">A Transformation from Any Linear PCP</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">An Efficient Linear PCP</a></li>
            <li><a href="#sec-3.3" class="hover:text-white">Performance</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">System Evaluation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">System Overview</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">System Performance</a></li>
            <li><a href="#sec-4.3" class="hover:text-white">Performance for Rectilinear TSP Example</a></li>
            <li><a href="#sec-4.4" class="hover:text-white">Further Optimizations</a></li>
          </ol>
        </li>
        <li><a href="#sec-5" class="hover:text-white">Extensions</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li><a href="#app-a" class="hover:text-white">Definition of Zero-Knowledge SNARKs</a></li>
        <li><a href="#app-b" class="hover:text-white">Summary of Theoretical Work on Succinct Verification</a></li>
        <li>
          <a href="#app-c" class="hover:text-white">Prior Implementation Work</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-c.1" class="hover:text-white">Prior Implementations of Proof Systems for Verifiably Delegating Computation</a></li>
            <li><a href="#app-c.2" class="hover:text-white">Prior Implementations of Circuit Generators</a></li>
          </ol>
        </li>
        <li><a href="#app-d" class="hover:text-white">Definition of Linear PCPs</a></li>
        <li>
          <a href="#app-e" class="hover:text-white">An Efficient HVZK Linear PCP</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-e.1" class="hover:text-white">The Construction</a></li>
            <li><a href="#app-e.2" class="hover:text-white">Computational Complexity of the Construction</a></li>
          </ol>
        </li>
        <li><a href="#app-f" class="hover:text-white">Examples Used in Section 2.2</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#acknowledgements" class="hover:text-white">Acknowledgements</a></li>
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="verifying-program-executions-succinctly-and-in-zero-2013" />
  </article>
</BaseLayout>
