---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/380';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Nearly Linear-Time Zero-Knowledge Proofs for Correct Program Execution';
const AUTHORS_HTML = 'Jonathan Bootle, Andrea Cerulli, Jens Groth, Sune Jakobsen, Mary Maller';

const CONTENT = `    <p class="text-gray-300">New Work</p>

    <p class="text-gray-300">A zero-knowledge proof system [GMR85] enables a prover to convince a verifier that a statement is true without revealing anything else. We are interested in proving statements of the form  <span class="math">u \\in \\mathcal{L}</span> , where  <span class="math">\\mathcal{L}</span>  is a language in NP. A zero-knowledge proof is an interactive protocol between a prover and a verifier, where both hold the same instance  <span class="math">u</span> , and the prover also holds a witness  <span class="math">w</span>  to  <span class="math">u \\in \\mathcal{L}</span> . The protocol should satisfy three properties:</p>

    <p class="text-gray-300">\\* The research leading to these results has received funding from the European Research Council under the European Unions Seventh Framework Programme (FP/2007-2013) / ERC Grant Agreement n. 307937</p>

    <p class="text-gray-300">\\<em>\\</em> Supported by a scholarship from Microsoft Research</p>

    <p class="text-gray-300">Completeness: A prover holding a witness to <span class="math">u\\in\\mathcal{L}</span> can convince the verifier. Soundness: A cheating prover cannot convince the verifier when <span class="math">u\\notin\\mathcal{L}</span>. Zero-knowledge: The interaction only shows the statement <span class="math">u\\in\\mathcal{L}</span> is true. It reveals nothing else, in particular it does not disclose anything of the witness.</p>

    <p class="text-gray-300">Zero-knowledge proofs have numerous applications and are for instance used in constructions of public-key encryption schemes secure against chosen ciphertext attack, digital signatures, voting systems, auction systems, e-cash, secure multi-party computation, and verifiable outsourced computation. The zero-knowledge proofs impact the performance of all these applications, and it is therefore important for them to be as efficient as possible.</p>

    <p class="text-gray-300">There are many zero-knowledge proofs for dealing with arithmetic or boolean circuit satisfiability. However, in applications usually the type of statements we want to prove is that a protocol participant is following the protocol honestly; whatever that protocol may be. This means we want to express statements relating to program execution such as “running program <span class="math">P</span> specified by the protocol on public input <span class="math">x</span> and private input <span class="math">y</span> returns the output <span class="math">z</span>.” In principle such a statement can be reduced to circuit satisfiability but the cost of the NP-reduction incurs a prohibitive cost. In this paper, we therefore focus on the important question of getting zero-knowledge proofs for statements relating directly to program execution.</p>

    <p class="text-gray-300">Performance can be measured on a number of parameters including the prover’s running time, the verifier’s running time, the number of transmitted bits and the number of rounds the prover and verifier interact. Current state of the art zero-knowledge proofs get very good performance on verification time, communication and round complexity, which makes the prover’s running time the crucial bottleneck. Indeed, since the other costs are so low, we would happily increase them for even modest savings on the proving time since this is the barrier that make some applications such as verifiable outsourced computation currently unviable. The research challenge we focus on is therefore to get <em>prover-efficient</em> zero-knowledge proofs for correct program execution.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">1.1 Our Contribution</h3>

    <p class="text-gray-300">We use the TinyRAM model <em>[BCG^{+}13, BSCG^{+}13]</em> for computation. TinyRAM specifies a random access machine with a small instruction set working on <span class="math">W</span>-bit words and addresses. The specification of TinyRAM considers a Harvard-architecture processor, which means that the program being executed is stored separately from the data being processed and does not change during execution. Experimental results <em>[BCG^{+}13]</em> show that programs written in C can be compiled efficiently into TinyRAM programs and only have a modest constant overhead compared to optimized compilation to machine code on a modern processor.</p>

    <p class="text-gray-300">3</p>

    <p class="text-gray-300">In our proof system, an instance consists of a TinyRAM program and public data given to the program, and a witness is private data given as input to the program. The statement is the claim that the TinyRAM program <span class="math">P</span> running on given public and private data will terminate with answer 0 within specific time and memory bounds. When measuring performance we think of the prover and verifier as being TinyRAM programs with the same word size².</p>

    <p class="text-gray-300">Our main contribution is an interactive proof system for correct TinyRAM computation, which has perfect completeness, statistical special honest-verifier zero-knowledge, and computational knowledge soundness based on collision-resistant hash functions. Knowledge soundness means that not only do we have soundness and it is infeasible to prove a false statement, but it is also a proof of knowledge such that given access to a successful prover it is possible to extract a witness. For maximal asymptotic efficiency we may use linear-time computable hash functions, which yields the performance given in Fig. 1.</p>

    <p class="text-gray-300">Our proof system is highly efficient for computationally intensive programs where the execution time dominates other parameters (see Section 5.2 for a detailed discussion of parameter choices). For a statement about the execution of a TinyRAM program of length <span class="math">L</span>, running with time bound <span class="math">T</span> and memory bound <span class="math">M</span>, the prover runs in <span class="math">\\mathcal{O}(\\alpha T)</span> steps³ for an arbitrarily small superconstant function <span class="math">\\alpha(\\lambda) = \\omega(1)</span>. The proof system is also efficient on other performance parameters: the verifier running time and the communication grows roughly with the square-root of the execution time⁴ and we have log-logarithmic round complexity. Figure 1 gives an efficiency comparison with a state of the art zk-SNARK [BCTV14b] for verifying correct program execution on TinyRAM. Further discussion of other proof systems that can verify correct TinyRAM or other types of program execution can be found in Section 1.3. The best of these achieve similar asymptotic prover efficiency as [BCTV14b].</p>

    <p class="text-gray-300">Remarks. Our proof system assumes some public parameters to be set up that include a description of a finite field, an error-correcting code, and a collision-resistant hash function. The size of the public parameters is just <span class="math">\\mathrm{poly}(\\lambda)(L + M + \\sqrt{T})</span> bits though and they can be computed from a small uniformly random string in <span class="math">\\mathrm{poly}(\\lambda)(L + M + \\sqrt{T})</span> TinyRAM steps. This means the public parameters</p>

    <p class="text-gray-300">² We stress the choice of comparing the prover and verifier to program execution on the same platform. We do this to get an apples-to-apples comparison; there are many zero-knowledge proofs that are "linear time" because they use different metrics for statement evaluation and the prover time, for instance that the cost of validating the statement given the witness is measured in field multiplications and the prover computation is measured in exponentiations.</p>

    <p class="text-gray-300">³ The big-O notation hides big constants and we do not recommend implementing the proof system as it is; our contribution is to make significant asymptotic gains compared to state-of-the-art zero-knowledge proofs by demonstrating that the prover's computation can be nearly linear.</p>

    <p class="text-gray-300">⁴ Disregarding the SHVZK property for a moment, this is also the first proof system for general purpose computation that has both nearly linear computation for the prover and sublinear communication.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Work</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Communication</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assumption</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BCTV14b]</td>

            <td class="px-3 py-2 border-b border-gray-700">Ω(T log2T)</td>

            <td class="px-3 py-2 border-b border-gray-700">ω(L+</td>

            <td class="px-3 py-2 border-b border-gray-700">v</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">ω(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">KoE</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">O(αT)</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(λ)(√T+L+</td>

            <td class="px-3 py-2 border-b border-gray-700">v</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(λ)(√T+L)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log log T)</td>

            <td class="px-3 py-2 border-b border-gray-700">LT-CRHF</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig.1: Efficiency comparisons between our arguments and the most efficient zero-knowledge argument for the correct execution of TinyRAM programs, both at security level  <span class="math">2^{-\\omega (\\log \\lambda)}</span> . Computation is measured in TinyRAM steps and communication in words of length  <span class="math">W = \\Theta (\\log \\lambda)</span>  with  <span class="math">\\lambda</span>  the security parameter. KoE stands for knowledge of exponent type assumption in pairing-based groups and LT-CRHF stands for linear-time collision resistant hash function. It is worth noting KoE assumptions do not resist quantum computers while a LT-CRHF may be quantum resistant.</p>

    <p class="text-gray-300">have little effect on the overall efficiency of the proof system. Moreover, there are variants of the parameters where it is efficiently verifiable the public parameters have the correct structure. This means the prover does not need to trust the parameters to get special honest verifier zero-knowledge, so they can be chosen by the verifier making our proof systems work in the plain model without setup. We have chosen to separate the public parameters into a separate setup though because they are independent of the instance and can be used over many separate proofs.</p>

    <p class="text-gray-300">We did not optimize communication and verification time to go below  <span class="math">\\sqrt{T}</span>  but if needed it is possible to compose our proof system with a verifier-efficient proof system and get verification time that grows logarithmically in  <span class="math">T</span> . This is done by letting the prover send linear-time computable hashes of her messages to the verifier instead of the full messages. Since our proof system is public coin the prover knows after this interaction exactly how the verifier in our proof system ought to run if given the messages in our proof system. She can therefore give a verifier-efficient proof of knowledge that she knows pre-images to the hashes that would make the verifier in our proof system accept.</p>

    <p class="text-gray-300">Ben-Sasson et al.  <span class="math">\\left[\\mathrm{BCG}^{+}13\\right.</span> , BCTV14b] offer proof systems for correct TinyRAM program execution where the prover commits to a time-sorted execution trace as well as an address-sorted memory trace. They embed words, addresses and flags that describe the TinyRAM state at a given time into field elements. The correct transition in the execution trace between the state at time  <span class="math">t</span>  and the state at time  <span class="math">t + 1</span>  can then be checked by an arithmetic circuit, the correct writing and reading of memory at a particular address in the memory trace can be checked by another arithmetic circuit, and finally the consistency of memory values in the two traces can be checked by a third arithmetic circuit that embeds a permutation network. Importantly, in these proofs the state transitions can be proved with the same arithmetic circuits in each step so many of the proofs can be batched together at low average cost.</p>

    <p class="text-gray-300">Combining their approach with the recent linear-time proofs for arithmetic circuit satisfiability by Bootle et al. <em>[BCG^{+}17]</em> it would be possible to get a zero-knowledge proof system with sublinear communication and efficient verification. The prover time, however, would incur at least a logarithmic overhead compared to the time to execute the TinyRAM program. First, the use of an arithmetic circuit that embeds a permutation network to check consistency between execution and memory traces requires a logarithmic number of linear-size layers to describe an arbitrary permutation which translates into a logarithmic overhead when generating the proof. Second, TinyRAM allows both arithmetic operations such as addition and multiplication of words, and logical operations such as bit-wise XOR, AND and OR. To verify logical operations they decompose words into single bits that are handled individually. Bit-decomposition makes it easy to implement the logical operations, but causes an overhead when embedding bits into full size field elements. From a technical perspective our main contribution is to overcome these two obstacles.</p>

    <p class="text-gray-300">To reduce the time required to prove the execution trace is consistent with the memory usage we do not embed a permutation network into an arithmetic circuit. Instead we relate memory consistency to the existence of a permutation that maps one memory access in the execution trace to the next access of the same memory address in the execution trace. Neff <em>[x13]</em> proposed permutation proofs in the context of shuffle proofs used in mix-nets. Follow-up works <em>[x10, x11]</em> have improved efficiency of such proofs with Bayer and Groth <em>[x2]</em> giving a shuffle argument in the discrete logarithm setting where the prover uses a linear number of exponentiations and communication is sublinear. These shuffle proofs are proposed for the discrete logarithm setting and we do not want to pay the cost of computing exponentiations. The core of the shuffle proofs can be formulated abstractly using homomorphic commitments to vectors though. Since the proofs by Bootle et al. <em>[BCG^{+}17]</em> also rely on an idealization of homomorphic commitments to vectors the ideas are compatible and we get permutation proofs that cost a linear number of field operations.</p>

    <p class="text-gray-300">To remove the overhead of bit-decomposition we invent a less costly decomposition. While additions and multiplications are manageable using a natural embedding of words into field elements, such a representation is not well suited to logical operations though. However, instead of decomposing words into individual bits, we decompose them into interleaved odd-position bits and even-position bits. A nibble <span class="math">(a_{3},a_{2},a_{1},a_{0})</span> can for instance be decomposed into <span class="math">(a_{3},0,a_{1},0)+(0,a_{2},0,a_{0})</span>. The key point of this idea is that adding two interleaved even bit nibbles yields <span class="math">(0,a_{2},0,a_{0})+(0,b_{2},0,b_{0})=(a_{2}\\wedge b_{2},a_{2}\\oplus b_{2},a_{0}\\wedge b_{0},a_{0}\\oplus b_{0})</span>. So using another decomposition into odd-position and even-position bits we can now extract the XORs and the ANDs. Using this core idea, it is possible to represent all logical operations using field additions together with decomposition into odd and even-position bits. This reduces the verification of logical operations to verifying correct decomposition into odd and even bits.</p>

    <p class="text-gray-300">To enable decomposition proofs into odd and even-position bits, we develop a new lookup proof that makes it possible to check that a field element belongs</p>

    <p class="text-gray-300">to a table of permitted values. By creating a lookup table of all words with even-position bits, we make it possible to verify such decompositions. Lookup proofs not only enable decomposition into odd and even-position bits but also turn out to have many other uses such as demonstrating that a field element represents a correct program instruction, or that a field element represents a valid word within the range <span class="math">\\{0,\\ldots,2^{W}-1\\}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Combining arithmetic circuits, permutations and table lookups we get a set of conditions for a TinyRAM execution being correct. The program execution of <span class="math">T</span> steps on the TinyRAM machine can in our system be encoded as <span class="math">\\mathcal{O}(T)</span> field elements that satisfy the conditions. Using prime order fields of size <span class="math">2^{\\mathcal{O}(W)}</span> would make it possible to represent these field elements as <span class="math">\\mathcal{O}(1)</span> words each. However, the soundness of our proof systems depends on the field size and to get negligible soundness error we choose a larger field to get a superconstant ratio $e=\\frac{\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{W}<span class="math">. This factors into the efficiency of our proof system giving a prover runtime of </span>\\mathcal{O}(\\alpha T)<span class="math"> TinyRAM steps for an instance requiring time </span>T<span class="math">, where </span>\\alpha<span class="math"> is a superconstant function which specifies how many steps it takes to compute a field operation, i.e., </span>\\alpha=\\mathcal{O}(e^{2})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Having the inner core of conditions in place: arithmetic circuits for instruction executions, permutations for memory consistency, and look-ups for word decompositions we now deploy the framework of Bootle et al. <em>[BCG^{+}17]</em> to get a zero-knowlegde proof system. They use error-correcting codes and linear-time collision-resistant hash functions to give proof systems for arithmetic circuit satisfiability, while we will use their techniques to prove our conditions on the execution trace are satisfied. Their proof system for arithmetic circuit satisfiability requires the prover to use a linear number of field multiplications and the verifier to use a linear number of field additions. However, we can actually get sublinear verification when the program and the input is smaller than the execution time. Technically, the performance difference stems from the type of permutation proof that they use for verifying the correct wiring of the circuit and that we use for memory consistency in the execution trace. In their use, the permutation needs to be linked to the publicly known wiring of the arithmetic circuit and in order for the verifier to check the wiring is correct he must read the entire circuit. We on the other hand do not disclose the memory accesses in the execution trace to the verifier, indeed to get zero-knowledge it is essential the memory accesses remain secret. We therefore need a hidden permutation proof and such proofs can have sublinear verification time.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">1.3 Related work</h3>

    <p class="text-gray-300">Interaction. Interaction is measured by the number of rounds the prover and verifier exchange messages. Feige and Shamir <em>[x10]</em> showed that constant round argument systems exist, and Blum, Feldman and Micali <em>[x3]</em> showed that if the prover and verifier have access to an honestly generated common reference string it is possible to have non-interactive zero-knowledge proofs where the prover sends a single message to the verifier.</p>

    <p class="text-gray-300">Communication. A series of works <em>[x11, x10, x12, GGI^{+}15]</em> have constructed proof systems where the number of transmitted bits is proportional to the witness size. It is unlikely that sublinear communication is possible in proof systems with statistical soundness but Kilian <em>[x13]</em> constructed an argument system, a computationally sound proof system, with polylogarithmic communication complexity. Kilian’s zero-knowledge argument relies on probablistically checkable proofs <em>[x2]</em>, which are still complex for practical use, but the invention of interactive oracle proofs <em>[x3]</em> have made this type of proof system a realistic option. Ishai et al. <em>[x11]</em> give laconic arguments where the prover’s communication is minimal. Groth <em>[x16]</em>, working in the common reference string model and using strong assumptions, gave a pairing-based non-interactive zero-knowledge argument consisting of a constant number of group elements. Follow-up works on succinct non-interactive arguments of knowledge (SNARKs) have shown that it is possible to have both a modest size common reference string and proofs as small as 3 group elements <em>[x4, x10, x7, x12, x3]</em>.</p>

    <p class="text-gray-300">Verifier computation. In general the verifier has to read the entire instance since even a single deviating bit may render the statement <span class="math">u\\in\\mathcal{L}</span> false. However, in many cases an instance can be represented more compactly than the witness and the instance may be small compared to the computational effort it takes to verify a witness for the instance. In these cases it is possible to get sublinear verification time compared to the time it takes to check the relation defining the language <span class="math">\\mathcal{L}</span>. This is for instance the case for the SNARKs mentioned above, where the verification time only depends on the size of the instance but not the complexity of the relation.</p>

    <p class="text-gray-300">Prover computation. Given the success in reducing interaction, communication and verification time, the important remaining challenge is to get good efficiency for the prover.</p>

    <p class="text-gray-300">Boolean and arithmetic circuits. Many classic zero-knowedge proofs rely on cyclic groups and have applications in digital signatures, encryption schemes, etc. The techniques first suggested by Schnorr <em>[x17]</em> can be generalized to NP-completel languages such as boolean and arithmetic circuit satisfiability <em>[x5, x12, BCC^{+}16]</em>. In these proofs and arguments the prover uses <span class="math">\\mathcal{O}(N)</span> group exponentiations, where <span class="math">N</span> is the number of gates in the circuit. For the discrete logarithm assumption to hold, the groups must have superpolynomial size in the security parameter though, so exponentiations incur a significant overhead compared to direct evaluation of the witness in the circuit. The SNARKs mentioned earlier also rely on cyclic groups and likewise require the prover to do <span class="math">\\mathcal{O}(N)</span> exponentiations. Recently, Bootle et al. <em>[BCG^{+}17]</em> used the structure of <em>[x12]</em> to give constant overhead zero-knowledge proofs for arithmetic circuit satisfiability, where the prover uses <span class="math">\\mathcal{O}(N)</span> field multiplications, relying on error-correcting codes and efficient collision-resistant hash functions instead of cyclic groups.</p>

    <p class="text-gray-300">An alternative to these techniques is to use the “MPC in the head” paradigm by Ishai et al. <em>[x11]</em>. Relying on efficient MPC techniques, Damgård, Ishai and Krøigaard gave zero-knowledge arguments with little communication and a</p>

    <p class="text-gray-300">prover complexity of <span class="math">\\text{polylog}(\\lambda)N</span>. Instead of focusing on theoretical performance, ZKBoo <em>[x13]</em> and its subsequent optimisation ZKB++ <em>[CDG^{+}17]</em> are practical implementations of a “3PC in the head” style zero-knowledge proof for boolean circuit satisfiability. Communication grows linearly in the circuit size in both proofs, and a superlogarithmic number of repetitions is required to make the soundness error negligible, but the speed of the symmetric key primitives makes practical performance good. Ligero <em>[x1]</em> provides another implementation using techniques related to <em>[BCG^{+}17]</em>. It has excellent practical performance but asymptotically it is not as efficienct as <em>[BCG^{+}17]</em> due to the use of more expensive error-correcting codes. Another alternative also inspired by the MPC world is to use garbled circuits to construct zero-knowledge arguments for boolean circuits <em>[x4, x11, x12]</em>.The proofs grow linearly in the size of the circuit and there is a polylogarithmic overhead for the prover and verifier due to the cryptographic operations but implementations are practical <em>[x11]</em>.</p>

    <p class="text-gray-300">There are several proof systems for efficient verification of outsourced computation <em>[x14, x10, x27, WHG^{+}16]</em>. While this line of works mostly focus on verifying deterministic computation and does not require zero-knowledge, recent works add in cryptographic techniques to obtain zero-knowledge <em>[ZGK^{+}17, WJB^{+}17, WTas^{+}17]</em>. Hyrax <em>[WTas^{+}17]</em> offers an implementation with good concrete performance. It has sublinear communication and verification, while the prover computation is dominated by <span class="math">\\mathcal{O}(dN+S\\log S)</span> field operations for a depth <span class="math">d</span> and width <span class="math">S</span> circuit when the witness is small compared to the circuit size. If in addition the circuit can be parallelized into many identical sub-computations the prover cost can be further reduced to <span class="math">O(dN)</span> field operations. The system vSQL <em>[ZGK^{+}17]</em> is tailored towards verifing database queries and as in this work it avoids the use of permutation networks using permutation proofs based on invariance of roots in polynomials as first suggested by Neff <em>[x22]</em>.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Correct program execution.</h4>

    <p class="text-gray-300">In practice, most computation does not resemble circuit evaluation but is instead done by computer programs processing one instruction at a time. There has been a sustained effort to construct efficient zero-knowledge proofs that support real-life computation, i.e., proving statements of the form “when executing program <span class="math">P</span> on public input <span class="math">x</span> and private input <span class="math">y</span> we get the output <span class="math">z</span>.” In the context of SNARKs there are already several systems for proving correct execution of programs written in C <em>[x20, BFR^{+}13, BCG^{+}13, WSR^{+}15]</em>. These system generally involve a <em>front-end</em> which compiles the program into an arithmetic circuit which is then fed into a cryptographic <em>back-end</em>. Much work has been dedicated to improving both sides and achieving different trade-offs between efficiency and expressiveness of the computation.</p>

    <p class="text-gray-300">When we want to reason theoretically about zero-knowledge proofs for correct program execution, it is useful to abstract program execution as a random-access machine that in each instruction can address an arbitrary location in memory and do integer operations on it. For closer resemblance to real-life computation, we can bound the integers to a specific word size and specify a more general set of operations the random-access machine can execute. TinyRAM <em>[BSCG^{+}13, BCG^{+}13]</em> is a prominent example of a computational model bridging the gap</p>

    <p class="text-gray-300">between theory and real-word computation. It comes with a compiler from C to TinyRAM code and underpins several implementations of zero-knowledge proofs for correct program execution <em>[BCG^{+}13, x1, x1, x2]</em> where the prover time is <span class="math">\\Omega(T\\log^{2}\\lambda)</span> for a program execution that takes time <span class="math">T</span>. Similar efficiency is also achieved, asymptotically, by other proof systems that can compile (restricted) C programs and prove correct execution such as Pinocchio <em>[x10]</em>, Pantry <em>[BFR^{+}13]</em> and Buffet <em>[WSR^{+}15]</em>. Our work reduces the prover’s overhead from <span class="math">\\Omega(\\log^{2}\\lambda)</span> to an arbitrary superconstant <span class="math">\\alpha=\\omega(1)</span> and is therefore an important step towards optimal prover complexity.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Concurrent Work.</h4>

    <p class="text-gray-300">Zhang et al. <em>[ZGK^{+}18]</em> have concurrently with our work developed and implemented a scheme for verifying RAM computations. Like us and <em>[ZGK^{+}17]</em>, they avoid the use of permutation networks by using permutation proofs based on polynomial invariance by Neff <em>[x13]</em>. The idea underlying their technique for proving the correct fetch of an operation is related to the idea underpinning our look-up proofs. There are significant differences between the techniques used in our works; e.g. they rely on techniques from <em>[x4]</em> for instantiating proofs where we use techniques based on ideal linear commitments <em>[BCG^{+}17]</em>. The proofs in <em>[ZGK^{+}18]</em> are not zero-knowledge since they leak the number of times each type of instruction is executed, while our proofs are zero-knowledge. In terms of prover efficiency, <em>[ZGK^{+}18]</em> focuses on concrete efficiency and yields impressive concrete performance. Asymptotically speaking, however, we are a polylogarithmic factor more efficient. This may require some explanation because they claim linear complexity for the prover. The reason is that they treat the prover as a TinyRAM machine with logarithmic word size in their performance measurement. Looking under the hood, we see that they use bit-decomposition to handle logical operations, which is constant overhead when you fix a particular word size (e.g. 32 bits) but asymptotically the cost of this is logarithmic since it is linear in the word size. Also, they base commitments on cyclic groups and the use of exponentiations incurs a superlogarithmic overhead for the prover when implemented in TinyRAM.</p>

    <h2 id="sec-14" class="text-2xl font-bold">2 Preliminaries</h2>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">2.1 Notation</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We write <span class="math">y\\leftarrow A(x)</span> for an algorithm returning <span class="math">y</span> on input <span class="math">x</span>. When the algorithm is randomized, we write <span class="math">y\\leftarrow A(x;r)</span> to explicitly refer to the random coins <span class="math">r</span> picked by the algorithm. We use a security parameter <span class="math">\\lambda</span> to indicate the desired level of security. The higher the security parameter, the smaller the risk of an adversary compromising security should be. For functions <span class="math">f,g:\\mathbb{N}\\rightarrow[0,1]</span>, we write <span class="math">f(\\lambda)\\approx g(\\lambda)</span> if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(\\lambda)-g(\\lambda)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\frac{1}{\\lambda^{\\omega(1)}}<span class="math">. We say a function </span>f<span class="math"> is <em>overwhelming</em> if </span>f(\\lambda)\\approx 1<span class="math"> and that it is <em>negligible</em> if </span>f(\\lambda)\\approx 0<span class="math">. In general we want the adversary’s chance of breaking our proof systems to be negligible in </span>\\lambda$. As a minimum requirement for an algorithm or adversary to be efficient it has to run in polynomial time in the security parameter. We abbreviate probabilistic (deterministic) polynomial time</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">in the security parameter PPT (DPT). For a positive integer <span class="math">n</span>, <span class="math">[n]</span> denotes the set <span class="math">\\{1,\\ldots,n\\}</span>. We use bold letters such as <span class="math">\\bm{v}</span> for row vectors over a finite field <span class="math">\\mathbb{F}</span>.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">2.2 Proofs of Knowledge</h3>

    <p class="text-gray-300">We follow <em>[BCG^{+}17]</em> in defining proofs of knowledge over a communication channel and their specification of the ideal linear commitment channel and the standard channel. A <em>proof system</em> is defined by stateful PPT algorithms <span class="math">(\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>. The setup generator <span class="math">\\mathcal{K}</span> is only run once to provide public parameters <span class="math">pp</span> that will be used by the prover <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span>. We will in our security definitions just assume <span class="math">\\mathcal{K}</span> is honest, which is reasonable since in our constructions the public parameters are publicly verifiable and could even be generated by the verifier.</p>

    <p class="text-gray-300">The prover and verifier communicate with each other through a <em>communication channel</em> <span class="math">\\xleftrightarrow{\\text{chan}}</span>. When <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> interact on inputs <span class="math">s</span> and <span class="math">t</span> through a channel <span class="math">\\xleftrightarrow{\\text{chan}}</span> we let <span class="math">\\mathsf{view}_{\\mathcal{V}}\\leftarrow\\langle\\mathcal{P}(s)\\xleftrightarrow{\\text{chan}}\\mathcal{V}(t)\\rangle</span> be the view of the verifier in the execution, i.e., all inputs he gets including random coins, and we let <span class="math">\\mathsf{trans}_{\\mathcal{P}}\\leftarrow\\langle\\mathcal{P}(s)\\xleftrightarrow{\\text{chan}}\\mathcal{V}(t)\\rangle</span> denote the transcript of the communication between prover and channel. The protocol ends with the verifier accepting or rejecting the proof. We write <span class="math">\\langle\\mathcal{P}(s)\\xleftrightarrow{\\text{chan}}\\mathcal{V}(t)\\rangle=b</span> depending on whether he accepts <span class="math">(b=1)</span> or rejects <span class="math">(b=0)</span>.</p>

    <p class="text-gray-300">In the <em>standard channel</em> <span class="math">\\longleftrightarrow</span>, all messages are forwarded between prover and verifier. As in <em>[BCG^{+}17]</em>, we also consider an <em>ideal linear commitment</em> channel, <span class="math">\\xleftrightarrow{\\text{ILC}}</span>, described in Figure 2. When using the ILC channel, the prover can submit a commit command to commit to vectors of field elements of some fixed length <span class="math">k</span>, specified in the public parameters. The vectors remain secretly stored in the channel, and will not be forwarded to the verifier. Instead, the verifier only learns how many vectors the prover has committed to. The verifier can submit a send command to the ILC channel to send a mesage to the prover. In addition, the verifier can also submit open queries to the ILC channel to obtain openings of linear combinations of the vectors sent by the prover. We stress that the verifier can request several linear combinations of stored vectors within a single open query, as depicted in Figure 2 using matrix notation.</p>

    <p class="text-gray-300">We say a proof system is <em>public coin</em> if the verifier’s messages to the communication channel are chosen uniformly at random and independently of the actions of the prover, i.e., the verifier’s messages to the prover correspond to the verifier’s randomness <span class="math">\\rho</span>. All our proof systems will be public coin. In a proof system over the ILC channel, sequences of commit, send and open queries can alternate arbitrarily. However, since our proof systems are public coin we can without loss of generality assume the verifier will only make one big open query at the end of the protocol and then decide whether to accept or reject.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{R}</span> be an efficiently decidable relation of tuples <span class="math">(pp,u,w)</span>. We can define a matching language $\\mathcal{L}=\\{(pp,u)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\exists w:(pp,u,w)\\in\\mathcal{R}\\}<span class="math">. We refer to </span>u<span class="math"> as the <em>instance</em> and </span>w<span class="math"> as the <em>witness</em> to </span>(pp,u)\\in\\mathcal{L}<span class="math">. The public parameter </span>pp<span class="math"> will specify the security parameter </span>\\lambda<span class="math">, perhaps implicitly through its length, and may also contain other parameters used for specifying the relation. Typically, </span>pp$ will also</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 2: Description of the ILC channel.</p>

    <p class="text-gray-300">contain parameters that do not influence membership of  <span class="math">\\mathcal{R}</span>  but may aid the prover and verifier, for instance the field and vector size in the ILC channel.</p>

    <p class="text-gray-300">The protocol  <span class="math">(\\mathcal{K},\\mathcal{P},\\mathcal{V})</span>  is called a proof of knowledge over a communication channel  <span class="math">\\stackrel{\\mathrm{chan}}{\\longleftrightarrow}</span>  for a relation  <span class="math">\\mathcal{R}</span>  if it has perfect completeness and computational knowledge soundness as defined below.</p>

    <p class="text-gray-300">Definition 1 (Perfect Completeness). A proof system is perfectly complete if for all PPT adversaries  <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} p p \\leftarrow \\mathcal {K} (1 ^ {\\lambda}); (u, w) \\leftarrow \\mathcal {A} (p p): \\\\ (p p, u, w) \\notin \\mathcal {R} \\lor \\langle \\mathcal {P} (p p, u, w) \\stackrel {{\\mathrm {c h a n}}} {{\\longleftrightarrow}} \\mathcal {V} (p p, u) \\rangle = 1 \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300">Definition 2 (Knowledge soundness). A public-coin proof system has computational (strong black-box) knowledge soundness if for all DPT  <span class="math">\\mathcal{P}^*</span>  there exists an expected PPT extractor  <span class="math">\\mathcal{E}</span>  such that for all PPT adversaries  <span class="math">\\mathcal{A}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} p p \\leftarrow \\mathcal {K} (1 ^ {\\lambda}); (u, s) \\leftarrow \\mathcal {A} (p p); w \\leftarrow \\mathcal {E} ^ {\\langle \\mathcal {P} ^ {*} (s) \\stackrel {{\\mathrm {c h a n}}} {{\\longleftrightarrow}} \\mathcal {V} (p p, u) \\rangle} (p p, u): \\\\ b = 1 \\wedge (p p, u, w) \\notin \\mathcal {R} \\end{array} \\right] \\approx 0.</span></div>

    <p class="text-gray-300">Here the oracle  <span class="math">\\langle \\mathcal{P}^*(s) \\stackrel{\\mathrm{chan}}{\\longleftrightarrow} \\mathcal{V}(pp, u) \\rangle</span>  runs a full protocol execution and if the proof is successful it returns the transcript  <span class="math">\\mathrm{trans}_{\\mathcal{P}}</span>  of the prover's communication with the channel. The extractor  <span class="math">\\mathcal{E}</span>  can ask the oracle to rewind the proof to any point in a previous transcript and execute the proof again from this point on with fresh public-coin challenges from the verifier. We let  <span class="math">b \\in \\{0, 1\\}</span>  be the verifier's output in the first oracle execution, i.e., whether it accepts or not, and we think of  <span class="math">s</span>  as the state of the prover. The definition can then be paraphrased as saying that if the prover in state  <span class="math">s</span>  makes a convincing proof, then  <span class="math">\\mathcal{E}</span>  can extract a witness.</p>

    <p class="text-gray-300">If the definition holds also for unbounded  <span class="math">\\mathcal{P}^*</span>  and  <span class="math">\\mathcal{A}</span>  we say the proof has statistical knowledge soundness.</p>

    <p class="text-gray-300">If the definition holds for a non-rewinding extractor, i.e.,  <span class="math">\\mathcal{E}</span>  only requires a single transcript of the prover's communication with the channel, we say the proof system has knowledge soundness with straight-line extraction.</p>

    <p class="text-gray-300">We will construct public-coin proofs of knowledge that have special honest-verifier zero-knowledge. This means that if the verifier’s challenges are known in advance then it is possible to simulate the verifier’s view without knowing a witness. In our definition, the simulator works even for verifiers who may use adversarial biased coins in choosing their challenges as long as they honestly follow the specification of the protocol.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 3 (Special Honest-Verifier Zero-Knowledge)</h6>

    <p class="text-gray-300">A public-coin proof of knowledge is <em>computationally special honest-verifier zero-knowledge (SHVZK)</em> if there exists a PPT simulator <span class="math">\\mathcal{S}</span> such that for all stateful interactive PPT adversaries <span class="math">\\mathcal{A}</span> that output <span class="math">(u,w)</span> such that <span class="math">(pp,u,w)\\in R</span> and randomness <span class="math">\\rho</span> for the verifier</p>

    <p class="text-gray-300">\\[ \\Pr\\begin{bmatrix}pp\\leftarrow\\mathcal{K}(1^{\\lambda});(u,w,\\rho)\\leftarrow\\mathcal{A}(pp);\\\\ \\mathsf{view}_{\\mathcal{V}}\\leftarrow\\langle\\mathcal{P}(pp,u,w)\\xleftrightarrow{\\text{chan}}\\mathcal{V}(pp,u;\\rho)\\rangle:\\mathcal{A}(\\mathsf{view}_{\\mathcal{V}})=1\\end{bmatrix} \\] <span class="math">\\approx\\Pr\\left[pp\\leftarrow\\mathcal{K}(1^{\\lambda});(u,w,\\rho)\\leftarrow\\mathcal{A}(pp);\\mathsf{view}_{\\mathcal{V}}\\leftarrow\\mathcal{S}(pp,u,\\rho):\\mathcal{A}(\\mathsf{view}_{\\mathcal{V}})=1\\right].</span></p>

    <p class="text-gray-300">We say the proof is <em>statistically SHVZK</em> if the definition holds also against unbounded adversaries, and we say the proof is <em>perfectly SHVZK</em> if the probabilities are exactly equal.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">3.2.2 Full Zero-Knowledge</h4>

    <p class="text-gray-300">SHVZK only guarantees the simulator works for honest verifiers. It is in some applications desirable to have full zero-knowledge where the simulator works for arbitrary malicious verifiers, even those that deviate from the protocol. However, it makes sense to simply focus on SHVZK since there are very efficient standard transformations from SHVZK to full zero-knowledge.</p>

    <p class="text-gray-300">In the Fiat-Shamir transform <em>[x10]</em> the verifier’s challenges in a proof system are computed using a cryptographic hash function applied to the transcript up to the challenge. The Fiat-Shamir transform can therefore make a public-coin proof system non-interactive. Our proof system is such that the Fiat-Shamir heuristic yields a non-interactive proof that is knowledge sound and has full zero-knowledge in the random oracle model.</p>

    <p class="text-gray-300">If the random oracle model is undesirable, an alternative is to use coin-flipping between the prover and verifier to decide on the challenges. We let the public parameters include a trapdoor commitment scheme. The prover commits to coins <span class="math">\\delta_{1},\\ldots,\\delta_{\\mu}</span> and starts executing the proof system, where in round <span class="math">i</span> with challenge <span class="math">\\rho_{i}</span> from the verifier, the prover uses the modified challenge <span class="math">\\rho^{\\prime}_{i}=\\rho_{i}\\oplus\\delta_{i}</span>. In the last round the prover then opens the commitment to <span class="math">\\delta_{1},\\ldots,\\delta_{\\mu}</span> so the verifier learns the modifiers and hence what the challenges were. The idea is now that we give the simulator the trapdoor for the commitment scheme. This means it can simulate the proof with random public coin challenges <span class="math">\\rho^{\\prime}_{i}</span>, and then at the end after seeing the verifier challenges <span class="math">\\rho_{i}</span> open the commitments to suitable <span class="math">\\delta_{i}=\\rho^{\\prime}_{i}\\oplus\\rho_{i}</span> to make the simulation work.</p>

    <p class="text-gray-300">2.3 TinyRAM</p>

    <p class="text-gray-300">TinyRAM is a random-access machine model operating on <span class="math">W</span>-bit words and using <span class="math">K</span> registers. We now describe the key features of TinyRAM but refer the reader to the specification <em>[BSCG^{+}13]</em> for full details. A state of the TinyRAM machine consists of a program <span class="math">P</span> (list of <span class="math">L</span> instructions), a program counter pc (word), <span class="math">K</span> registers <span class="math">\\textsf{reg}_{0},\\ldots,\\textsf{reg}_{K-1}</span> (words), a condition flag flag (bit), and <span class="math">M</span> words of memory with addresses <span class="math">0,\\ldots,M-1</span>.</p>

    <p class="text-gray-300">The TinyRAM specification includes two read-only tapes to retrieve its inputs but with little loss of efficiency we may assume the program starts by reading the tapes into memory We will therefore skip the reading phase and assume the memory is initialized with the inputs (and 0 for the remaining words). Also, we will assume on initialization that pc, the registers and flag are all set to 0.</p>

    <p class="text-gray-300">The program consists of a sequence of <span class="math">L</span> instructions that include bit-wise logical operations, arithmetic operations, shifts, comparisons, jumps, and storing and loading data in memory. The program terminates by using a special command answer that returns a word. We consider the program to have succeeded if it answers 0, otherwise we consider the answer to be a failure code.</p>

    <p class="text-gray-300">We write <span class="math">\\textsf{reg}_{i}</span> and <span class="math">r_{i}</span> when referring to register <span class="math">i</span> and to its content, respectively. We write <span class="math">A</span> to refer to either a register or an immediate value specified in a program instruction and write A for the value stored therein. Depending on the instruction a word a may be interpreted as an unsigned value in <span class="math">\\{0,\\ldots,2^{W}-1\\}</span> or as a signed value in <span class="math">\\{-2^{W-1},\\ldots,2^{W-1}-1\\}</span>. Signed values are in two’s complement, so given a word <span class="math">\\textsf{a}=(a_{w-1},\\ldots,a_{0})\\in\\{0,1\\}^{W}</span> the bit <span class="math">a_{W-1}</span> is the sign and the signed value is <span class="math">-2^{W}+\\textsf{a}</span> if <span class="math">a_{W-1}=1</span> and a if <span class="math">a_{W-1}=0</span>. We distinguish operations over signed values by using subscript <span class="math">s</span>, e.g. <span class="math">\\textsf{a}\\times_{s}\\textsf{b}</span> and <span class="math">\\textsf{a}\\geq_{s}\\textsf{b}</span> are used to denote product and comparison over the signed values. With this notation in mind, we specify the instruction set in Table 1.</p>

    <p class="text-gray-300">Correct Program Execution. It is often important to check that a protocol participant supposedly running program <span class="math">P</span> on public input <span class="math">x</span> and private input <span class="math">w</span> provides the correct output <span class="math">z</span>. Without loss of generality, we can formulate the verification as an extended program that takes public input <span class="math">v=(x,z)</span> and answers 0 if and only if <span class="math">z</span> is the output of the computation. We therefore formulate correct program execution as the program just answering 0.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now give a relation that captures correct TinyRAM program execution. An instance is of the form <span class="math">u=(P,v,T,M)</span>, where <span class="math">P</span> is a TinyRAM program, <span class="math">v</span> is a list of words given as input to the program, <span class="math">T</span> is a time bound, and <span class="math">M</span> is the size of the memory. A witness <span class="math">w</span> is another list of words. We assume without loss of generality that the witness is appended by 0’s, such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=M$ and the program starts with the memory being initialized to these words.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The statement we want to prove is that the program <span class="math">P</span> terminates in <span class="math">T</span> steps using <span class="math">M</span> words of memory on the public input <span class="math">v</span> and private input <span class="math">w</span> with the</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Instruction</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operands</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Effect</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Flag</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">and</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700">regj</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">compute ri as bitwise AND of rj and A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">or</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700">regj</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">compute ri as bitwise OR of rj and A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">xor</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700">regj</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">compute ri as bitwise XOR of rj and A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">not</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">compute ri as bitwise NOT of A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">add</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700">regj</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">compute ri = rj + A mod 2W</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sub</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700">regj</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">compute ri = rj - A mod 2W</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">mull</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700">regj</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">compute ri = rj × A mod 2W</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">umulh</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700">regj</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">compute ri as upper W bits of rj × A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">smulh</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700">regj</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">compute ri as upper W bits of the signed 2W-bit rj × s A (mull gives lower word)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">udiv</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700">regj</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">compute ri as quotient of rj/A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">umod</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700">regj</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">compute ri as remainder of rj/A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">shl</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700">regj</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">compute ri as ri shifted left by A bits</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">shr</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700">regj</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">compute ri as ri shifted right by A bits</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">cmpe</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">compare if equal</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">cmpa</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">compare if above</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">cmpae</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">compare if above or equal</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">cmpg</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">signed compare if greater</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">cmpge</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">signed compare if greater or equal</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">mov</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">set ri = A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">cmov</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">if flag = 1 set ri = A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">jmp</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">set pc = A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">cjmp</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">if flag = 1 set pc = A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">cnjmp</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">if flag = 0 set pc = A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">store</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">store in memory address A the word ri</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">load</td>

            <td class="px-3 py-2 border-b border-gray-700">regi</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">set ri to the word stored at address A</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">answer</td>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">stall or halt returning the word A</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: TinyRAM instruction set, excluding the read command. The flag is set equal to 1 if the condition is met and 0 otherwise. If the pc exceeds the program length, i.e.,  <span class="math">\\mathsf{pc} \\geq L</span> , or we address a non-existing part of memory, i.e., in a store or load instruction  <span class="math">A \\geq M</span> , the TinyRAM machine halts with answer 1.</p>

    <p class="text-gray-300">instruction answer 0. We therefore define</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathcal{R}_{\\text{TinyRAM}}=\\left\\{\\begin{array}[]{c}(pp,u,w)=((W,K,*),(P,v,T,M),w)\\ \\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">P\\text{ is a TinyRAM program with }W\\text{-bit words, }K\\text{ registers,}\\\\ \\text{and }M\\text{ words of addressable memory, which on inputs }v\\text{ and }w\\\\ \\text{terminates in }T\\text{ steps with the instruction answer 0.}\\end{array}\\right\\} \\]</p>

    <p class="text-gray-300">Our main interest is to prove correct execution of programs that require heavy computation so we will throughout the article assume the number of steps outweigh the other parameters, i.e., <span class="math">T&gt;L+M</span>, where <span class="math">L</span> is the number of instructions in the program.</p>

    <h2 id="sec-19" class="text-2xl font-bold">3 Arithmetization of Correct Program Execution</h2>

    <p class="text-gray-300">As a first step towards the realization of proofs for the correct execution of TinyRAM programs we translate <span class="math">\\mathcal{R}_{\\text{TinyRAM}}</span> into a more amenable relation involving elements in a finite field. Given a TinyRAM machine with word-size <span class="math">W</span> and a finite field <span class="math">\\mathbb{F}</span>, we can in a natural way embed words into field elements by encoding a word <span class="math">a\\in\\{0,\\ldots,2^{W}-1\\}</span> as the field element <span class="math">a1_{\\mathbb{F}}=1_{\\mathbb{F}}+\\cdots+1_{\\mathbb{F}}</span> (<span class="math">a</span> times). We will use fields of characteristic <span class="math">p&gt;2^{2W}-2^{W-1}</span> because then sums and products of words are less than <span class="math">p</span> and we avoid overflow in the field operations we apply to the embedded words.</p>

    <p class="text-gray-300">We will encode the program, memory and states of a TinyRAM program as tuples of field elements. We then introduce a new relation <span class="math">\\mathcal{R}_{\\text{TinyRAM}}^{\\text{field}}</span> consisting of a set of arithmetic constraints these encodings should satisfy to guarantee the correct program execution. The relation will take instances <span class="math">u=(P,v,T,M)</span>, and witnesses w consisting of the encodings as well as a set of auxiliary field elements.</p>

    <p class="text-gray-300">In this section we specify the structure of the witness w and how the relation of correct program execution decomposes into simpler sub-relations. It will be the case that the encoding of the witness can be done alongside an execution of the program in <span class="math">\\mathcal{O}(L+M+T)</span> field operations.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">3.1 Witness Structure</h3>

    <p class="text-gray-300">Given a correct program execution we encode program, memory and states of the TinyRAM machine as field elements and arrange them in a number of tables as pictured in Table 2. The execution table Exe, contains the field elements encoding of the states of the TinyRAM machine. It consists of <span class="math">T</span> rows, where row <span class="math">t</span> describes the state at the beginning of step <span class="math">t</span>. A row includes field elements that encode the time <span class="math">t</span>, the program counter <span class="math">\\mathsf{pc}_{t}</span>, the instruction <span class="math">\\mathsf{inst}_{\\mathsf{pc}_{t}}</span> corresponding to <span class="math">\\mathsf{pc}_{t}</span>, an immediate value <span class="math">\\mathsf{A}_{t}</span>, the values <span class="math">\\mathsf{r}_{0,t},\\ldots,\\mathsf{r}_{K-1,t}</span> contained in the registers <span class="math">\\mathsf{reg}_{0},\\ldots,\\mathsf{reg}_{K-1}</span> at time <span class="math">t</span>, and the flag <span class="math">\\mathsf{flag}_{t}</span>. The next row contains the resulting state of the TinyRAM machine at time <span class="math">t+1</span>. Each row also includes a memory address <span class="math">\\mathsf{addr}_{t}</span>, and the value <span class="math">\\mathsf{v}_{\\mathsf{addr}_{t}}</span> stored at this address after the execution of the step, as well as a constant number of auxiliary field elements to be specified later that will be used to check correctness of program execution.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pc</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Instruction</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Immediate</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">reg0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">regK-1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Flag</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Address</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Value</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">auxExe</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">inst0</td>

            <td class="px-3 py-2 border-b border-gray-700">A0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">...</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">...</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  |  |  |  | : |  |  |  |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pct</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">instpct</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">At</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r0,t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rK-1,t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">flagt</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">addrt</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">vaddrt</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  |  |  |  | : |  |  |  |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pCT</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">answer 0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r0,T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rK-1,T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">flagT</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">addrT</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">vaddrT</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(a) The execution table Exe.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pc</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Instruction</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Immediate</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">auxProg</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">inst0</td>

            <td class="px-3 py-2 border-b border-gray-700">A0</td>

            <td class="px-3 py-2 border-b border-gray-700">...</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | : |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L-1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">instL-1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">AL-1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(b) The program table Prog.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Address</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Initial value</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">und</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">v1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | : |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M-1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">vM-1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">v1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | : |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M-1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">vM-1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(c) The memory table Mem.</p>

    <p class="text-gray-300">|  Values  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  0  |</p>

    <p class="text-gray-300">|  1  |</p>

    <p class="text-gray-300">|  4  |</p>

    <p class="text-gray-300">|  5  |</p>

    <p class="text-gray-300">|  :  |</p>

    <p class="text-gray-300">|  ∑i=0 n-1/22i  |</p>

    <p class="text-gray-300">|  ∑i=0 n-1/22i  |</p>

    <p class="text-gray-300">(d) The table EvenBits.</p>

    <p class="text-gray-300">Table 2: The execution table Exe, the program table Prog, the memory table Mem and the table EvenBits.</p>

    <p class="text-gray-300">The next table is the program table <span class="math">\\mathsf{Prog}</span>, which contains the field elements encoding of the TinyRAM program <span class="math">P</span>. Each row contains the description of one line of the program, consisting of one instruction, at most three operands, and possibly an immediate value. Furthermore, we introduce a constant number of auxiliary field elements in each row. These entries can be efficiently computed given the program line stored in the same row and will help verifying its execution, e.g. we encode the position of input and output registers as auxiliary field elements.</p>

    <p class="text-gray-300">The memory table <span class="math">\\mathsf{Mem}</span> has rows that list the possible memory addresses, their initial values, and an auxiliary field element <span class="math">\\mathsf{usd}\\in\\{0,1\\}</span>. For every pair of address and corresponding initial value, the memory table <span class="math">\\mathsf{Mem}</span> contains a row in which <span class="math">\\mathsf{usd}=0</span> and another row in which <span class="math">\\mathsf{usd}=1</span>. Recall that the memory is initialized with input words listed in <span class="math">v,w</span>, i.e., the input words contributing to the instance and witness of the relation <span class="math">\\mathcal{R}_{\\mathsf{TinyRAM}}</span>.</p>

    <p class="text-gray-300">In addition to these, we also consider an auxiliary lookup table <span class="math">\\mathsf{EvenBits}</span> containing the encoding of words of length <span class="math">W</span> whose binary expansion has <span class="math">0</span> in all odd positions. The table contains <span class="math">2^{\\frac{W}{2}}</span> field elements and will be used as part of a check that certain field elements encode a word of length <span class="math">W</span>.</p>

    <p class="text-gray-300">Let <span class="math">(\\mathsf{Exe},\\mathsf{Prog},\\mathsf{Mem},\\mathsf{EvenBits})</span> be the tuple of field elements encoding the program execution and the auxiliary values. We can now reformulate the correct execution of a TinyRAM program defined by <span class="math">\\mathcal{R}_{\\mathsf{TinyRAM}}</span> as a relation that imposes a number of constraints the field elements should satisfy:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathcal{R}_{\\mathsf{TinyRAM}}^{\\mathsf{field}}=\\left\\{\\begin{array}[]{c}\\left(pp,u,w\\right)=\\left(\\left(W,K,\\mathbb{F},*\\right),\\left(P,v,T,M\\right),\\mathsf{w}\\right)\\ \\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf{w}=\\left(\\mathsf{Exe},\\mathsf{Prog},\\mathsf{Mem},\\mathsf{EvenBits},*\\right)\\\\ \\left(pp,\\left(P,v,T,M\\right),\\mathsf{w}\\right)\\in\\mathcal{R}_{\\mathsf{check}}\\\\ \\left(pp,\\left(T,M\\right),\\mathsf{w}\\right)\\in\\mathcal{R}_{\\mathsf{mem}}\\\\ \\left(pp,\\bot,\\mathsf{w}\\right)\\in\\mathcal{R}_{\\mathsf{step}}\\end{array}\\right\\} \\]</p>

    <p class="text-gray-300">where the relations <span class="math">\\mathcal{R}_{\\mathsf{check}}</span>, <span class="math">\\mathcal{R}_{\\mathsf{mem}},\\mathcal{R}_{\\mathsf{step}}</span> jointly guarantee the witness <span class="math">\\mathsf{w}</span> consists of field elements encoding a correct TinyRAM execution that answers <span class="math">0</span> in <span class="math">T</span> steps using <span class="math">M</span> words of memory, public input <span class="math">v</span>, and additional private inputs.</p>

    <p class="text-gray-300">Specifically, the relation <span class="math">\\mathcal{R}_{\\mathsf{check}}</span> checks the initial values of the memory are correctly included into <span class="math">\\mathsf{Mem}</span>, the program is correctly encoded in <span class="math">\\mathsf{Prog}</span>, <span class="math">\\mathsf{EvenBits}</span> contains the correct encodings of the auxiliary lookup table, the initial state of the TinyRAM machine is correct and that it terminates with answer <span class="math">0</span> in step <span class="math">T</span>. The role of <span class="math">\\mathcal{R}_{\\mathsf{mem}}</span> is to check that memory usage is consistent throughout the execution of the program. That is, if a memory value is loaded at time <span class="math">t</span> then it should match the last stored value at the same address. Finally, <span class="math">\\mathcal{R}_{\\mathsf{step}}</span> checks that each step of the execution has been performed correctly. In the rest of the section we describe each of these sub-relations, decomposing them in terms of elemental relations such as equality, lookup, and range relations.</p>

    <p class="text-gray-300">Equality Relations. An equality relation <span class="math">\\mathcal{R}_{\\mathsf{eq}}</span> can be used to check that rows <span class="math">\\mathsf{Tab}_{i}</span> of a table <span class="math">\\mathsf{Tab}</span> encode tuples <span class="math">\\bm{v}_{1},\\ldots,\\bm{v}_{m}</span> of given <span class="math">W</span>-bit words</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathcal{R}_{\\mathsf{eq}}=\\left\\{\\begin{array}[]{c}\\left(pp,u,w\\right)=\\left(\\left(W,K,\\mathbb{F},*\\right),\\left(\\bm{v}_{1},\\ldots,\\bm{v}_{m}\\right),\\mathsf{Tab}\\right)\\ \\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf{Tab}=\\left\\{\\mathsf{Tab}_{i}\\right\\}_{i}\\wedge\\mathsf{Tab}_{i}=\\bm{v}_{i}\\cdot 1_{\\mathbb{F}}\\ \\forall\\ i\\in[m]\\end{array}\\right\\}^{\\</p>

    <p class="text-gray-300">18</p>

    <p class="text-gray-300"><strong>Lookup Relations.</strong> A lookup relation can be used to check membership of a tuple of field elements <span class="math">\\boldsymbol{w}</span> in the set of rows of a table <span class="math">\\mathsf{Tab}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\text{lookup}} = \\left\\{ \\begin{array}{c} (pp, u, w) = ((W, K, \\mathbb{F}, *), \\bot, (\\boldsymbol{w}, \\mathsf{Tab})) \\\\ \\mathsf{Tab} = \\{\\mathsf{Tab}_i\\}_i \\wedge \\exists i: \\mathsf{Tab}_i = \\boldsymbol{w} \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">We extend this relation in the natural way for checking the membership of multiple tuples <span class="math">\\boldsymbol{w}_1, \\boldsymbol{w}_2, \\ldots</span> in a table.</p>

    <p class="text-gray-300"><strong>Range Relations.</strong> We will use a range relation to check that a field element <span class="math">\\mathsf{a}</span> can be written as a <span class="math">W</span>-bit word, i.e., <span class="math">\\mathsf{a}</span> is in the range <span class="math">\\{0, \\ldots, 2^W - 1\\}</span>. One could use a lookup table of length <span class="math">2^W</span> storing all values in the range and check that <span class="math">\\mathsf{a}</span> is one of the entries in the table. However, this would give a table of size <span class="math">2^W</span> which is too large. To get around this, we use <span class="math">\\mathsf{a}_{\\mathrm{e}}</span> to store the integer corresponding to the even-position bits of the word stored in <span class="math">\\mathsf{a}</span>, and for <span class="math">\\mathsf{a}_{\\mathrm{o}}</span> to store the integer corresponding to the odd-position bits of <span class="math">\\mathsf{a}</span>. For example, assume that <span class="math">\\mathsf{a}</span> is a 4-bit value <span class="math">\\mathsf{a} = (\\mathsf{a}_3, \\mathsf{a}_2, \\mathsf{a}_1, \\mathsf{a}_0)</span> then we set its decomposition to be</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{a}_{\\mathrm{e}} = (0, \\mathsf{a}_2, 0, \\mathsf{a}_0) \\quad \\mathsf{a}_{\\mathrm{o}} = (0, \\mathsf{a}_3, 0, \\mathsf{a}_1),</span></div>

    <p class="text-gray-300">such that <span class="math">\\mathsf{a} = 2\\mathsf{a}_{\\mathrm{o}} + \\mathsf{a}_{\\mathrm{e}}</span>. Let <span class="math">\\mathsf{EvenBits}</span> be the <span class="math">2^{\\frac{W}{2}}</span> word table storing all the words where all the odd bit positions are zero. We can now check that <span class="math">\\mathsf{a}</span> is in the range <span class="math">\\{0, \\ldots, 2^W - 1\\}</span> by checking that <span class="math">\\mathsf{a} = 2\\mathsf{a}_{\\mathrm{o}} + \\mathsf{a}_{\\mathrm{e}}</span> for <span class="math">\\mathsf{a}_{\\mathrm{o}}, \\mathsf{a}_{\\mathrm{e}} \\in \\mathsf{EvenBits}</span>. This gives us the following relation for a value <span class="math">\\mathsf{a}</span> to be contained in a range <span class="math">\\{0, \\ldots, 2^W - 1\\}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\text{range}} = \\left\\{ \\begin{array}{l} (pp, u, w) = ((W, K, \\mathbb{F}, *), \\bot, (\\mathsf{a}, (\\mathsf{a}_{\\mathrm{o}}, \\mathsf{a}_{\\mathrm{e}}), \\mathsf{EvenBits})) \\\\ (pp, \\bot, ((\\mathsf{a}_{\\mathrm{o}}, \\mathsf{a}_{\\mathrm{e}}), \\mathsf{EvenBits})) \\in \\mathcal{R}_{\\text{lookup}} \\wedge \\mathsf{a} = 2\\mathsf{a}_{\\mathrm{o}} + \\mathsf{a}_{\\mathrm{e}} \\end{array} \\right\\}.</span></div>

    <p class="text-gray-300"><strong>Permutation Relations.</strong> A permutation relation can be used to check that two vectors are permutations of each other. The permutation is in the witness i.e. it is unknown to the verifier.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\text{perm}} = \\left\\{ \\begin{array}{c} (pp, u, w) = \\big((W, K, \\mathbb{F}, *), T, (\\{\\boldsymbol{a}_i, \\boldsymbol{b}_i, \\mathsf{Tab}_i\\}_{i=1}^N, \\pi)\\big) \\\\ \\pi \\text{ is a permutation over } \\{1, \\ldots, T\\} \\wedge \\pi(\\boldsymbol{a}_i) = \\boldsymbol{b}_i \\end{array} \\right\\}.</span></div>

    <h2 id="sec-21" class="text-2xl font-bold">3.2 Checking the Correctness of Values</h2>

    <p class="text-gray-300">The role of <span class="math">\\mathcal{R}_{\\mathrm{check}}</span> is to check that <span class="math">\\mathsf{w}</span> consists of the correct number of field elements that can be partitioned into the appropriate tables and also to check that specific entries in these tables are correct. In details, the relation <span class="math">\\mathcal{R}_{\\mathrm{check}}</span> is specified by the following conditions</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6 The relation can easily be extended to use decomposition into <span class="math">\\kappa</span> words of length <span class="math">\\frac{W}{\\kappa}</span>, thus reducing the size of the lookup table to $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{EvenBits}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{\\frac{W}{\\kappa}}<span class="math">. To get good efficiency the important thing is to have </span>2^{\\frac{W}{\\kappa}} \\ll T<span class="math">. In the article we assume for simplicity </span>2^{\\frac{W}{2}} \\ll T<span class="math"> enabling us to use </span>\\kappa = 2<span class="math"> but our proof system can be modified to handle any </span>T = \\mathrm{poly}(\\lambda)<span class="math"> with appropriate choice of </span>\\kappa$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The first row <span class="math">\\mathsf{Exe}_1</span> of the execution table <span class="math">\\mathsf{Exe}</span> contains the following values: time is set equal to 1, the program counter <span class="math">\\mathsf{pc}_1</span> is equal to 0, the instruction <span class="math">\\mathsf{inst}_{\\mathsf{pc}_1}</span> is equal to the first instruction of the program, the immediate value <span class="math">\\mathsf{A}_1</span> is the first immediate value of the program, and the contents of the registers <span class="math">\\mathsf{r}_{i,1}</span>, the memory address <span class="math">\\mathsf{addr}_1</span> and its content value <span class="math">\\mathsf{v}_{\\mathsf{addr}_1}</span> are all 0.</li>

      <li>The last row <span class="math">\\mathsf{Exe}_T</span> contains the following values: the time is set equal to <span class="math">T</span>, the program counter is <span class="math">\\mathsf{pc}_T = L - 1</span>, the instruction <span class="math">\\mathsf{inst}_{\\mathsf{pc}_T}</span> is answer, and the immediate value is 0.</li>

      <li>The auxiliary lookup table EvenBits contains the embeddings of all <span class="math">W</span>-bit words with 0 in all odd positions, i.e.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\text{EvenBits} = \\left(0, 1, 4, 5 \\dots , \\sum_{i = 0}^{W - 1} 2^{2i}\\right)</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The program table Prog contains the correct field element embedding of the program <span class="math">P</span> as well as the correct auxiliary entries.</li>

      <li>The memory table Mem contains the correct embedding of the input words listed in <span class="math">v</span> and of the auxiliary entry usd.</li>

    </ul>

    <p class="text-gray-300">We formalize these equality checks in the relation</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}_{\\text{check}} = \\left\\{ \\begin{array}{l} (pp, u, w) = ((W, K, \\mathbb{F}, *), (P, v, T, M), \\mathsf{w}) \\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\ \\mathsf{w} = (\\mathsf{Exe}, \\mathsf{Prog}, \\mathsf{Mem}, \\mathsf{EvenBits}, *), \\\\ \\mathsf{Exe} = \\{\\mathsf{Exe}_t\\}_{t=1}^T, \\quad \\mathsf{Prog} = \\{\\mathsf{Prog}_i\\}_{i=0}^{L-1} \\\\ \\mathsf{Prog}_0 = (0, \\mathsf{inst}_0, \\mathsf{A}_0, \\ldots) \\\\ (pp, (1, 0, \\mathsf{inst}_0, A_0, 0, \\ldots, 0, \\ldots), \\mathsf{Exe}_1) \\in \\mathcal{R}_{\\mathsf{eq}} \\\\ (pp, (T, \\mathsf{answer}, 0, \\ldots), \\mathsf{Exe}_T) \\in \\mathcal{R}_{\\mathsf{eq}} \\\\ (pp, (0, 1, 4, 5, \\ldots, \\sum_{i=0}^{W-1} 2^{2i}), \\mathsf{EvenBits}) \\in \\mathcal{R}_{\\mathsf{eq}} \\\\ (pp, P, \\mathsf{Prog}) \\in \\mathcal{R}_{\\mathsf{eq}} \\quad (pp, v, \\mathsf{Mem}) \\in \\mathcal{R}_{\\mathsf{eq}} \\end{array} \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">In the relation <span class="math">\\mathcal{R}_{\\mathrm{eq}}</span> checking table Prog we omitted the auxiliary entries which we have not yet specified. It will later become clear that these entries can be efficiently computed given the program <span class="math">P</span> and checked within the above relation.</p>

    <h2 id="sec-22" class="text-2xl font-bold">3.3 Checking Memory Consistency</h2>

    <p class="text-gray-300">The relation <span class="math">\\mathcal{R}_{\\mathrm{mem}}</span> checks that the memory is used consistently across different steps in the execution. For instance, if at step <span class="math">t</span> a value is loaded from memory, then it should be equal to the last value stored in the same address. If it is the first time a memory address is accessed, we need to ensure consistency with the initial values. If two consecutive memory accesses to the same address were placed into two adjacent rows of Exe it would be easy to check their consistency. However, this is generally not the case since the Exe table is sorted by execution time rather than memory access. Therefore, we need to devise a way to check consistency of memory accesses that could be located in any position of Exe.</p>

    <p class="text-gray-300">20</p>

    <p class="text-gray-300">To help with checking the memory consistency, we include in each row of the execution table the following auxiliary entries</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {a u x} _ {\\text {E x e}} = \\boxed {\\tau_ {\\text {l i n k}} \\boxed {\\mathrm {v} _ {\\text {l i n k}}} \\boxed {\\mathrm {v} _ {\\text {i n i t}}} \\boxed {\\mathrm {u s d}} \\boxed {\\mathrm {S}} \\boxed {\\mathrm {L}} \\dots}</span></div>

    <p class="text-gray-300">where <span class="math">\\tau_{\\mathrm{link}}</span> contains the previous time-step at which the current address was accessed, unless this is the first time a location is accessed in which case it is set equal to the last time-step this location is accessed. Similarly, <span class="math">\\mathsf{v}_{\\mathrm{link}}</span> stores the value contained in the address after time <span class="math">\\tau_{\\mathrm{link}}</span>, unless this is the first time that location is accessed, in which case it stores the last value stored in that location. The value <span class="math">\\mathsf{v}_{\\mathrm{init}}</span> is a copy of the initial value assigned to that memory location, which is also stored in the memory table Mem. The value usd is a flag which is set equal to 0 if this is the first time we access the current memory address, and 1 otherwise. The values S, L are flags set equal to 1 in case the current instruction is a store or load operation, respectively, and 0 otherwise. The values S, L are also stored in the auxiliary entries of the program table <span class="math">\\mathbf{a u x}_{\\mathrm{Prog}} = \\boxed{\\mathrm{S}}\\boxed{\\mathrm{L}}\\dots</span>.</p>

    <p class="text-gray-300">We check memory consistency by specifying cycles of memory accesses, so that consecutive terms in a cycle correspond to two consecutive accesses to the same memory location. By using the above auxiliary entries, we use the relation <span class="math">\\mathcal{R}_{\\mathrm{cycle}}</span> for the memory access pattern in the rows of Exe being in correspondence with a permutation <span class="math">\\pi</span> defined by such cycles. The relation <span class="math">\\mathcal{R}_{\\mathrm{cycle}}</span> checks that all memory accesses (with <span class="math">S + L = 1</span>) relative to the same address are connected into cycles and that rows not involving memory operations (<span class="math">S + L = 0</span>) are not included in these cycles. The relation does not include any explicit checks on whether <span class="math">S + L</span> is equal to 0 or 1. It is sufficient to check that <span class="math">S_{t} + L_{t} = S_{t^{\\prime}} + L_{t^{\\prime}}</span>, <span class="math">t = \\tau_{\\mathrm{link}t^{\\prime}}</span>, <span class="math">\\mathsf{v}_{\\mathrm{addr}_t} = \\mathsf{v}_{\\mathrm{link}t&#x27;}</span> and <span class="math">\\mathsf{addr}_t = \\mathsf{addr}_{t&#x27;}</span>, which ensures that operations which are not memory operations are not part of cycles including memory operations.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {R} _ {\\text {c y c l e}} = \\left\\{ \\begin{array}{c} (p p, u, w) = ((W, K, \\mathbb {F}, *, T, (\\mathsf {E x e}, \\pi)) \\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\ \\mathsf {E x e} _ {t} = (t, \\ldots , \\mathsf {a d d r} _ {t}, \\mathsf {v} _ {\\mathrm {l i n k} t}, \\tau_ {\\mathrm {l i n k} t}, \\ldots , S _ {t}, L _ {t}, \\ldots) \\text {f o r} t \\in [ T ] \\\\ \\boldsymbol {a} _ {1} = \\{t \\} _ {t \\in [ T ]}, \\boldsymbol {a} _ {2} = \\{\\mathsf {a d d r} _ {t} \\} _ {t \\in [ T ]}, \\boldsymbol {a} _ {3} = \\{\\mathsf {v} _ {\\mathsf {a d d r} _ {t}} \\} _ {t \\in [ T ]}, \\boldsymbol {a} _ {4} = \\{\\mathsf {S} _ {t} + \\mathsf {L} _ {t} \\} _ {t \\in [ T ]} \\\\ \\boldsymbol {b} _ {1} = \\{\\tau_ {\\mathrm {l i n k} t} \\} _ {t \\in [ T ]}, \\boldsymbol {b} _ {2} = \\{\\mathsf {a d d r} _ {t} \\} _ {t \\in [ T ]}, \\boldsymbol {b} _ {3} = \\{\\mathsf {v} _ {\\mathrm {l i n k} t} \\} _ {t \\in [ T ]}, \\boldsymbol {b} _ {4} = \\{\\mathsf {S} _ {t} + \\mathsf {L} _ {t} \\} _ {t \\in [ T ]} \\\\ ((W, K, \\mathbb {F}, *, T, (\\{\\boldsymbol {a} _ {i}, \\boldsymbol {b} _ {i} \\} _ {i = 1} ^ {4}, \\pi)) \\in \\mathcal {R} _ {\\text {p e r m}} \\end{array} \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The above relation only guarantees the existence of cycles over the same memory location, but it does not guarantee that consecutive terms in a cycle correspond to consecutive time-steps in which the memory is accessed. To check that the memory cycles are time-ordered we can simply verify that <span class="math">t &amp;gt; \\tau_{\\mathrm{link}t}</span> for any given time-step <span class="math">t \\in [T]^{\\mathrm{f}}</span>. Since memory accesses are connected into cycles, the first time we access a new memory location the <span class="math">\\tau_{\\mathrm{link}}</span> entry stores the last point in time that location is accessed by the program. In this case (<span class="math">\\mathsf{usd} = 0</span>), we verify that <span class="math">t \\leq \\tau_{\\mathrm{link}t}</span>. The relation <span class="math">\\mathcal{R}_{\\mathrm{time}}</span> incorporates these conditions</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {R} _ {\\text {t i m e}} = \\left\\{ \\begin{array}{c} (p p, u, w) = ((W, K, \\mathbb {F}, *, T, \\mathsf {E x e}) \\big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\ \\mathsf {E x e} _ {t} = (t, \\ldots , \\tau_ {\\mathrm {l i n k} t}, \\ldots , \\mathsf {u s d} _ {t}, \\ldots) \\text {f o r} t \\in [ T ] \\\\ \\forall t \\in [ T ]: (\\mathsf {u s d} = 0 \\land t \\leq \\tau_ {\\mathrm {l i n k} t}) \\lor (\\mathsf {u s d} = 1 \\land t &gt; \\tau_ {\\mathrm {l i n k} t}) \\end{array} \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">7 For this to be sufficient we also need the time-steps in the execution table to be correct but this is ensured by the <span class="math">\\mathcal{R}_{\\mathrm{check}}</span> and <span class="math">\\mathcal{R}_{\\mathrm{consistent}}</span> (appears later) relations.</p>

    <p class="text-gray-300">Next, to ensure that the cycles correspond to sequences of memory addresses we also require that all the rows touching the same memory address are included in the <em>same</em> cycle. Since the cycles are time-ordered, they require one time-step for which <span class="math">\\mathsf{usd}=0</span> in order to close a cycle. Thus, we can ensure each memory location to be part of at most on cycle by letting <span class="math">\\mathsf{usd}</span> to be set equal to <span class="math">0</span> at most once for each memory address. We introduce a <em>bounded</em> lookup relation <span class="math">\\mathcal{R}_{\\mathsf{blookup}}</span> to address this requirement. The relation checks that for any row in <span class="math">\\mathsf{Exe}</span>, the tuple <span class="math">(\\mathsf{addr}_{t},\\mathsf{v}_{\\mathsf{init}t},\\mathsf{usd})</span> is contained in one row of the table <span class="math">\\mathsf{Mem}</span> and that each row <span class="math">(j,\\mathsf{v}_{j},0)</span> of <span class="math">\\mathsf{Mem}</span> is accessed at most once by the program.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathcal{R}_{\\mathsf{blookup}}=\\left\\{\\begin{array}[]{c}(pp,u,w)=((W,K,\\mathbb{F},*),(T,M),(\\mathsf{Exe},\\mathsf{Mem}))\\ \\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf{Exe}_{t}=(t,\\ldots,\\mathsf{addr}_{t},\\ldots,\\mathsf{v}_{\\mathsf{init}t},\\mathsf{usd}_{t},\\ldots)\\ \\text{for}\\ t\\in[T]\\\\ \\forall\\ t\\in[T]\\ (pp,\\bot,((\\mathsf{addr}_{t},\\mathsf{v}_{\\mathsf{init}t},\\mathsf{usd}_{t})\\,,\\mathsf{Mem}))\\in\\mathcal{R}_{\\mathsf{lookup}}\\wedge\\\\ \\forall\\ (j,\\mathsf{v}_{j},0)\\in\\mathsf{Mem}:(\\ldots,j,\\ldots,\\mathsf{v}_{j},0,\\ldots)\\ \\text{occurs at most once in}\\ \\mathsf{Exe}\\end{array}\\right\\} \\]</p>

    <p class="text-gray-300">Finally, we are only left to check that if the program executes a load instruction the value <span class="math">\\mathsf{v}_{\\mathsf{addr}_{t}}</span> loaded from memory is consistent with the value stored at the same address at the previous access. Similarly, if load is executed on a new memory location, then the value loaded should match with the initial value <span class="math">\\mathsf{v}_{\\mathsf{init}t}</span>. No additional checks are required for store instructions. These checks are incorporated in the relation <span class="math">\\mathcal{R}_{\\mathsf{load}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathcal{R}_{\\mathsf{load}}=\\left\\{\\begin{array}[]{c}(pp,u,w)=((W,K,\\mathbb{F},*),T,\\mathsf{Exe})\\ \\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf{Exe}_{t}=(t,\\ldots,\\mathsf{addr}_{t},\\mathsf{v}_{\\mathsf{addr}_{t}},\\tau_{\\mathsf{link}t},\\mathsf{v}_{\\mathsf{link}t},\\mathsf{v}_{\\mathsf{init}t},\\mathsf{usd}_{t},\\ldots)\\ \\text{for}\\ t\\in[T]\\\\ \\forall\\ t\\in[T]:\\mathsf{L}_{t}(\\mathsf{v}_{\\mathsf{addr}_{t}}-\\mathsf{v}_{\\mathsf{init}t}+\\mathsf{usd}_{t}(\\mathsf{v}_{\\mathsf{init}t}-\\mathsf{v}_{\\mathsf{link}t}))=0\\end{array}\\right\\} \\]</p>

    <p class="text-gray-300">Overall the memory consistency relation <span class="math">\\mathcal{R}_{\\mathsf{mem}}</span> decomposes as follows</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathcal{R}_{\\mathsf{mem}}=\\left\\{\\begin{array}[]{c}(pp,u,w)=((W,K,\\mathbb{F},*),(T,M),\\mathsf{w})\\ \\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathsf{w}=(\\mathsf{Exe},\\mathsf{Prog},\\mathsf{Mem},\\mathsf{EvenBits},\\pi,*),\\\\ \\mathsf{Exe}=\\{\\mathsf{Exe}_{t}\\}_{t=1}^{T}\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\mathsf{Mem}=\\{\\mathsf{Mem}_{j}\\}_{j=0}^{2M-2}\\\\ (pp,T,(\\mathsf{Exe},\\pi))\\in\\mathcal{R}_{\\mathsf{cycle}},\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad(pp,T,\\mathsf{Exe})\\in\\mathcal{R}_{\\mathsf{time}}\\\\ (pp,(T,M),(\\mathsf{Exe},\\mathsf{Mem}))\\in\\mathcal{R}_{\\mathsf{blookup}},\\qquad(pp,T,\\mathsf{Exe})\\in\\mathcal{R}_{\\mathsf{load}}\\end{array}\\right\\} \\]</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">3.4 Checking Correct Execution of Instructions</h3>

    <p class="text-gray-300">We use the relation <span class="math">\\mathcal{R}_{\\mathsf{step}}</span> to guarantee that each step of the execution has been performed correctly. This involves checking for each row <span class="math">\\mathsf{Exe}_{t}</span> of the execution table that the stored words are in the range <span class="math">\\{0,\\ldots,2^{W}-1\\}</span>, the <span class="math">\\mathsf{flag}_{t}</span> is a bit, the program counter <span class="math">\\mathsf{pc}_{t}</span> matches the instruction and the immediate value <span class="math">\\mathsf{A}_{t}</span> in the program, and that <span class="math">\\mathsf{inst}_{t}</span> is correctly executed. An instruction takes some inputs, e.g., values indicated by the operands <span class="math">\\mathsf{reg}_{j},A</span> or the flag and as a result may change the program counter, a register value, a value stored at a memory address, or the flag. Since we have already checked memory correctness, if the operation is a load or store we may assume the memory value is correct.</p>

    <p class="text-gray-300">To help checking the consistency of the operations the rows of the execution and program tables include the following auxiliary entries</p>

    <p class="text-gray-300"><span class="math">\\bm{aux}_{\\text{Exe}}</span> <span class="math">=\\boxed{\\ldots\\boxed{a}\\boxed{b}\\boxed{c}\\boxed{d}\\boxed{out}\\boxed{s_{a}}\\boxed{s_{b}}\\boxed{s_{c}}\\boxed{s_{d}}\\boxed{s_{\\text{out}}}\\boxed{s_{\\text{ch}}}\\boxed{\\ldots}}</span> <span class="math">\\bm{aux}_{\\text{Prog}}</span> <span class="math">=\\boxed{\\ldots\\boxed{s_{a}}\\boxed{s_{b}}\\boxed{s_{c}}\\boxed{s_{d}}\\boxed{s_{\\text{out}}}\\boxed{s_{\\text{ch}}}}</span></p>

    <p class="text-gray-300">These consist of some <em>temporary variables</em> <span class="math">\\mathsf{a},\\mathsf{b},\\mathsf{c},\\mathsf{d}</span>, an output vector <span class="math">\\bm{out}</span>, and some <em>selection vectors</em> <span class="math">\\bm{s_{a}},\\ldots,\\bm{s_{\\text{ch}}}</span> which are also listed in the program table.</p>

    <p class="text-gray-300">The temporary variables are used to store a copy of the inputs and outputs of an instruction. For example, if we have to check an addition operation <span class="math">\\mathbf{add}\\ \\text{reg}_{i}\\ \\text{reg}_{j}\\ A</span>, we let <span class="math">\\mathsf{c}=\\mathsf{r}_{i,t+1},\\mathsf{a}=\\mathsf{r}_{j,t},\\mathsf{b}=\\mathsf{A}_{t}</span> and check <span class="math">\\mathsf{c}=\\mathsf{a}+\\mathsf{b}</span>. The advantage of the temporary variables is that for each addition operation we check, we will always have the inputs and output in <span class="math">\\mathsf{a},\\mathsf{b}</span> and <span class="math">\\mathsf{c}</span>, instead of having to handle multiple registers holding inputs and output in arbitrary order.</p>

    <p class="text-gray-300">Checking operations on temporary values <span class="math">\\mathsf{a},\\mathsf{b},\\mathsf{c}</span> and <span class="math">\\mathsf{d}</span> require us to multiplex the corresponding register, immediate, and memory values in and out of the temporary values. We do this using selection vectors <span class="math">\\bm{s_{a}},\\bm{s_{b}},\\bm{s_{c}},\\bm{s_{d}}</span> that are bit-vectors encoding the operands of an instruction. Each row of the execution table includes multiple variables that may be selected as an operand, e.g., <span class="math">\\mathsf{pc}_{t},\\mathsf{A}_{t},\\mathsf{r}_{0,t},\\ldots</span> and variables in the next row of the execution table <span class="math">\\mathsf{pc}_{t+1},\\mathsf{A}_{t+1},\\mathsf{r}_{0,t+1},\\ldots</span> may also be selected. A selection vector will have a bit for each of these variables indicating whether it is picked or not, so if we for instance let <span class="math">\\bm{s_{a}}=(0,0,1,0,\\ldots,0)</span> this corresponds to pick <span class="math">\\mathsf{a}</span> as <span class="math">\\mathsf{r}_{0,t}</span>.</p>

    <p class="text-gray-300">Multiplexing the operands into temporary variables leaves us with the task of checking correct instruction execution on <span class="math">\\mathsf{a},\\mathsf{b},\\mathsf{c}</span> and <span class="math">\\mathsf{d}</span>. TinyRAM has 26 instructions and since we want the proof system to be zero-knowledge, we cannot reveal which operation we execute in a given step. However, we can still obtain significant savings compared to using 26 independent instruction checkers. We make the key observation that many operations are closely related. For instance checking a subtraction operation <span class="math">\\mathbf{sub}\\ \\text{reg}_{i}\\ \\text{reg}_{j}\\ A</span> corresponds to checking <span class="math">\\mathsf{c}=\\mathsf{a}+\\mathsf{b}</span> with <span class="math">\\mathsf{c}=\\mathsf{r}_{j,t},\\mathsf{a}=\\mathsf{r}_{i,t+1},\\mathsf{b}=\\mathsf{A}_{t}</span>, which is of the same form as an addition operation. Using clever multiplexing we reduce the checking of the 26 possible instructions to 9 easily computable values <span class="math">\\mathsf{AND},\\mathsf{XOR},\\mathsf{OR},\\mathsf{SUM},\\mathsf{SSUM},\\mathsf{PROD},\\mathsf{SPROD},\\mathsf{MOD},\\mathsf{SHIFT}</span> and 4 additional values <span class="math">\\mathsf{FLAG}_{1},\\mathsf{FLAG}_{2},\\mathsf{FLAG}_{3},\\mathsf{FLAG}_{4}</span> to check consistency of the flag. We include all these values into the vector <span class="math">\\bm{out}</span>. Each instruction can be verified by checking that an appropriate subset of the values are 0. To check an addition operation, we will for instance check that <span class="math">\\mathsf{SUM}=0</span>. Similarly to the selection of the operands, we use a binary selection vector <span class="math">\\bm{s_{\\text{out}}}</span> to select which entries of <span class="math">\\bm{out}</span> are relevant for each operation and check that <span class="math">\\bm{s_{\\text{out}}}\\circ\\bm{out}=\\bm{0}</span>, where <span class="math">\\circ</span> is the entry-wise product.</p>

    <p class="text-gray-300">Verifying that rows of the execution table match with states of a TinyRAM machine also involves checking that entries that are not affected by an instruction remain the same in the next state. For this we use another selector vector <span class="math">\\bm{s_{\\text{ch}}}</span> with entries equal to 0, positioned in correspondence of entries that are changed during the execution, and 1 for entries that do not change in the execution.</p>

    <p class="text-gray-300">The relation <span class="math">\\mathcal{R}_{\\mathrm{step}}</span> decomposes into the following sub-relations over each pair of consecutive rows <span class="math">\\mathsf{Exe}_t, \\mathsf{Exe}_{t+1}</span> in the execution table.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A multiplexing relation <span class="math">\\mathcal{R}_{\\mathrm{mux}}</span> checking that values <span class="math">\\mathsf{a}_t, \\mathsf{b}_t, \\mathsf{c}_t, \\mathsf{d}_t</span> are consistent with operands contained in <span class="math">\\mathsf{inst}_t</span>.</li>

      <li>A consistency relation <span class="math">\\mathcal{R}_{\\mathrm{consistent}}</span> checking that the time counter is correctly increased, the program counter is in the correct range, the instruction <span class="math">\\mathsf{inst}_t</span> and the immediate value <span class="math">\\mathsf{A}_t</span> are consistent with the ones specified in line <span class="math">\\mathsf{pc}_t</span> of the program, the correctness of the selector vectors, the entries in <span class="math">\\mathbf{out}_t</span> relevant to <span class="math">\\mathsf{inst}_t</span> are all equal to zero and all registers are equal in the two rows unless specified by the instruction.</li>

      <li>An instruction checker relation <span class="math">\\mathcal{R}_{\\mathrm{ins}}</span> checking that entries <span class="math">\\mathsf{a}_t, \\mathsf{b}_t, \\mathsf{c}_t, \\mathsf{d}_t</span> are in the range <span class="math">\\{0, \\dots, 2^W - 1\\}</span>, the vector <span class="math">\\mathbf{out}_t</span> is consistent with <span class="math">\\mathsf{a}_t, \\mathsf{b}_t, \\mathsf{c}_t, \\mathsf{d}_t</span>.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {s t e p}} = \\left\\{ \\begin{array}{c} (p p, u, w) = ((W, K, \\mathbb {F}, *, \\bot , \\mathsf {w}) \\mid \\\\ \\mathsf {w} = (\\mathsf {E x e}, \\mathsf {P r o g}, \\mathsf {M e m}, \\mathsf {E v e n B i t s}, *) \\wedge \\mathsf {E x e} = \\{\\mathsf {E x e} _ {t} \\} _ {t = 1} ^ {T} \\\\ \\forall t \\in \\{1, \\ldots , T - 1 \\}: \\\\ (p p, \\bot , (\\mathsf {E x e} _ {t}, \\mathsf {E x e} _ {t + 1})) \\in \\mathcal {R} _ {\\mathrm {m u x}} \\\\ (p p, \\bot , (\\mathsf {E x e} _ {i}, \\mathsf {E x e} _ {i + 1}, \\mathsf {P r o g})) \\in \\mathcal {R} _ {\\mathrm {c o n s i s t e n t}} \\\\ (p p, \\bot , (\\mathsf {E x e} _ {i}, \\mathsf {E x e} _ {i + 1}, \\mathsf {E v e n B i t s}, *) \\in \\mathcal {R} _ {\\mathrm {i n s}} \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">Multiplexing Relation. The multiplexing relation <span class="math">\\mathcal{R}_{\\mathrm{mux}}</span> checks that <span class="math">\\mathsf{a}, \\mathsf{b}, \\mathsf{c}, \\mathsf{d}</span> match with the entries in the rows selected by the vectors <span class="math">\\mathbf{s}_{\\mathrm{a}}, \\mathbf{s}_{\\mathrm{b}}, \\mathbf{s}_{\\mathrm{c}}, \\mathbf{s}_{\\mathrm{d}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\widetilde{\\mathsf{Exe}}_t = (\\mathsf{pc}_t, \\mathsf{A}_t, \\mathsf{r}_{0,t}, \\ldots, \\mathsf{r}_{K-1,t}, \\mathsf{flag}_t, \\mathsf{addr}_t, \\mathsf{v}_{\\mathsf{addr}_t})</span> be the tuples of selectable entries of row <span class="math">\\mathsf{Exe}_t</span> and let <span class="math">\\mathbf{s}_{\\mathrm{at}}, \\mathbf{s}_{\\mathrm{bt}}, \\mathbf{s}_{\\mathrm{ct}}, \\mathbf{s}_{\\mathrm{dt}}</span> be binary vectors of length $2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\widetilde{\\mathsf{Exe}}_t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. We can then express the multiplexing relation </span>\\mathcal{R}_{\\mathrm{mux}}$ in terms of inner product relations as follows</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {R} _ {\\mathrm {m u x}} = \\left\\{ \\begin{array}{c} (p p, u, w) = ((W, K, \\mathbb {F}, *, \\bot , (\\mathsf {E x e} _ {t}, \\mathsf {E x e} _ {t + 1})) \\mid \\\\ \\mathsf {E x e} _ {t} = (t, \\ldots , \\mathsf {a} _ {t}, \\mathsf {b} _ {t}, \\mathsf {c} _ {t}, \\mathsf {d} _ {t}, \\mathbf {o u t} _ {t}, \\mathbf {s} _ {\\mathsf {a} t}, \\mathbf {s} _ {\\mathsf {b} t}, \\mathbf {s} _ {\\mathsf {c} t}, \\mathbf {s} _ {\\mathsf {d} t}, \\ldots) \\\\ \\mathsf {a} _ {t} = \\mathbf {s} _ {\\mathsf {a} t} \\cdot (\\widetilde {\\mathsf {E x e}} _ {t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\widetilde {\\mathsf {E x e}} _ {t + 1}) \\quad \\mathsf {b} _ {t} = \\mathbf {s} _ {\\mathsf {b} t} \\cdot (\\widetilde {\\mathsf {E x e}} _ {t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\widetilde {\\mathsf {E x e}} _ {t + 1}) \\\\ \\mathsf {c} _ {t} = \\mathbf {s} _ {\\mathsf {c} t} \\cdot (\\widetilde {\\mathsf {E x e}} _ {t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\widetilde {\\mathsf {E x e}} _ {t + 1}) \\quad \\mathsf {d} _ {t} = \\mathbf {s} _ {\\mathsf {d} t} \\cdot (\\widetilde {\\mathsf {E x e}} _ {t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\widetilde {\\mathsf {E x e}} _ {t + 1}) \\end{array} \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Consistency Relation. The consistency relation <span class="math">\\mathcal{R}_{\\mathrm{consistent}}</span> is checked that the time is correctly incremented and that the program counter is in the correct range, i.e. <span class="math">\\mathsf{pc}_{t + 1}\\in \\{0,\\ldots ,L - 1\\}</span> and is incremented unless a jump-instruction is executed. It also checks that the instruction, the immediate value and the selection vectors stored in the execution table are consistent with the program the line indexed pc. Furthermore, it checks that the entries in out relevant to inst are all equal to zero and that the contents of the registers do not change, unless specified by the instruction, e.g. the register storing the result of the computation.</p>

    <p class="text-gray-300">Let <span class="math">\\mathbf{s}_{\\mathrm{ch}}</span> be a binary vector of length <span class="math">K + 2</span>, let <span class="math">\\widetilde{\\mathsf{Exe}}_t = (\\mathsf{pc}_t, \\mathsf{r}_{0,t}, \\ldots, \\mathsf{r}_{K-1,t}, \\mathsf{flag}_t)</span> be the restriction of the row <span class="math">\\mathsf{Exe}_t</span> to the entries concerning the program counter, the register values and the flag and let <span class="math">\\mathbf{s}_{\\mathrm{out}}</span> be a binary vector of length</p>

    <p class="text-gray-300">24</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb{s}_{\\mathrm{out}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 13<span class="math">. The consistency relation </span>\\mathcal{R}_{\\mathrm{consistent}}$ is defined as follows</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\text{consistent}} = \\left\\{ \\begin{array}{l} (pp, u, w) = ((W, K, \\mathbb{F}, *), \\bot, (\\text{Exe}_t, \\text{Exe}_{t+1}, \\text{Prog})) \\mid \\\\ \\text{Exe}_t = (t, \\mathsf{pc}_t, \\text{inst}_t, \\mathsf{A}_t, \\ldots, r_{0,t}, \\ldots, r_{K-1,t}, \\ldots, \\mathsf{S}_t, \\mathsf{L}_t, \\ldots, \\text{out}, \\mathbf{s}_a, \\mathbf{s}_b, \\mathbf{s}_c, \\mathbf{s}_d, \\mathbf{s}_{\\text{out}}, \\mathbf{s}_{\\text{ch}}) \\wedge \\\\ \\text{Exe}_{t+1} = (t&#x27;, \\mathsf{pc}_{t+1}, \\ldots, r_{0,t+1}, \\ldots, r_{K-1,t+1}, \\ldots) \\\\ t&#x27; = t + 1 \\wedge \\mathsf{pc}_{t+1} \\in \\{0, \\ldots, L-1\\} \\wedge \\\\ \\mathbf{s}_{\\text{ch}} \\circ (\\text{Exe}_{t+1} - \\text{Exe}_t - (1, 0, \\ldots, 0)) = (0, 0, \\ldots, 0) \\wedge \\mathbf{s}_{\\text{out}} \\circ \\text{out} = \\mathbf{0} \\wedge \\\\ (pp, \\bot, ((\\mathsf{pc}_t, \\text{inst}_t, \\mathsf{A}_t, \\mathsf{S}_t, \\mathsf{L}_t, \\mathbf{s}_a, \\mathbf{s}_b, \\mathbf{s}_c, \\mathbf{s}_d, \\mathbf{s}_{\\text{out}}, \\mathbf{s}_{\\text{ch}}), \\text{Prog})) \\in \\mathcal{R}_{\\text{lookup}} \\end{array} \\right\\}</span></div>

    <p class="text-gray-300"><strong>Instruction Relation.</strong> The role of the instruction checker relation <span class="math">\\mathcal{R}_{\\mathrm{ins}}</span> is to guarantee the correct execution of an instruction has taken place. We show that this can be reduced to check that <span class="math">\\mathsf{a}, \\mathsf{b}, \\mathsf{c}, \\mathsf{d} \\in \\{0, \\ldots, 2^W - 1\\}</span> and that the output vector <span class="math">\\mathbf{out}</span> is consistent with the temporary variables. We divide the entries of <span class="math">\\mathbf{out}</span> into 4 groups: logical (AND, XOR, OR), arithmetic (SUM, PROD, SSUM, SPROD, MOD), shift (SHIFT), and flag (FLAG_1, FLAG_2, FLAG_3, FLAG_4). By specifying constraints to all these entries, we can directly verify all the logical, arithmetic, and shifts operations after which the variables are named. In Section 3.5 we show choices of selection vectors which reduce the verification of any other operation to the ones contained in these 3 categories.</p>

    <p class="text-gray-300">The <span class="math">\\mathcal{R}_{\\mathrm{ins}}</span> can be thus decomposed into 3 sub-relations.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\mathrm{ins}} = \\left\\{ \\begin{array}{l} (pp, u, w) = ((W, K, \\mathbb{F}, *), \\bot, (\\text{Exe}_t, \\text{Exe}_{t+1}, \\text{EvenBits}, *)) \\mid \\\\ \\qquad \\qquad (pp, \\bot, (\\text{Exe}_t, \\text{Exe}_{t+1}, \\text{EvenBits})) \\in \\mathcal{R}_{\\mathrm{logic}} \\\\ \\qquad \\qquad (pp, \\bot, (\\text{Exe}_t, \\text{Exe}_{t+1}, \\text{EvenBits})) \\in \\mathcal{R}_{\\mathrm{arith}} \\\\ \\qquad \\qquad (pp, \\bot, (\\text{Exe}_t, \\text{Exe}_{t+1}, \\text{EvenBits}, *)) \\in \\mathcal{R}_{\\mathrm{shift}} \\end{array} \\right\\}</span></div>

    <h2 id="sec-24" class="text-2xl font-bold">3.5 A Breakdown of the Instruction Relation</h2>

    <p class="text-gray-300">We describe the instruction checker relation <span class="math">\\mathcal{R}_{\\mathrm{ins}}</span> that verifies correct execution of an instruction in a given time-step. We recall that for each operation we multiplex inputs and outputs into temporary variables <span class="math">\\mathsf{a}, \\mathsf{b}, \\mathsf{c}, \\mathsf{d}</span> and use selection vectors <span class="math">\\mathbf{s}_{\\mathsf{a}}, \\mathbf{s}_{\\mathsf{b}}, \\mathbf{s}_{\\mathsf{c}}, \\mathbf{s}_{\\mathsf{d}}</span> to ensure that this is done consistently with the operands specified by the instruction. Since our aim is to construct zero-knowledge arguments, the relation <span class="math">\\mathcal{R}_{\\mathrm{ins}}</span> will incorporate checks concerning all possible TinyRAM instructions to hide which one was executed. We will show this can be reduced to 13 values stored in the output vector</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{out} = (\\text{AND}, \\text{XOR}, \\text{OR}, \\text{SUM}, \\text{SSUM}, \\text{PROD}, \\text{SPROD}, \\text{MOD}, \\text{SHIFT}, \\text{FLAG}_1, \\text{FLAG}_2, \\text{FLAG}_3, \\text{FLAG}_4)</span></div>

    <p class="text-gray-300">Each instruction can be verified by checking that an entry of either the of <span class="math">\\mathbf{out}</span> are 0, using a selection vector <span class="math">\\mathbf{s}_{\\mathrm{out}}</span>. Similarly, we use vector <span class="math">\\mathbf{s}_{\\mathrm{ch}}</span> to check that the program counter, registers and flag do not change unless the instruction specifies so. Here we assume the selection vectors stored in each row of the execution table to be consistent with the instruction and immediate value stored in the same row of <span class="math">\\mathbf{Exe}</span>, as already ensured by the relation <span class="math">\\mathcal{R}_{\\mathrm{consistent}}</span>.</p>

    <p class="text-gray-300">We decompose the relation <span class="math">\\mathcal{R}_{\\mathrm{ins}}</span> into 3 sub-relations.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\mathrm{ins}} = \\left\\{ \\begin{array}{l} (pp, u, w) = ((W, K, \\mathbb{F}, *), \\bot, (\\text{Exe}_t, \\text{Exe}_{t+1}, \\text{EvenBits}, *)) \\mid \\\\ \\qquad \\qquad (pp, \\bot, (\\text{Exe}_t, \\text{Exe}_{t+1}, \\text{EvenBits})) \\in \\mathcal{R}_{\\mathrm{logic}} \\\\ \\qquad \\qquad (pp, \\bot, (\\text{Exe}_t, \\text{Exe}_{t+1}, \\text{EvenBits})) \\in \\mathcal{R}_{\\mathrm{arith}} \\\\ \\qquad \\qquad (pp, \\bot, (\\text{Exe}_t, \\text{Exe}_{t+1}, \\text{EvenBits}, *)) \\in \\mathcal{R}_{\\mathrm{shift}} \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">In this section we describe all the sub-relations and reduce the verification of any operation to these by showing appropriate choices of selection vectors.</p>

    <p class="text-gray-300">We recall that a line in the program consists of an instruction and up to three operands, e.g. <span class="math">\\mathbf{add}\\ \\mathsf{reg}_{i}\\ \\mathsf{reg}_{j}\\ A</span>. The first operand, <span class="math">\\mathsf{reg}_{i}</span>, usually points to the register storing the result of the operation, <span class="math">\\mathbf{add}</span>, computed on the words specified by the next two operands, <span class="math">\\mathsf{reg}_{j},A</span>. The last operand <span class="math">A</span> indicates an immediate value that could be either used directly in the operation or to point to the content of another register. We refer to the value to be used in the operation generically as <span class="math">\\mathsf{A}</span>, stressing that the selection between either the immediate value or a register value can be handled by using the appropriate selection vector.</p>

    <p class="text-gray-300">In what follows we specify what constraints the entries of <span class="math">\\boldsymbol{out}</span> need to satisfy and the appropriate choice of selection vectors for each operation. More precisely, which entries <span class="math">\\boldsymbol{s_{a}},\\boldsymbol{s_{b}},\\boldsymbol{s_{c}},\\boldsymbol{s_{d}},\\boldsymbol{s_{\\text{out}}}</span> are set equal to 1 (with the rest set to 0) and which entries of <span class="math">\\boldsymbol{s_{\\text{ch}}}</span> are set equal to 0 (with the rest set to 1).</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">3.2.2 Logical Operations</h4>

    <p class="text-gray-300">Logical operations can be verified using the odd and even-position bits decomposition introduced in Section 3.1. Let <span class="math">\\mathsf{a},\\mathsf{b}</span> be the inputs of a logical operation, e.g. bit-wise AND, and let <span class="math">\\mathsf{c}</span> be the output. To verify the correctness of the operation, e.g. <span class="math">\\mathsf{a}\\wedge\\mathsf{b}=\\mathsf{c}</span>, consider the decompositions of the inputs into their odd and even-position bits, namely <span class="math">\\mathsf{a}=2\\mathsf{a}_{\\mathrm{o}}+\\mathsf{a}_{\\mathrm{e}}</span> and <span class="math">\\mathsf{b}=2\\mathsf{b}_{\\mathrm{o}}+\\mathsf{b}_{\\mathrm{e}}</span>.</p>

    <p class="text-gray-300">Observe that taking the sum of the integers storing the even-positions of <span class="math">\\mathsf{a}</span> and <span class="math">\\mathsf{b}</span> gives</p>

    <p class="text-gray-300"><span class="math">\\mathsf{a}_{\\mathrm{e}}+\\mathsf{b}_{\\mathrm{e}}</span> <span class="math">=(0,\\mathsf{a}_{W-2},\\ldots,0,\\mathsf{a}_{0})+(0,\\mathsf{b}_{W-2},\\ldots,0,\\mathsf{b}_{0})</span> <span class="math">=(\\mathsf{a}_{W-2}\\wedge\\mathsf{b}_{W-2},\\mathsf{a}_{W-2}\\oplus\\mathsf{b}_{W-2},\\ldots,\\mathsf{a}_{0}\\wedge\\mathsf{b}_{0},\\mathsf{a}_{0}\\oplus\\mathsf{b}_{0})</span></p>

    <p class="text-gray-300">The above contains the bit-wise AND and XOR of the even bits of <span class="math">\\mathsf{a}</span> and <span class="math">\\mathsf{b}</span> placed in even in odd positions, respectively. Therefore we can consider taking again the decomposition of <span class="math">\\mathsf{a}_{\\mathrm{e}}+\\mathsf{b}_{\\mathrm{e}}</span> into its odd and even-position bits, i.e. <span class="math">\\mathsf{a}_{\\mathrm{e}}+\\mathsf{b}_{\\mathrm{e}}=2\\mathrm{e}_{\\mathrm{o}}+\\mathrm{e}_{\\mathrm{e}}</span> so that half of the bits of <span class="math">\\mathsf{a}\\wedge\\mathsf{b}</span> are stored in <span class="math">\\mathrm{e}_{\\mathrm{o}}</span> and half of the bits of <span class="math">\\mathsf{a}\\oplus\\mathsf{b}</span> are stored in <span class="math">\\mathrm{e}_{\\mathrm{e}}</span>. We can repeat the above procedure starting from the odd-position bits of <span class="math">\\mathsf{a}</span> and <span class="math">\\mathsf{b}</span> getting the following</p>

    <p class="text-gray-300"><span class="math">\\mathsf{a}_{\\mathrm{o}}+\\mathsf{b}_{\\mathrm{o}}</span> <span class="math">=(0,\\mathsf{a}_{W-1},\\ldots,0,\\mathsf{a}_{1})+(0,\\mathsf{b}_{W-1},\\ldots,0,\\mathsf{b}_{1})</span> <span class="math">=(\\mathsf{a}_{W-1}\\wedge\\mathsf{b}_{W-1},\\mathsf{a}_{W-1}\\oplus\\mathsf{b}_{W-1},\\ldots,\\mathsf{a}_{1}\\wedge\\mathsf{b}_{1},\\mathsf{a}_{1}\\oplus\\mathsf{b}_{1})</span> <span class="math">=2\\mathrm{o}_{\\mathrm{o}}+\\mathrm{o}_{\\mathrm{e}}</span></p>

    <p class="text-gray-300">where <span class="math">\\mathrm{o}_{\\mathrm{o}}</span> stores half of the bits of <span class="math">\\mathsf{a}\\wedge\\mathsf{b}</span> and <span class="math">\\mathrm{o}_{\\mathrm{e}}</span> stores and half of the bits of <span class="math">\\mathsf{a}\\oplus\\mathsf{b}</span>.</p>

    <p class="text-gray-300">Putting everything together, given the decompositions <span class="math">\\mathsf{a}_{\\mathrm{o}},\\mathsf{a}_{\\mathrm{e}},\\mathsf{b}_{\\mathrm{o}},\\mathsf{b}_{\\mathrm{e}},\\mathrm{o}_{\\mathrm{o}},\\mathrm{o}_{\\mathrm{e}},\\mathrm{e}_{\\mathrm{o}},\\mathrm{e}_{\\mathrm{e}}\\in\\mathsf{EvenBits}</span>, if the following hold</p>

    <p class="text-gray-300"><span class="math">\\mathsf{a}</span> <span class="math">=2\\mathsf{a}_{\\mathrm{o}}+\\mathsf{a}_{\\mathrm{e}}\\qquad\\mathsf{b}=2\\mathsf{b}_{\\mathrm{o}}+\\mathsf{b}_{\\mathrm{e}}</span> <span class="math">\\mathsf{a}_{\\mathrm{o}}+\\mathsf{b}_{\\mathrm{o}}</span> <span class="math">=2\\mathrm{o}_{\\mathrm{o}}+\\mathrm{o}_{\\mathrm{e}}\\qquad\\mathsf{a}_{\\mathrm{e}}+\\mathsf{b}_{\\mathrm{e}}=2\\mathrm{e}_{\\mathrm{o}}+\\mathrm{e}_{\\mathrm{e}}</span></p>

    <p class="text-gray-300">then we also have</p>

    <p class="text-gray-300"><span class="math">\\mathsf{a}\\wedge\\mathsf{b}=2\\mathrm{o}_{\\mathrm{o}}+\\mathrm{e}_{\\mathrm{o}}\\qquad\\mathsf{a}\\oplus\\mathsf{b}=2\\mathrm{o}_{\\mathrm{e}}+\\mathrm{e}_{\\mathrm{e}}</span></p>

    <p class="text-gray-300">Let  <span class="math">\\mathsf{AND} = 2\\mathrm{o}_{\\mathrm{o}} + \\mathrm{e}_{\\mathrm{o}} - \\mathsf{c}</span>  and  <span class="math">\\mathsf{XOR} = 2\\mathrm{o}_{\\mathrm{e}} + \\mathrm{e}_{\\mathrm{e}} - \\mathsf{c}</span> . We can verify the execution of the and  <span class="math">\\mathsf{reg}_i</span> <span class="math">\\mathsf{reg}_j</span> <span class="math">A</span>  setting selection vectors so that  <span class="math">\\mathsf{a} = \\mathsf{A}_t, \\mathsf{b} = \\mathsf{r}_{j,t}, \\mathsf{c} = \\mathsf{r}_{i,t+1}</span>  and checking that  <span class="math">\\mathsf{AND} = 0</span> . Note that the latter is 0 if and only if  <span class="math">\\mathsf{c}</span>  contains the bit-wise AND of  <span class="math">\\mathsf{a}</span>  and  <span class="math">\\mathsf{b}</span> . Similarly, the execution of  <span class="math">\\mathbf{xor}</span> <span class="math">\\mathsf{reg}_i</span> <span class="math">\\mathsf{reg}_j</span> <span class="math">A</span>  can be verified by using the selector vectors as above and checking that  <span class="math">\\mathsf{XOR} = 0</span> .</p>

    <p class="text-gray-300">Given  <span class="math">\\mathsf{a} \\wedge \\mathsf{b}</span>  and  <span class="math">\\mathsf{a} \\oplus \\mathsf{b}</span>  we can compute the bit-wise OR of  <span class="math">\\mathsf{a}</span>  and  <span class="math">\\mathsf{b}</span>  in the following way</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {a} \\vee \\mathsf {b} = (\\mathsf {a} \\wedge \\mathsf {b}) + (\\mathsf {a} \\oplus \\mathsf {b})</span></div>

    <p class="text-gray-300">Let  <span class="math">\\mathsf{OR} = \\mathsf{XOR} + \\mathsf{AND} + \\mathsf{c}</span> . To verify the execution of or  <span class="math">\\mathsf{reg}_i\\mathsf{reg}_jA</span>  it is sufficient to set the selection vectors such that  <span class="math">\\mathsf{a} = \\mathsf{A}_t,\\mathsf{b} = \\mathsf{r}_{j,t},\\mathsf{c} = \\mathsf{r}_{i,t + 1}</span>  and check that  <span class="math">\\mathsf{OR} = 0</span> , which happens if and only if  <span class="math">\\mathsf{c} = \\mathsf{a}\\lor \\mathsf{b}</span> .</p>

    <p class="text-gray-300">Bit-wise NOT can be handled by computing bit-wise XOR of A with the word  <span class="math">2^{W} - 1</span> . We can use an additional auxiliary entry in the execution table storing the word  <span class="math">2^{W} - 1</span>  and use the selector vector to route b to it. Similarly to the other logical operations, bit-wise NOT the same chek related to the flag, namely  <span class="math">\\mathsf{FLAG}_1 = 0</span> ,  <span class="math">\\mathsf{FLAG}_2 = 0</span> .</p>

    <p class="text-gray-300">The execution of the above logical operations can also affect the flag. Specifically, the flag is set equal to 1 exactly when the output is equal to 0. This can be verified by letting</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {F L A G} _ {1} = \\mathsf {f l a g} _ {t + 1} \\cdot \\mathsf {c} \\quad \\mathsf {F L A G} _ {2} = (\\mathsf {f l a g} _ {t + 1} + \\mathsf {c}) \\cdot \\mathsf {a} _ {\\mathsf {f l a g}} - 1</span></div>

    <p class="text-gray-300">and checking both of them to be equal to 0. The first condition guarantees that at least one among  <span class="math">\\mathsf{c}</span>  and  <span class="math">\\mathsf{flag}_{t + 1}</span>  is zero, while the second guarantees that not both of them are equal to zero. In fact,  <span class="math">\\mathsf{FLAG}_2</span>  can be made equal to 0 by choosing  <span class="math">\\mathsf{a}_{\\mathsf{flag}}</span>  as the inverse of  <span class="math">\\mathsf{flag}_{t + 1} + \\mathsf{c}</span>  unless their sum is 0.</p>

    <p class="text-gray-300">We append the decompositions of  <span class="math">\\mathsf{a},\\mathsf{b},\\mathsf{c},\\mathsf{d}</span>  as well as  <span class="math">\\mathrm{o_o,o_e,e_o,e_e a_{flag}}</span>  to the auxiliary entries of the execution table, i.e.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol {a u x} _ {\\text {E x e}} = \\boxed {\\dots \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {a} _ {\\mathrm {o}} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {a} _ {\\mathrm {e}} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {b} _ {\\mathrm {o}} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {b} _ {\\mathrm {e}} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {c} _ {\\mathrm {o}} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {c} _ {\\mathrm {e}} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {d} _ {\\mathrm {o}} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {d} _ {\\mathrm {e}} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {o} _ {\\mathrm {o}} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {o} _ {\\mathrm {e}} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {e} _ {\\mathrm {o}} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {e} _ {\\mathrm {e}} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {a} _ {\\text {f l a g}} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We now give the  <span class="math">\\mathcal{R}_{\\mathrm{logic}}</span>  relation which includes all the above checks, as well as the range checks on  <span class="math">\\mathsf{a},\\mathsf{b},\\mathsf{c},\\mathsf{d}</span> .</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {R} _ {\\text {l o g i c}} = \\left\\{ \\begin{array}{c} (p p, u, w) = ((W, K, \\mathbb {F}, *), \\bot , (\\operatorname {E x e} _ {t}, \\operatorname {E x e} _ {t + 1}, \\operatorname {E v e n B i t s})) \\quad</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\ \\operatorname {E x e} _ {t} = (t, \\dots , \\dots , \\mathsf {a}, \\mathsf {b}, \\mathsf {c}, \\mathsf {d}, \\boldsymbol {o u t}, \\dots , \\mathsf {a} _ {\\mathrm {o}}, \\mathsf {a} _ {\\mathrm {e}}, \\mathsf {b} _ {\\mathrm {o}}, \\mathsf {b} _ {\\mathrm {e}}, \\mathsf {c} _ {\\mathrm {o}}, \\mathsf {c} _ {\\mathrm {e}}, \\mathsf {d} _ {\\mathrm {o}}, \\mathsf {d} _ {\\mathrm {e}}, \\mathsf {e} _ {\\mathrm {o}}, \\mathsf {e} _ {\\mathrm {e}}, \\mathsf {o} _ {\\mathrm {o}}, \\mathsf {o} _ {\\mathrm {e}}, \\mathsf {a} _ {\\text {f l a g}}, \\dots) \\\\ \\boldsymbol {o u t} = (\\text {A N D}, \\text {X O R}, \\text {O R}, \\dots , \\text {F L A G} _ {1}, \\text {F L A G} _ {2}, \\dots) \\\\ \\operatorname {E x e} _ {t + 1} = (t + 1, \\dots , \\operatorname {f l a g} _ {t + 1}, \\dots) \\\\ (p p, \\bot , (\\mathsf {a}, (\\mathsf {a} _ {\\mathrm {o}}, \\mathsf {a} _ {\\mathrm {e}}), \\text {E v e n B i t s}) \\in \\mathcal {R} _ {\\text {r a n g e}} \\quad (p p, \\bot , (\\mathsf {b}, (\\mathsf {b} _ {\\mathrm {o}}, \\mathsf {b} _ {\\mathrm {e}}), \\text {E v e n B i t s}) \\in \\mathcal {R} _ {\\text {r a n g e}} \\\\ (p p, \\bot , (\\mathsf {c}, (\\mathsf {c} _ {\\mathrm {o}}, \\mathsf {c} _ {\\mathrm {e}}), \\text {E v e n B i t s}) \\in \\mathcal {R} _ {\\text {r a n g e}} \\quad (p p, \\bot , (\\mathsf {d}, (\\mathsf {d} _ {\\mathrm {o}}, \\mathsf {d} _ {\\mathrm {e}}), \\text {E v e n B i t s}) \\in \\mathcal {R} _ {\\text {r a n g e}} \\\\ (p p, \\bot , (\\mathsf {a} _ {\\mathrm {o}} + \\mathsf {b} _ {\\mathrm {o}}, (\\mathsf {o} _ {\\mathrm {o}}, \\mathsf {o} _ {\\mathrm {e}}), \\text {E v e n B i t s}) \\in \\mathcal {R} _ {\\text {r a n g e}} \\quad (p p, \\bot , (\\mathsf {a} _ {\\mathrm {e}} + \\mathsf {b} _ {\\mathrm {e}}, (\\mathsf {e} _ {\\mathrm {o}}, \\mathsf {e} _ {\\mathrm {e}}), \\text {E v e n B i t s}) \\in \\mathcal {R} _ {\\text {r a n g e}} \\\\ \\text {X O R} = 2 \\mathrm {o} _ {\\mathrm {e}} + \\mathrm {e} _ {\\mathrm {e}} - \\mathrm {c} \\quad \\text {A N D} = 2 \\mathrm {o} _ {\\mathrm {o}} + \\mathrm {e} _ {\\mathrm {o}} - \\mathrm {c} \\quad \\text {O R} = \\text {X O R} + \\text {A N D} + \\mathrm {c} \\\\ \\text {F L A G} _ {1} = \\text {f l a g} _ {t + 1} \\cdot \\mathrm {c} \\quad \\text {F L A G} _ {2} = (\\text {f l a g} _ {t + 1} + \\mathrm {c}) \\cdot \\text {a} _ {\\text {f l a g}} - 1 \\end{array} \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We summarise the choice of selector vectors for all the logical operations in Figure 3. The entries specified in the table correspond to the entries of  <span class="math">s_{\\mathbf{a}}, s_{\\mathbf{b}}, s_{\\mathbf{c}}, s_{\\mathbf{d}}, s_{\\mathrm{out}}</span>  which are set equal to 1 and which entries of  <span class="math">s_{\\mathrm{ch}}</span>  are set equal to 0. Note that none of the logical operations requires the temporary variable  <span class="math">\\mathbf{d}</span> , therefore we can simply let  <span class="math">s_{\\mathbf{d}}</span>  to be the zero vector.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">or</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">xor</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">not</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sa</td>

            <td class="px-3 py-2 border-b border-gray-700">At</td>

            <td class="px-3 py-2 border-b border-gray-700">At</td>

            <td class="px-3 py-2 border-b border-gray-700">At</td>

            <td class="px-3 py-2 border-b border-gray-700">At</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sb</td>

            <td class="px-3 py-2 border-b border-gray-700">rj,t</td>

            <td class="px-3 py-2 border-b border-gray-700">rj,t</td>

            <td class="px-3 py-2 border-b border-gray-700">rj,t</td>

            <td class="px-3 py-2 border-b border-gray-700">2W-1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sc</td>

            <td class="px-3 py-2 border-b border-gray-700">ri,t+1</td>

            <td class="px-3 py-2 border-b border-gray-700">ri,t+1</td>

            <td class="px-3 py-2 border-b border-gray-700">ri,t+1</td>

            <td class="px-3 py-2 border-b border-gray-700">ri,t+1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sd</td>

            <td class="px-3 py-2 border-b border-gray-700">/</td>

            <td class="px-3 py-2 border-b border-gray-700">/</td>

            <td class="px-3 py-2 border-b border-gray-700">/</td>

            <td class="px-3 py-2 border-b border-gray-700">/</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sout</td>

            <td class="px-3 py-2 border-b border-gray-700">AND, FLAG1, FLAG2</td>

            <td class="px-3 py-2 border-b border-gray-700">OR, FLAG1, FLAG2</td>

            <td class="px-3 py-2 border-b border-gray-700">XOR, FLAG1, FLAG2</td>

            <td class="px-3 py-2 border-b border-gray-700">XOR, FLAG1, FLAG2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sch</td>

            <td class="px-3 py-2 border-b border-gray-700">ri, flag</td>

            <td class="px-3 py-2 border-b border-gray-700">ri, flag</td>

            <td class="px-3 py-2 border-b border-gray-700">ri, flag</td>

            <td class="px-3 py-2 border-b border-gray-700">ri, flag</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The execution of an addition operation  <span class="math">\\mathbf{add} \\, \\mathrm{reg}_i \\, \\mathrm{reg}_j \\, A</span>  can be verified by picking selection vectors such that  <span class="math">\\mathsf{a} = \\mathsf{A}_t, \\mathsf{b} = \\mathsf{r}_{j,t}, \\mathsf{c} = \\mathsf{r}_{i,t+1}</span>  and check that the following holds</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {a} + \\mathsf {b} - \\mathsf {c} - 2 ^ {W} \\mathsf {f l a g} _ {t + 1} = 0</span></div>

    <p class="text-gray-300">Note that this is equal to 0 if and only if  <span class="math">\\mathsf{c}</span>  contains the result of  <span class="math">\\mathsf{a} + \\mathsf{b}</span>  with the flag  <span class="math">\\mathsf{flag}_{t+1}</span>  indicating overflow.</p>

    <p class="text-gray-300">The same check can be used to verify a subtraction operation  <span class="math">\\mathbf{sub} \\, \\mathrm{reg}_i \\, \\mathrm{reg}_j \\, A</span>  by swapping the role of the selection vector  <span class="math">s_b, s_c</span>  and letting  <span class="math">b = r_{i,t+1}</span>  and  <span class="math">c = r_{j,t}</span> . The above equation is identically 0 if and only if  <span class="math">b</span>  is equal to the difference of  <span class="math">c</span>  and  <span class="math">a</span>  where the flag  <span class="math">\\mathrm{flag}_{t+1}</span>  denotes borrow.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathsf{SUM} = \\mathsf{a} + \\mathsf{b} - \\mathsf{c} - 2^W\\mathsf{flag}_{t + 1} + \\mathsf{d}</span> . We can check the both additions and subtractions by letting  <span class="math">\\mathsf{d} = 0</span>  and checking that  <span class="math">\\mathsf{SUM} = 0</span> . While the temporary variable  <span class="math">\\mathsf{d}</span>  is not strictly required for the verification of the above operations, we will see later that including this variable into the equation will make the verification of other operations easier.</p>

    <p class="text-gray-300">Selection vectors for addition and subtraction are summarised in Figure 4.</p>

    <p class="text-gray-300">Fig. 3: Logical operations</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">add</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">sub</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sa</td>

            <td class="px-3 py-2 border-b border-gray-700">At</td>

            <td class="px-3 py-2 border-b border-gray-700">At</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sb</td>

            <td class="px-3 py-2 border-b border-gray-700">rj,t</td>

            <td class="px-3 py-2 border-b border-gray-700">ri,t+1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sc</td>

            <td class="px-3 py-2 border-b border-gray-700">ri,t+1</td>

            <td class="px-3 py-2 border-b border-gray-700">rj,t</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sd</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sout</td>

            <td class="px-3 py-2 border-b border-gray-700">SUM</td>

            <td class="px-3 py-2 border-b border-gray-700">SUM</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sch</td>

            <td class="px-3 py-2 border-b border-gray-700">rt, flag</td>

            <td class="px-3 py-2 border-b border-gray-700">rt, flag</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 4: Addition and subtraction.</p>

    <p class="text-gray-300">TinyRAM instruction set includes three multiplication instructions: mull, for computing the lower word of the product of two unsigned integers; umull, for</p>

    <p class="text-gray-300">computing the upper word of the product of two unsigned integers; umulh, for computing the upper word of the product of two signed integers.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathsf{PROD} = \\mathsf{a}\\cdot \\mathsf{b} - \\mathsf{d} - 2^{W}\\mathsf{c}</span> . We can then verify the correct execution of  <span class="math">\\mathbf{null}\\mathsf{reg}_i\\mathsf{reg}_jA</span>  by setting the temporary variables such that  <span class="math">\\mathsf{a} = \\mathsf{A}_t,\\mathsf{b} = \\mathsf{r}_{j,t},\\mathsf{d} = \\mathsf{r}_{i,t + 1}</span> ,  <span class="math">\\mathsf{c}</span>  to contain some non-deterministic advice and check that  <span class="math">\\mathsf{PROD} = 0</span> . Note that the latter is equal to 0 if and only if  <span class="math">\\mathsf{d}</span>  stores the lower word of the product  <span class="math">\\mathsf{a}\\cdot \\mathsf{b}</span>  and the upper word is stored in  <span class="math">\\mathsf{c}</span> .</p>

    <p class="text-gray-300">For the execution of umulh reg  <span class="math">i</span>  reg  <span class="math">j</span>  A we can simply change the role of the selector vectors  <span class="math">\\mathbf{s}_{\\mathbf{c}},\\mathbf{s}_{\\mathbf{d}}</span>  , letting  <span class="math">\\mathbf{c} = \\mathbf{r}_{i,t + 1}</span>  and d be some non-deterministic advice, and checking that PROD  <span class="math">= 0</span></p>

    <p class="text-gray-300">Signed Integers. Signed  <span class="math">W</span> -bit words use the two's complement representation to store an integer. We write  <span class="math">\\sigma_{\\mathsf{a}}</span>  for the most significant bit of a word  <span class="math">\\mathsf{a}</span> . We recall that according to the two's complement representation, a negative word  <span class="math">\\mathsf{a}</span>  has  <span class="math">\\sigma_{\\mathsf{a}} = 1</span> . We define the corresponding field element  <span class="math">\\mathsf{a}_{\\sigma} = -\\sigma_{\\mathsf{a}}2^{W} + \\mathsf{a} \\in \\{-2^{W-1}, \\ldots, 2^{W-1} - 1\\}</span> . Given the decomposition of  <span class="math">\\mathsf{a}</span>  it is easy to check the sign is correct by testing  <span class="math">\\mathsf{a}_{\\mathrm{o}} + (1 - 2\\sigma_{\\mathsf{a}})2^{W-2} \\in \\text{EvenBits}</span> . Thus, in order to ensure that  <span class="math">\\mathsf{a}, \\mathsf{b}, \\mathsf{c}, \\mathsf{d}</span>  are in the correct range, and the matching signs and signed values are correct we include the following entries in the auxiliary inputs of the execution table  <span class="math">\\mathbf{aux}_{\\text{Exe}} = \\boxed{\\ldots} \\boxed{\\mathsf{a}_{\\sigma}} \\boxed{\\sigma_{\\mathsf{a}}} \\boxed{\\mathsf{b}_{\\sigma}} \\boxed{\\sigma_{\\mathsf{b}}} \\boxed{\\mathsf{c}_{\\sigma}} \\boxed{\\sigma_{\\mathsf{c}}} \\ldots</span> .</p>

    <p class="text-gray-300">To verify the execution of signed multiplication operations smulh reg  <span class="math">i</span>  reg  <span class="math">j</span>  A we proceed similarly to umulh. Let  <span class="math">\\mathsf{SPROD} = \\mathsf{a}_{\\sigma}\\cdot \\mathsf{b}_{\\sigma} - \\mathsf{d} - 2^{W}\\mathsf{c}_{\\sigma}</span> . By selecting  <span class="math">\\mathsf{a} = \\mathsf{A}_t,\\mathsf{b} = \\mathsf{r}_{j,t},\\mathsf{c} = \\mathsf{r}_{i,t + 1}</span> , and letting  <span class="math">\\mathsf{d}</span>  be some non-deterministic advice, we can verify the execution of signed multiplication by checking that  <span class="math">\\mathsf{SPROD} = 0</span> .</p>

    <p class="text-gray-300">The consistency of the flag of the multiplication operations can be verified by checking  <span class="math">\\mathsf{FLAG}_1 = 0</span> ,  <span class="math">\\mathsf{FLAG}_2 = 0</span> .</p>

    <p class="text-gray-300">We notice that the two's complement representation allows to perform additions and subtractions by reusing the unsigned operation. However, in order to verify signed comparisons, it will be helpful to define a signed equivalent of SUM. Thus, we define  <span class="math">\\mathsf{SSUM} = \\mathsf{a}_{\\sigma} + \\mathsf{b} - \\mathsf{c}_{\\sigma} - 2^{W}\\mathsf{flag}_{t + 1} + \\mathsf{d}</span></p>

    <p class="text-gray-300">The selection vectors for the the multiplication operations are specified in Figure 5.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">mull</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">umulh</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">smulh</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sa</td>

            <td class="px-3 py-2 border-b border-gray-700">At</td>

            <td class="px-3 py-2 border-b border-gray-700">At</td>

            <td class="px-3 py-2 border-b border-gray-700">At</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sb</td>

            <td class="px-3 py-2 border-b border-gray-700">rj,t</td>

            <td class="px-3 py-2 border-b border-gray-700">rj,t</td>

            <td class="px-3 py-2 border-b border-gray-700">rj,t</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sc</td>

            <td class="px-3 py-2 border-b border-gray-700">c</td>

            <td class="px-3 py-2 border-b border-gray-700">ri,t+1</td>

            <td class="px-3 py-2 border-b border-gray-700">ri,t+1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sd</td>

            <td class="px-3 py-2 border-b border-gray-700">ri,t+1</td>

            <td class="px-3 py-2 border-b border-gray-700">d</td>

            <td class="px-3 py-2 border-b border-gray-700">d</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sout</td>

            <td class="px-3 py-2 border-b border-gray-700">PROD, FLAG1, FLAG2</td>

            <td class="px-3 py-2 border-b border-gray-700">PROD, FLAG1, FLAG2</td>

            <td class="px-3 py-2 border-b border-gray-700">SPROD, FLAG1, FLAG2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sch</td>

            <td class="px-3 py-2 border-b border-gray-700">ri, flag</td>

            <td class="px-3 py-2 border-b border-gray-700">ri, flag</td>

            <td class="px-3 py-2 border-b border-gray-700">ri, flag</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 5: Multiplications.</p>

    <p class="text-gray-300">To check the execution of modular reduction <span class="math">\\mathbf{umod~{}reg}_{i}~{}\\mathsf{reg}_{j}</span> <span class="math">A</span>, let <span class="math">\\mathsf{d}=\\mathsf{r}_{j,t}</span>, <span class="math">\\mathsf{c}</span> the modulus <span class="math">\\mathsf{A}_{t}</span>, <span class="math">\\mathsf{b}</span> the quotient of the division <span class="math">\\frac{\\mathsf{d}}{\\mathsf{c}}</span>, and <span class="math">\\mathsf{a}</span> the remainder <span class="math">\\mathsf{r}_{i,t+1}</span>. We can then check that <span class="math">\\mathsf{d}-\\mathsf{b}\\cdot\\mathsf{c}-\\mathsf{a}=0</span>. This check however is not sufficient to guarantee the correctness of the the operation <span class="math">\\mathbf{umod}</span>. For example, in case the modulus is set equal to <span class="math">0</span>, the operation should return <span class="math">0</span> and set the flag equal to <span class="math">1</span>. This can be solved first, by checking that <span class="math">\\mathsf{FLAG}_{1}=0</span> and <span class="math">\\mathsf{FLAG}_{2}=0</span> which ensure that <span class="math">\\mathsf{flag}_{t+1}=1</span> if and only if <span class="math">\\mathsf{c}=0</span> and second, by checking the following</p>

    <p class="text-gray-300"><span class="math">-\\mathsf{flag}\\cdot\\mathsf{d}+\\mathsf{d}-\\mathsf{b}\\cdot\\mathsf{c}-\\mathsf{a}=0</span> (1)</p>

    <p class="text-gray-300">In case <span class="math">\\mathsf{c}=0</span>, then <span class="math">\\mathsf{flag}_{t+1}=1</span> and so <span class="math">\\mathsf{a}=0</span>. Otherwise if <span class="math">\\mathsf{c}\\neq 0</span>, then <span class="math">\\mathsf{flag}_{t+1}=0</span> and the check correspond to the previous one.</p>

    <p class="text-gray-300">The last thing that we need to check in order to guarantee the correctness of the computation is that <span class="math">\\mathsf{a}&lt;\\mathsf{c}</span>, in case <span class="math">\\mathsf{c}\\neq 0</span>. We can do this by doing a range check on the value <span class="math">\\mathsf{c}-\\mathsf{a}-1</span>, which involves computing its even/odd decomposition <span class="math">\\mathsf{r}_{\\mathrm{o}},\\mathsf{r}_{\\mathrm{e}}</span> and check that <span class="math">\\mathsf{c}-\\mathsf{a}-1=2\\mathsf{r}_{\\mathrm{o}}+\\mathsf{r}_{\\mathrm{e}}</span>. We can include the decomposition <span class="math">\\mathsf{r}_{\\mathrm{o}},\\mathsf{r}_{\\mathrm{e}}</span> into the auxiliary entries of the execution table and check that <span class="math">\\mathsf{r}_{\\mathrm{o}},\\mathsf{r}_{\\mathrm{e}}\\in\\mathsf{EvenBits}</span> and check that</p>

    <p class="text-gray-300"><span class="math">(1-\\mathsf{flag}_{t+1})(\\mathsf{c}-\\mathsf{a}-1-2\\mathsf{r}_{\\mathrm{o}}-\\mathsf{r}_{\\mathrm{e}})=0</span> (2)</p>

    <p class="text-gray-300">Since the above checks also include checking the correctness of the quotient of the division, we can reuse them to check the execution of <span class="math">\\mathbf{udiv}</span> operation. It is sufficient to swap the selector vectors <span class="math">\\bm{s}_{\\mathsf{a}},\\bm{s}_{\\mathsf{b}}</span> so that <span class="math">\\mathsf{r}_{i,t+1}=\\mathsf{b}</span> and check that Eq. (1). Again, this check is not sufficient in the case of division by <span class="math">\\mathsf{c}=0</span>. In this case the operation is expected to return <span class="math">0</span> and set the flag equal to <span class="math">1</span>. The above check does not suffice since it is merely checking that the remainder <span class="math">\\mathsf{a}</span> is equal to <span class="math">0</span>, instead of the quotient <span class="math">\\mathsf{b}</span>. This can be addressed by additionally checking the following</p>

    <p class="text-gray-300"><span class="math">\\mathsf{b}\\cdot\\mathsf{flag}_{t+1}=0</span> (3)</p>

    <p class="text-gray-300">In case <span class="math">\\mathsf{c}\\neq 0</span>, we still need to ensure that <span class="math">\\mathsf{a}&lt;\\mathsf{c}</span> to guarantee the correctness of the result. Note that we can combine Eq. (2) and (3) into a single equation</p>

    <p class="text-gray-300"><span class="math">\\mathsf{FLAG}_{3}=\\mathsf{b}\\cdot\\mathsf{flag}_{t+1}+(1-\\mathsf{flag}_{t+1})(\\mathsf{c}-\\mathsf{a}-1-2\\mathsf{r}_{\\mathrm{o}}-\\mathsf{r}_{\\mathrm{e}})</span></p>

    <p class="text-gray-300">This does not affect the <span class="math">\\mathbf{umod}</span> operation since in case <span class="math">\\mathsf{flag}_{t+1}=1</span>, the prover can simply set the non-deterministic advice <span class="math">\\mathsf{b}</span> equal to <span class="math">0</span>.</p>

    <p class="text-gray-300">Looking ahead a little bit, Equation 1 will be used to check other operations by clever choice of the selector vector. With this goal in mind, it will be useful to replace Equation 1 with the following</p>

    <p class="text-gray-300"><span class="math">\\mathsf{MOD}=\\mathsf{flag}_{t+1}(\\mathsf{b}-\\mathsf{d})+\\mathsf{d}-\\mathsf{b}\\cdot\\mathsf{c}-\\mathsf{a}</span></p>

    <p class="text-gray-300">Note that replacing Eq. (1) with <span class="math">\\mathsf{MOD}=0</span> does not affect the checks done for <span class="math">\\mathbf{umod},\\mathbf{udiv}</span>. In case <span class="math">\\mathsf{flag}_{t+1}=0</span>, the two equations are equivalent. In case <span class="math">\\mathsf{flag}_{t+1}=1</span>, we have that <span class="math">\\mathsf{c}=0</span> which means that <span class="math">\\mathsf{b}-\\mathsf{a}=0</span>. In this case however we get that <span class="math">\\mathsf{FLAG}_{3}=0</span> implies <span class="math">\\mathsf{b}=0</span>, and hence <span class="math">\\mathsf{a}=0</span>, as in the case of Eq. (1). Details of the selection vector for <span class="math">\\mathbf{umod},\\mathbf{udiv}</span> operations are given in Figure 6.</p>

    <p class="text-gray-300">30</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">umod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">udiv</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s_{a}</td>

            <td class="px-3 py-2 border-b border-gray-700">r_{i,t+1}</td>

            <td class="px-3 py-2 border-b border-gray-700">a</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s_{b}</td>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">r_{i,t+1}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s_{c}</td>

            <td class="px-3 py-2 border-b border-gray-700">A_{t}</td>

            <td class="px-3 py-2 border-b border-gray-700">A_{t}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s_{d}</td>

            <td class="px-3 py-2 border-b border-gray-700">r_{j,t}</td>

            <td class="px-3 py-2 border-b border-gray-700">r_{j,t}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s_{out}</td>

            <td class="px-3 py-2 border-b border-gray-700">MOD, FLAG_{1}, FLAG_{2}, FLAG_{3}</td>

            <td class="px-3 py-2 border-b border-gray-700">MOD, FLAG_{1}, FLAG_{2}, FLAG_{3}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s_{ch}</td>

            <td class="px-3 py-2 border-b border-gray-700">r_{i}, flag</td>

            <td class="px-3 py-2 border-b border-gray-700">r_{i}, flag</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 6: Modular reduction and division.</p>

    <p class="text-gray-300">We can give the relation <span class="math">\\mathcal{R}_{\\mathrm{arith}}</span> for the verification of arithmetic operations.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\mathrm{arith}} = \\left\\{ \\begin{array}{l} (pp, u, w) = ((W, K, \\mathbb{F}, *), \\bot, (\\mathrm{Exe}_t, \\mathrm{Exe}_{t+1}, \\mathrm{EvenBits})) \\\\ \\mathrm{Exe}_t = (t, \\dots, \\mathrm{flag}_t, \\dots, \\mathrm{a}, \\mathrm{b}, \\mathrm{c}, \\mathrm{d}, \\mathrm{out}, \\dots, \\mathrm{a}_o, \\mathrm{b}_o, \\mathrm{c}_o, \\dots, \\sigma_{\\mathrm{a}}, \\sigma_{\\mathrm{b}}, \\sigma_{\\mathrm{c}}, r_o, r_e, \\dots, \\dots) \\\\ \\mathrm{out} = (\\dots, \\mathrm{SUM}, \\mathrm{SSUM}, \\mathrm{PROD}, \\mathrm{SPROD}, \\mathrm{MOD}, \\dots, \\mathrm{FLAG}_3, \\dots) \\\\ \\mathrm{Exe}_{t+1} = (t + 1, \\dots, \\mathrm{flag}_{t+1}, \\dots) \\\\ (pp, \\bot, ((\\mathrm{a}_o + (1 - 2\\sigma_{\\mathrm{a}}))2^{W-2}, \\mathrm{EvenBits}) \\in \\mathcal{R}_{\\mathrm{lookup}}) \\\\ (pp, \\bot, \\mathrm{c}_o + (1 - 2\\sigma_{\\mathrm{c}}))2^{W-2}, \\mathrm{EvenBits}) \\in \\mathcal{R}_{\\mathrm{lookup}}) \\\\ (pp, \\bot, \\mathrm{b}_o + (1 - 2\\sigma_{\\mathrm{b}}))2^{W-2}, \\mathrm{EvenBits}) \\in \\mathcal{R}_{\\mathrm{lookup}} \\\\ \\end{array} \\right.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sigma_{\\mathrm{a}}, \\sigma_{\\mathrm{b}}, \\sigma_{\\mathrm{c}}, \\mathrm{flag}_t, \\mathrm{flag}_{t+1} \\in \\{0, 1\\} \\quad a_\\sigma = -\\sigma_{\\mathrm{a}}2^W + a \\\\ b_\\sigma = -\\sigma_{\\mathrm{b}}2^W + b \\quad c_\\sigma = -\\sigma_{\\mathrm{c}}2^W + c \\\\ \\mathrm{SUM} = a + b - c - 2^W \\mathrm{flag}_{t+1} + d \\quad \\mathrm{PROD} = a \\cdot b - d - 2^W c \\\\ \\mathrm{MOD} = \\mathrm{flag}_{t+1}(b - d) + d - b \\cdot c - a \\\\ \\mathrm{SSUM} = a_\\sigma + b - c_\\sigma - 2^W \\mathrm{flag}_{t+1} + d \\quad \\mathrm{SPROD} = a_\\sigma \\cdot b_\\sigma - d - 2^W c_\\sigma \\\\ \\mathrm{FLAG}_3 = b \\cdot \\mathrm{flag}_{t+1} + (1 - \\mathrm{flag}_{t+1})(c - a - 1 - 2r_o - r_e) \\\\ \\end{array}</span></div>

    <p class="text-gray-300"><strong>Shift Operations.</strong> Operations <span class="math">\\mathbf{shl} \\, \\mathrm{reg}_i \\, \\mathrm{reg}_j A</span> and <span class="math">\\mathbf{shr} \\, \\mathrm{reg}_i \\, \\mathrm{reg}_j A</span> are used to shift the word <span class="math">r_{j,t}</span> of <span class="math">A</span> positions to the left, respectively to the right, filling the vacant positions with 0. The flag is set to the most significant bit and least significant bit of <span class="math">r_{j,t}</span>, respectively.</p>

    <p class="text-gray-300">Following the observation that shifting a word by <span class="math">\\mathsf{A}</span> positions is equivalent to multiply or divide <span class="math">\\mathsf{r}_{j,t}</span> by <span class="math">2^{\\mathsf{A}}</span>, we can treat shifts similarly to the integers operations shown above. To efficiently check the correctness of shift operations we include into <span class="math">\\mathsf{w}</span> the table <span class="math">\\mathsf{Pow}</span> storing the pairs <span class="math">(a, 2^a \\mod 2^W)</span> for <span class="math">a \\in [W]</span>.</p>

    <p class="text-gray-300">Note that the <span class="math">\\mathsf{Pow}</span> table contains only <span class="math">2W + 2</span> entries, which is considerably smaller than the other tables included in the witness <span class="math">\\mathsf{w}</span>.</p>

    <p class="text-gray-300">In addition to <span class="math">\\mathsf{Pow}</span> we store two additional values <span class="math">\\mathsf{a}_{\\mathrm{shift}}, \\mathsf{a}_{\\mathrm{power}}</span> in the auxiliary entries of <span class="math">\\mathsf{Exe}</span>. Say that <span class="math">\\mathsf{a}</span> stores the value <span class="math">\\mathsf{A}_t</span>, the offset of a shift operation. Then the entry <span class="math">\\mathsf{a}_{\\mathrm{shift}}</span> can be used to check if <span class="math">\\mathsf{A}_t \\in [W]</span> by checking that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{a}_{\\mathrm{shift}}(\\mathsf{a}_{\\mathrm{shift}} - 1) = 0 \\quad \\wedge \\quad (1 - \\mathsf{a}_{\\mathrm{shift}})(W - \\mathsf{a} - 2r_o - r_e) = 0 \\tag{4}</span></div>

    <p class="text-gray-300">where the first equation checks that <span class="math">\\mathsf{a}_{\\mathrm{shift}}</span> is a bit and the second checks that if <span class="math">W &amp;lt; \\mathsf{a}</span> then <span class="math">\\mathsf{a}_{\\mathrm{shift}} = 1</span>. The entry <span class="math">\\mathsf{a}_{\\mathrm{power}}</span> can be used to store the element <span class="math">2^{\\mathsf{a}}</span></p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Table 3: Table Pow.</p>

    <p class="text-gray-300">mod  <span class="math">2^{W}</span>  in case  <span class="math">\\mathsf{a}_{\\mathrm{shift}} = 0</span>  and 0 otherwise. We can then check that  <span class="math">\\mathsf{a}_{\\mathrm{power}}</span>  is consistent with  <span class="math">\\mathsf{a}</span>  by checking that</p>

    <div class="my-4 text-center"><span class="math-block">\\left(p p, \\left(\\mathrm {a} + \\mathrm {a} _ {\\text {s h i f t}} (W - \\mathrm {a}), \\mathrm {a} _ {\\text {p o w e r}}\\right), \\mathrm {P o w}\\right) \\in \\mathcal {R} _ {\\text {l o o k u p}} \\tag {5}</span></div>

    <p class="text-gray-300">A left shift operation shl can be checked by setting  <span class="math">\\mathsf{b} = \\mathsf{r}_{j,t},\\mathsf{d} = \\mathsf{r}_{i,t + 1}</span> , respectively, and check that the following is equal to 0</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {S H I F T} = \\mathsf {a} _ {\\text {p o w e r}} \\cdot \\mathsf {b} - \\mathsf {d} - 2 ^ {W} \\mathsf {c} \\tag {6}</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathsf{c}</span>  is some non-deterministic advice. The consistency of the flag with the most significant bit of  <span class="math">\\mathsf{r}_{j,t}</span>  is checked by the following</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {f l a g} _ {t + 1} - \\sigma_ {\\mathsf {b}} = 0</span></div>

    <p class="text-gray-300">Observe that if we had registers storing two words of  <span class="math">W</span> -bits each, shifting a  <span class="math">W</span> -bit word to the right of  <span class="math">A</span>  positions would correspond to shift the same word to the left by  <span class="math">W - A</span>  positions and taking the resulting upper  <span class="math">W</span>  bits. Since the size of the field  <span class="math">\\mathbb{F}</span>  is big enough, we can use the above observations to check a right shift as a left shift. This allows to reuse most of the above checks. It is sufficient to set  <span class="math">a = W - A_t</span> ,  <span class="math">b = r_{j,t}</span> ,  <span class="math">d = r_{i,t+1}</span> , let  <span class="math">c</span>  be some non-deterministic advice and check conditions (4), (5) and (6) as well as the following</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {f l a g} _ {t + 1} - \\rho_ {\\mathsf {b}} = 0</span></div>

    <p class="text-gray-300">where  <span class="math">\\rho_{\\mathsf{b}}</span>  is the least significant bit of  <span class="math">\\mathsf{b}</span> . We can introduce an additional auxiliary value  <span class="math">\\mathsf{b}_{\\mathrm{flag}}</span>  in the auxiliary information of the program and duplicated in the execution table which is set equal to for left shifts and equal to 0 otherwise. we can then merge the above flag checks in the following</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {F L A G} _ {4} = \\mathsf {f l a g} _ {t + 1} - \\mathsf {b} _ {\\mathsf {f l a g}} \\sigma_ {\\mathsf {b}} - (1 - \\mathsf {b} _ {\\mathsf {f l a g}}) \\rho_ {\\mathsf {b}}</span></div>

    <p class="text-gray-300">We can now give the relation  <span class="math">\\mathcal{R}_{\\mathrm{shift}}</span>  for the correct execution of shifts operations and summarise the selection vectors of these in Figure 7.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 7: Shift Operations</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">shl</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">shr</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s_s</td>

            <td class="px-3 py-2 border-b border-gray-700">A_t</td>

            <td class="px-3 py-2 border-b border-gray-700">A_t</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s_b</td>

            <td class="px-3 py-2 border-b border-gray-700">r_j,t</td>

            <td class="px-3 py-2 border-b border-gray-700">r_j,t</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s_c</td>

            <td class="px-3 py-2 border-b border-gray-700">c</td>

            <td class="px-3 py-2 border-b border-gray-700">r_i,t+1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s_d</td>

            <td class="px-3 py-2 border-b border-gray-700">r_i,t+1</td>

            <td class="px-3 py-2 border-b border-gray-700">d</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s_out</td>

            <td class="px-3 py-2 border-b border-gray-700">SHIFT, FLAG4</td>

            <td class="px-3 py-2 border-b border-gray-700">SHIFT, FLAG4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">s_ch</td>

            <td class="px-3 py-2 border-b border-gray-700">r_i,flag</td>

            <td class="px-3 py-2 border-b border-gray-700">r_i,flag</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Comparison Operations. The instruction  <span class="math">\\text{compe reg}_i A</span>  sets the flag equal to 1 if  <span class="math">r_{i,t} = A_t</span> , and 0 otherwise. To check the execution of this operation we can set  <span class="math">a = A_t, b = r_{i,t}</span>  and check their bit-wise XOR is equal to 0 or that  <span class="math">\\text{flag}_{t+1} = 0</span> . Therefore, we can reuse the checks specified for the bit-wise XOR to check the compare-equal instruction.</p>

    <p class="text-gray-300">The compare-above instruction  <span class="math">\\mathbf{comp}\\mathbf{a}\\mathbf{reg}_i</span> <span class="math">A</span>  sets the flag equal to 1 if and only if  <span class="math">\\mathsf{r}_{i,t} &amp;gt; \\mathsf{A}_t</span>  and to 0 otherwise. Let  <span class="math">\\mathsf{a} = \\mathsf{r}_{i,t}</span> ,  <span class="math">\\mathsf{c} = \\mathsf{A}_t</span> ,  <span class="math">\\mathsf{d} = 0</span> , and  <span class="math">\\mathsf{b}</span>  store some non-deterministic advice. By checking that  <span class="math">\\mathsf{SUM} = 0</span>  we have that  <span class="math">(\\mathsf{a} - \\mathsf{c}) = (2^{W}\\mathsf{flag}_{t + 1} - \\mathsf{b})</span> . Note that if  <span class="math">\\mathsf{flag}_{t + 1} = 1</span> , the right-hand side is greater than 0, since  <span class="math">\\mathsf{b} \\in \\{0,\\dots ,2^{W} - 1\\}</span> , and so is the left-hand side. Thus, if  <span class="math">\\mathsf{flag}_{t + 1} = 1</span> ,  <span class="math">\\mathsf{a} &amp;gt; \\mathsf{c}</span> . On the other hand if  <span class="math">\\mathsf{flag}_{t + 1} = 0</span> , the right-hand side is less or equal than 0, and thus  <span class="math">\\mathsf{a} \\leq \\mathsf{c}</span> . The operation  <span class="math">\\mathbf{compg}</span>  is the equivalent of  <span class="math">\\mathbf{comp}\\mathbf{a}</span>  for the comparison of signed integers and can be checked in a similar way by checking that  <span class="math">\\mathsf{SSUM} = \\mathsf{a}_{\\sigma} + \\mathsf{b} - \\mathsf{c}_{\\sigma} - 2^{W}\\mathsf{flag}_{t + 1} + \\mathsf{d}</span>  is equal to 0, where  <span class="math">\\mathsf{d}</span>  is also set equal to 0 and the other temporary variables are set as above.</p>

    <p class="text-gray-300">Similarly, the  <span class="math">\\mathbf{comp}\\mathbf{a}\\mathbf{e}\\mathbf{r}\\mathbf{g}_{i}</span> <span class="math">A</span>  sets the flag equal to 1 if and only if  <span class="math">\\mathsf{r}_{i,t} &amp;gt; \\mathsf{A}_t</span>  and to 0 otherwise. We can set the selection vector as for the previous operation while setting  <span class="math">\\mathsf{d} = 1</span> . Whenever  <span class="math">\\mathsf{SUM} = 0</span>  we will have that  <span class="math">(\\mathsf{a} - \\mathsf{c}) = (2^{W}\\mathsf{flag}_{t + 1} - \\mathsf{b} - 1)</span> . Now,  <span class="math">\\mathsf{flag}_{t + 1} = 1</span>  makes the right-hand side greater or equal than 0, and thus</p>

    <p class="text-gray-300"><span class="math">\\mathsf{a} \\geq \\mathsf{c}</span> . On the other hand,  <span class="math">\\mathsf{flag}_{t+1} = 0</span>  makes the right-hand side strictly less than 0, giving us  <span class="math">\\mathsf{a} &amp;lt; \\mathsf{c}</span> . The operation  <span class="math">\\mathbf{compg}</span>  is the equivalent of  <span class="math">\\mathbf{compa}</span>  for the comparison of signed integers and can be checked in a similar way by checking that  <span class="math">\\mathsf{SSUM} = \\mathsf{a}_{\\sigma} + \\mathsf{b} - \\mathsf{c}_{\\sigma} - 2^{W} \\mathsf{flag}_{t+1} + \\mathsf{d}</span>  is equal to 0, where  <span class="math">\\mathsf{d}</span>  is also set equal to 1 and the other temporary variables are set as above.</p>

    <p class="text-gray-300">Selection vectors of the comparison operations are summarised in Figure 8.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cmpe</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cmpa</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cmpae</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cmpg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cmpge</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sa</td>

            <td class="px-3 py-2 border-b border-gray-700">At</td>

            <td class="px-3 py-2 border-b border-gray-700">ri,t</td>

            <td class="px-3 py-2 border-b border-gray-700">ri,t</td>

            <td class="px-3 py-2 border-b border-gray-700">ri,t</td>

            <td class="px-3 py-2 border-b border-gray-700">ri,t</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sb</td>

            <td class="px-3 py-2 border-b border-gray-700">ri,t</td>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sc</td>

            <td class="px-3 py-2 border-b border-gray-700">c</td>

            <td class="px-3 py-2 border-b border-gray-700">At</td>

            <td class="px-3 py-2 border-b border-gray-700">At</td>

            <td class="px-3 py-2 border-b border-gray-700">At</td>

            <td class="px-3 py-2 border-b border-gray-700">At</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sd</td>

            <td class="px-3 py-2 border-b border-gray-700">/</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sout</td>

            <td class="px-3 py-2 border-b border-gray-700">XOR, FLAG1, FLAG2</td>

            <td class="px-3 py-2 border-b border-gray-700">SUM</td>

            <td class="px-3 py-2 border-b border-gray-700">SUM</td>

            <td class="px-3 py-2 border-b border-gray-700">SSUM</td>

            <td class="px-3 py-2 border-b border-gray-700">SSUM</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sch</td>

            <td class="px-3 py-2 border-b border-gray-700">flag</td>

            <td class="px-3 py-2 border-b border-gray-700">flag</td>

            <td class="px-3 py-2 border-b border-gray-700">flag</td>

            <td class="px-3 py-2 border-b border-gray-700">flag</td>

            <td class="px-3 py-2 border-b border-gray-700">flag</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 8: Comparison operations.</p>

    <p class="text-gray-300">The instruction relation insures that logic, arithmetic and shift operations are carried out correctly. Remaining operations that need to be checked are move and jump operations, memory operations, and a terminating answer operation. Correct execution can be ensured whenever  <span class="math">\\mathcal{R}_{\\mathrm{mux}}</span>  and  <span class="math">\\mathcal{R}_{\\mathrm{consistent}}</span>  are satisfied with a certain choice of selection vectors. Here we specify these remaining selection vectors.</p>

    <p class="text-gray-300">Move and Jump Operations. The instruction  <span class="math">\\mathbf{mov} \\, \\mathrm{reg}_i</span> <span class="math">A</span>  stores the value  <span class="math">A_t</span>  into  <span class="math">\\mathrm{reg}_i</span>  and the instruction  <span class="math">\\mathbf{jmp} \\, A</span>  sets the program counter  <span class="math">\\mathsf{pc}_{t+1}</span>  equal to  <span class="math">A_t</span> . We can check both this operations by storing input and output in  <span class="math">\\mathsf{a}</span>  and  <span class="math">\\mathsf{b}</span> , respectively, and check that their bit-wise XOR is equal to 0. We summarise the selection vectors for these operations in Figure 9.</p>

    <p class="text-gray-300">The operation  <span class="math">\\mathbf{cmov}</span>  is the conditional operation executing a  <span class="math">\\mathbf{mov}</span>  instruction only in the case the  <span class="math">\\mathsf{flag}_t</span>  is set equal to 1. It can be verified by setting the selection vectors so that  <span class="math">\\mathsf{a} = \\mathsf{r}_{i,t + 1},\\mathsf{b} = \\mathsf{A}_t,\\mathsf{c} = 0,\\mathsf{d} = \\mathsf{r}_{i,t}</span>  and check that  <span class="math">\\mathsf{MOD} = 0</span> . Note that when  <span class="math">\\mathsf{c} = 0</span> , the latter amounts to check</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {f l a g} _ {t + 1} (\\mathsf {b} - \\mathsf {d}) + \\mathsf {d} - \\mathsf {a} = 0</span></div>

    <p class="text-gray-300">To conclude, by setting the entry of vector  <span class="math">s_{\\mathrm{ch}}</span>  relative to the flag equal to 1, we can check that  <span class="math">\\mathsf{flag}_t = \\mathsf{flag}_{t + 1}</span> .</p>

    <p class="text-gray-300">The conditional operation cjmp executes a jump operation only in case  <span class="math">\\mathsf{flag}_t = 1</span> . This can be checked in the same way as above by setting  <span class="math">\\mathsf{a} = \\mathsf{pc}_{t + 1},\\mathsf{b} =</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{A}_t, \\mathsf{c} = 0, \\mathsf{d} = \\mathsf{pc}_t + 1</span>  and check that  <span class="math">\\mathsf{MOD} = 0</span> . Note that exceptionally we allow the selector vector  <span class="math">\\mathbf{s}_{\\mathsf{c}}</span>  to have two entries set equal to 1. Note that  <span class="math">\\mathcal{R}_{\\mathrm{ins}}</span>  also performs a range check on the size of  <span class="math">\\mathsf{c}</span> . Thus we would require the length of the program to be such that  <span class="math">L &amp;lt; 2^{W} - 1</span> . However, this is already implied by the parameter selection of Section 5.2. The conditional operations  <span class="math">\\mathbf{cnjmp}</span>  only performs a jump instruction if  <span class="math">\\mathsf{flag}_t = 0</span> . It is sufficient to swap the roles of  <span class="math">\\mathsf{b}</span>  and check  <span class="math">\\mathsf{MOD} = 0</span> .</p>

    <p class="text-gray-300">Selection vectors for the above operations are summarised in Figure 9. We recall that for all the above operations the selection vector  <span class="math">s_{\\mathrm{ch}}</span>  is set so that we check the flag does not change during the execution of the instruction.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">mov</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">jmp</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cmov</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cjmp</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cnjmp</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sa</td>

            <td class="px-3 py-2 border-b border-gray-700">At</td>

            <td class="px-3 py-2 border-b border-gray-700">At</td>

            <td class="px-3 py-2 border-b border-gray-700">ri,t+1</td>

            <td class="px-3 py-2 border-b border-gray-700">pct+1</td>

            <td class="px-3 py-2 border-b border-gray-700">pct+1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sb</td>

            <td class="px-3 py-2 border-b border-gray-700">ri,t+1</td>

            <td class="px-3 py-2 border-b border-gray-700">pct+1</td>

            <td class="px-3 py-2 border-b border-gray-700">At</td>

            <td class="px-3 py-2 border-b border-gray-700">At</td>

            <td class="px-3 py-2 border-b border-gray-700">pct+1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sc</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sd</td>

            <td class="px-3 py-2 border-b border-gray-700">/</td>

            <td class="px-3 py-2 border-b border-gray-700">/</td>

            <td class="px-3 py-2 border-b border-gray-700">rj,t</td>

            <td class="px-3 py-2 border-b border-gray-700">pct+1</td>

            <td class="px-3 py-2 border-b border-gray-700">At</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sout</td>

            <td class="px-3 py-2 border-b border-gray-700">XOR</td>

            <td class="px-3 py-2 border-b border-gray-700">XOR</td>

            <td class="px-3 py-2 border-b border-gray-700">MOD</td>

            <td class="px-3 py-2 border-b border-gray-700">MOD</td>

            <td class="px-3 py-2 border-b border-gray-700">MOD</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">sch</td>

            <td class="px-3 py-2 border-b border-gray-700">ri</td>

            <td class="px-3 py-2 border-b border-gray-700">pc</td>

            <td class="px-3 py-2 border-b border-gray-700">ri</td>

            <td class="px-3 py-2 border-b border-gray-700">pc</td>

            <td class="px-3 py-2 border-b border-gray-700">pc</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Memory Operations. The consistency of memory operations across the execution has been checked by the memory check relation  <span class="math">\\mathcal{R}_{\\mathrm{mem}}</span> . Among other things,  <span class="math">\\mathcal{R}_{\\mathrm{mem}}</span>  checks that entries  <span class="math">\\mathsf{addr}_t</span>  and  <span class="math">\\mathsf{v}_{\\mathsf{addr}_t}</span>  are updated consistently. The last thing that remains to check is that when performing load and store operations, the registers are updated consistently to the value stored in  <span class="math">\\mathsf{v}_{\\mathsf{addr}_t}</span> . This involves checking equality between  <span class="math">\\mathsf{v}_{\\mathsf{addr}_t}</span>  and either the value stored in the input or output register, which can be done by checking that their bit-wise XOR is equal to 0. Details of the selection vectors are given in Figure 10.</p>

    <p class="text-gray-300">Fig. 9: Move and Jump operations.</p>

    <p class="text-gray-300">Fig. 10: Store/load.</p>

    <p class="text-gray-300">Fig. 9: Move and Jump operations.</p>

    <p class="text-gray-300">Answer. A correct program execution terminates in step <span class="math">T</span> with answer 0. With little loss of generality we can assume this is done by jumping to the last line of the program, which has instruction answer <span class="math">A</span> specifying immediate value <span class="math">\\mathsf{A}=0</span>, which we check in <span class="math">\\mathcal{R}_{\\text{check}}</span>. A correct program execution only executes answer once so we also need to ensure the program execution does not encounter an answer instruction prematurely. We ensure this by removing all answer instructions from the program table Prog such that no execution step checked by <span class="math">\\mathcal{R}_{\\text{ins}}</span> for <span class="math">t=1,\\ldots,T-1</span> can be an answer instruction.</p>

    <h2 id="sec-28" class="text-2xl font-bold">4 Proofs for the Correct Program Execution over the ILC Channel</h2>

    <p class="text-gray-300">In this section we give an overview of our proof system for correct TinyRAM program execution over the ILC channel by giving a breakdown of it into simpler proofs, which are detailed in Appendix A, B, and C. Recall that in the idealised linear commitment channel ILC the prover can submit commit commands to commit vectors of field elements of length <span class="math">k</span>. The vectors remain secretly stored in the channel. The verifier can do two things: it can use a send command to send a message to the prover; and it can submit open queries to the ILC channel for obtaining the openings of linear combinations of vectors committed by the prover. The field <span class="math">\\mathbb{F}</span> and the vector length <span class="math">k</span> are specified by the public parameter <span class="math">pp_{\\text{ILC}}</span>. It will later emerge that the best communication and computation complexity for a TinyRAM program terminating in <span class="math">T</span> is achieved when <span class="math">k</span> is approximately <span class="math">\\sqrt{T}</span>.</p>

    <p class="text-gray-300">In Section 3 we broke the relation of correct program execution down to a number of sub-relations defined over a finite field <span class="math">\\mathbb{F}</span>. Our strategy for proving that they are all satisfied is to commit the extended witness to the ILC channel and then give an sub-proofs for each sub-relation. To begin we describe how we commit to the execution trace to the ILC model and discuss a relation <span class="math">\\mathcal{R}_{\\text{format}}</span> for checking that the commitments are well formed. We then take a top down approach in order to describe how to check in the ILC model that the program has been executed correctly. In the first layer we describe a proof for correct TinyRAM execution in the ILC model. This proof decomposes into proofs checking that <span class="math">\\mathcal{R}_{\\text{check}}</span>, <span class="math">\\mathcal{R}_{\\text{mem}}</span>, <span class="math">\\mathcal{R}_{\\text{step}}</span>, and <span class="math">\\mathcal{R}_{\\text{format}}</span> all hold. In the second layer we then decompose proofs for <span class="math">\\mathcal{R}_{\\text{format}}</span>, <span class="math">\\mathcal{R}_{\\text{check}}</span>, <span class="math">\\mathcal{R}_{\\text{mem}}</span>, and <span class="math">\\mathcal{R}_{\\text{step}}</span> in terms of generic proofs for checking relations <span class="math">\\mathcal{R}_{\\text{const}}</span>, <span class="math">\\mathcal{R}_{\\text{perm}}</span>, <span class="math">\\mathcal{R}_{\\text{range}}</span>, <span class="math">\\mathcal{R}_{\\text{eq}}</span>, <span class="math">\\mathcal{R}_{\\text{blookup}}</span> and <span class="math">\\mathcal{R}_{\\text{lookup}}</span>. We detail this decomposition in Appendix A. In the third layer we detail how these proofs decompose into proofs in ILC for elemental relations, such as sums, products, shifts, known permutations, and entry products of committed vectors. Details of this decomposition can be found in Appendix B. Our fourth and final layer will provide proofs in the ILC for these elemental relations, which are detailed in Appendix A. A breakdown of these layers is given in Figure 11.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">4.1 Commitments to the Tables</h3>

    <p class="text-gray-300">In our proof system, the prover first commits to the extended witness w. The extended witness includes the field elements in the execution table Exe, the</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 11: A breakdown of the relations required at each layer to prove correct TinyRAM execution.</p>

    <p class="text-gray-300">memory table Mem, the program table Prog, the range table EvenBits and the exponent table Pow. The prover arranges these tables in multiple matrices and to their rows.</p>

    <p class="text-gray-300">The prover commits to each column of the execution table (such as the  <span class="math">T</span>  entries containing the time  <span class="math">t</span> , the  <span class="math">T</span>  entries containing the programt counter  <span class="math">\\mathsf{pc}_t</span> , etc.) by arranging it into an  <span class="math">\\ell</span>  by  <span class="math">k</span>  matrix, and making a commitment to each row of the resulting matrix. Entries of Exe relative to the same TinyRAM state will be inserted in the same position across the different matrices. Furthermore, in all these matrices the last entry of each column is duplicated in the first entry of the next column. As an example, let consider the first column of Exe which contains field elements representing the time-steps of the execution. Without loss of generality let  <span class="math">T = (\\ell - 1)k + 1</span> , where  <span class="math">T</span>  is the number of steps executed by the program and  <span class="math">k</span>  is the vector length of the ILC. The prover organizes the field elements representing time in a matrix  <span class="math">\\mathsf{E}_t \\in \\mathbb{F}^{\\ell \\times k}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {E} _ {t} = \\left( \\begin{array}{c c c c} 1 &amp;amp; \\ell &amp;amp; 2 \\ell - 1 \\ldots \\\\ 2 &amp;amp; \\ell + 1 &amp;amp; 2 \\ell &amp;amp; \\ldots \\\\ \\vdots &amp;amp; &amp;amp; &amp;amp; \\ddots \\\\ \\ell - 1 &amp;amp; 2 \\ell - 2 &amp;amp; 3 \\ell - 3 \\ldots &amp;amp; (\\ell - 1) k \\\\ \\ell &amp;amp; 2 \\ell - 1 &amp;amp; 3 \\ell - 2 \\ldots &amp;amp; T \\end{array} \\right)</span></div>

    <p class="text-gray-300">37</p>

    <p class="text-gray-300">Similarly, the prover organizes the rest of the Exe table into matrices <span class="math">\\mathsf{E}_{\\mathsf{pc}}, \\mathsf{E}_{\\mathsf{inst}}, \\mathsf{E}_A, \\ldots</span> one for each column. Let <span class="math">\\mathsf{E}</span> be the matrix obtained by stacking all matrices on top of each other and let <span class="math">\\mathsf{E} = \\{\\pmb{e}_i\\}</span>, for <span class="math">\\pmb{e}_i \\in \\mathbb{F}^k</span>. The prover commits to Exe by sending the command (commit, <span class="math">\\{\\pmb{e}_i\\}_i</span>) to the ILC.</p>

    <p class="text-gray-300">Each column of the program table is also committed to the ILC separately. In case <span class="math">L \\leq k</span> we can store each column of Prog in one vector, i.e.</p>

    <div class="my-4 text-center"><span class="math-block">P = \\left( \\begin{array}{c} P _ {p c} \\\\ P _ {i n s t} \\\\ P _ {A} \\\\ \\ldots \\end{array} \\right) = \\left( \\begin{array}{c c c c} 0 &amp;amp; 1 &amp;amp; \\ldots &amp;amp; L - 1 \\\\ \\operatorname {i n s t} _ {0} &amp;amp; \\operatorname {i n s t} _ {1} &amp;amp; \\ldots &amp;amp; \\operatorname {i n s t} _ {L - 1} \\\\ A _ {0} &amp;amp; A _ {1} &amp;amp; \\ldots &amp;amp; A _ {L - 1} \\\\ \\ldots &amp;amp; &amp;amp; \\ldots \\end{array} \\right)</span></div>

    <p class="text-gray-300">otherwise, multiple rows can be used. The prover sends (commit, <span class="math">\\{\\mathsf{P}_{\\mathsf{pc}},\\mathsf{P}_{\\mathsf{inst}},\\ldots \\}</span>) to the ILC channel to commit to P.</p>

    <p class="text-gray-300">The memory table Mem, the auxiliary lookup table EvenBits and the exponent table Pow can be committed in a similar way using matrices M,R and S, respectively</p>

    <div class="my-4 text-center"><span class="math-block">M = \\left( \\begin{array}{c} M _ {0} \\\\ M _ {1} \\end{array} \\right) \\quad R = \\left( \\begin{array}{c c c c} 0 &amp;amp; 1 &amp;amp; 4 &amp;amp; 5 \\\\ &amp;amp; \\ddots &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; \\sum_ {i = 0} ^ {W - 1} 2 ^ {2 i} \\end{array} \\right) \\quad S = \\left( \\begin{array}{c c c c} 0 &amp;amp; 1 &amp;amp; 2 &amp;amp; 3 \\\\ &amp;amp; \\dots &amp;amp; W - 1 &amp;amp; W \\\\ 1 &amp;amp; 2 &amp;amp; 4 &amp;amp; 8 \\\\ &amp;amp; \\ddots &amp;amp; 2 ^ {W - 1} &amp;amp; 0 \\end{array} \\right)</span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">M _ {0} = \\left( \\begin{array}{c} M _ {\\text {a d d r}, 0} \\\\ M _ {v, 0} \\\\ M _ {u s d, 0} \\end{array} \\right) = \\left( \\begin{array}{c c c c} 0 &amp;amp; 1 &amp;amp; \\ldots &amp;amp; M - 1 \\\\ v _ {0} &amp;amp; v _ {1} &amp;amp; \\ldots &amp;amp; v _ {M - 1} \\\\ 0 &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\end{array} \\right) \\quad M _ {1} = \\left( \\begin{array}{c} M _ {\\text {a d d r}, 1} \\\\ M _ {v, 1} \\\\ M _ {u s d, 1} \\end{array} \\right) = \\left( \\begin{array}{c c c c} 0 &amp;amp; 1 &amp;amp; \\ldots &amp;amp; M - 1 \\\\ v _ {0} &amp;amp; v _ {1} &amp;amp; \\ldots &amp;amp; v _ {M - 1} \\\\ 1 &amp;amp; 1 &amp;amp; \\ldots &amp;amp; 1 \\end{array} \\right)</span></div>

    <p class="text-gray-300">and <span class="math">(k_{\\frac{W}{2} -1},\\ldots ,k_0)</span> is the binary expansion of <span class="math">k</span>.</p>

    <p class="text-gray-300">In order to show that the tables are committed to in the above manner the prover will show that the first row each of the matrices describing [Exe] is a shift the last row.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\text {f o r m a t}} = \\left\\{ \\begin{array}{l} (p p, u, w) = ((W, K, \\mathbb {F}, *, [ \\mathsf {E} ], \\bot) \\mid \\\\ \\text {f o r} 1 \\leq j \\leq k - 1: [ \\mathsf {E} ] _ {\\ell , j} = [ \\mathsf {E} ] _ {1, j + 1} \\end{array} \\right\\}</span></div>

    <h2 id="sec-30" class="text-2xl font-bold">4.2 Proof for Correct TinyRAM Execution in the ILC Model</h2>

    <p class="text-gray-300">Given the witness for the correct execution of a TinyRAM program, we now describe how a prover can use the ILC channel to convince a verifier that the trace satisfies the relation <span class="math">\\mathcal{R}_{\\mathrm{TinyRAM}}^{\\mathrm{field}}</span> corresponding to the correct program execution. The prover and verifier are given in Figure 12.</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> <span class="math">(\\mathcal{K}_{\\mathrm{ILC}},\\mathcal{P}_{\\mathrm{TinyRAM}},\\mathcal{V}_{\\mathrm{TinyRAM}})</span> is a proof system for <span class="math">\\mathcal{R}_{\\mathrm{TinyRAM}}</span> over the ILC channel with perfect completeness, statistical knowledge soundness with straight-line extraction, and perfect special honest-verifier zero-knowledge.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PTinyRAM(ppILC,u,w)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V TinyRAM(ppILC,u)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Parse u=(P,v,T,M).</td>

            <td class="px-3 py-2 border-b border-gray-700">- parse u={[E],[P],[M],[R]}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Extend w to w and parse it as {E_t,Epc,Emin,E,t,Eng0,...,Engq-1,...}as in Sec. {Ppc,Pmin,...,M0,adjk,M0,sat,...,R}as in Sec. tion 4.1. Commit w in this form to the ILC channel.</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vcheck(ppILC,u) - Vmem(ppILC,u) - Vstop(ppILC,u) - Vformat(ppILC,[E]) - Return 1 if all checks pass Return 0 otherwise</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  - Pcheck(ppILC,u,w) |   |</p>

    <p class="text-gray-300">|  - Pmem(ppILC,u,w) |   |</p>

    <p class="text-gray-300">|  - Pstop(ppILC,u,w) |   |</p>

    <p class="text-gray-300">|  - Pformat(ppILC,u,w) |   |</p>

    <p class="text-gray-300">Proof. Perfect completeness follows from the perfect completeness of the sub-proofs. Perfect SHVZK follows from the perfect SHVZK of the sub-proofs. A simulated transcript is obtained by combining the outputs of the simulators of all the sub-proofs. Statistical knowledge soundness follows from the knowledge soundness of the sub-proofs. Since all sub-proofs have knowledge soundness with straight-line extraction, so does the main proof.  <span class="math">\\square</span></p>

    <p class="text-gray-300">The efficiency of our TinyRAM proof in the ILC model is given in Figure 13. The asymptotic results displayed below are obtained when the parameter  <span class="math">k</span>  specified by  <span class="math">pp_{\\mathrm{ILC}}</span>  is approximately  <span class="math">\\sqrt{T}</span> . The query complexity  <span class="math">\\mathrm{qc}</span>  is the number of linear combinations the verifier queries from the ILC channel in the opening query. The verifier communication  <span class="math">C_{\\mathrm{ILC}}</span>  is the number of messages sent from the verifier to the prover via the ILC channel and in our proof system it is proportional to the number of rounds. Let  <span class="math">\\mu</span>  be the number of rounds in the ILC proof and  <span class="math">t_1, \\ldots, t_\\mu</span>  be the numbers of vectors that the prover sends to the ILC channel in each round, and let  <span class="math">t = \\sum_{i=1}^{\\mu} t_i</span> .</p>

    <p class="text-gray-300">Fig. 12: Proof of correct TinyRAM execution in the ILC model</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover computation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">TPILC = O(T) multiplications in F</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verifier computation</td>

            <td class="px-3 py-2 border-b border-gray-700">TVILC = poly(λ)(L +</td>

            <td class="px-3 py-2 border-b border-gray-700">v</td>

            <td class="px-3 py-2 border-b border-gray-700">+ √T) multiplications in F</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Query complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">qc = O(1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verifier communication</td>

            <td class="px-3 py-2 border-b border-gray-700">CILC = O(log log T) field elements</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Round complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">μ = O(log log T)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Total number of committed vectors</td>

            <td class="px-3 py-2 border-b border-gray-700">t = O(√T) vectors in Fk</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 13: Efficiency of our TinyRAM proof in the ILC model for  <span class="math">(pp, u, w) \\in \\mathcal{R}_{\\mathrm{TinyRAM}}</span> . Here we are assuming that the number of instructions and words of memory  <span class="math">L, M &amp;lt; \\sqrt{T}</span> , and that the number of registers  <span class="math">K</span>  is constant.</p>

    <p class="text-gray-300">5 Proofs for the Correct Program Execution over the Standard Channel</p>

    <p class="text-gray-300">In the previous section we gave an efficient SHVZK proof of knowledge over the ILC channel for correct TinyRAM program execution. We now want to give a SHVZK proof of knowledge for correct TinyRAM program execution in the standard communication model where messages are exchanged directly between prover and verifier. To do this, we use the compiler from Bootle et al. <em>[BCG^{+}17]</em> who use an error-correcting code and a collision-resistant hash function to compile a zero-knowledge proof over the ILC channel to a zero-knowledge proof over the standard communication channel. In the compilation the hash function is used to instantiate a non-interactive commitment scheme which realizes the commitment functionality of the ILC in the standard model. The compilation by Bootle et al. relies on a common reference string that specifies the error-correcting code and the hash function. However, the common reference string is instance-independent, it just sets up an ILC channel. Moreover, it can be generated from uniformly random bits in <span class="math">\\text{poly}(\\lambda)(L+M+\\sqrt{T})</span> TinyRAM steps and has similar size, so it has little effect on the overall performance of the system.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">5.0.1 Linear Error-Correcting Codes With Linear Distance.</h4>

    <p class="text-gray-300">A linear code over a finite field <span class="math">\\mathbb{F}</span> encodes messages in <span class="math">\\mathbb{F}^{k}</span> as codewords in <span class="math">\\mathbb{F}^{n}</span>. The code <span class="math">\\mathcal{C}</span> is defined by an <span class="math">\\mathbb{F}</span>-linear map <span class="math">\\mathsf{E}_{\\mathcal{C}}:\\mathbb{F}^{k}\\to\\mathbb{F}^{n}</span>. The rate of the code is defined to be <span class="math">\\frac{k}{n}</span> and the minimum Hamming distance <span class="math">\\mathsf{hd}_{\\min}</span> is the smallest number of entries two distinct codewords <span class="math">\\boldsymbol{x},\\boldsymbol{y}\\in\\mathbb{F}^{n}</span> differ in. We need our codes to be efficiently generatable, i.e., there should be a polynomial time setup algorithm <span class="math">\\text{Gen}_{\\mathsf{E}_{\\mathcal{C}}}</span> that given <span class="math">\\mathbb{F}</span> and <span class="math">k</span> outputs an encoding function <span class="math">\\mathsf{E}_{\\mathcal{C}}</span></p>

    <p class="text-gray-300">In the compilation of proof systems over the ILC channel to the standard channel, Bootle et al. use efficiently generatable codes with constant rate and linear minimum distance, i.e., <span class="math">n=\\mathcal{O}(k)</span> and <span class="math">\\frac{k}{n}=\\Omega(1)</span>. From a computational perspective it will be desirable for the codes to be as efficiently encodable as possible. A rich body of research <em>[x10, x23, x11, x12, x13, x14, CDD^{+}16]</em> has studied constant-rate linear minimum distance codes that also have linear-time encoding. Druk and Ishai <em>[x12]</em> for instance show that there are constants <span class="math">\\nu&gt;1,\\delta&gt;0</span> such that for every finite field <span class="math">\\mathbb{F}</span> there is an efficiently generatable family of codes with dimension <span class="math">n=\\lceil\\nu k\\rceil</span> and minimum distance <span class="math">\\mathsf{hd}_{\\min}=\\lfloor\\delta k\\rfloor</span>, where the encoding functions only use <span class="math">\\mathcal{O}(k)</span> field additions.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">5.0.2 Linear-Time Non-Interactive Commitments.</h4>

    <p class="text-gray-300">A commitment scheme allows a prover to commit to a secret message. The prover may then later open the commitment and reveal the message inside. Once the commitment has been sent, the prover cannot open the same commitment to two different messages, a property known as binding. At the same time the commitment does not reveal the committed message to the receiver, a property known as hiding.</p>

    <p class="text-gray-300">Halevi and Micali <em>[x15]</em> show that a collision-resistant hash function gives rise to a compact statistically hiding commitment scheme. Their transformation</p>

    <p class="text-gray-300">is very efficient, so starting with a linear-time hash function such as the one by Applebaum et al.  <span class="math">\\mathrm{[AHI^{+}17]}</span> , which is public coin, we obtain a linear-time public-coin statistically hiding commitment scheme.</p>

    <p class="text-gray-300">Let now  <span class="math">(\\mathcal{K}_{\\mathrm{ILC}},\\mathcal{P}_{\\mathrm{ILC}},\\mathcal{V}_{\\mathrm{ILC}})</span>  be a proof for a relation  <span class="math">\\mathcal{R}</span>  over the ILC channel that is straight-line extractable and where all the verifier queries are sent in parallel at the end. Bootle et al. adapt the setup algorithm to take the field  <span class="math">\\mathbb{F}</span>  and vector size  <span class="math">k</span>  specified in the ILC parameters and generate a matching linear-distance linear error correcting code  <span class="math">\\mathsf{E}_{\\mathcal{C}}:\\mathbb{F}^k\\to \\mathbb{F}^n</span>  and a commitment key  <span class="math">ck</span>  that will be included in the public parameters alongside the original ILC parameters  <span class="math">pp_{\\mathrm{ILC}}</span> .</p>

    <p class="text-gray-300">Figure 14 illustrates the instantiation of the ILC model. The core idea is to commit to a vector by first mapping it into a codeword and then apply the commitment scheme to entries in the codeword. For high efficiency, this is done not just on one vector at a time but to a batch of vectors  <span class="math">\\pmb{v}_1, \\dots, \\pmb{v}_m</span>  at once. More precisely, the vectors  <span class="math">\\pmb{v}_1, \\dots, \\pmb{v}_m</span>  are organised as rows in a matrix  <span class="math">V</span>  and then each row is encoded. Let us define  <span class="math">E = \\mathsf{E}_{\\mathcal{C}}(V)</span>  as the matrix where the rows are the corresponding codewords  <span class="math">\\pmb{e}_1, \\dots, \\pmb{e}_m</span>  and let us write  <span class="math">E_j</span>  for column  <span class="math">j</span>  of the matrix  <span class="math">E</span> . Bootle et al. suggest committing to the row vectors in  <span class="math">V</span>  by committing to each column of the matrix  <span class="math">E = \\mathsf{E}_{\\mathcal{C}}(V)</span> , giving commitments  <span class="math">c_1, \\dots, c_n</span> .</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 14: Vectors  <span class="math">\\pmb{v}_1, \\dots, \\pmb{v}_m</span>  organized in matrix  <span class="math">V</span>  are encoded row-wise as matrix  <span class="math">E = \\mathsf{E}_{\\mathcal{C}}(V)</span> . The prover commits to each column of  <span class="math">E</span>  and given query  <span class="math">\\pmb{q} = (q_1, \\dots, q_m) \\in \\mathbb{F}^m</span>  for a linear combination she sends  <span class="math">\\pmb{v} = \\pmb{q}V</span> . The verifier now asks for openings of  <span class="math">\\lambda</span>  columns  <span class="math">\\{j_1, \\dots, j_\\lambda\\}</span>  in  <span class="math">E</span>  and verifies for these columns that  <span class="math">\\mathsf{E}_{\\mathcal{C}}(\\pmb{v})_j = \\pmb{q}E_j</span> . If the spot checks pass, the verifier believes that  <span class="math">\\pmb{v} = \\pmb{q}V</span> .</p>

    <p class="text-gray-300">Later when the verifier makes a query to the ILC channel to open some linear combination of the vectors  <span class="math">\\pmb{v}_1, \\dots, \\pmb{v}_m</span>  the prover will first send the resulting linear combination  <span class="math">\\pmb{v} = \\sum_{i=1}^{m} q_i \\pmb{v}_i</span> . The verifier can now pick at random a set of columns to open, for instance  <span class="math">\\lambda</span>  columns indexed by  <span class="math">j_1, \\dots, j_\\lambda</span> . The prover opens the corresponding commitments  <span class="math">c_{j_1}, \\dots, c_{j_\\lambda}</span>  to the verifier by revealing the field elements and randomness.</p>

    <p class="text-gray-300">If the prover is honest we should have <span class="math">\\bm{v}=\\sum_{i=1}^{m}\\bm{v}_{i}</span> and since the code is linear <span class="math">\\mathsf{E}_{\\mathcal{C}}(\\bm{v})=\\sum_{i=1}^{m}q_{i}\\bm{e}_{i}</span>. The verifier spot checks in the opened columns that this is indeed the case. Since the verifier only needs to encode one codeword and check on <span class="math">\\lambda</span> columns this is highly efficient for the verifier. Yet, since the code has linear minimum distance a cheating prover has overwhelming probability of being caught unless each row in the committed <span class="math">E</span> is close to a codeword and the encoded vectors <span class="math">\\bm{v}_{1},\\ldots,\\bm{v}_{m}</span> indeed do satisfy <span class="math">\\bm{v}=\\sum_{i=1}^{m}q_{i}\\bm{v}_{i}</span>.</p>

    <p class="text-gray-300">The idea as described is not zero-knowledge because revealing parts of a codeword leaks information about the encoded vector. However, by replacing the encoding with a randomized exposure-resilient encoding and some other modifications, Bootle et al. get an instantiation of the ILC channel where the prover only has negligible chance of opening a wrong linear combination of the committed vectors. The following theorem follows directly from their work.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Theorem 2 (Bootle et al. <em>[BCG^{+}17]</em>).</h6>

    <p class="text-gray-300">Using a linear-distance linear error-correcting code and a statistically-hiding commitment scheme, we can compile a public-coin straight-line extractable proof <span class="math">(\\mathcal{K}_{\\mathsf{ILC}},\\mathcal{P}_{\\mathsf{ILC}},\\mathcal{V}_{\\mathsf{ILC}})</span> for a relation <span class="math">\\mathcal{R}</span> over the ILC channel to a proof <span class="math">(\\mathcal{K},\\mathcal{P},\\mathcal{V})</span> for <span class="math">\\mathcal{R}</span> over the standard channel. The compilation is computationally knowledge sound, statistically SHVZK, and preserves perfect completeness of the ILC proof.</p>

    <p class="text-gray-300">If instead of being statistically hiding the commitment scheme is statistically binding, the compilation gives a statistically knowledge sound and computationally SHVZK proof system. However, since our main interest is to get high efficiency we want the commitment scheme to be compact to get low communication and we therefore do not consider statistically binding commitments here.</p>

    <p class="text-gray-300">Combining the above with Theorem 1 we get our main theorem.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Theorem 3 (Main theorem).</h6>

    <p class="text-gray-300">Compiling the ILC proof system <span class="math">(\\mathcal{K}_{\\mathsf{ILC}},\\mathcal{P}_{\\mathrm{TinyRAM}},</span> <span class="math">\\mathcal{V}_{\\mathrm{TinyRAM}})</span> of Fig. 12, we get a proof system over the standard channel for correct TinyRAM program execution with perfect completeness, statistical SHVZK, and computational knowledge soundness assuming the existence of collision-resistant hash functions. Moreover, using coin flipping as described in Section 2.2 we get a proof system for correct TinyRAM program execution with perfect completeness, statistical zero-knowledge, and computational knowledge soundness.</p>

    <p class="text-gray-300">In the following section we detail the efficiency of the proof system obtained by compiling the proof system of Fig. 12.</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">5.2 Efficiency of the compiled TinyRAM Proof System</h3>

    <p class="text-gray-300">Computation is feasible only when it is polynomial in the security parameter, i.e., <span class="math">T=\\mathrm{poly}(\\lambda)</span> and <span class="math">M=\\mathrm{poly}(\\lambda)</span>. Assuming <span class="math">T,M\\geq\\lambda</span>, this means <span class="math">\\log T=\\Theta(\\log\\lambda)</span> and <span class="math">\\log M=\\Theta(\\log\\lambda)</span>. To address all memory we therefore need <span class="math">W=\\Omega(\\log\\lambda)</span>. To keep the circuit size of a processor modest, it is reasonable to keep the word size low, so we will assume <span class="math">W=\\Theta(\\log\\lambda)</span>. Our proof system also works for larger word size but it is less efficient when the word size is superlogarithmic. Note that</p>

    <p class="text-gray-300">we can at the cost of a constant factor overhead store register values in memory and therefore without loss of generality assume  <span class="math">K = \\mathcal{O}(1)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To get negligible knowledge error we need the field to have superpolynomial size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\lambda^{\\omega(1)}<span class="math"> . This means we need a superconstant ratio  </span>e = \\frac{\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{W} = \\omega(1)<span class="math"> . On a TinyRAM machine, field elements require  </span>e<span class="math">  words to store and using school book arithmetic field operations can be implemented in  </span>\\alpha = \\mathcal{O}(e^2)$  steps</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our proof system is designed for a setting where the running time is large, so we will assume  <span class="math">T \\gg L + M</span> . In the ILC proof for correct program execution the prover commits to  <span class="math">\\mathcal{O}(T)</span>  field elements and uses  <span class="math">\\mathcal{O}(T)</span>  field operations. The verifier on the other hand, only uses  $\\mathcal{O}(L +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\sqrt{T})$  field operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To compile the ILC proof into a proof over the standard channel, Bootle et al. use a linear-time collision-resistant hash function and linear error-correcting codes. The collision-resistant hash function by Applebaum et al.  <span class="math">\\mathrm{[AHI^{+}17]}</span>  based on the bSVP assumption for sparse matrices is computable in linear time and can be used to instantiate the statistically hiding commitment scheme used in the compilation. As the hash function operates over bit-strings we need to ensure that the efficiency is preserved once implemented in a TinyRAM program. If we stored each bit in a separate word of size  <span class="math">W = \\Theta (\\log \\lambda)</span>  we would incur a logarithmic overhead. However, the hash function is computable by a linear-size boolean circuit and we can therefore apply a bit-slicing technique. We view the hash of an  <span class="math">n</span> -word string as  <span class="math">W</span>  parallel hashes of  <span class="math">n</span> -bit strings. Each of the bit-strings is processed with the same boolean circuit, which means they can computed in parallel in one go by a TinyRAM program using a linear number of steps.</p>

    <p class="text-gray-300">The error-correcting codes by Druk and Ishai [DI14] have constant rate and can be computed with a linear number of field additions. Applying the error-correcting codes therefore only changes the prover and verifier complexities by constant factors during the compilation. This means the compilation preserves the efficiency of the ILC proof up to constant factors. Taking into account the overhead of doing field operations, we summarize the efficiency of our proof system in Table 15.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Field operations</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">TinyRAM operations</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Prover Computation</td>

            <td class="px-3 py-2 border-b border-gray-700">O(T) operations in F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(αT) TinyRAM steps</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verifier Computation</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(λ)(L+</td>

            <td class="px-3 py-2 border-b border-gray-700">v</td>

            <td class="px-3 py-2 border-b border-gray-700">+√T) ops in F</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(λ)(L+</td>

            <td class="px-3 py-2 border-b border-gray-700">v</td>

            <td class="px-3 py-2 border-b border-gray-700">+√T) steps</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Communication</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(λ)√T field elements</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(λ)√T words</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Round Complexity</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log log T)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log log T)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fig. 15: Efficiency of our proof system for  <span class="math">\\mathcal{R}_{\\mathrm{TinyRAM}}</span>  under the assumption  <span class="math">W = \\Theta (\\log \\lambda)</span> ,  <span class="math">K = \\mathcal{O}(1)</span> ,  <span class="math">L + M &amp;lt; T \\approx 2^{W}</span> ,  <span class="math">k \\approx \\sqrt{T}</span> , and  $\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\Theta (\\sqrt{\\alpha})\\log \\lambda<span class="math">  for an arbitrarily small  </span>\\alpha = \\omega (1)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>AHI^{+}17. Benny Applebaum, Naama Haramaty, Yuval Ishai, Eyal Kushilevitz, and Vinod Vaikuntanathan. Low-complexity cryptographic hash functions. Electronic Colloquium on Computational Complexity (ECCC), 24:8, 2017.</li>

      <li>AHIV17. Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkita-subramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In Conference on Computer and Communications Security, CCS 2017, pages 2087–2104, 2017.</li>

      <li>AS98. Sanjeev Arora and Shmuel Safra. Probabilistic checking of proofs: A new characterization of NP. J. ACM, 45(1):70–122, 1998.</li>

      <li>BBC^{+}17. Eli Ben-Sasson, Iddo Bentov, Alessandro Chiesa, Ariel Gabizon, Daniel Genkin, Matan Hamilis, Evgenya Pergament, Michael Riabzev, Mark Silberstein, Eran Tromer, and Madars Virza. Computational integrity with a public random string from quasi-linear pcps. In EUROCRYPT 2017, pages 551–579, 2017.</li>

      <li>BCC^{+}16. Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In EUROCRYPT 2016, pages 327–357, 2016.</li>

      <li>BCCT12. Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In Innovations in Theoretical Computer Science ITCS 2012, pages 326–349, 2012.</li>

      <li>BCCT13. Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for SNARKS and proof-carrying data. In Symposium on Theory of Computing Conference, STOC’13, pages 111–120, 2013.</li>

      <li>BCG^{+}13. Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. Snarks for C: verifying program executions succinctly and in zero knowledge. In CRYPTO 2013, pages 90–108, 2013.</li>

      <li>BCG^{+}17. Jonathan Bootle, Andrea Cerulli, Essam Ghadafi, Jens Groth, Mohammad Hajiabadi, and Sune K. Jakobsen. Linear-time zero-knowledge proofs for arithmetic circuit satisfiability. In ASIACRYPT 2017, pages 336–365, 2017.</li>

      <li>BCS16. Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In Theory of Cryptography, TCC 2016-B, pages 31–60, 2016.</li>

      <li>BCTV14a. Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Scalable zero knowledge via cycles of elliptic curves. In CRYPTO 2014, pages 276–294, 2014.</li>

      <li>BCTV14b. Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive zero knowledge for a von neumann architecture. In Proceedings of the 23rd USENIX Security Symposium., pages 781–796, 2014.</li>

      <li>BFM88. Manuel Blum, Paul Feldman, and Silvio Micali. Non-interactive zero-knowledge and its applications (extended abstract). In ACM Symposium on Theory of Computing, STOC’98, pages 103–112, 1988.</li>

      <li>BFR^{+}13. Benjamin Braun, Ariel J. Feldman, Zuocheng Ren, Srinath T. V. Setty, Andrew J. Blumberg, and Michael Walfish. Verifying computations with state. In ACM Symposium on Operating Systems Principles, SOSP, pages 341–357, 2013.</li>

      <li>BG12. Stephanie Bayer and Jens Groth. Efficient zero-knowledge argument for correctness of a shuffle. In EUROCRYPT 2012, pages 263–280, 2012.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BP12] Nir Bitansky and Omer Paneth. Point obfuscation and 3-round zero-knowledge. In Theory of Cryptography - TCC 2012, pages 190–208, 2012.</li>

      <li>[BSCG^{+}13] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza. Tinyram architecture specification, v0. 991, 2013.</li>

      <li>[CD98] Ronald Cramer and Ivan Damgård. Zero-knowledge proofs for finite field arithmetic; or: Can zero-knowledge be for free? In CRYPTO ’98, pages 424–441, 1998.</li>

      <li>[CDD^{+}16] Ignacio Cascudo, Ivan Damgård, Bernardo David, Nico Döttling, and Jesper Buus Nielsen. Rate-1, linear time and additively homomorphic UC commitments. In CRYPTO 2016, pages 179–207, 2016.</li>

      <li>[CDG^{+}17] Melissa Chase, David Derler, Steven Goldfeder, Claudio Orlandi, Sebastian Ramacher, Christian Rechberger, Daniel Slamanig, and Greg Zaverucha. Post-quantum zero-knowledge and signatures from symmetric-key primitives. In ACM Conference on Computer and Communications Security, CCS 2017, pages 1825–1842, 2017.</li>

      <li>[CMT12] Graham Cormode, Michael Mitzenmacher, and Justin Thaler. Practical verified computation with streaming interactive proofs. In Innovations in Theoretical Computer Science, ITCS’12, pages 90–112, 2012.</li>

      <li>[CTV15] Alessandro Chiesa, Eran Tromer, and Madars Virza. Cluster computing in zero knowledge. In EUROCRYPT 2015, pages 371–403, 2015.</li>

      <li>[DI14] Erez Druk and Yuval Ishai. Linear-time encodable codes meeting the gilbert-varshamov bound and their cryptographic applications. In Innovations in Theoretical Computer Science, ITCS’14, pages 169–182, 2014.</li>

      <li>[FNO15] Tore Kasper Frederiksen, Jesper Buus Nielsen, and Claudio Orlandi. Privacy-free garbled circuits with applications to efficient zero-knowledge. In EUROCRYPT 2015, pages 191–219, 2015.</li>

      <li>[FS86] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In CRYPTO ’86, pages 186–194, 1986.</li>

      <li>[FS90] Uriel Feige and Adi Shamir. Witness indistinguishable and witness hiding protocols. In ACM Symposium on Theory of Computing, STOC 1990, pages 416–426, 1990.</li>

      <li>[GDP73] S. I. Gelfand, R. L. Dobrushin, and M. S. Pinsker. On the complexity of coding. In 2nd International Symposium of Information Theory, pages 177–184, 1973.</li>

      <li>[Gen09] Craig Gentry. Computing on encrypted data. In Cryptology and Network Security,CANS 2009, page 477, 2009.</li>

      <li>[GGI^{+}15] Craig Gentry, Jens Groth, Yuval Ishai, Chris Peikert, Amit Sahai, and Adam D. Smith. Using fully homomorphic hybrid encryption to minimize non-interative zero-knowledge proofs. J. Cryptology, 28(4):820–843, 2015.</li>

      <li>[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct nizks without pcps. In EUROCRYPT 2013, pages 626–645, 2013.</li>

      <li>[GI01] Venkatesan Guruswami and Piotr Indyk. Expander-based constructions of efficiently decodable codes. In Symposium on Foundations of Computer Science, FOCS 2001, pages 658–667, 2001.</li>

      <li>[GI02] Venkatesan Guruswami and Piotr Indyk. Near-optimal linear-time codes for unique decoding and new list-decodable codes over smaller alphabets. In ACM Symposium on Theory of Computing, STOC 2002, pages 812–821, 2002.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GI03] Venkatesan Guruswami and Piotr Indyk. Linear time encodable and list decodable codes. In ACM Symposium on Theory of Computing, STOC 2003, pages 126–135, 2003.</li>

      <li>[GI05] Venkatesan Guruswami and Piotr Indyk. Linear-time encodable/decodable codes with near-optimal rate. IEEE Trans. Information Theory, 51(10):3393–3400, 2005.</li>

      <li>[GI08] Jens Groth and Yuval Ishai. Sub-linear zero-knowledge argument for correctness of a shuffle. In EUROCRYPT 2008, pages 379–396, 2008.</li>

      <li>[GKR08] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. Delegating computation: interactive proofs for muggles. In Proceedings of the 40th Annual ACM Symposium on Theory of Computing, Victoria, British Columbia, Canada, May 17-20, 2008, pages 113–122, 2008.</li>

      <li>[GMO16] Irene Giacomelli, Jesper Madsen, and Claudio Orlandi. Zkboo: Faster zero-knowledge for boolean circuits. In 25th USENIX Security Symposium, pages 1069–1083, 2016.</li>

      <li>[GMR85] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof-systems (extended abstract). In ACM Symposium on Theory of Computing, STOC 1985, pages 291–304, 1985.</li>

      <li>[Gro09] Jens Groth. Linear algebra with sub-linear zero-knowledge arguments. In CRYPTO 2009, pages 192–208, 2009.</li>

      <li>[Gro10a] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In ASIACRYPT 2010, pages 321–340, 2010.</li>

      <li>[Gro10b] Jens Groth. A verifiable secret shuffle of homomorphic encryptions. J. Cryptology, 23(4):546–579, 2010.</li>

      <li>[Gro16] Jens Groth. On the size of pairing-based non-interactive arguments. In EUROCRYPT 2016, pages 305–326, 2016.</li>

      <li>[HM96] Shai Halevi and Silvio Micali. Practical and provably-secure commitment schemes from collision-free hashing. In CRYPTO ’96, pages 201–215, 1996.</li>

      <li>[IKO07] Yuval Ishai, Eyal Kushilevitz, and Rafail Ostrovsky. Efficient arguments without short pcps. In IEEE Conference on Computational Complexity, CCC 2007, pages 278–291, 2007.</li>

      <li>[IKOS09] Yuval Ishai, Eyal Kushilevitz, Rafail Ostrovsky, and Amit Sahai. Zero-knowledge proofs from secure multiparty computation. SIAM J. Comput., 39(3):1121–1152, 2009.</li>

      <li>[JKO13] Marek Jawurek, Florian Kerschbaum, and Claudio Orlandi. Zero-knowledge using garbled circuits: how to prove non-algebraic statements efficiently. In ACMConference on Computer and Communications Security, CCS’13, pages 955–966, 2013.</li>

      <li>[Kil92] Joe Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In ACM Symposium on Theory of Computing, STOC 1992, pages 723–732, 1992.</li>

      <li>[KR08] Yael Tauman Kalai and Ran Raz. Interactive PCP. In ICALP 2008, pages 536–547, 2008.</li>

      <li>[Nef01] C. Andrew Neff. A verifiable secret shuffle and its application to e-voting. In ACM Conference on Computer and Communications Security, CCS 2001, pages 116–125, 2001.</li>

      <li>[PHGR16] Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: nearly practical verifiable computation. Commun. ACM, 59(2):103–112, 2016.</li>

      <li>[Sch91] Claus-Peter Schnorr. Efficient signature generation by smart cards. J. Cryptology, 4(3):161–174, 1991.</li>

    </ul>

    <p class="text-gray-300">Spi96. Daniel A. Spielman. Linear-time encodable and decodable error-correcting codes. IEEE Trans. Information Theory, 42(6):1723–1731, 1996.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Tha13. Justin Thaler. Time-optimal interactive proofs for circuit evaluation. In CRYPTO 2013, volume 8043 of Lecture Notes in Computer Science, pages 71–89, 2013.</li>

      <li>WHG^{+}16. Riad S. Wahby, Max Howald, Siddharth Garg, Abhi Shelat, and Michael Walfish. Verifiable ASICs. In IEEE Symposium on Security and Privacy, SP 2016, pages 759–778, 2016.</li>

      <li>WJB^{+}17. Riad S. Wahby, Ye Ji, Andrew J. Blumberg, Abhi Shelat, Justin Thaler, Michael Walfish, and Thomas Wies. Full accounting for verifiable outsourcing. In ACM Conference on Computer and Communications Security, CCS 2017, pages 2071–2086, 2017.</li>

      <li>WSR^{+}15. Riad S. Wahby, Srinath T. V. Setty, Zuocheng Ren, Andrew J. Blumberg, and Michael Walfish. Efficient RAM and control flow in verifiable outsourced computation. In Network and Distributed System Security Symposium, NDSS 2015, 2015.</li>

      <li>WTas^{+}17. Riad S. Wahby, Ioanna Tzialla, abhi shelat, Justin Thaler, and Michael Walfish. Doubly-efficient zksnarks without trusted setup. Cryptology ePrint Archive, Report 2017/1132, 2017. https://eprint.iacr.org/2017/1132.</li>

      <li>ZGK^{+}17. Yupeng Zhang, Daniel Genkin, Jonathan Katz, Dimitrios Papadopoulos, and Charalampos Papamanthou. vsql: Verifying arbitrary SQL queries over dynamic outsourced databases. In IEEE Symposium on Security and Privacy, SP 2017, pages 863–880, 2017.</li>

      <li>ZGK^{+}18. Yupeng Zhang, Daniel Genkin, Jonathan Katz, Dimitrios Papadopoulos, and Charalampos Papamanthou. vram: Faster verifiable ram with program-independent preprocessing, 2018.</li>

    </ul>

    <p class="text-gray-300">A Layer 2 Proofs of Correct TinyRAM Execution</p>

    <p class="text-gray-300">Recall that we take a top down approach in order to describe how to check that program has been executed correctly in the ILC model. In Section 4 we gave the first layer for a proof for correct TinyRAM execution in the ILC model. This proof required provers for <span class="math">\\mathcal{R}_{\\text{format}}</span>, <span class="math">\\mathcal{R}_{\\text{check}}</span>, <span class="math">\\mathcal{R}_{\\text{mem}}</span>, and <span class="math">\\mathcal{R}_{\\text{step}}</span>. In this section we describe these provers in a model independent manner i.e. we give the second layer of provers. We will use provers for the relations <span class="math">\\mathcal{R}_{\\text{const}}</span>, <span class="math">\\mathcal{R}_{\\text{perm}}</span>, <span class="math">\\mathcal{R}_{\\text{range}}</span>, <span class="math">\\mathcal{R}_{\\text{eq}}</span>, <span class="math">\\mathcal{R}_{\\text{blookup}}</span> and <span class="math">\\mathcal{R}_{\\text{lookup}}</span>. Instantiations of these third layer provers will be given in the ILC model in Section B.</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">A.1 Checking the Algebraic Constraints</h3>

    <p class="text-gray-300">Many of the subproofs we use in checking memory consistency and correct execution trace include algebraic constraints on the variables in the form of quadratic equations. We shall store every quadratic constraint that needs checking in a list <span class="math">\\mathsf{const}</span>. For instance, suppose that in each row of the execution table the flag should satisfy <span class="math">\\mathsf{flag}(\\mathsf{flag}-1)=0</span> in order to guarantee it is a bit. Then the constraints list would equal <span class="math">\\mathsf{const}=\\{[E_{\\mathsf{flag}}]\\circ[E_{\\mathsf{flag}}-J]=[O])\\}</span> where <span class="math">J</span> is a committed matrix containing all ones and <span class="math">O</span> is a committed matrix containing all zeros. We then define the relation <span class="math">\\mathcal{R}_{\\mathsf{const}}</span> to be satisfied if and only if every constraint in the list constraints holds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathcal{R}_{\\mathsf{const}}=\\left\\{\\begin{array}[]{c}(pp,u,w)=((W,K,\\mathbb{F},*),(\\mathsf{const},[\\mathsf{w}]),\\mathsf{w})~{}\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\text{The committed value }[\\mathsf{w}]~{}\\text{satisfies all of the constraints in }\\mathsf{const}\\end{array}\\right\\}. \\]</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">A.2 Correct Format of Committed Matrices</h3>

    <p class="text-gray-300">Our execution table is committed in a particular format. The reason this is necessary is that we aim to check that each time step is carried out correctly. However, if there was no format to the entries, it would require addition checks to ensure that the final entry in a matrix column is correctly transitioned into the first entry in the next matrix column. Instead, we force the prover to repeat their the final entry into the first entry of the next column. This is the role of <span class="math">\\mathcal{R}_{\\text{format}}</span> whose proof is described in Figure 16. The proof simply consists of checking that a constraint relation holds.</p>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">A.3 Checking Correctness of Values</h3>

    <p class="text-gray-300">Figure 17 provides a proof that <span class="math">\\mathcal{R}_{\\text{check}}</span> holds i.e. that certain values in the tables have been committed to correctly.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">A.4 Memory Consistency</h3>

    <p class="text-gray-300">Figure 18 provides a proof that <span class="math">\\mathcal{R}_{\\mathsf{mem}}</span> holds i.e. that the memory is consistent. It uses the matrix of ones <span class="math">J=(1,1,\\ldots))</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pformat(ppILC, [E], E)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Vformat(ppILC, [E])</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- const = add checks for Rformat</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Vconst(ppILC, (const, [EI], [E1]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Pconst(ppILC, (const, [EI], [E1]))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Return 1 if all proofs accept, Return 0 otherwise</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 16: Argument that  <span class="math">\\mathcal{R}_{\\mathrm{format}}</span>  holds for a committed execution table.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pcheck(ppILC, (inst0, A0, answer, [w]), (E, P, M, R, S))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Vcheck(ppILC, (inst0, A0, answer, [E], [P], [M], [R], [S]))</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Initial program state correct. Preq(ppILC, (1, 0, inst0, 0, ...), [(EI)0,0, (Epr)0,0, (Einst)0,0, ...])</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vreq(ppILC, (1, 0, inst0, 0, ...), [(EI)0,0, (Epr)0,0, (Einst)0,0, ...])</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Final program state correct. Preq(ppILC, (T, L-1, answer, 0, ...), [(EI)I-1,k-1, (Epr)I-1,k-1, (Einst)I-1,k-1, ...])</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vreq(ppILC, (T, L-1, answer, 0, ...), [(EI)I-1,k-1, (Epr)I-1,k-1, (Einst)I-1,k-1, ...])</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Range table correct. Preq(ppILC, EvenBits, [R])</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vreq(ppILC, Pow, [S])</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Power table correct Preq(ppILC, Pow, [S])</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vreq(ppILC, Prog, ([P]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Program table correct. Preq(ppILC, Prog, ([P]))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vreq(ppILC, v, [Mv])</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Memory table correctly initialised with instance. Preq(ppILC, v, [Mv])</td>

            <td class="px-3 py-2 border-b border-gray-700">- Return 1 if all proofs accept, Return 0 otherwise</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 17: Prover and Verifier for Proof of Correctness of Values.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pmem(ppILC, ([E], [M]), (E, M, π))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Vmem(ppILC, ([E], [M]))</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Memory accesses form cycles in Exe i.e. Rcycle.</td>

            <td class="px-3 py-2 border-b border-gray-700">- [A1], ..., [A4], [B1], ..., [B4] = same as prover.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Set [A1] = [E1], [A2] = [Eaddr], [A3] = [Ee]</td>

            <td class="px-3 py-2 border-b border-gray-700">Run Vprem(ppILC, (T, { [A1], [B1]}i=1))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Commit to A4 = 5 + L</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vrange(ppILC, ([M1], [R]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Set [B1] = [Eτlink], [B2] = [Eaddr], [B3] = [Eelink], [B4] = [A4]</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vblockup(ppILC, ({[Eaddr], [Eelink], [Eaddr]}, [M]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">const = add checks for Rformat</td>

            <td class="px-3 py-2 border-b border-gray-700">Vconst(ppILC, (const, [E], [O], [J], [M1], [M2], [A4]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Pprov(ppILC, (T, { [A1], [B1]}i=1), π))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Return 1 if all proofs accept, Return 0 otherwise</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  - The cycles are in the correct order i.e. Rtime. |   |</p>

    <p class="text-gray-300">|  Commit to M1 = (J - Eadd) ∘ (Eτlink - E1) + Eadd ∘ (Ee - Eτlink - J) |   |</p>

    <p class="text-gray-300">|  const = add checks for Rtime |   |</p>

    <p class="text-gray-300">|  Prange(ppILC, [M1], [R]) |   |</p>

    <p class="text-gray-300">|  - Cycles are disjoint i.e. Rblockup |   |</p>

    <p class="text-gray-300">|  Pblockup(ppILC, {Eaddr, Eelink, Eadd}, [M])). |   |</p>

    <p class="text-gray-300">|  - Loads and stores are consistent i.e. Rload. |   |</p>

    <p class="text-gray-300">|  const = add checks for Rload |   |</p>

    <p class="text-gray-300">|  - Pconst(ppILC, (const, [E], [M1], [A4])) |   |</p>

    <p class="text-gray-300">Fig. 18: Prover and Verifier for Proof of Memory Consistency.</p>

    <p class="text-gray-300">Figure 19 provides a proof that  <span class="math">\\mathcal{R}_{\\mathrm{step}}</span>  holds i.e. that each step of the program has been evaluated correctly. It uses the matrix of ones  <span class="math">J = (1,1,\\ldots)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pstep(ppILC, ([E], [P], [R], [S]), (E, P, R, S))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Vstep(ppILC, ([E], [P], [R], [S]))</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Multiplexer relations are satisfied i.e. Rmax. const = add checks for Rmax</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vlookup(ppILC, { [Epr], [Ppr] })</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Exe and Prog are consistent i.e. Rconsistent. Plookup(ppILC, { [Epr], [Ppr] })</td>

            <td class="px-3 py-2 border-b border-gray-700">Vlookup{ pPILC, { [Epr], [Esat], [EA], [E5], [E1], [Eπa], [Preg] }</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Plookup{ pPILC, { [Epr], [Esat], [EA], [E5], [E1], [Eπa], [Preg] }</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vrange(ppILC, { [E4], [R]), Vrange(ppILC, { [E6], [R]), Vrange(ppILC, { [E1], [R]), Vrange(ppILC, { [E2], [R]), Vrange(ppILC, { [M3], [R]), Vrange(ppILC, { [M5], [R]), Vrange(ppILC, { [M7], [R]), Vrange(ppILC, { [M8], [R]), ( [M9], [Eepee]), [S]) }</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Instructions are satisfied i.e. Rins Logic instructions Prange(ppILC, { [E4], [R]), Prange(ppILC, { [E6], [R]), Prange(ppILC, { [E1], [R]), Prange(ppILC, { [E2], [R]), Prange(ppILC, { [M3], [R]), Prange(ppILC, { [M5], [R]),</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vconst(ppILC, { const, [E], [M3], ..., [M9] ) - Return 1 if all proofs accept, Return 0 otherwise</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Commit to M3 = Exe0, + Exe0, M4 = Exe0, + Exe0, Prange(ppILC, { [M3], [R]), Prange(ppILC, { [M4], [R] ) |   |</p>

    <p class="text-gray-300">|  const = add checks for Rlogic Arithmetic instructions Commit to M5 = Exe0, + (J - 2Exeσa)2W-2 M6 = Exe0, + (J - 2Exeσa)2W-2 M7 = Exe0, + (J - 2Exeσa)2W-2 const = add checks for Rarith Plookup(ppILC, { [M5], [R], { [M6], [R], { [M7], [R] } ) |   |</p>

    <p class="text-gray-300">|  Shift instructions Commit to M8 = Exe0, + (J - 2Exeσb), M9 = Exe0 + Exe0, + (WJ - Exe0) const = add checks for Rreath Plookup(ppILC, { [M8], [R], { [M9], [Eepee]), [S] } ) |   |</p>

    <p class="text-gray-300">|  - Pconst(ppILC, { const, [E], [M3], ..., [M9] ) |   |</p>

    <p class="text-gray-300">Fig. 19: Prover and Verifier for Correctness of Instruction Execution.</p>

    <p class="text-gray-300">The efficiency of the proof system is given in the following table, where  <span class="math">T_{\\mathcal{P}}</span>  and  <span class="math">T_{\\mathcal{V}}</span>  refers to the prover and verifier computation (measured in field operations), qc is the query complexity (measured in the number of linear combination the verifier asks for), and  <span class="math">t</span>  is the number of vectors the prover commits to during the proof.</p>

    <p class="text-gray-300">Recall that we take a top down approach in order to describe how to check that program has been executed correctly in the ILC model. In Appendix A we</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">TP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">TV</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">qc</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rformat</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kN log N + kMN) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kMN) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">log M + 2</td>

            <td class="px-3 py-2 border-b border-gray-700">O(MN)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rcheck</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">O(tk) add.</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rmem</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kN log N + kMN) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kMN) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">308</td>

            <td class="px-3 py-2 border-b border-gray-700">log M + 2</td>

            <td class="px-3 py-2 border-b border-gray-700">O(MN)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rdisp</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kN log N + kMN) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kMN) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">1452</td>

            <td class="px-3 py-2 border-b border-gray-700">log M + 2</td>

            <td class="px-3 py-2 border-b border-gray-700">O(MN)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: Efficiency of protocols in Layer 2. The values  <span class="math">M, N</span>  are tuneable parameters in the Hadamard product proof; good performance is achieved in the condition  <span class="math">N_{*} = MN</span> .</p>

    <p class="text-gray-300">gave the second layer for a proofs for correct TinyRAM execution in the ILC model. These proof required provers for  <span class="math">\\mathcal{R}_{\\mathrm{const}}</span> ,  <span class="math">\\mathcal{R}_{\\mathrm{perm}}</span> ,  <span class="math">\\mathcal{R}_{\\mathrm{range}}</span> ,  <span class="math">\\mathcal{R}_{\\mathrm{eq}}</span> ,  <span class="math">\\mathcal{R}_{\\mathrm{lookup}}</span> , and  <span class="math">\\mathcal{R}_{\\mathrm{lookup}}</span> . In this section we describe these provers in the ILC model i.e. we give the third layer of provers. We will use ILC provers for sums, products, known permutations, shifts, entry-products and grand sums. Instantiations or references for these fourth layer ILC provers will be given in Appendix C.</p>

    <p class="text-gray-300">Sums and Products Let  <span class="math">[A_1],\\ldots ,[A_n],[B]</span>  be matrices committed to the ILC. Then the relation  <span class="math">\\mathcal{R}_{\\mathrm{sum}}</span>  is given by</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {s u m}} = \\left\\{ \\begin{array}{c} (p p _ {\\mathrm {I L C}}, u) = ((\\mathbb {F}, k), (\\mathbf {v}, [ A _ {1} ], \\ldots , [ A _ {n} ], [ B ]), (A _ {1}, \\ldots , A _ {n}, B)): \\\\ \\mathbf {v} \\in \\mathbb {F} ^ {n} \\wedge A _ {1}, \\ldots , A _ {n}, B \\in \\mathbb {F} ^ {N _ {*} \\times k} \\quad \\wedge \\quad \\sum_ {i = 1} ^ {n} \\mathbf {v} _ {i} A _ {i} = B \\end{array} \\right\\}.</span></div>

    <p class="text-gray-300">Let  <span class="math">[A],[B],[C]</span>  be matrices committed to the ILC. Then the relation  <span class="math">\\mathcal{R}_{\\mathrm{prod}}</span>  is given by</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {p r o d}} = \\left\\{ \\begin{array}{c} (p p _ {\\mathrm {I L C}}, u) = ((\\mathbb {F}, k), ([ A ], [ B ], [ C ]), (A, B, C)): \\\\ A, B \\in \\mathbb {F} ^ {N M \\times k} \\quad \\wedge \\quad A \\circ B = C \\end{array} \\right\\}.</span></div>

    <p class="text-gray-300">Known Permutations Let  <span class="math">[A],[B]\\in \\mathbb{F}^{N_{<em>}\\times k}</span>  be matrices committed to the ILC, and  <span class="math">\\pi</span>  be a permutation  <span class="math">\\pi \\in \\Sigma_{[N_</em>] \\times [k]}</span> . Then the relation  <span class="math">\\mathcal{R}_{\\mathrm{kperm}}</span>  is given by</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {k p e r m}} = \\left\\{ \\begin{array}{c} (p p _ {\\mathrm {I L C}}, u) = ((\\mathbb {F}, k), (\\pi , [ A ], [ B ]), (A, B)): \\\\ A, B \\in \\mathbb {F} ^ {N _ {*} \\times k} \\quad \\wedge \\quad \\pi \\in \\Sigma_ {[ N _ {*} ] \\times [ k ]} \\quad \\text {a n d} \\quad A = B ^ {\\pi} \\end{array} \\right\\}.</span></div>

    <p class="text-gray-300">Shifts Let  <span class="math">[A],[B]</span> , be matrices committed to the ILC which have  <span class="math">MN</span>  rows, given respectively by vectors  <span class="math">\\mathbf{a}_{i,j},\\mathbf{b}_{i,j}\\in \\mathbb{F}^k</span> , with  <span class="math">0\\leq i\\leq M - 1,1\\leq j\\leq N</span> . The shift condition specifies that  <span class="math">A</span>  is a shift of  <span class="math">B</span> . This means that: the top-right element of  <span class="math">A</span>  is a 1; columns 2 up to  <span class="math">k</span>  of  <span class="math">A</span>  are equal to columns 1 up to  <span class="math">k - 1</span>  of  <span class="math">B</span> ; we can obtain the final column of  <span class="math">B</span>  from the first column of  <span class="math">A</span>  by deleting the first entry and appending some quantity. The relation  <span class="math">\\mathcal{R}_{\\mathrm{mshift}}</span>  is given by</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {m s h i f t}} = \\left\\{ \\begin{array}{c} (p p _ {\\mathrm {I L C}}, u) = ((\\mathbb {F}, k), ([ A ], [ B ]), (A, B)): \\\\ A, B \\mathrm {s a t i s f y t h e s h i f t c o n d i t i o n} \\end{array} \\right\\}.</span></div>

    <p class="text-gray-300">51</p>

    <p class="text-gray-300">Entry Products Let <span class="math">[A],[P]</span>, be matrices committed to the ILC where <span class="math">[P]</span> is committed by itself as the final entry of a vector whose other entries are all zero. Then then relation <span class="math">\\mathcal{R}_{\\text{entry-prod}}</span> is given by</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\text{entry-prod}} = \\left\\{ \\begin{array}{c} (pp_{\\mathrm{ILC}}, u) = ((\\mathbb{F}, k) \\, , \\, ([A], [P]), (A, P)) : \\\\ A \\in \\mathbb{F}^{N_* \\times k} \\quad \\wedge \\quad A = (a_{i,j}) \\\\ \\quad \\wedge \\quad P = \\prod_{i,j} a_{i,j} \\end{array} \\right\\}.</span></div>

    <p class="text-gray-300">Grandsum Let <span class="math">[A]</span> be a matrix committed to the ILC, and <span class="math">x \\in \\mathbb{F}</span>. Then the relation <span class="math">\\mathcal{R}_{\\text{grandsum}}</span> is given by</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\text{grandsum}} = \\left\\{ \\begin{array}{c} (pp_{\\mathrm{ILC}}, u) = ((\\mathbb{F}, k) \\, , \\, (x, [A]), (A)) : \\\\ A \\in \\mathbb{F}^{N_* \\times k} \\quad \\wedge \\quad \\sum_{i,j} a_{i,j} = x \\end{array} \\right\\}.</span></div>

    <h2 id="sec-46" class="text-2xl font-bold">B.2 Proofs of Correct Openings</h2>

    <p class="text-gray-300">In the ILC model, <span class="math">[\\mathrm{BCG}^{+}17]</span> gives a proof for checking consistency of committed vectors with values in the instance. In their proof, the prover <span class="math">\\mathcal{P}_{\\mathrm{eq}}</span> simply commits to a set of vectors by sending <span class="math">(\\mathrm{commit}, \\boldsymbol{u}_1, \\dots, \\boldsymbol{u}_t)</span> to the ILC channel. Let <span class="math">U = (\\boldsymbol{u}_i)_{i=1}^t</span> be the part of a given table that we are interested in. We denote by <span class="math">[U]</span> the committed values stored in the ILC. The verifier asks for a random linear combination of the corresponding vectors and checks it against the values <span class="math">\\boldsymbol{u}_1, \\dots, \\boldsymbol{u}_t</span> in the instance. The corresponding relation is</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\mathrm{eq}} = \\left\\{ \\begin{array}{c} (pp_{\\mathrm{ILC}}, u) = ((\\mathbb{F}, k), (\\boldsymbol{u}_1, \\dots, \\boldsymbol{u}_t, [U]), (U)) : \\\\ \\boldsymbol{u}_1, \\dots, \\boldsymbol{u}_t \\in \\mathbb{F}^k \\quad \\wedge \\quad U = (\\boldsymbol{u}_i)_{i=1}^t \\end{array} \\right\\}.</span></div>

    <p class="text-gray-300">Theorem 4 <span class="math">([\\mathbf{BCG}^{+}17])</span>. There is a proof system <span class="math">(\\mathcal{K}_{\\mathrm{ILC}},\\mathcal{P}_{\\mathrm{eq}},\\mathcal{V}_{\\mathrm{eq}})</span> for the relation <span class="math">\\mathcal{R}_{\\mathrm{eq}}</span> in the ILC model with perfect completeness, statistical knowledge soundness with straight-line extraction and perfect special honest verifier zero-knowledge.</p>

    <h2 id="sec-47" class="text-2xl font-bold">B.3 Arithmetic Constraints</h2>

    <p class="text-gray-300">Recall that the relation <span class="math">\\mathcal{R}_{\\mathrm{const}}</span> is given by</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\mathrm{const}} = \\left\\{ \\begin{array}{c} (pp, u, w) = ((W, K, \\mathbb{F}, *), (\\mathrm{const}, [\\mathsf{w}]), \\mathsf{w}) \\\\ \\text{The committed value } [\\mathsf{w}] \\text{ satisfies all of the constraints in const} \\end{array} \\right\\}.</span></div>

    <p class="text-gray-300">In order to simultaneously check that all of the different equations are satisfied, we use a quadratic arithmetic program (QAP) based approach [GGPR13]. Quadratic arithmetic programs are a means to batch together a set of quadratic equations with a single multiplication each into a polynomial equation. While QAPs have mainly been used to construct pairing-based SNARKs, we find that they can also be used in interactive proofs.</p>

    <p class="text-gray-300">We will extend the QAP approach to give a new batch-QAP argument for the same QAP holding over many sets of variables. We can specify the algebraic constraints over each consecutive rows in the execution table as a QAP. Now we need to prove the QAP holds over the variables in each of the  <span class="math">T - 1</span>  pairs of consecutive rows.</p>

    <p class="text-gray-300">Formally, we will be working with QAPs that have the following description</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {Q A P} = \\left(\\mathbb {F}, n, \\{u _ {i} (\\bar {X}), v _ {i} (\\bar {X}), w _ {i} (\\bar {X}) \\} _ {i = 0} ^ {m}, t (\\bar {X})\\right),</span></div>

    <p class="text-gray-300">where  <span class="math">1 \\leq n \\leq m</span> ,  <span class="math">u_{i}(X), v_{i}(X), w_{i}(X), t(X) \\in \\mathbb{F}[X]</span>  and  <span class="math">u_{i}(X), v_{i}(X), w_{i}(X)</span>  have strictly lower degree than  <span class="math">n</span> , the degree of  <span class="math">t(X)</span> . The polynomials can be determined from a list of quadratic constraints. In our case these are the constraints stored in const. A quadratic arithmetic program with such a description defines the following binary relation, where we define  <span class="math">a_{0} = 1</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} = \\left\\{ \\begin{array}{l} (p p _ {\\mathrm {I L C}}, u, w) = ((\\mathbb {F}, k), (x, \\mathsf {Q A P}), w): \\\\ x = (a _ {i}) _ {i = n} ^ {I} \\in \\mathbb {F} ^ {k}, w = (a _ {i}) _ {i = 1} ^ {n - 1} \\in \\mathbb {F} ^ {k} \\\\ \\exists z (X) \\in \\mathbb {F} [ X ], \\deg (h) \\leq n - 2: \\\\ (\\sum_ {i = 0} ^ {m} a _ {i} u _ {i} (X)) \\cdot (\\sum_ {i = 0} ^ {m} a _ {i} v _ {i} (X)) = \\sum_ {i = 0} ^ {m} a _ {i} w _ {i} (X) + z (X) t (X) \\end{array} \\right\\}.</span></div>

    <p class="text-gray-300">It follows from [GGPR13] that the algebraic constraints we have can be bundled together and expressed as a QAP. To provide a proof for a correct TinyRAM execution, we will require a batched argument for checking many identical QAPs using a single proof. For  <span class="math">x = (\\pmb{a}_{i,j})_{i=n,j=1}^{I,MN} \\in \\mathbb{F}^k</span>  and a witness known only to the prover  <span class="math">w = (\\pmb{a}_{i,j})_{i=1,j=1}^{n-1,MN} \\in \\mathbb{F}^k</span>  the prover shows that for all  <span class="math">j</span> , there is a polynomial  <span class="math">\\pmb{z}_j(X) \\in \\mathbb{F}^k[X]</span>  of  <span class="math">\\deg \\leq n-2</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\sum_ {i = 1} ^ {I} \\boldsymbol {a} _ {i, j} u _ {i} (\\bar {X})\\right) \\cdot \\left(\\sum_ {i = 1} ^ {I} \\boldsymbol {a} _ {i, j} v _ {i} (\\bar {X})\\right) = \\sum_ {i = 1} ^ {I} \\boldsymbol {a} _ {i, j} u _ {i} (\\bar {X}) + \\boldsymbol {z} _ {j} (X) t (X).</span></div>

    <p class="text-gray-300">Formal Description. Next, we provide a formal description of the proof of knowledge of committed matrices satisfying the relation  <span class="math">\\mathcal{R}_{\\mathrm{const}}</span> .</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 20: QAP Proof decomposed into sub-proofs.</p>

    <p class="text-gray-300">Proof:</p>

    <p class="text-gray-300">53</p>

    <p class="text-gray-300">Instance: The prover has already sent <span class="math">[\\pmb{a}_{i,i,j}]_{i=n+1,j=1}^{I,MN}</span> to the ILC channel.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{\\mathrm{const}} \\to \\mathrm{ILC}</span>: For <span class="math">1 \\leq j \\leq MN</span>, the prover computes</p>

    <div class="my-4 text-center"><span class="math-block">\\left[ \\left(\\sum_{i=1}^{I} \\boldsymbol{a}_{i,j} u_i(\\bar{X})\\right) \\circ \\left(\\sum_{i=1}^{I} \\boldsymbol{a}_{i,j} v_i(\\bar{X})\\right) - \\sum_{i=1}^{I} \\boldsymbol{a}_{i,j} w_i(\\bar{X}) \\right] / t(\\bar{X}) = \\sum_{i=1}^{I} \\boldsymbol{z}_{i,j} \\bar{X}^i</span></div>

    <p class="text-gray-300">The prover sends <span class="math">\\{\\pmb{z}_{i,j}\\}_{i=1,j=1}^{I,MN}</span> to ILC.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ILC}\\gets \\mathcal{V}_{\\mathrm{const}}</span>: Verifier sends <span class="math">\\bar{x}\\gets \\mathbb{F}^{\\times}</span> to ILC.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{\\mathrm{const}} \\to \\mathrm{ILC}</span>: For each <span class="math">j</span>, the prover computes</p>

    <div class="my-4 text-center"><span class="math-block">\\hat{\\boldsymbol{a}}_j = \\sum_{i=1}^{I} \\boldsymbol{a}_{i,j} u_i(\\bar{x})</span></div>

    <div class="my-4 text-center"><span class="math-block">\\hat{\\boldsymbol{b}}_j = \\sum_{i=1}^{I} \\boldsymbol{a}_{i,j} v_i(\\bar{x})</span></div>

    <div class="my-4 text-center"><span class="math-block">\\hat{\\boldsymbol{c}}_j = \\sum_{i=1}^{I} \\boldsymbol{a}_{i,j} w_i(\\bar{x}) + \\sum_{i=1}^{I} \\boldsymbol{z}_{i,j} \\bar{x}^i t(\\bar{x})</span></div>

    <p class="text-gray-300">The prover sends <span class="math">[\\hat{\\pmb{a}}_j]_{j=1}^{MN}</span>, <span class="math">[\\hat{\\pmb{b}}_j]_{j=1}^{MN}</span>, <span class="math">[\\hat{\\pmb{c}}_j]_{ij=1}^{MN}</span> to ILC.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{\\mathrm{const}} \\to \\mathrm{ILC} \\gets \\mathcal{V}_{\\mathrm{const}}</span>: The prover and verifier engage in three sum sub-proofs in order to show that <span class="math">\\hat{\\pmb{a}}_j</span>, <span class="math">\\hat{\\pmb{b}}_j</span> and <span class="math">\\hat{\\pmb{c}}_j</span> were formed correctly from previously committed values and the public QAP wire values.</p>

    <p class="text-gray-300">The prover and verifier engage in a product proof in order to show that for each <span class="math">j</span>, we have <span class="math">\\hat{\\pmb{a}}_j \\circ \\hat{\\pmb{b}}_j = \\hat{\\pmb{c}}_j</span>.</p>

    <h2 id="sec-48" class="text-2xl font-bold">Security Analysis.</h2>

    <p class="text-gray-300">Theorem 5. <span class="math">(\\mathcal{K}_{\\mathrm{ILC}}, \\mathcal{P}_{\\mathrm{const}}, \\mathcal{V}_{\\mathrm{const}})</span> is a proof system for the relation <span class="math">\\mathcal{R}_{\\mathrm{QAP}}</span> in the ILC model with perfect completeness, statistical knowledge soundness with straight-line extraction, and perfect special honest verifier zero-knowledge.</p>

    <p class="text-gray-300">Proof. Perfect completeness follows by careful inspection of the protocol and considering the various polynomial expressions computed by the prover.</p>

    <p class="text-gray-300">Next, we show that the proof has statistical knowledge soundness with straight-line extraction. This is because the knowledge extractor already has access to the committed matrices <span class="math">[A]</span> and <span class="math">[Z]</span>, having seen all messages sent between the prover and the ILC. It remains to show that for any deterministic malicious prover <span class="math">\\mathcal{P}_{\\mathrm{QAP}}^s</span>, if the committed vectors are not a valid witness for <span class="math">\\mathcal{R}_{\\mathrm{QAP}}</span>, then there is</p>

    <p class="text-gray-300">negligible probability of accept. By the knowledge-soundness of the sum proof, it must be the case that for each <span class="math">j</span>, the values <span class="math">\\hat{\\boldsymbol{a}}_{j},\\hat{\\boldsymbol{b}}_{j},\\hat{\\boldsymbol{c}}_{j}</span> were computed correctly.</p>

    <p class="text-gray-300"><span class="math">\\hat{\\boldsymbol{a}}_{j}</span> <span class="math">=\\sum_{i=1}^{I}\\boldsymbol{a}_{i,j}u_{i}(\\bar{x})</span> <span class="math">\\hat{\\boldsymbol{b}}_{j}</span> <span class="math">=\\sum_{i=1}^{I}\\boldsymbol{a}_{i,j}v_{i}(\\bar{x})</span> <span class="math">\\hat{\\boldsymbol{c}}_{j}</span> <span class="math">=\\sum_{i=1}^{I}\\boldsymbol{a}_{i,j}w_{i}(\\bar{x})+\\sum_{i=1}^{I}\\boldsymbol{z}_{i,j}\\bar{x}^{i}t(\\bar{x})</span></p>

    <p class="text-gray-300">By the knowledge-soundness of the product proof, we see that we must have</p>

    <p class="text-gray-300"><span class="math">\\left(\\sum_{i=1}^{I}\\boldsymbol{a}_{i,j}u_{i}(\\bar{x})\\right)\\circ\\left(\\sum_{i=1}^{I}\\boldsymbol{a}_{i,j}v_{i}(\\bar{x})\\right)=\\sum_{i=1}^{I}\\boldsymbol{a}_{i,j}w_{i}(\\bar{x})+\\sum_{i=1}^{I}\\boldsymbol{z}_{i,j}\\bar{x}^{i}t(\\bar{x}).</span></p>

    <p class="text-gray-300">Since the prover committed to <span class="math">\\boldsymbol{a}_{i,j}</span> and <span class="math">\\boldsymbol{z}_{i,j}</span> before seeing the challenge <span class="math">\\bar{x}</span>, these values must be constant and independent of <span class="math">\\bar{x}</span>. By the Schwarz-Zippel lemma, if the <span class="math">\\boldsymbol{a}_{i,j}</span> do not form valid QAP wire assignments, then there is negligible probability for the above equality to hold over the random choice of <span class="math">\\bar{x}</span>. Therefore, we have statistical knowledge-soundness.</p>

    <p class="text-gray-300">Finally, we show that the proof is honest-verifier zero-knowledge. This follows trivially from the fact that the sum and product sub-proofs are all honest-verifier zero-knowledge. ∎</p>

    <h4 id="sec-49" class="text-lg font-semibold mt-6">0.B.4.2 Efficiency.</h4>

    <p class="text-gray-300">The efficiency of the proof system is given in Table 5, and since the cost is dominated by the cost of the product argument, the efficiency of the protocol is similar asymptotically. In the verification of a TinyRAM execution, we need only consider QAPs with constant size <span class="math">I</span>. Therefore, we exclude <span class="math">I</span> in our efficiency estimates, as it only introduces a constant overhead over the costs in the product proof, for example.</p>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">0.B.4 Unknown Permutations</h3>

    <p class="text-gray-300">We will now give an unknown permutation proof for the relation <span class="math">\\mathcal{R}_{\\text{\\tiny perm}}</span>. To correspond to the matrix values committed to the ILC, we write the values being permuted as matrices. Our techniques are inspired by the shuffle proofs of Neff <em>[x13]</em>. Suppose the prover has committed to the rows of two matrices <span class="math">A,B\\in\\mathbb{F}^{N_{*}\\times k}</span>, which we will write with square brackets. Then the claim is that the committed matrices satisfy <span class="math">B=A^{\\pi}</span> for some permutation <span class="math">\\pi</span>, where the notation <span class="math">A^{\\pi}</span> means the matrix with entries <span class="math">a_{i,j}^{\\pi}=a_{\\pi(i,j)}</span>. We generalise this notion to extend to the case of multiple pairs of permuted matrices.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Fig. 21: Unknown Permutation Proof decomposed into sub-proofs.</p>

    <p class="text-gray-300">Define  <span class="math">J \\in \\mathbb{F}^{N_* \\times k}</span>  to be the matrix that has 1 in all entries, i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">J = \\left( \\begin{array}{c c} 1 &amp;amp; 1 \\\\ \\ddots &amp;amp; \\\\ 1 &amp;amp; 1 \\end{array} \\right).</span></div>

    <p class="text-gray-300">Our permutation proof for  <span class="math">\\mathcal{R}_{\\mathrm{perm}}</span>  is given in Fig. 22. The idea behind the construction is to let the verifier pick random challenges  <span class="math">x, y</span>  and let the prover commit to  <span class="math">A - xJ</span>  and  <span class="math">B - xJ</span> . The prover will now convince the verifier that the product of the entries in  <span class="math">A - xJ</span>  is equal to the product of the entries in  <span class="math">B - xJ</span> . What happens if the prover is trying to cheat and  <span class="math">B \\neq A^{\\pi}</span> ? Writing out the products of entries, we then get that to cheat the prover must have</p>

    <div class="my-4 text-center"><span class="math-block">\\prod_ {i, j} (a _ {i, j} - x) = \\prod_ {i, j} (b _ {i, j} - x).</span></div>

    <p class="text-gray-300">By the Schwartz-Zippel lemma this is unlikely to hold over the random choice of  <span class="math">x</span>  unless indeed  <span class="math">B</span>  contains a permutation of the entries in  <span class="math">A</span> .</p>

    <p class="text-gray-300">The final permutation proof applies also to lookups over tuples of length  <span class="math">n</span> , rather than single elements. See B.6 for a discussion on how to extend the permutation proof to permutations of tuples.</p>

    <p class="text-gray-300">Theorem 6.  <span class="math">(\\mathcal{K}_{\\mathrm{ILC}},\\mathcal{P}_{\\mathrm{perm}},\\mathcal{V}_{\\mathrm{perm}})</span>  is a proof system for the relation  <span class="math">\\mathcal{R}_{\\mathrm{perm}}</span>  in the ILC model with perfect completeness, statistical knowledge soundness with straight-line extraction, and perfect special honest verifier zero-knowledge.</p>

    <p class="text-gray-300">Proof. Perfect completeness follows by inspection.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For statistical soundness, note that by the knowledge soundness of the equality and sum proofs we know the prover has indeed committed correctly to  <span class="math">A - xJ</span>  and  <span class="math">B - xJ</span>  and can extract these committed values. By the knowledge soundness of the entry product and sum proofs, we get  <span class="math">\\prod_{i,j}(a_{i,j} - x) = \\prod_{i,j}(b_{i,j} - x)</span> . The Schwartz-Zippel Lemma tells us that if  <span class="math">A</span>  and  <span class="math">B</span>  have different entries, then the probability that this equality holds over the random choice of  <span class="math">x \\gets \\mathbb{F}</span>  is at most  $\\frac{N_*k}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ , which is negligible. Finally, note that each sub-protocol has straight-line extraction.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To see we have perfect special honest verifier zero-knowledge, simulate that the verifier receives commitments to three matrices in  <span class="math">\\mathbb{F}^{N_* \\times k}</span>  and run the perfect special honest verifier zero-knowledge simulators on the equality, sum and same product proofs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pperm(ppILC, {{{Ai}}}, [Bi]n=1), (π, {Ai, Bi}n=1))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Vperm(ppILC, {{{Ai}}}, [Bi]n=1))</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- If n > 1:</td>

            <td class="px-3 py-2 border-b border-gray-700">- If n > 1:</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Get challenge z ∈ F from ILC</td>

            <td class="px-3 py-2 border-b border-gray-700">- Pick z ∈ F</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Commit to A = ∑i=1nAi zi</td>

            <td class="px-3 py-2 border-b border-gray-700">- Send z to ILC</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Commit to B = ∑i=1nBi zi</td>

            <td class="px-3 py-2 border-b border-gray-700">- Commit to A = ∑i=1nAi zi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Set z = (z, z2, ..., zn)</td>

            <td class="px-3 py-2 border-b border-gray-700">- Commit to B = ∑i=1nBi zi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Psum(pplc, {z, [Ai], ..., [An], [A]), (Ai, ..., An, A)</td>

            <td class="px-3 py-2 border-b border-gray-700">- Set z = (z, z2, ..., zn)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Psum(pplc, {z, [Bi], ..., [Bn], [B]), (Bi, ..., Bn, B)</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Vsum(pplc, {z, [Bi], ..., [Bn], [B]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Pperm(pplc, {{{Ai}, [B]}}, (π, A, B))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Vperm(pplc, {{{Ai}, [B]}})</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Get challenge x ∈ F from ILC</td>

            <td class="px-3 py-2 border-b border-gray-700">- Return 1 if all proofs accept</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Let U = -xJ</td>

            <td class="px-3 py-2 border-b border-gray-700">- Return 0 otherwise</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Let A' = A - xJ and B' = B - xJ</td>

            <td class="px-3 py-2 border-b border-gray-700">- Pick x ← F</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Commit to the rows of U, A', B'</td>

            <td class="px-3 py-2 border-b border-gray-700">- Send x to ILC</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Pup(pplc, (U, [U]), (U))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Compute U = -xJ</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Psum(pplc, ((1, 1), [A], [U], [A]), (A, U, A'))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Vsum(pplc, ((1, 1), [A], [U], [A]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Psum(pplc, ((1, 1), [B], [U], [B]), (B, U, B'))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Vsum(pplc, ((1, 1), [B], [U], [B]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Pentry-prod(pplc, {{{Ai}}, [Pa]), (A', PA))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Ventry-prod(pplc, {{{Ai}}, [Pa]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Pentry-prod(pplc, {{{Bi}}, [Pb]), (B', Pb))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Ventry-prod(pplc, {{{Bi}}, [Pb]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Psum(pplc, ((1, 0), [Pa], [O], [Pb]), (Pa, O, Pb))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Return 1 if all proofs accept, Return 0 otherwise</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Fig. 22: Unknown permutation proof for two committed matrices. Fig. 23: Lookup Proof decomposed into sub-proofs.</p>

    <p class="text-gray-300">We will now give a novel lookup proof for matrices, which shows that every element of a given matrix is an element of another committed matrix. We will use the notation  <span class="math">A \\subseteq B</span>  to mean that the set of field elements in the entries of  <span class="math">A</span>  is a subset of the set of field elements in the entries of  <span class="math">B</span> . Suppose the prover has committed to the rows of a matrix  <span class="math">A \\in \\mathbb{F}^{N_* \\times k}</span>  and the rows of  <span class="math">B \\in \\mathbb{F}^{K \\times k}</span> . Then the claim is that every entry  <span class="math">a_{i,j}</span>  of the committed matrix  <span class="math">A</span>  is equal to some entry  <span class="math">b_{i,k}</span>  of  <span class="math">B</span> . We generalise this to the case of multiple pairs of matrices. The corresponding relation is</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{\\mathrm{lookup}} = \\left\\{ \\begin{array}{ll}(pp_{\\mathrm{ILC}},u) = ((\\mathbb{F},k),(\\{[A_i],[B_i]\\}_{i = 1}^n),(\\{A_i,B_i\\}_{i = 1}^n)):\\\\ for1\\leq i\\leq n,\\quad A_i\\in \\mathbb{F}^{N_*\\times k}\\quad \\wedge \\quad B_i\\in \\mathbb{F}^{K\\times k}\\quad \\wedge \\quad A_i\\subseteq B_i \\end{array} \\right\\} .</span></p>

    <p class="text-gray-300">We give the lookup proof for  <span class="math">\\mathcal{R}_{\\mathrm{lookup}}</span>  in Fig. 24. The idea behind the construction is that if  <span class="math">\\{a_{i,j}\\} \\subset \\{b_{i,j}\\}</span>  then we can express the polynomial  <span class="math">\\prod_{i,j}(X - a_{i,j})</span>  as  <span class="math">\\prod_{i,j}(X - b_{i,j})^{e_{i,j}}</span>  for non-negative integers  <span class="math">e_{1,1},\\ldots ,e_{K,k}</span>  which sum to  <span class="math">N_{*}\\times k</span> . To construct the argument, we let the verifier pick a random challenge  <span class="math">x</span> , and let the prover commit to  <span class="math">A - xJ</span>  and the binary expansions of  <span class="math">e_{1,1},\\ldots ,e_{K,k}</span> . The prover will now use the entry-product argument to compute the product of the entries in  <span class="math">A - xJ</span> , and compute  <span class="math">\\prod_{i,j}(X - b_{i,j})^{e_{i,j}}</span>  in a verifiable manner using a square-and-multiply algorithm and several product arguments. What happens if the prover is trying to cheat? Writing out the products of entries, we then get that to cheat the prover must have</p>

    <div class="my-4 text-center"><span class="math-block">\\prod_ {i, j} (a _ {i, j} - x) = \\prod_ {i, j} (b _ {i, j} - x) ^ {e _ {i, j}}.</span></div>

    <p class="text-gray-300">By the Schwartz-Zippel lemma this is unlikely to hold over the random choice of  <span class="math">x</span>  unless indeed  <span class="math">\\{a_{i,j}\\} \\subset \\{b_{i,j}\\}</span> .</p>

    <p class="text-gray-300">It is relatively simple for the prover to compute the product  <span class="math">\\prod_{i,j}(a_{i,j} - x)</span>  in a verifiable manner. They first use the sum and equality arguments to prove that they have correctly committed to  <span class="math">A&#x27; = A - xJ</span> . They then commit to  <span class="math">P</span>  with a single non-zero entry in the bottom left corner equal to  <span class="math">\\prod_{i,j}x - a_{i,j}</span>  and use the entry-product argument on  <span class="math">A&#x27;</span>  and  <span class="math">P</span> .</p>

    <p class="text-gray-300">Implementing the square-and-multiply algorithm requires more steps. The prover commits to a matrix  <span class="math">E \\in \\mathbb{F}^{K\\log (N_{<em>}k)\\times k}</span> , such that the first row consists of the lowest order binary digits of  <span class="math">e_{1,1},\\ldots ,e_{1,k}</span> , the second row consists of the next digits, and so on. We use the notation  <span class="math">e_{i,j}[\\ell]</span>  to refer to the  <span class="math">\\ell</span> th binary digit of  <span class="math">e_{i,j}</span> . After  <span class="math">\\log (N_{</em>}k)</span>  rows, the matrix continues with the digits of  <span class="math">e_{2,1},\\ldots ,e_{2,k}</span> , and so on. The prover also computes a matrix  <span class="math">V \\in \\mathbb{F}^{K\\log (N_{<em>}k)\\times k}</span> , such that the first row is  <span class="math">(x - b_{1,1},\\dots,x - b_{1,k})</span> , the second row consists of  <span class="math">(x - b_{1,1})^2,\\dots,(x - b_{1,k})^2</span> , and so on. Again, after  <span class="math">\\log (N_{</em>}k)</span>  rows, the matrix continues with rows corresponding to  <span class="math">b_{2,1},\\ldots ,b_{2,k}</span> , and so on.</p>

    <div class="my-4 text-center"><span class="math-block">E = \\left( \\begin{array}{c c c} e _ {1, 1} [ 1 ] &amp;amp; \\ldots &amp;amp; e _ {1, k} [ 1 ] \\\\ \\vdots &amp;amp; &amp;amp; \\vdots \\\\ e _ {1, 1} [ \\log (N _ {*} k) ] &amp;amp; \\ldots &amp;amp; e _ {1, k} [ \\log (N _ {*} k) ] \\\\ e _ {2, 1} [ 1 ] &amp;amp; \\ldots &amp;amp; e _ {2, k} [ 1 ] \\\\ \\vdots &amp;amp; &amp;amp; \\vdots \\\\ e _ {K, 1} [ \\log (N _ {*} k) ] &amp;amp; \\ldots &amp;amp; e _ {K, k} [ \\log (N _ {*} k) ] \\end{array} \\right) V = \\left( \\begin{array}{c c c} (x - b _ {1, 1}) &amp;amp; \\ldots &amp;amp; (x - b _ {1, k}) \\\\ (x - b _ {1, 1}) ^ {2} &amp;amp; \\ldots &amp;amp; (x - b _ {1, k}) ^ {2} \\\\ (x - b _ {1, 1}) ^ {4} &amp;amp; \\ldots &amp;amp; (x - b _ {1, k}) ^ {4} \\\\ \\vdots &amp;amp; &amp;amp; \\vdots \\\\ (x - b _ {1, 1}) ^ {N _ {*} k} &amp;amp; \\ldots &amp;amp; (x - b _ {1, k}) ^ {N _ {*} k} \\\\ \\vdots &amp;amp; &amp;amp; \\vdots \\\\ (x - b _ {K, 1}) ^ {N _ {*} k} &amp;amp; \\ldots &amp;amp; (x - b _ {K, k}) ^ {N _ {*} k} \\end{array} \\right).</span></div>

    <p class="text-gray-300">The prover needs to demonstrate that both of these matrices are correctly formed. In order to show that  <span class="math">E</span>  is correctly formed it does two things. It first uses a product argument to show that  <span class="math">E \\circ E = E</span> , and hence that the entries of  <span class="math">E</span>  must consist of zeroes and ones. In order to check that the sum of the  <span class="math">e_{i,j}</span>  is equal to  <span class="math">N_<em> \\times k</span> , the prover first commits to the matrix  <span class="math">R \\in \\mathbb{F}^{K\\log (N_</em>k)\\times k}</span>  whose rows contain powers of 2 ( <span class="math">r_{i,j} = 2^i</span> ). It runs an equality argument on  <span class="math">R</span> . It calculates</p>

    <p class="text-gray-300">the matrix  <span class="math">E_{\\mathrm{exp}} = E \\circ R</span>  and runs a product argument.</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a></p>

    <p class="text-gray-300">Finally, it runs the grand sum argument on  <span class="math">E_{\\mathrm{exp}}</span> .</p>

    <p class="text-gray-300">In order to show that  <span class="math">E</span>  is correctly formed it does the following. First it demonstrates that the rows containing linear terms in  <span class="math">x</span>  were computed correctly showing that  <span class="math">V_{\\mathrm{linear}} = xJ^{<em>} - B</span> , where  <span class="math">J^{</em>}</span>  is an all ones matrix of the same size as  <span class="math">B</span>  and  <span class="math">V_{\\mathrm{linear}i} = V_{(i-1)\\times \\log (N_{*}k)+1}</span> . Let  <span class="math">V_{\\top}</span>  be  <span class="math">V</span>  with the rows corresponding to most significant bits removed, and let  <span class="math">V_{\\perp}</span>  be  <span class="math">V</span>  with the rows corresponding to least significant bits removed.</p>

    <p class="text-gray-300"><span class="math">V_{\\top} = V_{1},\\ldots ,V_{\\log (N_{<em>}k) - 1},V_{\\log (N_{</em>}k) + 1},\\ldots ,V_{2\\log (N_{<em>}k) - 1},V_{2\\log (N_{</em>}k) + 1},\\ldots</span></p>

    <p class="text-gray-300"><span class="math">V_{\\perp} = V_{2},\\ldots ,V_{\\log (N_{<em>}k)},\\quad V_{\\log (N_{</em>}k) + 2},\\ldots ,V_{2\\log (N_{<em>}k)},\\quad V_{2\\log (N_{</em>}k) + 2},\\ldots</span></p>

    <p class="text-gray-300">The prover runs a product proof to demonstrate that  <span class="math">V_{\\top} \\circ V_{\\top} = V_{\\perp}</span> , which proves that the other elements of  <span class="math">V</span>  are well-formed.</p>

    <p class="text-gray-300">Let  <span class="math">J&#x27;</span>  be the matrix with the same dimensions as  <span class="math">E</span>  and  <span class="math">V</span>  that contains 1 in all entries. The prover computes  <span class="math">G = E \\circ V + J&#x27; - E</span> , and uses several sub-proofs to demonstrate that it is correctly formed. The matrix  <span class="math">G</span>  was chosen because it contains all 2-powers of the factors  <span class="math">(x - b_{i,j})</span>  which multiply together to give  <span class="math">\\prod_{i,j} (x - b_{i,j})</span> . Finally, the prover uses an entry product argument on  <span class="math">G</span>  and  <span class="math">P</span> . Since  <span class="math">P</span>  is the same value as before, the proof will only work if the entry-product of  <span class="math">A</span>  is equal to the entry-product of  <span class="math">B</span> .</p>

    <p class="text-gray-300">The final lookup proof applies also to lookups over tuples of length  <span class="math">n</span> , rather than single elements. See B.6 for a discussion on how to extend the lookup proof to tuples.</p>

    <p class="text-gray-300">Theorem 7.  <span class="math">(\\mathcal{K}_{\\mathrm{ILC}},\\mathcal{P}_{\\mathrm{lookup}},\\mathcal{V}_{\\mathrm{lookup}})</span>  is a proof system for the relation  <span class="math">\\mathcal{R}_{\\mathrm{lookup}}</span>  in the ILC model with perfect completeness, statistical knowledge soundness with straight-line extraction, and perfect special honest verifier zero-knowledge.</p>

    <p class="text-gray-300">Proof. Perfect completeness follows by inspection.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For statistical soundness, note that by the knowledge soundness of the various sub-proofs we know the prover has indeed committed correctly to  <span class="math">\\prod_{i,j}(a_{i,j} - x)</span>  and  <span class="math">\\prod_{i,j}(b_{i,j} - x)^{e_{i,j}}</span>  and can extract these committed values. By the knowledge soundness of the sum proof, we get  <span class="math">\\prod_{i,j}(a_{i,j} - x) = \\prod_{i,j}(b_{i,j} - x)^{e_{i,j}}</span> . The Schwartz-Zippel Lemma tells us that if the entries of  <span class="math">A</span>  are not all entries of  <span class="math">B</span> , then the probability over the random choice of  <span class="math">x \\gets \\mathbb{F}</span>  of this equality to hold is at most  $\\frac{N_*k}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ , which is negligible. Finally, note that each sub-protocol has straight-line extraction.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To see we have perfect special honest verifier zero-knowledge, simulate that the verifier receives commitments to the correct number of matrices, with the</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Plookup(ppILC, {{{A_i}}}_{i=1}^n, {{{B_i}}}_{i=1}^n), {{{A_i},B_i}}_{i=1}^n))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Vlookup(ppILC, {{{A_i}}}_{i=1}^n, {{{B_i}}}_{i=1}^n))</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- If n > 1:</td>

            <td class="px-3 py-2 border-b border-gray-700">- If n > 1:</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Get challenge z ∈ F from ILC</td>

            <td class="px-3 py-2 border-b border-gray-700">- Pick z ∈ F</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Commit to A = ∑i=1nAi zi</td>

            <td class="px-3 py-2 border-b border-gray-700">- Send z to ILC</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Commit to B = ∑i=1nBi zi</td>

            <td class="px-3 py-2 border-b border-gray-700">- Commit to A = ∑i=1nAi zi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Set z = (z, z2, ..., zn)</td>

            <td class="px-3 py-2 border-b border-gray-700">- Commit to B = ∑i=1nBi zi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Psum(ppILC, {z, [A1], ..., [An], [A]}, (A1, ..., An, A)</td>

            <td class="px-3 py-2 border-b border-gray-700">- Set z = (z, z2, ..., zn)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Psum(ppILC, {z, [B1], ..., [Bn], [B]}, (B1, ..., Bn, B)</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Vsum(ppILC, {z, [A1], ..., [An], [A]})</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Plookup(ppILC, {{{A}}, [B]}, (A, B))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Vlookup(ppILC, {{{A}}, [B]})</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Get challenge x ∈ F from ILC.</td>

            <td class="px-3 py-2 border-b border-gray-700">- Return 1 if all proofs accept</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Find ∏i,j x - ai,j</td>

            <td class="px-3 py-2 border-b border-gray-700">- Return 0 otherwise</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Commit to A' = xJ - A and P.</td>

            <td class="px-3 py-2 border-b border-gray-700">- Send x ∈ F to the ILC.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Psum(ppILC, ((x, -1), [J], [A], [A']), (J, A, A'))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vsum(ppILC, ((x, -1), [J], [A], [A']))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Pentry-prof(ppILC, ([A'], [P]), (A', P)).</td>

            <td class="px-3 py-2 border-b border-gray-700">- Ventry-prof(ppILC, ([A'], [P]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Vpuf(ppILC, (R, [R])).</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vpuf(ppILC, (R, [R]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Find binary expansion of exponents</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vpuf(ppILC, ([E], [B], [Eexp]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Commit to E,R,Eexp.</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vgrandsum(ppILC, (N* × k, [E]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Pprof(ppILC, ([E], [E], [E]), (E, E, E)).</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vsum(ppILC, ((x, -1), [J*], [B], [Vlinear]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Peq(ppILC, (R, [R]), (R)).</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vprof(ppILC, ([Vγ], [Vγ], [V⊥]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Pprof(ppILC, ([E], [R], [Eexp]), (E, R, Eexp)).</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vprof(ppILC, ([E], [V], [E ⊕ V]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Pgrandsum(ppILC, (N* × k, [E]), (E)).</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vsum(ppILC, ((1, 1, -1), [E ⊕ V], [J*], [E], [G]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Find matrix of values (x - bi,j)2.</td>

            <td class="px-3 py-2 border-b border-gray-700">- Ventry-prof(ppILC, ([G], [P]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Commit to V.</td>

            <td class="px-3 py-2 border-b border-gray-700">- Return 1 if all proofs accept,</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Psum(ppILC, ((x, -1), [J<em>], [B], [Vlinear]), (B', B, xJ</em>))</td>

            <td class="px-3 py-2 border-b border-gray-700">Return 0 otherwise</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Pprof(ppILC, ([Vγ], [Vγ], [V⊥]), (Vγ, Vγ, V⊥)). |   |</p>

    <p class="text-gray-300">|  - Find ∏i,j (x - bi,j)2i,j |   |</p>

    <p class="text-gray-300">|  Commit to G = E ⊕ V + J' - E, and to E ⊕ V. |   |</p>

    <p class="text-gray-300">|  Pprof(ppILC, ([E], [V], [E ⊕ V]), (E, V, E ⊕ V)). |   |</p>

    <p class="text-gray-300">|  Psum(ppILC, ((1, 1, -1), [E ⊕ V], [J*], [E], [G]), (E ⊕ V, J', E, G)) |   |</p>

    <p class="text-gray-300">|  Pentry-prof(ppILC, ([G], [P]), (G, P)). |   |</p>

    <p class="text-gray-300">Fig. 24: Lookup proof</p>

    <p class="text-gray-300">correct dimensions, and run the perfect special honest verifier zero-knowledge simulators on the sub-proofs.</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> Fig. 25: Bounded Lookup Proof decomposed into sub-proofs.</p>

    <p class="text-gray-300">Based on the lookup proof, we present an efficient proof for checking bounded lookups. More precisely, the prover is able to convince the verifier that every element of the conjugation of committed columns of the execution table  <span class="math">\\left[\\mathsf{E}_{\\mathsf{addr}}\\right],\\left[\\mathsf{E}_{\\mathsf{v}_{\\mathrm{init}}}\\right],\\left[\\mathsf{E}_{\\mathsf{usd}}\\right]</span>  appear in the committed memory table [M], and that moreover every entry in  <span class="math">[\\mathsf{M}_1]</span>  occurs at most once in  <span class="math">\\left[\\mathsf{E}_{\\mathsf{addr}}\\right],\\left[\\mathsf{E}_{\\mathsf{v}_{\\mathrm{init}}}\\right],\\left[\\mathsf{E}_{\\mathsf{usd}}\\right]</span> . The protocol is given in Fig. 26.</p>

    <p class="text-gray-300">The proof begins by running the lookup argument as a sub-proof. This involves committing to the binary matrix  <span class="math">E</span>  that encodes information about the number of times  <span class="math">e_{i,j}</span>  that each  <span class="math">\\mathsf{M}_{\\ell}</span>  appears in  <span class="math">[\\mathsf{E}_{\\mathsf{addr}}], [\\mathsf{E}_{\\mathsf{v}_{\\mathsf{init}}}]</span> ,  <span class="math">[\\mathsf{E}_{\\mathsf{usd}}]</span> . Each column of  <span class="math">E</span>  contains the binary expansion of several  <span class="math">e_{i,j}</span> . Use the notation  <span class="math">e_{0,k}</span>  for the number of times each  <span class="math">\\mathsf{M}_{0k}</span>  occurs and  <span class="math">e_{1,k}</span>  for the number of times each  <span class="math">\\mathsf{M}_{1k}</span>  occurs. To prove that entries in  <span class="math">\\mathsf{M}_0</span>  occur no more than once in  <span class="math">[\\mathsf{E}_{\\mathsf{addr}}], [\\mathsf{E}_{\\mathsf{v}_{\\mathsf{init}}}]</span> ,  <span class="math">[\\mathsf{E}_{\\mathsf{usd}}]</span> , the prover commits to a matrix of  <span class="math">Q</span> .</p>

    <p class="text-gray-300">This  <span class="math">Q</span>  contains zeros for all entries corresponding to  <span class="math">e_{1,k}</span> , and ones in all entries corresponding to  <span class="math">e_{0,k}</span>  except those corresponding to the least significant bit. The entries corresponding to the lsb are 0. The prover and verifier then engage in an equality proof to demonstrate that  <span class="math">Q</span>  is correctly formed. Next, the prover shows that  <span class="math">O = Q \\circ E</span> . The prover now has that,  <span class="math">Q</span>  contains all zeroes fpr entries corresponding to  <span class="math">\\mathsf{M}_0</span> , except possibly the least significant bit, which may be a zero or a one.</p>

    <p class="text-gray-300">Note on Bounded Lookup Arguments for Tuples As stated, the bounded lookup proofs deal with single values. In order to run the argument for constant-sized tuples of values, which will be very useful when verifying a correct TinyRAM execution, we can do as follows. First, the verifier picks a random challenge  <span class="math">z \\gets \\mathbb{F}</span> . Now, if the prover wanted to run a bounded lookup argument to show that tuples  <span class="math">\\{(a_1, a_2, a_3)\\}</span>  were elements of the collection of tuples  <span class="math">\\{(b_1, b_2, b_3)\\}</span> , stored in matrices  <span class="math">A_1, A_2, A_3</span>  and  <span class="math">B_1, B_2, B_3</span> , then the prover could commit to matrices  <span class="math">A = zA_1 + z^2A_2 + z^3A_3</span> , and  <span class="math">B = zB_1 + z^2B_2 + z^3B_3</span> . The prover can demonstrate</p>

    <p class="text-gray-300">that  <span class="math">A</span>  and  <span class="math">B</span>  are correctly formed with little overhead using a sum argument. By the Schwarz-Zippel lemma, with high probability, running a bounded lookup argument on the new matrices  <span class="math">A</span>  and  <span class="math">B</span>  demonstrates that the tuples of elements in  <span class="math">B_{1}, B_{2}, B_{3}</span>  in entries defined by  <span class="math">S</span>  will only appear at most once in  <span class="math">A_{1}, A_{2}, A_{3}</span> . The same trick applies to regular lookup proofs and permutation arguments.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Plookup(ppILC, ([Eaddr], [Eviisir], [Euod], [M]), (E, M))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Vlookup(ppILC, ([Eaddr], [Eviisir], [Euod], [M]))</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Get challenge z ∈ F from ILC</td>

            <td class="px-3 py-2 border-b border-gray-700">- Pick z ∈ F</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Commit to A = Eaddrz + Eviisirz2 + Euodz3</td>

            <td class="px-3 py-2 border-b border-gray-700">- Send z to ILC</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Commit to B = Maddrz + Mviisirz2 + Muodz3</td>

            <td class="px-3 py-2 border-b border-gray-700">- Set z = (z, z2, z3)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Set z = (z, z2, z3)</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vsum(ppILC, (z, [Eaddr], [Eviisir], [Euod], [A]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Psum(ppILC, (z, [Eaddr], [Eviisir], [Euod], [A]), (Eaddr, Eviisir, Euod))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vsum(ppILC, (z, [Maddr], [Mviisir], [Muod], [B]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Psum(ppILC, (z, [Maddr], [Mviisir], [Muod], [B]), (Maddr, Mviisir, Muod)</td>

            <td class="px-3 py-2 border-b border-gray-700">- Veq(ppILC, Q, [Q]),</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Plookup(ppILC, ([A], [B]), (A, B)).</td>

            <td class="px-3 py-2 border-b border-gray-700">- Vprod(ppILC, ([Q], [E], [O))).</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Commit to Q</td>

            <td class="px-3 py-2 border-b border-gray-700">- Return 1 if all proofs accept,</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Pequal(ppILC, (Q, [Q]), (Q)).</td>

            <td class="px-3 py-2 border-b border-gray-700">Return 0 otherwise</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  - Pequal(ppILC, (Q, [E], [O]), (Q, E, O)). |   |</p>

    <p class="text-gray-300">Fig. 26: Bounded lookup proof.</p>

    <p class="text-gray-300">Theorem 8.  <span class="math">(\\mathcal{K}_{\\mathrm{ILC}},\\mathcal{P}_{\\mathrm{lookup}},\\mathcal{V}_{\\mathrm{lookup}})</span>  is a proof system for  <span class="math">\\mathcal{R}_{\\mathrm{lookup}}</span>  in the ILC model with perfect completeness, statistical knowledge soundness with straight-line extraction, and perfect special honest verifier zero-knowledge.</p>

    <p class="text-gray-300">Proof. Perfect completeness follows by inspection.</p>

    <p class="text-gray-300">Let  <span class="math">n = 1</span> . For statistical soundness, by the soundness of the lookup proof, we know that every entry of  <span class="math">A_{1}</span>  is an element of  <span class="math">B_{1}</span> . The soundness of the equality and product proofs, ensure both that  <span class="math">Q&#x27;</span>  was computed correctly, and imply that the relevant entries of  <span class="math">E</span>  are zero. Finally, note that each sub-protocol has straight-line extraction.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If  <span class="math">n &amp;gt; 1</span> , then by the soundness of the argument for  <span class="math">n = 1</span> , we know that every entry of  <span class="math">A</span>  is an element of  <span class="math">B</span> . By the Schwarz-Zippel lemma, if the tuples given by  <span class="math">A_{1},\\ldots ,A_{n}</span>  are not elements in the table of tuples given by  <span class="math">B_{1},\\ldots ,B_{n}</span> , this is only true for randomly chosen  <span class="math">z</span>  with probability  $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ . The additional sub-protocols used in this case all have straight-line extraction.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To see we have perfect special honest verifier zero-knowledge, simulate that the verifier receives commitments to two matrices of the correct sizes, and run the perfect special honest verifier zero-knowledge simulators on the sub-proofs.  <span class="math">\\square</span></p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> Fig. 27: Range Proof decomposed into sub-proofs.</p>

    <p class="text-gray-300">Based on the lookup proof and the constraints proof, we present an efficient proof for checking that all of the elements of a committed matrix are in a given range  <span class="math">[0, 2^W - 1]</span> , where  <span class="math">W</span>  is the word-length of the TinyRAM machine. As we store entries of the tables with field elements, we often need to check that a given entry can be written as a  <span class="math">W</span> -bit word. Let  <span class="math">A</span>  be a matrix containing integers in the range. We could simply imagine checking that each element was in the range using a simple lookup proof. One could use a table of length  <span class="math">2^W</span>  storing all values in the range and check that  <span class="math">\\mathsf{a}</span>  is one of the entries in the table. However, this would give a table of size  <span class="math">2^W</span>  which is too large, as it exceeds the running time of the program.</p>

    <p class="text-gray-300">We give a more efficient solution in Fig. 28. Intuitively, this works as follows. Suppose that we need to check that  <span class="math">\\mathsf{a}</span>  is in the range  <span class="math">\\{0,\\dots ,2^{W} - 1\\}</span> . To get around using a large lookup table, we can decompose  <span class="math">\\mathsf{a}</span>  into two words  <span class="math">\\mathsf{a}_e,\\mathsf{a}_o</span>  of length  <span class="math">2^{\\frac{W}{2}}</span> . By using a table of length  <span class="math">2^{\\frac{W}{2}}</span>  we can then check that  <span class="math">\\mathsf{a}_e,\\mathsf{a}_o</span>  are entries in the table. The only thing left to check is that  <span class="math">\\mathsf{a}_e,\\mathsf{a}_o</span>  are the correct decomposition of  <span class="math">\\mathsf{a}</span> .</p>

    <p class="text-gray-300">For the decomposition, we use  <span class="math">\\mathsf{a}_e</span>  to store the integer corresponding to the even bits of the binary decomposition of  <span class="math">\\mathsf{a}</span> , and for  <span class="math">\\mathsf{a}_o</span>  to store the integer corresponding to the odd bits of  <span class="math">\\mathsf{a}</span>  shifted in even position. For example, assume that  <span class="math">\\mathsf{a}</span>  is a 4 bit value  <span class="math">\\mathsf{a} = (\\mathsf{a}_3, \\mathsf{a}_2, \\mathsf{a}_1, \\mathsf{a}_0)</span>  then we set its decomposition to be</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {a} _ {e} = (0, \\mathsf {a} _ {2}, 0, \\mathsf {a} _ {0}) \\quad \\mathsf {a} _ {o} = (0, \\mathsf {a} _ {3}, 0, \\mathsf {a} _ {1})</span></div>

    <p class="text-gray-300">Let EvenBits be the table storing all the integers of this form. Note that this table has size  <span class="math">2^{\\frac{W}{2}}</span> . By checking that  <span class="math">\\mathsf{a}_e, \\mathsf{a}_o</span>  are entries in EvenBits we can check that  <span class="math">\\mathsf{a}</span>  is in the range  <span class="math">\\{0, \\dots, 2^W - 1\\}</span>  by checking that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {a} = 2 \\mathsf {a} _ {o} + \\mathsf {a} _ {e}</span></div>

    <p class="text-gray-300">Overall, we can write the relation for a value  <span class="math">\\mathsf{a}</span>  to be contained in a range  <span class="math">\\{0,\\ldots ,2^{W} - 1\\}</span>  as follows</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\text {r a n g e}} = \\left\\{ \\begin{array}{c} (p p, u, w) = ((W, K, \\mathbb {F}, *, \\mathsf {a}, (\\mathsf {a} _ {\\mathrm {o}}, \\mathsf {a} _ {\\mathrm {e}}, \\mathsf {E v e n B i t s}) \\mid \\\\ (p p, \\mathsf {a} _ {\\mathrm {o}}, \\mathsf {E v e n B i t s}) \\in \\mathcal {R} _ {\\text {l o o k u p}} \\wedge (p p, \\mathsf {a} _ {\\mathrm {e}}, \\mathsf {E v e n B i t s}) \\in \\mathcal {R} _ {\\text {l o o k u p}} \\\\ \\wedge \\mathsf {a} = 2 \\mathsf {a} _ {\\mathrm {o}} + \\mathsf {a} _ {\\mathrm {e}} \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">The above process can be easily extended to use decomposition into  <span class="math">\\kappa</span>  words of length  <span class="math">\\frac{W}{\\kappa}</span> . As long as  <span class="math">\\kappa = \\mathcal{O}(1)</span> , the number of arithmetic constraints introduced is still constant. In the rest of the paper we mostly refer to the decomposition into two words to keep the exposition simpler, however, later when we consider efficiency of the whole system we will use that it is easy to decompose a range check into more pieces.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prange(ppILC, ([A], [EvenBits]), (A, EvenBits))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Vrange(ppILC, ([A], [EvenBits]))</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Compute Ae and Ao by decomposing each entry of A.</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Vlookup(ppILC, [Ae], [EvenBits]).</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Commit to Ae and 2Ao.</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Vlookup(ppILC, [2Ao], [EvenBits]).</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Plookup(ppILC, ([Ae], [EvenBits]), (Ae, EvenBits)).</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Vlook(ppILC, ((1, 1/2), [Ae], [Ao], [A])).</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Plookup(ppILC, ([2Ao], [EvenBits]), (2Ao, EvenBits)).</td>

            <td class="px-3 py-2 border-b border-gray-700">- Return 1 if all proofs accept,</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Plook(ppILC, ((1, 1/2), [Ae], [Ao], [A]), (Ae, Ao, A)).</td>

            <td class="px-3 py-2 border-b border-gray-700">Return 0 otherwise</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 28: Range proof for a committed matrix.</p>

    <p class="text-gray-300">Theorem 9.  <span class="math">(\\mathcal{K}_{\\mathrm{ILC}},\\mathcal{P}_{\\mathrm{range}},\\mathcal{V}_{\\mathrm{range}})</span>  is a proof system for the relation  <span class="math">\\mathcal{R}_{\\mathrm{range}}</span>  in the ILC model with perfect completeness, statistical knowledge soundness with straight-line extraction, and perfect special honest verifier zero-knowledge.</p>

    <p class="text-gray-300">Proof. Perfect completeness follows by inspection.</p>

    <p class="text-gray-300">For statistical soundness, note that by the knowledge soundness of the lookup and sum proofs, we know the prover has indeed committed correctly to  <span class="math">A_{e}</span>  and  <span class="math">A_{o}</span>  whose entries are in EvenBits, and that  <span class="math">A = 2A_{o} + A_{e}</span> , which implies that every element of  <span class="math">A</span>  is in the desired range. Finally, note that each sub-protocol has straight-line extraction.</p>

    <p class="text-gray-300">To see we have perfect special honest verifier zero-knowledge, simulate that the verifier receives commitments to two matrices in  <span class="math">\\mathbb{F}^{N_s\\times k}</span>  and run the perfect special honest verifier zero-knowledge simulators on the sub-proofs.</p>

    <p class="text-gray-300">The efficiency of the proof system is given in the following table, where  <span class="math">T_{\\mathcal{P}}</span>  and  <span class="math">T_{\\mathcal{V}}</span>  refers to the prover and verifier computation (measured in field operations), qc is the query complexity (measured in the number of linear combination the verifier asks for), and  <span class="math">t</span>  is the number of vectors the prover commits to during the proof.</p>

    <p class="text-gray-300">Recall that we take a top down approach in order to describe how to check that the program has been executed correctly in the ILC model. In Appendix B we</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">TP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">TV</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">qc</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rsq</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">O(tk) add.</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rconst</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kN log N + kMN) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kMN) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">log M + 4</td>

            <td class="px-3 py-2 border-b border-gray-700">O(MN)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rgerm</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kN log N + kMN) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">O(MN + k) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">log M + 2</td>

            <td class="px-3 py-2 border-b border-gray-700">O(MN)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rhndop</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kN log N + kMN) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">O(MN + k) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">90</td>

            <td class="px-3 py-2 border-b border-gray-700">log M + 2</td>

            <td class="px-3 py-2 border-b border-gray-700">O(MN)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rhndoup</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kN log N + kMN) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">O(MN + k) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">95</td>

            <td class="px-3 py-2 border-b border-gray-700">log M + 2</td>

            <td class="px-3 py-2 border-b border-gray-700">O(MN)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rrange</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kN log N + kMN) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kMN) add.</td>

            <td class="px-3 py-2 border-b border-gray-700">181</td>

            <td class="px-3 py-2 border-b border-gray-700">log M + 2</td>

            <td class="px-3 py-2 border-b border-gray-700">O(MN)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5: Efficiency of protocols in Layer 3. The values  <span class="math">M, N</span>  are tuneable parameters in the Hadamard product proof; good performance is achieved in the condition  <span class="math">N_{*} = MN</span> .</p>

    <p class="text-gray-300">gave the third layer for proofs for correct TinyRAM execution. These provers required provers for  <span class="math">\\mathcal{R}_{\\mathrm{sum}}</span> ,  <span class="math">\\mathcal{R}_{\\mathrm{prod}}</span> ,  <span class="math">\\mathcal{R}_{\\mathrm{mshift}}</span> ,  <span class="math">\\mathcal{R}_{\\mathrm{kperm}}</span> ,  <span class="math">\\mathcal{R}_{\\mathrm{entry - prod}}</span> ,  <span class="math">\\mathcal{R}_{\\mathrm{grandsum}}</span> . These basic proof systems rely on known techniques, several of them appearing in [BCG+17].</p>

    <p class="text-gray-300">In the ILC model,  <span class="math">\\left[\\mathrm{BCG}^{+}17\\right]</span>  gives a proof of knowledge of committed matrices  <span class="math">A,B,C\\in \\mathbb{F}^{N_{*}\\times k}</span>  such that  <span class="math">A + B = C</span> . The proof trivially generalizes to sums of more matrices, and arbitrary linear combinations of matrices.</p>

    <p class="text-gray-300">Theorem 10 ([BCG+17]). There is a proof system  <span class="math">(\\mathcal{K}_{\\mathrm{ILC}},\\mathcal{P}_{\\mathrm{sum}},\\mathcal{V}_{\\mathrm{sum}})</span>  for the relation  <span class="math">\\mathcal{R}_{\\mathrm{sum}}</span>  in the ILC model with perfect completeness, statistical knowledge soundness with straight-line extraction, and perfect special honest verifier zero-knowledge.</p>

    <p class="text-gray-300">In the ILC model,  <span class="math">\\left[\\mathrm{BCG}^{+}17\\right]</span>  describes a proof of knowledge of matrices  <span class="math">A,B,C\\in</span> <span class="math">\\mathbb{F}^{MN\\times k}</span>  such that  <span class="math">A\\circ B = C</span>  , where  <span class="math">A\\circ B</span>  is the Hadamard (entry-wise) product of the matrices.</p>

    <p class="text-gray-300">Theorem 11 ([BCG+17]). There is a proof system  <span class="math">(\\mathcal{K}_{\\mathrm{ILC}},\\mathcal{P}_{\\mathrm{prod}},\\mathcal{V}_{\\mathrm{prod}})</span>  for the relation  <span class="math">\\mathcal{R}_{\\mathrm{prod}}</span>  in the ILC model with perfect completeness, statistical knowledge soundness with straight-line extraction and perfect special honest verifier zero-knowledge.</p>

    <p class="text-gray-300">In the ILC model,  <span class="math">\\left[\\mathrm{BCG}^{+}17\\right]</span>  gives a known permutation proof for two committed matrices. The claim is that the matrices  <span class="math">A, B \\in \\mathbb{F}^{MN \\times k}</span>  satisfy  <span class="math">B = A^{\\pi}</span> , where the notation  <span class="math">A^{\\pi}</span>  means the matrix with entries  <span class="math">a_{i,j}^{\\pi} = a_{\\pi(i,j)}</span> .</p>

    <p class="text-gray-300">Theorem 12 ([BCG+17]). There is a proof system  <span class="math">(\\mathcal{K}_{\\mathrm{ILC}},\\mathcal{P}_{\\mathrm{kperm}},\\mathcal{V}_{\\mathrm{kperm}})</span>  for the relation  <span class="math">\\mathcal{R}_{\\mathrm{kperm}}</span>  in the ILC model with perfect completeness, statistical knowledge soundness with straight-line extraction, and perfect special honest verifier zero-knowledge.</p>

    <p class="text-gray-300">We will now give a shift proof. The proof is a tweak of the double-shift proof in  <span class="math">\\mathrm{[BCG^{+}17]}</span> . Consider the matrices  <span class="math">A</span>  and  <span class="math">B</span> , which have  <span class="math">MN</span>  rows, given respectively by vectors  <span class="math">\\mathbf{a}_{i,j}, \\mathbf{b}_{i,j} \\in \\mathbb{F}^k</span> , with  <span class="math">0 \\leq i \\leq M - 1, 1 \\leq j \\leq N</span> . The top-right element of  <span class="math">A</span>  is a 1. Columns 2 up to  <span class="math">k</span>  of  <span class="math">A</span>  are equal to columns 1 up to  <span class="math">k - 1</span>  of  <span class="math">B</span> . Further, we can obtain the final column of  <span class="math">B</span>  from the first column of  <span class="math">A</span>  by deleting the first entry and appending  <span class="math">c</span> . In this case,  <span class="math">A</span>  is said to be the shift of  <span class="math">B</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a0,1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a1,2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">···</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a1,k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b0,1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a1,2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a1,3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">···</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a1,k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a2,1</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">a1,1</td>

            <td class="px-3 py-2 border-b border-gray-700">a2,1</td>

            <td class="px-3 py-2 border-b border-gray-700">a2,2</td>

            <td class="px-3 py-2 border-b border-gray-700">···</td>

            <td class="px-3 py-2 border-b border-gray-700">a2,k</td>

            <td class="px-3 py-2 border-b border-gray-700">b1,1</td>

            <td class="px-3 py-2 border-b border-gray-700">a2,2</td>

            <td class="px-3 py-2 border-b border-gray-700">a2,3</td>

            <td class="px-3 py-2 border-b border-gray-700">···</td>

            <td class="px-3 py-2 border-b border-gray-700">a2,k</td>

            <td class="px-3 py-2 border-b border-gray-700">a3,1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

            <td class="px-3 py-2 border-b border-gray-700">···</td>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

            <td class="px-3 py-2 border-b border-gray-700">:</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">aM-1,N</td>

            <td class="px-3 py-2 border-b border-gray-700">aMN,1</td>

            <td class="px-3 py-2 border-b border-gray-700">aMN,2</td>

            <td class="px-3 py-2 border-b border-gray-700">···</td>

            <td class="px-3 py-2 border-b border-gray-700">aMN,k</td>

            <td class="px-3 py-2 border-b border-gray-700">bM-1,N</td>

            <td class="px-3 py-2 border-b border-gray-700">aMN,2</td>

            <td class="px-3 py-2 border-b border-gray-700">aMN,3</td>

            <td class="px-3 py-2 border-b border-gray-700">···</td>

            <td class="px-3 py-2 border-b border-gray-700">aMN,k</td>

            <td class="px-3 py-2 border-b border-gray-700">c</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Here, we give an proof which allows a prover to convince a verifier in zero knowledge that for committed matrices  <span class="math">A</span>  and  <span class="math">B</span> , we have  <span class="math">A</span>  the shift of  <span class="math">B</span> . This is referred to as the shift condition.</p>

    <p class="text-gray-300">Parsing each matrix as a collection of row vectors as above, we now describe a proof of knowledge of vectors satisfying the stated shift condition. The shift condition can be encoded as many linear consistency constraints between the entries of  <span class="math">A</span>  and  <span class="math">B</span> . For example, for the shift condition to hold, it is necessary that  <span class="math">(\\pmb{a}_{0,1})_2 - (\\pmb{b}_{0,1})_1 = 0</span> . We will use a random challenge  <span class="math">y</span>  to embed all linear consistency constraints into one, with each individual constraint embedded with a different power of  <span class="math">y</span> .</p>

    <p class="text-gray-300">We use challenges  <span class="math">X_0, \\ldots, X_{M&#x27; - 1}</span> , where  <span class="math">M = 2^{M&#x27;}</span> , for compression, and reduce the number of vectors from  <span class="math">4MN</span>  to  <span class="math">4N</span> . Vectors are compressed as follows</p>

    <div class="my-4 text-center"><span class="math-block">\\hat {\\boldsymbol {a}} _ {j} (x _ {0}, \\dots , x _ {M ^ {\\prime} - 1}) = \\sum_ {i = 0} ^ {M - 1} \\boldsymbol {a} _ {i, j} x _ {0} ^ {i _ {0}} x _ {1} ^ {i _ {1}} \\dots x _ {M ^ {\\prime} - 1} ^ {i _ {M ^ {\\prime} - 1}}</span></div>

    <p class="text-gray-300">with a similar expression when  <span class="math">a</span>  is replaced by  <span class="math">b</span> .</p>

    <p class="text-gray-300">We then embed the compressed vectors into polynomials in  <span class="math">X</span> , again with a similar expression for  <span class="math">a</span>  replaced by  <span class="math">b</span> .</p>

    <div class="my-4 text-center"><span class="math-block">\\hat {\\boldsymbol {a}} (X, x _ {0}, \\dots , x _ {M ^ {\\prime} - 1}) = \\sum_ {j = 1} ^ {N} \\hat {\\boldsymbol {a}} _ {j} (x _ {0}, \\dots , x _ {M ^ {\\prime} - 1}) X ^ {j}</span></div>

    <p class="text-gray-300">We embed all linear consistency constraints into vectors  <span class="math">\\hat{\\pmb{w}}_a</span>  and  <span class="math">\\hat{\\pmb{w}}_b</span>  as follows. Set  <span class="math">\\pmb {y} = (1,y,\\dots ,y^{k - 1})</span> . Set</p>

    <div class="my-4 text-center"><span class="math-block">\\hat {\\boldsymbol {w}} _ {a} (y, X, x _ {0}, \\dots , x _ {M ^ {\\prime}}) = \\boldsymbol {y} \\sum_ {i = 0, j = 1} ^ {M - 1, N} y ^ {k (i + (j - 1) M)} x _ {0} ^ {- i _ {0}} \\dots x _ {M ^ {\\prime} - 1} ^ {- i _ {M ^ {\\prime} - 1}} X ^ {- j}</span></div>

    <p class="text-gray-300"><span class="math">\\hat{\\bm{w}}_{b}(y,X,x_{0},\\ldots,x_{M^{\\prime}})=</span> <span class="math">-y\\ \\hat{\\bm{w}}_{a}(y,X,x_{0},\\ldots,x_{M^{\\prime}})</span> <span class="math">+(0,\\ldots,0,y^{LMN-1}x_{0}^{-1}\\ldots x_{M^{\\prime}-1}^{-1}X^{-N})</span></p>

    <p class="text-gray-300">To explain our choice of linear consistency constraint vectors, consider computing the scalar product of <span class="math">\\hat{\\bm{a}}(y,X,x_{0},\\ldots,x_{M^{\\prime}})</span> and <span class="math">\\hat{\\bm{w}}_{a}(y,X,x_{0},\\ldots,x_{M^{\\prime}})</span>. Focussing on the constant term in <span class="math">X,x_{0},\\ldots,x_{M^{\\prime}}</span>, we see that the only contributions come from perfect cancellation of a monomial <span class="math">x_{0}^{i_{0}}x_{1}^{i_{1}}\\ldots x_{M^{\\prime}-1}^{i_{M^{\\prime}-1}}X^{j}</span> in <span class="math">\\hat{\\bm{a}}</span> with a corresponding monomial <span class="math">x_{0}^{-i_{0}}\\ldots x_{M^{\\prime}-1}^{-i_{M^{\\prime}-1}}X^{-j}</span> in <span class="math">\\hat{\\bm{w}}_{a}</span>. In addition, each monomial in <span class="math">\\hat{\\bm{w}}_{a}</span> is multiplied by a unique power of <span class="math">y^{k}</span>. Since <span class="math">\\hat{\\bm{w}}_{a}</span> also contains <span class="math">\\bm{y}</span> as a factor, the constant term of the expression is a sum of all elements of the matrix <span class="math">A</span>, each separated by a unique power of <span class="math">y</span>. We can also multiply by powers of <span class="math">y</span> to move all elements of the matrix to different powers of <span class="math">y</span>. It is then straightforward to see that we can encode the shift condition for <span class="math">A</span> and <span class="math">B</span> by using this trick, and subtracting one monomial to ensure that the final element of <span class="math">B</span> is not included.</p>

    <p class="text-gray-300">Careful calculation shows that</p>

    <p class="text-gray-300"><span class="math">\\hat{\\bm{a}}\\cdot\\hat{\\bm{w}}_{a}(y,X,x_{0},\\ldots,x_{M^{\\prime}-1})+\\hat{\\bm{b}}\\cdot\\hat{\\bm{w}}_{b}(y,X,x_{0},\\ldots,x_{M^{\\prime}-1})</span></p>

    <p class="text-gray-300">has constant term in <span class="math">X,x_{0},\\ldots,x_{M^{\\prime}}</span> equal to <span class="math">1</span> if and only if <span class="math">A</span> and <span class="math">B</span> satisfy the shift condition. This happens because when we take the scalar products of the vectors of polynomials, all of the the linear consistency constraints end up in the constant term in <span class="math">X</span>, separated by different powers of <span class="math">y</span>. All other <em>waste</em> terms end up in other coefficients.</p>

    <p class="text-gray-300">The verifier will check the following polynomial expression evaluated in <span class="math">x</span>.</p>

    <p class="text-gray-300"><span class="math">\\hat{\\bm{a}}\\cdot\\hat{\\bm{w}}_{a}(X,x_{0},\\ldots,x_{M^{\\prime}-1})</span> <span class="math">+\\hat{\\bm{b}}\\cdot\\hat{\\bm{w}}_{b}(X,x_{0},\\ldots,x_{M^{\\prime}-1})=1+\\sum_{t=0}^{M^{\\prime}-1}(f_{t}^{+}x_{t}+f_{t}^{-}x_{t}^{-1})\\quad+\\sum_{r=1-N,r\\neq 0}^{N-1}g_{r}X^{r}</span></p>

    <p class="text-gray-300">In this expression, the values <span class="math">f_{j}^{+},f_{j}^{-}</span> can be seen as compression factors to make up for the lossy compression, and the <span class="math">g_{r}</span> are coefficients containing <em>waste</em> values.</p>

    <p class="text-gray-300">As part of this protocol, the prover is required to send single values to ILC rather than vectors, but this is easily incorporated into the model by padding, and has no impact on the asymptotic efficiency.</p>

    <p class="text-gray-300">Note that the polynomials chosen above leak information about the wire values, so we must also incorporate some random blinders <span class="math">\\hat{\\bm{a}}_{0}</span> and <span class="math">\\hat{\\bm{b}}_{0}</span> into the real protocol to achieve zero-knowledge.</p>

    <h4 id="sec-60" class="text-lg font-semibold mt-6">Formal Description.</h4>

    <p class="text-gray-300">Next, we provide a formal description of the proof of knowledge of committed matrices satisfying the shift relation <span class="math">\\mathcal{R}_{\\mathsf{mshift}}</span>.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">67</p>

    <p class="text-gray-300"><strong>Proof:</strong></p>

    <p class="text-gray-300">Instance: The prover has already sent <span class="math">[\\pmb{a}_{i,j},\\pmb{b}_{i,j}]_{i = 0,j = 1}^{M - 1,N}</span> to the ILC channel.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{\\text{shift}} \\to \\text{ILC}</span>: The prover randomly selects <span class="math">\\hat{\\pmb{a}}_0, \\hat{\\pmb{b}}_0 \\gets \\mathbb{F}^k</span>.</p>

    <p class="text-gray-300">The prover sends <span class="math">\\hat{\\pmb{a}}_0</span> and <span class="math">\\hat{\\pmb{b}}_0</span> to ILC.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ILC}\\gets \\mathcal{V}_{\\mathrm{shift}}</span>: Verifier sends <span class="math">y\\gets \\mathbb{F}^{\\times}</span> to ILC.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{\\mathrm{shift}} \\to \\mathrm{ILC}</span>: The prover computes the following polynomial with vector coefficients in the variables <span class="math">X_0, \\ldots, X_{M&#x27; - 1}</span>, where <span class="math">M = 2^{M&#x27;}</span>, and similar polynomials with <span class="math">a</span> replaced by <span class="math">b, c</span> and <span class="math">d</span>. Here, <span class="math">i_0, \\ldots, i_{M&#x27; - 1}</span> represent the digits of the binary expansion of <span class="math">i</span>.</p>

    <div class="my-4 text-center"><span class="math-block">\\hat {\\boldsymbol {a}} _ {j} (X _ {0}, \\dots , X _ {M ^ {\\prime} - 1}) = \\sum_ {i = 0} ^ {M - 1} \\boldsymbol {a} _ {i, j} X _ {0} ^ {i _ {0}} X _ {1} ^ {i _ {1}} \\dots X _ {M ^ {\\prime} - 1} ^ {i _ {M ^ {\\prime} - 1}}</span></div>

    <p class="text-gray-300">The prover computes the following polynomials with vector coefficients in the variable <span class="math">X</span>, and similarly for <span class="math">b</span>.</p>

    <div class="my-4 text-center"><span class="math-block">\\hat {\\boldsymbol {a}} (X, X _ {0}, \\dots , X _ {M ^ {\\prime} - 1}) = \\hat {\\boldsymbol {a}} _ {0} + \\sum_ {j = 1} ^ {N} \\hat {\\boldsymbol {a}} _ {j} (X _ {0}, \\dots , X _ {M ^ {\\prime} - 1}) X ^ {j}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\hat {\\boldsymbol {w}} _ {a} (y, X, x _ {0}, \\dots , x _ {M ^ {\\prime}}) = \\boldsymbol {y} \\sum_ {i = 0, j = 1} ^ {M - 1, N} y ^ {k (i + (j - 1) M)} x _ {0} ^ {- i _ {0}} \\dots x _ {M ^ {\\prime} - 1} ^ {- i _ {M ^ {\\prime} - 1}} X ^ {- j}</span></div>

    <p class="text-gray-300">The prover finally takes the scalar product of the previous vectors of polynomials</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\hat {\\boldsymbol {a}} (X, X _ {0}, \\dots , X _ {M ^ {\\prime} - 1}) \\cdot \\hat {\\boldsymbol {w}} _ {a} (X, X _ {0}, \\dots , X _ {M ^ {\\prime} - 1}) \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\hat {\\boldsymbol {b}} (X, X _ {0}, \\dots , X _ {M ^ {\\prime} - 1}) \\cdot \\hat {\\boldsymbol {w}} _ {b} (X, X _ {0}, \\dots , X _ {M ^ {\\prime} - 1}) = 1 + f _ {0} ^ {+} X _ {0} + f _ {0} ^ {-} X _ {0} ^ {- 1} \\\\</li>

      <li>f _ {1} ^ {+} (X _ {0}) X _ {1} + f _ {1} ^ {-} (X _ {0}) X _ {1} ^ {- 1} \\\\</li>

    </ul>

    <p class="text-gray-300">\\vdots \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>f _ {M ^ {\\prime} - 1} ^ {+} (X _ {0}, \\dots , X _ {M ^ {\\prime} - 2}) X _ {M ^ {\\prime} - 1} \\\\</li>

      <li>f _ {M ^ {\\prime} - 1} ^ {-} \\left(X _ {0}, \\dots , X _ {M ^ {\\prime} - 2}\\right) X _ {M ^ {\\prime} - 1} ^ {- 1} \\\\</li>

      <li>\\sum_ {r = - N, r \\neq 0} ^ {N - 1} g _ {r} \\left(X _ {0}, \\dots , X _ {M ^ {\\prime} - 1}\\right) X ^ {r} \\\\</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">The prover sends <span class="math">f_0^+, f_0^-</span> to ILC.</p>

    <p class="text-gray-300">68</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ILC}\\gets \\mathcal{V}_{\\mathrm{shift}}</span>: The verifier sends <span class="math">x_0 \\gets \\mathbb{F}^\\times</span> to ILC.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{\\mathrm{shift}} \\to \\mathsf{ILC}</span>: The prover sends <span class="math">f_1^+ = f_1^+(x_0), f_1^- = f_1^-(x_0)</span> to ILC.</p>

    <p class="text-gray-300">For <span class="math">t = 1</span> to <span class="math">M&#x27; - 2</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>ILC <span class="math">\\leftarrow</span> <span class="math">\\mathcal{V}_{\\mathrm{shift}}</span>: The verifier sends <span class="math">x_{t} \\gets \\mathbb{F}^{\\times}</span> to ILC</li>

      <li><span class="math">\\mathcal{P}_{\\mathrm{shift}} \\to \\mathsf{ILC}</span>: The prover sends <span class="math">f_{t+1}^{+} = f_{t+1}^{+}(x_0, \\ldots, x_t), f_{t+1}^{-} = f_{t+1}^{-}(x_0, \\ldots, x_t)</span> to ILC.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{ILC}\\gets \\mathcal{V}_{\\mathrm{shift}}</span>: The verifier sends <span class="math">x_{M&#x27; - 1} \\gets \\mathbb{F}^{\\times}</span> to ILC.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{\\mathrm{shift}} \\to \\mathsf{ILC}</span>: The prover computes <span class="math">g_r = g_r(x_0, \\ldots, x_{M&#x27; - 1})</span> for <span class="math">-N \\leq r \\leq N - 1, r \\neq 0</span>.</p>

    <p class="text-gray-300">The prover sends <span class="math">\\{g_r\\}_{r = -N,r\\neq 0}^{N - 1}</span> to ILC.</p>

    <p class="text-gray-300"><strong>Verification</strong>: The verifier selects <span class="math">x \\gets \\mathbb{F}^{\\times}</span> uniformly at random. The verifier queries the ILC channel to get</p>

    <div class="my-4 text-center"><span class="math-block">\\hat{\\boldsymbol{a}} = \\hat{\\boldsymbol{a}}_0 + \\sum_{i=0,j=1}^{M-1,N} \\boldsymbol{a}_{i,j} x_0^{i_0} x_1^{i_1} \\dots x_{M&#x27; - 1}^{i_{M&#x27; - 1}} x^j</span></div>

    <p class="text-gray-300">and similarly for <span class="math">b</span>. The verifier also queries the ILC channel to get</p>

    <div class="my-4 text-center"><span class="math-block">\\hat{e} = 1 + \\sum_{t=0}^{M&#x27; - 1} \\left(f_t^+ x_t + f_t^- x_t^{-1}\\right) + \\sum_{r=-N,r\\neq 0}^{N-1} g_r x^r</span></div>

    <p class="text-gray-300">The verifier then checks whether the following equation holds and in that case accepts.</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\hat{\\boldsymbol{a}} \\cdot \\hat{\\boldsymbol{w}}_a(x, x_0, \\dots, x_{M' - 1}) \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\hat{\\boldsymbol{b}} \\cdot \\hat{\\boldsymbol{w}}_b(x, x_0, \\dots, x_{M' - 1}) \\stackrel{?}{=} \\hat{e}</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300"><strong>Security Analysis</strong>. Before analysing the security of the above protocol, we state a variation of the Schwarz-Zippel Lemma taken from <span class="math">\\left[\\mathrm{BCG}^{+}17\\right]</span>.</p>

    <p class="text-gray-300"><strong>Lemma 1</strong> ([BCG <span class="math">^+</span> 17]). Let <span class="math">\\mathbb{F}</span> be a field. Let <span class="math">P</span> be a function of the following form, where <span class="math">p_{0,i_0}</span> are constant values, and <span class="math">p_{1,i_1}(Z_0),\\ldots ,p_{u,i_u}(Z_0,\\ldots ,Z_{u - 1})</span> are</p>

    <p class="text-gray-300">arbitrary functions and not necessarily polynomials.</p>

    <div class="my-4 text-center"><span class="math-block">P(Z_0, \\dots, Z_u) = \\sum_{i_0 = -d_0}^{d_0} p_{0,i_0} Z_0^{i_0} + \\sum_{i_1 = -d_1, i_1 \\neq 0}^{d_1} p_{1,i_1}(Z_0) Z_1^{i_1} $$</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\dots + \\sum_{i_u = -d_u, i_u \\neq 0}^{d_u} p_{u,i_u}(Z_0, \\dots, Z_{u-1}) Z_u^{i_u}</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Let <span class="math">S</span> be a finite subset of <span class="math">\\mathbb{F}^{\\times}</span>. Let <span class="math">z_0, \\ldots, z_u</span> be selected at random independently and uniformly from <span class="math">S</span>. Let <span class="math">F</span> be the event that at least one value among <span class="math">p_{0,i_0}</span> or <span class="math">p_{s,i_s}(z_0, \\ldots, z_{s-1})</span> is not zero.</p>

    <p class="text-gray-300">Then</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr\\left[\\left\\{P(z_0, \\dots, z_u) = 0\\right\\} \\wedge F\\right] \\leq \\frac{\\sum_{t=0}^{u} (2d_t + 1)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Theorem 13.</strong> <span class="math">(\\mathcal{K}_{\\mathrm{ILC}}, \\mathcal{P}_{\\mathrm{shift}}, \\mathcal{V}_{\\mathrm{shift}})</span> is a proof system for the relation <span class="math">\\mathcal{R}_{\\mathrm{mshift}}</span> in the ILC model with perfect completeness, statistical knowledge soundness with straight-line extraction, and perfect special honest verifier zero-knowledge.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Perfect completeness follows by careful inspection of the protocol and considering the various polynomial expressions computed by the prover.</p>

    <p class="text-gray-300">Next, we show that the proof has statistical knowledge soundness with straight-line extraction. This is because the knowledge extractor already has access to the committed matrices <span class="math">[A]</span> and <span class="math">[B]</span>, having seen all messages sent between the prover and the ILC. It remains to show that for any deterministic malicious prover <span class="math">\\mathcal{P}_{\\mathrm{shift}}^*</span>, if the committed vectors are not a valid witness for <span class="math">\\mathcal{R}_{\\mathrm{mshift}}</span>, then there is negligible probability of accept. Recall that verifier queries to get the right-hand side of the following equations.</p>

    <div class="my-4 text-center"><span class="math-block">\\hat{\\boldsymbol{a}} = \\hat{\\boldsymbol{a}}_0 + \\sum_{i=0,j=1}^{M-1,N} \\boldsymbol{a}_{i,j} x_0^{i_0} x_1^{i_1} \\dots x_{M&#x27;-1}^{i_{M&#x27;-1}} x^j $$ $$ \\hat{\\boldsymbol{b}} = \\hat{\\boldsymbol{b}}_0 + \\sum_{i=0,j=1}^{M-1,N} \\boldsymbol{b}_{i,j} x_0^{i_0} x_1^{i_1} \\dots x_{M&#x27;-1}^{i_{M&#x27;-1}} x^j</span></div>

    <p class="text-gray-300">$$ \\begin{array}{l} \\hat{\\boldsymbol{a}} \\cdot \\hat{\\boldsymbol{w}}_a(x, x_0, \\dots, x_{M'-1}) \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\hat{\\boldsymbol{b}} \\cdot \\hat{\\boldsymbol{w}}_b(x, x_0, \\dots, x_{M'-1}) = \\sum_{t=0}^{M'-1} \\left(f_t^+ x_t + f_t^- x_t^{-1}\\right) + \\sum_{r=-N, r \\neq 0}^{N-1} g_r x^r.</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Now, substitute in the expressions for <span class="math">\\hat{\\pmb{a}}</span> and <span class="math">\\hat{\\pmb{b}}</span> into the left-hand side of the final equality. The verifier only accepts if the last equation holds. By assumption, <span class="math">\\mathcal{P}_{\\mathrm{shift}}^*</span></p>

    <p class="text-gray-300">is deterministic, and we know when it made its commitments. Hence, <span class="math">\\hat{\\bm{a}}_{0}</span> and <span class="math">\\hat{\\bm{b}}_{0}</span> are constants, <span class="math">f_{0}^{+},f_{0}^{-}</span> are functions of <span class="math">y</span>, and <span class="math">f_{1}^{+},f_{1}^{-}</span> are functions of <span class="math">y</span> and <span class="math">x_{0},\\ldots,,x_{M^{\\prime}-1}</span>, and the <span class="math">g_{r}</span> are functions of <span class="math">y,x_{0},\\ldots,x_{M^{\\prime}-1}</span>. We can now apply Lemma 1. Let <span class="math">\\bm{A}</span> denote the concatenation of all the <span class="math">\\bm{a}</span> vectors, indexed from <span class="math">0</span> so that <span class="math">\\bm{A}_{l-1+k(i+(j-1)M)}=(\\bm{a}_{i,j})_{l}</span>, and similarly for <span class="math">b</span>. Suppose the committed vectors <span class="math">\\bm{a}_{i,j},\\bm{b}_{i,j}</span> do not satisfy the shift relation. This can happen in two ways:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\bm{A}_{0}\\neq 1</span></li>

      <li><span class="math">\\bm{A}_{i}\\neq\\bm{B}_{i-1}</span> for some <span class="math">i\\in[N-1]</span></li>

    </ol>

    <p class="text-gray-300">Consider the coefficients of the powers of <span class="math">y</span> in the equation obtained when substituting the expressions for <span class="math">\\hat{\\bm{a}}</span>, <span class="math">\\hat{\\bm{b}}</span>, <span class="math">\\hat{\\bm{c}}</span> and <span class="math">\\hat{\\bm{d}}</span> into the left-hand side of the above equation. The constant is <span class="math">\\bm{A}_{0}</span> on the left hand side and <span class="math">1</span> on the right-hand side. Hence, in the first of the five cases, the constant term would be different and we have the event <span class="math">F</span>. For <span class="math">i</span> from <span class="math">1</span> to <span class="math">N-1</span>, we see that the coefficient of <span class="math">y^{i}</span> is <span class="math">\\bm{A}_{i}-\\bm{B}_{i-1}</span> on the left-hand side and <span class="math">0</span> on the right-hand side, so in the second case, we will also have event <span class="math">F</span>. So if the input does not satisfy the shift relation, we have event <span class="math">F</span>. Now Lemma 1 implies that there is negligible probability that the equation will be satisfied, and hence negligible probability that verifier will accept.</p>

    <p class="text-gray-300">Finally, we show that the proof is honest-verifier zero-knowledge. We describe how to simulate the verifier’s view efficiently, given values <span class="math">y,x_{0},\\ldots,x_{M^{\\prime}-1},x\\leftarrow\\mathbb{F}^{\\times}</span> for the random challenges used in the protocol. In an honest transcript, <span class="math">\\hat{\\bm{a}}_{0}</span> is chosen uniformly at random and added to something independent of <span class="math">\\hat{\\bm{a}}_{0}</span> to obtain <span class="math">\\hat{\\bm{a}}</span>. Hence <span class="math">\\hat{\\bm{a}}</span> is uniformly distributed and can easily be simulated. Similarly for <span class="math">b,c</span> and <span class="math">d</span>. The final value to simulate is <span class="math">\\hat{e}</span>, but for an accepting transcript this is uniquely determined and easy to compute given <span class="math">\\hat{\\bm{a}}</span> and <span class="math">\\hat{\\bm{b}}</span>. Therefore, we can simulate the transcript and the proof system has special honest verifier zero knowledge. ∎</p>

    <h4 id="sec-61" class="text-lg font-semibold mt-6">Efficiency.</h4>

    <p class="text-gray-300">The verifier has a query complexity of <span class="math">3</span> and sends <span class="math">\\mu+1</span> field elements to the prover. The prover commits to a total of <span class="math">2M^{\\prime}+2N</span> vectors in <span class="math">\\mathbb{F}^{k}</span>.</p>

    <p class="text-gray-300">In the protocol as written, the prover has computed on multivariate polynomials with vector coefficients. However, the prover only needs to commit to elements of <span class="math">\\mathbb{F}^{k}</span>. Therefore, the prover can save considerable computational effort by computing mostly on vectors, and using challenges <span class="math">y,x_{0},\\ldots,x_{M^{\\prime}-1}</span> as they become available to partially evaluate expressions and ‘collapse’ multiple vectors into fewer vectors. We analyse the prover’s computation from the final round to the first round.</p>

    <p class="text-gray-300">After receiving <span class="math">x_{M^{\\prime}-1}</span>, and computing <span class="math">\\dot{\\bm{a}}_{j},\\dot{\\bm{b}}_{j}</span>, the prover must compute the values <span class="math">\\bm{e}_{r}</span>. This is done by expressing <span class="math">\\hat{\\bm{a}},\\hat{\\bm{b}}</span> as polynomials in <span class="math">X</span> of degree <span class="math">N</span>, with vector coefficients <span class="math">\\hat{\\bm{a}}_{j},\\hat{\\bm{b}}_{j}</span>. Then, the <span class="math">\\bm{e}_{r}</span> are the coefficients of the Hadamard product polynomial. Using FFT techniques for each vector component, the cost is <span class="math">O(kN\\log N)</span>.</p>

    <p class="text-gray-300">Now we explain how the prover computes the values <span class="math">f_{j}^{+},f_{j}^{-}</span> by computing the values of <span class="math">\\hat{\\bm{a}}_{j},\\hat{\\bm{b}}_{j}</span> and <span class="math">\\hat{\\bm{a}}_{j}\\circ\\hat{\\bm{b}}_{j}</span> recursively. Consider the following expressions,</p>

    <p class="text-gray-300">assuming that the prover has already evaluated in all challenges preceding <span class="math">X_{M^{\\prime}-1}</span>.</p>

    <p class="text-gray-300"><span class="math">\\dot{\\bm{a}}_{j}(x_{0},\\ldots,x_{M^{\\prime}-2},X_{M^{\\prime}-1})</span> <span class="math">=\\sum_{i=0}^{M-1}\\bm{a}_{i,j}y^{i}x_{0}^{i_{0}}x_{1}^{i_{1}}\\ldots x_{M^{\\prime}-2}^{i_{M^{\\prime}-2}}X_{M^{\\prime}-1}^{i_{M^{\\prime}-1}}</span> <span class="math">=\\bm{A}_{0,j}+\\bm{A}_{1,j}X_{M^{\\prime}-1}</span> <span class="math">\\dot{\\bm{b}}_{j}(x_{0},\\ldots,x_{M^{\\prime}-2},X_{M^{\\prime}-1})</span> <span class="math">=\\sum_{i=0}^{M-1}\\bm{b}_{i,j}x_{0}^{-i_{0}}x_{1}^{-i_{1}}\\ldots x_{M^{\\prime}-2}^{-i_{M^{\\prime}-2}}X_{M^{\\prime}-1}^{-i_{M^{\\prime}-1}}</span> <span class="math">=\\bm{B}_{0,j}+\\bm{B}_{1,j}X_{M^{\\prime}-1}^{-1}</span></p>

    <p class="text-gray-300">By assumption, <span class="math">\\bm{A}_{0,j},\\bm{A}_{1,j},\\bm{B}_{0,j},\\bm{B}_{1,j}</span> have already been computed at this stage. The cost of evaluating <span class="math">\\dot{\\bm{a}}_{j},\\dot{\\bm{b}}_{j}</span> and <span class="math">\\dot{\\bm{a}}_{j}\\circ\\dot{\\bm{b}}_{j}</span> and its <span class="math">X_{M^{\\prime}-1}</span> coefficients is then <span class="math">5k</span> multiplications to compute the necessary Hadamard products and multiply by <span class="math">x_{M^{\\prime}-1}</span> and its inverse, giving <span class="math">5Nk</span> multiplications, since we do the computation for <span class="math">1\\leq j\\leq N</span>. Now, <span class="math">f_{M^{\\prime}-1}^{+}=\\sum_{j=1}^{N}\\bm{A}_{1,j}\\cdot\\bm{B}_{0,j}</span>, and <span class="math">\\bm{d}_{M^{\\prime}-1}^{-}</span> can be computed using a similar expression, which costs only <span class="math">(N-1)k</span> additions, given that the Hadamard products, such as <span class="math">\\bm{A}_{1,j}\\circ\\bm{B}_{0,j}</span>, were already computed in evaluating <span class="math">\\dot{\\bm{a}}_{j}</span> and <span class="math">\\dot{\\bm{b}}_{j}</span>.</p>

    <p class="text-gray-300">Clearly <span class="math">\\bm{A}_{0,j},\\bm{A}_{1,j},\\bm{B}_{0,j},\\bm{B}_{1,j}</span> have the same structure as <span class="math">\\dot{\\bm{a}}_{j},\\dot{\\bm{b}}_{j}</span>, but without the variable <span class="math">X_{M^{\\prime}-1}</span>. Splitting into coefficients of <span class="math">X_{M^{\\prime}-2}</span> in a similar way as with <span class="math">X_{M^{\\prime}-1}</span>, and assuming that we already have evaluations with respect to <span class="math">X_{0},\\ldots,X_{M^{\\prime}-3}</span>, we can use the same techniques as above twice to obtain <span class="math">\\bm{A}_{0,j},\\bm{A}_{1,j},\\bm{B}_{0,j},\\bm{B}_{1,j}</span>, associated Hadamard products <span class="math">\\bm{A}_{0,j}\\circ\\bm{B}_{0,j},\\bm{A}_{1,j}\\circ\\bm{B}_{1,j}</span>, and <span class="math">f_{M^{\\prime}-2}^{+},f_{M^{\\prime}-2}^{-}</span> using <span class="math">2\\cdot 5Nk</span> multiplications.</p>

    <p class="text-gray-300">By repeatedly splitting and applying this procedure <span class="math">M^{\\prime}</span> times, we can use the same techniques 4, then 8, up to <span class="math">2^{M^{\\prime}-1}</span> times. Summing up, the overall cost is dominated by <span class="math">5kN(2^{M^{\\prime}}-1)</span> multiplications, which is <span class="math">\\mathcal{O}(kNM)</span> multiplications.</p>

    <p class="text-gray-300">Altogether, the computational costs for the prover are <span class="math">\\mathcal{O}(kN\\log N+kNM)</span> multiplications in <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">Note also that both prover and verifier must compute <span class="math">\\hat{\\bm{w}}_{a}(y,x,x_{0},\\ldots,x_{M^{\\prime}-1})</span>, and similarly for <span class="math">b</span>, in terms of the random challenges. We have that <span class="math">\\bm{y}=(1,y,\\ldots,y^{k-1})</span> and</p>

    <p class="text-gray-300"><span class="math">\\hat{\\bm{w}}_{a}(y,x,x_{0},\\ldots,x_{M^{\\prime}})=\\bm{y}\\sum_{i=0,j=1}^{M-1,N}y^{k(i+(j-1)M)}x_{0}^{-i_{0}}\\ldots x_{M^{\\prime}-1}^{-i_{M^{\\prime}-1}}x^{-j}</span></p>

    <p class="text-gray-300">This can be done using <span class="math">\\mathcal{O}(MN+k)</span> multiplications in <span class="math">\\mathbb{F}</span>, since <span class="math">\\bm{y}</span> requires <span class="math">\\mathcal{O}(k)</span> multiplications to compute, and the sum requires <span class="math">\\mathcal{O}(MN)</span>. Aside from that, the dominant costs of the other parts of the protocol are the same, resulting in a cost of <span class="math">\\mathcal{O}(kN\\log N+kMN)</span> multiplications in <span class="math">\\mathbb{F}</span> for the prover, and <span class="math">\\mathcal{O}(MN+k)</span> multiplications in <span class="math">\\mathbb{F}</span> for the verifier.</p>

    <h3 id="sec-62" class="text-xl font-semibold mt-8">C.5 Proof for the Entry-Product of Matrices</h3>

    <p class="text-gray-300">Now that we have a proof for the shift condition, and a Hadamard-product proof, it is easy to construct a proof which shows that the product of all entries in a</p>

    <p class="text-gray-300">!<a href="img-11.jpeg">img-11.jpeg</a> Fig. 29: Entry-Product Proof decomposed into sub-proofs.</p>

    <p class="text-gray-300">matrix  <span class="math">A</span>  was computed correctly. Bootle et al. [BCG+17] gave an ILC model proof for the product of all entries in two matrices yielding the same value, so this proof system can be seen as a tweak that handles the simpler setting with a single matrix.</p>

    <p class="text-gray-300">The proof is constructed by computing the partial products of entries of the matrix  <span class="math">A</span> , beginning with 1, and storing them in a matrix  <span class="math">A_{1}</span>  with the same dimensions as  <span class="math">A</span> . The partial products, ending with the product of all elements of  <span class="math">A</span> , are stored in another matrix  <span class="math">A_{2}</span> , of which  <span class="math">P</span>  is the final entry. Now,  <span class="math">A_{2} = A \\circ A_{1}</span>  by design. Note that the product of all entries in  <span class="math">A</span>  was correctly computed if and only if  <span class="math">A_{1}</span>  and  <span class="math">A_{2}</span>  satisfy the shift condition. This gives rise to the entry-product proof shown in Fig. 31. An example follows.</p>

    <p class="text-gray-300">!<a href="img-12.jpeg">img-12.jpeg</a></p>

    <p class="text-gray-300">Theorem 14.  <span class="math">(\\mathcal{K}_{\\mathrm{ILC}},\\mathcal{P}_{\\mathrm{entry - prod}},\\mathcal{V}_{\\mathrm{entry - prod}})</span>  is a proof system for the relation  <span class="math">\\mathcal{R}_{\\mathrm{entry - prod}}</span>  in the ILC model with perfect completeness, statistical knowledge soundness with straight-line extraction, and perfect special honest verifier zero-knowledge.</p>

    <p class="text-gray-300">Proof. Perfect completeness follows by inspection.</p>

    <p class="text-gray-300">For statistical knowledge soundness with straight-line extraction, let matrix  <span class="math">A</span>  be given. If there exist  <span class="math">A_{1}, A_{2}</span>  such that  <span class="math">((\\mathbb{F}, k), ([A], [A_{1}], [A_{2}]), (A, A_{1}, A_{2})) \\in \\mathcal{R}_{\\mathrm{prod}}</span>  and  <span class="math">((\\mathbb{F}, k), ([A_{1}], [A_{2}]), (A_{1}, A_{2})) \\in \\mathcal{R}_{\\mathrm{mshift}}</span> , and the final row of  <span class="math">A_{2}</span>  contains the value  <span class="math">P</span> , then  <span class="math">((\\mathbb{F}, k), ([A], [P]), (A, P)) \\in \\mathcal{R}_{\\mathrm{entry - prod}}</span> . So by the soundness property of the underlying protocols, if  <span class="math">((\\mathbb{F}, k), ([A], [B]), (A, B)) \\notin \\mathcal{R}_{\\mathrm{entry - prod}}</span> , one of the sub-protocols will have negligible probability of accept. Since the extractor can read the committed values, we have statistical knowledge soundness with straight-line extraction.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pentry-prod(ppILC, ([A], [P]), (A, P))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ventry-prod(ppILC, ([A], [P]))</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Commit to matrices A1, A2, i.e. the partial products of A</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Vprod(ppILC, ([A], [A1], [A2])) - Run Vshift(ppILC, ([A1], [A2]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Pprod(ppILC, ([A], [A1], [A2]), (A, A1, A2))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Vprod(ppILC, (v, [v]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Pshift(ppILC, ([A1], [A2]), (A1, A2))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Vprod(ppILC, ([p], [v], [P]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Commit to v = (0, ..., 0, 1).</td>

            <td class="px-3 py-2 border-b border-gray-700">- Return 1 if all proofs accept,</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Peq(ppILC, (v, [v]), (v))</td>

            <td class="px-3 py-2 border-b border-gray-700">Return 0 otherwise</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  - Let p be the final row of A2. |   |</p>

    <p class="text-gray-300">|  - Run Pprod(ppILC, ([p], [v], [P]), (p, v, P)) |   |</p>

    <p class="text-gray-300">Fig. 30: Entry-Product Argument for two committed matrices.</p>

    <p class="text-gray-300">To see we have perfect special honest verifier zero-knowledge, simulate that the verifier receives commitments to a matrix in  <span class="math">\\mathbb{F}^{N_x\\times k}</span> , commit to random matrices  <span class="math">A_{1}</span>  and  <span class="math">A_{2}</span>  in  <span class="math">\\mathbb{F}^{N_x\\times k}</span> , and run the perfect special honest verifier zero-knowledge simulators on the product and shift proofs.</p>

    <p class="text-gray-300">In the ILC model, we describes a proof the entries in a matrix  <span class="math">A \\in \\mathbb{F}^{MN \\times k}</span>  sum to a known value  <span class="math">x</span> .</p>

    <p class="text-gray-300">The prover wishes to show that the committed matrix  <span class="math">[A]</span>  is such that  <span class="math">\\sum_{i,j} a_{i,j} = x</span> . The prover begins by committing to a matrix of zeros in all but the final row, which contains all ones. It also commits to a matrix with ones in the first column and zeros everywhere else. It then commits to a matrix that contains the all zeros in all but the final row, which contains the column-wise sum of the matrix  <span class="math">A</span> , and the transpose of this matrix.</p>

    <p class="text-gray-300">!<a href="img-13.jpeg">img-13.jpeg</a></p>

    <p class="text-gray-300">If the dimensions do not match then the required matrices are padded with zeros. To show that these values are calculated correctly, it runs an equality argument with  <span class="math">J_{2}</span> ,  <span class="math">J_{2}^{T}</span> , a product argument to show that  <span class="math">V \\circ J_{2} = V</span>  and  <span class="math">V^{T} \\circ J_{2}^{T} = V^{T}</span> , and then a sum argument to show that  <span class="math">\\sum [A_{i}] = V</span> . Afterwards, it runs an</p>

    <p class="text-gray-300">unknown permutation argument to show that every entry in  <span class="math">V</span>  appears in  <span class="math">V^T</span>  (it does not matter which row the entries occur in because the values will be summed later anyway).</p>

    <p class="text-gray-300">Finally, the prover commits to the matrix  <span class="math">X</span>  containing  <span class="math">x</span>  in the bottom left corner and zeros everywhere else (and runs an equality argument). It runs a sum argument to show that  <span class="math">\\sum [V^T]_i = [X]</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pgrandsum(ppILC, (x, [A]), (A))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Vgrandsum(ppILC, (x, [A]))</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Commit to matrices J2, J2T, V, V^T, X.</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Veq(ppILC, (J2, [J2]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Peq(ppILC, (J2, [J2]), (J2))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Veq(ppILC, (J2T, [J2T]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Peq(ppILC, (J2T, [J2T]), (J2T))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Vprod(ppILC, ([V], [J2], [V]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Pprod(ppILC, ([V], [J2], [V]), (V, J2, V))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Vprod(ppILC, ([V^T], [J2^T], [V^T]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Pprod(ppILC, ([V^T], [J2^T], [V^T]), (V^T, J2^T, V^T))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Vperm(ppILC, ((1, ..., 1), [A], [V]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Pperm(ppILC, ((1, ..., 1), [A], [V]), (A1, ..., V))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Vperm(ppILC, ([V], [V^T]), π)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Pperm(ppILC, ([V], [V^T]), (π, V, V^T))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Veq(ppILC, (X, [X]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Peq(ppILC, (X, [X]), (X))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Run Vperm(ppILC, ((1, ..., 1), [V^T], [X]))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Run Psum(ppILC, ((1, ..., 1), [V^T], [X]), (V1^T, ..., X))</td>

            <td class="px-3 py-2 border-b border-gray-700">- Return 1 if all proofs accept, Return 0 otherwise</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 31: Entry-Product Argument for two committed matrices.</p>

    <p class="text-gray-300">Theorem 15. There is a proof system  <span class="math">(\\mathcal{K}_{\\mathrm{ILC}},\\mathcal{P}_{\\mathrm{grandum}},\\mathcal{V}_{\\mathrm{grandsum}})</span>  for the relation  <span class="math">\\mathcal{R}_{\\mathrm{grandsum}}</span>  in the ILC model with perfect completeness, statistical knowledge soundness with straight-line extraction and perfect special honest verifier zero-knowledge.</p>

    <p class="text-gray-300">Proof. Perfect completeness follows by inspection.</p>

    <p class="text-gray-300">For statistical knowledge soundness with straight-line extraction, let matrix  <span class="math">A</span>  be given. If there exist  <span class="math">V, V^T</span>  such that  <span class="math">((\\mathbb{F}, k), ([V], [J_2], [V]), (V, V^T)) \\in \\mathcal{R}_{\\mathrm{prod}}</span>  and  <span class="math">((\\mathbb{F}, k), ([V^T], [J_2^T], [V^T]), (V^T, J_2^T, V^T)) \\in \\mathcal{R}_{\\mathrm{prod}}</span>  then  <span class="math">V</span>  contains zeros except in the final row and  <span class="math">V^T</span>  contains zeros except in the first column. If further  <span class="math">((\\mathbb{F}, k), ((1, \\ldots, 1), [A]_i, [V]), (A_1, \\ldots, V)) \\in \\mathcal{R}_{\\mathrm{sum}}</span>  then  <span class="math">V</span>  contains the columnwise sum (which must be in the final row because this is the only nonzero row). The requirement that  <span class="math">((\\mathbb{F}, k), ([V], [V^T]), (V, V^T)) \\in \\mathcal{R}_{\\mathrm{perm}}</span>  means that all the entries in  <span class="math">[V]</span>  must occur in the first column of  <span class="math">V^T</span> . Finally, if  <span class="math">((\\mathbb{F}, k), ((1, \\ldots, 1), [V^T]_i, X), (V_1^T, \\ldots, X)) \\in \\mathcal{R}_{\\mathrm{sum}}</span>  then the sum of all the entries in  <span class="math">A</span>  must be equal to  <span class="math">x</span> . So by the soundness property of the underlying protocols, if  <span class="math">((\\mathbb{F}, k), (x, [A]), (A)) \\notin \\mathcal{R}_{\\mathrm{grandsum}}</span> , one of the sub-protocols will have negligible probability of accept. Since the extractor can read the committed values, we have statistical knowledge soundness with straight-line extraction.</p>

    <p class="text-gray-300">To see we have perfect special honest verifier zero-knowledge, simulate that the verifier receives commitments to a matrix in  <span class="math">\\mathbb{F}^{N_<em> \\times k}</span> , commit to random matrices  <span class="math">V</span>  and  <span class="math">V^T</span>  in  <span class="math">\\mathbb{F}^{N_</em> \\times k}</span> , and run the perfect special honest verifier zero-knowledge simulators on the product, sum, and permutation proofs.</p>

    <p class="text-gray-300">The efficiency of the protocol is given in the following table, where  <span class="math">T_{\\mathcal{P}}</span>  and  <span class="math">T_{\\mathcal{V}}</span>  refers to the prover and verifier computation (measured in field operations),  <span class="math">qc</span>  is the query complexity (measured in the number of linear combinations the verifier asks for), and  <span class="math">t</span>  is the number of vectors the prover commits to during the proof.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">TP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">TV</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">qc</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rsum</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">N* - 1 mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rpred</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kN log N + kMN) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">O(MN + k) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">log M + 2</td>

            <td class="px-3 py-2 border-b border-gray-700">2M' + 2N + 3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rsperm</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kN log N + kMN) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kMN) add.</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700">log M + 2</td>

            <td class="px-3 py-2 border-b border-gray-700">O(MN)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Runshift</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kN log N + kMN) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">O(MN + k) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">log M + 2</td>

            <td class="px-3 py-2 border-b border-gray-700">2M' + 2N</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rentry-prod</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kN log N + kMN) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">O(MN + k) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">log M + 2</td>

            <td class="px-3 py-2 border-b border-gray-700">O(MN)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Rgrandsum</td>

            <td class="px-3 py-2 border-b border-gray-700">O(kN log N + kMN) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">O(MN + k) mult.</td>

            <td class="px-3 py-2 border-b border-gray-700">35</td>

            <td class="px-3 py-2 border-b border-gray-700">log M + 2</td>

            <td class="px-3 py-2 border-b border-gray-700">O(MN)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6: Efficiency of protocols in Layer 4. THe values  <span class="math">M</span> ,  <span class="math">N</span>  are tuneable parameters in the Hadamard product proof; good performance is achieved on the condition  <span class="math">N_{*} = MN</span></p>`;
---

<BaseLayout title="Nearly Linear-Time Zero-Knowledge Proofs for Correct Program... (2018/380)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/380
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
