---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/462';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-14';
---

<BaseLayout title="New Optimization Techniques for PlonK's Arithmetization (2022/462)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        New Optimization Techniques for PlonK&rsquo;s Arithmetization
      </h1>
      <p class="text-gray-400 mb-2">
        Miguel Ambrona, Anne-Laure Schmitt, Raphael R. Toledo,
        and Danny Willems
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; Nomadic Labs, Paris, France &middot;
        eprint 2022/462
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">Converted with: {CRAWLER} &middot; {CONVERTED_DATE}</p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-1.1"
                class="hover:text-white">
                Applications of SNARKs</a>
            </li>
            <li>
              <a href="#sec-1.2"
                class="hover:text-white">Our Contributions</a>
            </li>
            <li>
              <a href="#sec-1.3"
                class="hover:text-white">Related Work</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-2.1"
                class="hover:text-white">Notation</a>
            </li>
            <li>
              <a href="#sec-2.2"
                class="hover:text-white">Hades Strategy</a>
            </li>
            <li>
              <a href="#sec-2.3"
                class="hover:text-white">Poseidon</a>
            </li>
            <li>
              <a href="#sec-2.4"
                class="hover:text-white">
                SNARKs Arithmetizations</a>
            </li>
            <li>
              <a href="#sec-2.5"
                class="hover:text-white">
                PlonK&rsquo;s Arithmetization</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">
            New Optimizations on PlonK&rsquo;s
            Arithmetization</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-3.1"
                class="hover:text-white">
                Optimizing Turbo-PlonK Constraint Systems</a>
            </li>
            <li>
              <a href="#sec-3.2"
                class="hover:text-white">
                Automated Optimizer of Constraints</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">
            Optimizing Poseidon Hash</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-4.1"
                class="hover:text-white">
                Optimized Implementation of Poseidon</a>
            </li>
            <li>
              <a href="#sec-4.2"
                class="hover:text-white">Linear Skip</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-5"
            class="hover:text-white">Results</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-5.1"
                class="hover:text-white">
                Optimized PlonK Circuits for Poseidon</a>
            </li>
            <li>
              <a href="#sec-5.2"
                class="hover:text-white">
                Optimized Poseidon on CPU</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-6"
            class="hover:text-white">Conclusions</a>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400 list-disc
        list-inside">
        <li>
          <a href="#acknowledgments"
            class="hover:text-white">Acknowledgments</a>
        </li>
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
        <li>
          <a href="#appendix-a"
            class="hover:text-white">
            Appendix A: Proofs of the Main Body</a>
        </li>
      </ul>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">
        PlonK is a universal and updatable zk-SNARK for general circuit
        satisfiability that allows a verifier to check the validity of
        a certain NP statement very efficiently, optionally in
        zero-knowledge. PlonK requires that the NP relation of interest
        be expressed as a system of so-called PlonK constraints. Such
        conversion is complex and can be implemented in various ways,
        having a great impact on the prover complexity (which is
        typically linearithmic in the number of PlonK constraints).
      </p>
      <p class="text-gray-300">
        We propose several general results for simplifying PlonK
        constraint systems, which produce more compact but equivalent
        systems and can lead to significant performance improvements.
        We also develop an automated optimizer of constraints, based on
        our techniques, that can be used to construct very compact and
        less error-prone constraint systems, favoring a more auditable
        circuit design.
      </p>
      <p class="text-gray-300">
        Finally, we demonstrate the potential of our techniques by
        implementing optimized constraint systems for the Poseidon
        hash, obtaining the most compact representations in the
        Turbo-PlonK model with minimal custom gates. En route, we
        devise a novel optimization idea for implementing Poseidon
        partial rounds and show that it can be applied to both
        simplifying SNARK circuits and achieving performance
        improvements in CPU implementations of the Poseidon hash.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1. Introduction</h2>

      <p class="text-gray-300">
        Succinct non-interactive arguments of knowledge (SNARKs)
        [GGPR13, BCG+13, PHGR13, Gro16] are a class of non-interactive
        arguments of knowledge systems with generally constant
        communication complexity and logarithmic verification
        complexity. This comes at the cost of a significantly slower
        prover, compared to other zero-knowledge proof systems with
        higher communication complexity [JKO13, GMO16, CGM16].
      </p>
      <p class="text-gray-300">
        To be secure, SNARKs usually require a so-called structured
        reference string (SRS), usually comprising the successive
        powers of a secret element, which if known would break
        soundness. The generation of such SRS is usually performed
        collaboratively through a multi-party computation (MPC)
        protocol in so-called setup ceremonies [BGM17].
      </p>
      <p class="text-gray-300">
        PlonK [GWC19], which stands for Permutations over
        Lagrange-bases for Oecumenical Non-interactive arguments of
        Knowledge, is a universal and updatable zero-knowledge SNARK
        for general circuit satisfiability. Given its significant
        improvements with respect to its predecessor Sonic [MBKM19],
        especially on prover efficiency, PlonK has become very popular
        and has been adopted by several state-of-the-art blockchain
        projects such as Zcash [HBHW22], Mina [BMRS20], the Dusk
        Network [MKF21] or Anoma [GYB21].
      </p>
      <p class="text-gray-300">
        In PlonK&rsquo;s original paper, circuits are expressed in
        terms of a 2 fan-in 1 fan-out parametric arithmetic gate over
        an algebraic field. The whole constraint system is transformed
        into polynomials which are then committed using a polynomial
        commitment scheme and evaluated on a random point during the
        proving process. Using Fast Fourier Transforms for the
        polynomial conversion and efficient polynomial multiplication,
        and computing the commitments with KZG [KZG10], the prover
        complexity is in
        <span class="math">O(kn \cdot \log n)</span> scalar
        operations for the former and
        <span class="math">O(kn)</span> group operations for the
        latter where <span class="math">k</span> is the number of
        wires, and <span class="math">n</span> the number of
        constraints.
      </p>
      <p class="text-gray-300">
        The circuit is furthermore limited by the SRS size.
        As the polynomials are committed with the SRS, the number of
        constraints in a circuit is upper-bounded by the size of the
        SRS. A compact representation of circuits is paramount to make
        PlonK-based SNARKs more practical. This is the subject of this
        paper.
      </p>

      <!-- 1.1 Applications of SNARKs -->

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8 mb-3">
        1.1 Applications of SNARKs
      </h3>
      <p class="text-gray-300">
        A number of blockchain projects have jumped on the opportunity
        of using zk-SNARKs, and leverage the unique properties that
        zero-knowledge proofs provide, for various applications. From
        identification to storage (Filecoin [Lab17]) as well as private
        transactions (Zcash [HBHW22]). Unlike other alternative ZK
        proving systems, zk-SNARKs enjoy extremely efficient
        verification times and very compact proofs, this makes them
        particularly suitable for on-chain validation.
      </p>
      <p class="text-gray-300">
        Hash functions are an essential building block for blockchain
        applications, as they are the basis for Merkle-tree-based set
        accumulator schemes and signature schemes. Although
        SNARK-friendly hash functions can be implemented significantly
        more efficiently than their more standard counterparts, they
        are still one of the main bottlenecks [WS21, Zca21]. For these
        reasons, it is important to develop new techniques that allow
        us to model efficient and compact circuits of such primitives.
      </p>

      <!-- 1.2 Our contributions -->

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8 mb-3">
        1.2 Our Contributions
      </h3>
      <p class="text-gray-300">
        <strong>Simplification of PlonK constraint systems.</strong>
        We propose generic optimization mechanisms to simplify
        Turbo-PlonK constraint systems. Our techniques can reduce the
        number of constraints and variables in the arithmetization,
        while preserving the satisfiability of the underlying system of
        polynomial equations induced by them. Our simplifications
        exploit the fact that Turbo-PlonK constraints can access the
        wires corresponding to the next constraint in the system.
      </p>
      <p class="text-gray-300">
        <strong>Automated optimizer of constraints.</strong> We propose
        an automated mechanism for applying the above simplification
        techniques, abstracted out as simple rewriting rules (Section
        3.2). This allows a user to design circuits in the original
        and less error-prone (but unoptimized) input/output abstraction
        based on arithmetic gates and then use the automated optimizer
        to benefit from the simplification techniques.
      </p>
      <p class="text-gray-300">
        <strong>Optimized circuits for the Poseidon hash.</strong> We
        demonstrate the potential of our techniques by implementing
        optimized circuits for the Poseidon hash. En route, we devise
        a novel idea for implementing partial rounds, coined the
        <em>linear skip</em> (Section 4.2), that leverages the fact
        that partial rounds are almost linear functions, and the
        composition of linear functions is again a linear function.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">Remark 1</div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            This work is part of a library implemented by the Nomadic
            Labs&rsquo; Crypto Team [Nom22b], designed to develop
            private transactions (based on the Sapling protocol by
            Zcash [HBHW22]) and zero-knowledge rollups over the Tezos
            blockchain [Goo14]. The current proposal uses Merkle-trees
            as set accumulators and Schnorr signatures for validating
            the authenticity of transactions. Both primitives heavily
            rely on a secure hash function, which has been chosen to be
            Poseidon.
          </p>
        </div>
      </div>

      <!-- 1.3 Related work -->

      <h3 id="sec-1.3" class="text-xl font-semibold mt-8 mb-3">
        1.3 Related Work
      </h3>
      <p class="text-gray-300">
        <strong>Zero-knowledge arguments.</strong> Zero-knowledge
        arguments were introduced by Goldwasser, Micali and Rackoff in
        1985 [GMR85]. They allow a prover to convince a verifier of the
        validity of a certain statement without revealing any other
        information, e.g., why the statement is true. A few years
        later, Blum, Feldman and Micali [BFM88] extended this notion
        and considered non-interactive zero-knowledge arguments (NIZK).
      </p>
      <p class="text-gray-300">
        <strong>PlonK family.</strong> A number of projects has
        branched out since PlonK&rsquo;s release. Following
        Turbo-PlonK, Plookup [GW20], in 2020, allows the use of
        look-up tables and facilitates range checks and queries with
        the use of new identities. Several polynomial commitment
        schemes, SHPlonk [BDFG20] and FFlonk [GW21a], released in
        2020 and 2021, implicitly target PlonK. The Electric Coin
        Company changed their proving system from Groth16 to PlonK in
        2020 when publishing Halo2 [BGH].
      </p>
      <p class="text-gray-300">
        <strong>R1CS vs PlonK&rsquo;s constraint system.</strong>
        Groth16 and PlonK are the two main proof systems used in the
        blockchain world. They differ in many points, including the
        universality of the setup, but especially in their
        arithmetization. PlonK uses an algebraic gate which corresponds
        to the equality of the addition and multiplication of two input
        wires with an output variable, while Groth16 uses Rank 1
        Constraint Systems (R1CS).
      </p>
      <p class="text-gray-300">
        <strong>Alternative efficient implementations of
        Poseidon.</strong> In the original Poseidon paper
        [GKR+19, Appendix B], the authors propose an optimization that
        exploits the structure of partial rounds and the fact that they
        only involve one S-box. This idea consists of rearranging the
        structure of the constant and linear layers in order to express
        the linear part of partial rounds as the multiplication by a
        very sparse matrix. This technique is similar to the proposed
        <em>linear skip</em>, where such linear part of partial rounds
        is replaced by the identity matrix at the cost of carrying a
        computation for the next layer.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 2. PRELIMINARIES                                             -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2. Preliminaries</h2>

      <!-- 2.1 Notation -->

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8 mb-3">
        2.1 Notation
      </h3>
      <p class="text-gray-300">
        We consider bilinear groups
        <span class="math">(\mathbb&#123;G&#125;_1, \mathbb&#123;G&#125;_2, \mathbb&#123;G&#125;_t, e : \mathbb&#123;G&#125;_1 \times \mathbb&#123;G&#125;_2 \to \mathbb&#123;G&#125;_t)</span>
        of prime order <span class="math">p</span>. We use additive
        notation for all three groups. Throughout the paper, all
        polynomial equations will have coefficients over the scalar
        field <span class="math">\mathbb&#123;Z&#125;_p</span>.
      </p>
      <p class="text-gray-300">
        We use bold case for vectors. Given a vector
        <span class="math">\boldsymbol&#123;x&#125;</span> over some
        <span class="math">n</span> dimensional vector space, we
        denote by <span class="math">x_i</span> its
        <span class="math">i</span>-th coordinate, for all
        <span class="math">i \in [n]</span>. We denote concatenation
        as <span class="math">\parallel</span>, used as a separator of
        elements of the same type (typically constraints).
      </p>

      <!-- 2.2 Hades strategy -->

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8 mb-3">
        2.2 Hades Strategy
      </h3>
      <p class="text-gray-300">
        Confusion and diffusion [Sha49] are two key properties when
        building cryptographic primitives. One of the simplest ways to
        achieve both is to use a substitution-permutation network
        (SPNs). This approach has been recently revisited in the case
        of algebraic hash functions in an effort to reduce the number
        of permutations. These partial SPNs (P-SPNs) gave birth to
        Zorro in 2013, LowMC in 2015 and MiMC in 2016 to cite a few.
      </p>
      <p class="text-gray-300">
        Grassi et al. presented in 2020 the HADES Design Strategy
        together with an analysis framework built upon the wide trail
        design strategy. The Hades strategy is organized in layers,
        with so-called partial rounds (P-SPNs) surrounded by full
        rounds (SPNs) to prevent statistical attacks.
      </p>

      <!-- 2.3 Poseidon -->

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8 mb-3">
        2.3 Poseidon
      </h3>
      <p class="text-gray-300">
        Poseidon [GKR+21] is an algebraic hash function family
        presented by Grassi et al. in 2020 relying on the Hades Design
        strategy. In particular, Poseidon consists of a
        substitution-permutation network applied to a state with
        <span class="math">w</span> registers. Such network combines
        so-called full rounds with partial rounds. In a full round the
        state is modified by adding a constant to each register
        element, applying a non-linear function (S-box) to each of
        them and a linear layer involving all the elements in the
        state. Partial rounds are similar, but only apply the
        non-linear S-box to one of the register elements.
      </p>
      <p class="text-gray-300">
        The use of partial rounds aims at reducing the number of
        non-linear (and more expensive) operations. For this reason,
        it is particularly amenable for its implementation in R1CS
        constraint systems and PlonK-based ones and the Poseidon
        function family has been used in a number of projects,
        including Zcash [HBHW22], the Dusk Network [MKF21] and Mina
        [BMRS20].
      </p>

      <!-- 2.4 SNARKs arithmetizations -->

      <h3 id="sec-2.4" class="text-xl font-semibold mt-8 mb-3">
        2.4 SNARKs Arithmetizations
      </h3>
      <p class="text-gray-300">
        Most SNARKs model NP relations as arithmetic circuits that are
        represented by systems of multivariate polynomial equations.
        More concretely, let
        <span class="math">C^&#123;\boldsymbol&#123;x&#125;&#125;(\boldsymbol&#123;w&#125;) := R(\boldsymbol&#123;x&#125;, \boldsymbol&#123;w&#125;)</span>
        be a circuit parameterized by a statement
        <span class="math">\boldsymbol&#123;x&#125;</span>, which is
        satisfiable (on a certain input witness
        <span class="math">\boldsymbol&#123;w&#125;</span>) iff
        <span class="math">\boldsymbol&#123;x&#125;</span> belongs in
        the NP language induced by
        <span class="math">R</span>.
      </p>
      <p class="text-gray-300">
        The specific details about how arithmetic circuits are
        transformed into polynomial constraints are known as the
        system&rsquo;s arithmetization. For example, Rank 1 Constraint
        Systems (R1CS) require that every polynomial
        <span class="math">f_i</span> be such that it can be factored
        into three linear polynomials
        <span class="math">a_i, b_i, c_i</span> as follows:
      </p>
      <div class="math-block">
        f_i(\boldsymbol&#123;x&#125;, \boldsymbol&#123;w&#125;) = a_i(\boldsymbol&#123;x&#125;, \boldsymbol&#123;w&#125;) \cdot b_i(\boldsymbol&#123;x&#125;, \boldsymbol&#123;w&#125;) - c_i(\boldsymbol&#123;x&#125;, \boldsymbol&#123;w&#125;)
      </div>
      <p class="text-gray-300">
        On the other hand, PlonK imposes the following restrictions:
        each polynomial <span class="math">f_i</span> can involve at
        most <span class="math">N</span> different variables, where
        <span class="math">N</span> is the gate architecture size; and
        a polynomial <span class="math">f_i</span> can only contain
        monomials of a restricted form, which may be extended with
        so-called <em>custom gates</em> [GW19].
      </p>

      <!-- 2.5 PlonK's arithmetization -->

      <h3 id="sec-2.5" class="text-xl font-semibold mt-8 mb-3">
        2.5 PlonK&rsquo;s Arithmetization
      </h3>
      <p class="text-gray-300">
        <strong>From PlonK constraint system.</strong> In the PlonK
        proof system [GWC19], a constraint is a tuple
        <span class="math">(\mathsf&#123;a&#125;, \mathsf&#123;b&#125;, \mathsf&#123;c&#125;, \mathsf&#123;sels&#125;)</span>
        where
        <span class="math">\mathsf&#123;a&#125;, \mathsf&#123;b&#125;, \mathsf&#123;c&#125;</span>
        are formal variables and
        <span class="math">\mathsf&#123;sels&#125;</span> is a set of
        so-called selectors. In the original version of PlonK, the
        available selectors are
        <span class="math">q_L, q_R, q_O</span>, adding the left,
        right and output wires (resp.
        <span class="math">\mathsf&#123;a&#125;, \mathsf&#123;b&#125;, \mathsf&#123;c&#125;</span>),
        <span class="math">q_M</span>, multiplying two wires
        (<span class="math">\mathsf&#123;a&#125;</span> and
        <span class="math">\mathsf&#123;b&#125;</span>), and
        <span class="math">q_C</span> adding a public constant. Every
        constraint induces a polynomial equation:
      </p>
      <div class="math-block">
        q_&#123;\mathsf&#123;L&#125;&#125; \cdot \mathsf&#123;a&#125; + q_&#123;\mathsf&#123;R&#125;&#125; \cdot \mathsf&#123;b&#125; + q_&#123;\mathsf&#123;O&#125;&#125; \cdot \mathsf&#123;c&#125; + q_&#123;\mathsf&#123;M&#125;&#125; \cdot \mathsf&#123;a&#125; \cdot \mathsf&#123;b&#125; + q_&#123;\mathsf&#123;C&#125;&#125; = 0 \tag&#123;1&#125;
      </div>
      <p class="text-gray-300">
        Such equation captures addition and multiplication gates. For
        example, an addition gate
        <span class="math">c = a + b</span> can be modeled by setting
        <span class="math">q_L = q_R = 1</span>,
        <span class="math">q_O = -1</span> and
        <span class="math">q_M = q_C = 0</span>. And a
        multiplication gate <span class="math">c = ab</span> can be
        modeled as <span class="math">q_M = 1</span>,
        <span class="math">q_O = -1</span> and
        <span class="math">q_L = q_R = q_C = 0</span>.
      </p>
      <p class="text-gray-300">
        <strong>To a polynomial equation.</strong> NP relations are
        converted into algebraic circuits by modeling their
        satisfiability as sets of polynomial equations of the
        form (1), induced by PlonK constraints
        <span class="math">\&#123;(\mathsf&#123;a&#125;_i, \mathsf&#123;b&#125;_i, \mathsf&#123;c&#125;_i, \mathsf&#123;sels&#125;_i)\&#125;_&#123;i \in [n]&#125;</span>.
        These constraints are then compiled into a single polynomial
        equation:
      </p>
      <div class="math-block">
        (Q_l \cdot A + Q_r \cdot B + Q_o \cdot C + Q_m \cdot A \cdot B + Q_c)(X) = 0 \tag&#123;2&#125;
      </div>
      <p class="text-gray-300">
        where polynomials <span class="math">A, B, C</span> encode
        the witness to the NP relation and
        <span class="math">Q</span> polynomials define the circuit
        and may be precomputed. Let
        <span class="math">\omega \in \mathbb&#123;Z&#125;_p</span> be
        a primitive <span class="math">2^k</span>-th root of unity,
        for some <span class="math">k</span> such that
        <span class="math">n &lt; 2^k</span>. Polynomial
        <span class="math">Q_l</span> is defined as the minimal
        polynomial that evaluates to
        <span class="math">q_&#123;L_i&#125;</span> on
        <span class="math">\omega^i</span>, for every
        <span class="math">i \in [n]</span>.
      </p>
      <p class="text-gray-300">
        <strong>Extending to arbitrary polynomials:
        Turbo-PlonK.</strong> The Turbo-PlonK proposal is key in
        unlocking PlonK capabilities by allowing one to change
        PlonK&rsquo;s constraint equation (1) or even append another
        one to it. With this technique, one can view the selectors as
        elementary gates that are added up to form an arithmetic
        identity. We can define new multivariate polynomials of any
        degree <span class="math">P(\mathsf&#123;a&#125;, \mathsf&#123;b&#125;, \mathsf&#123;c&#125;)</span>,
        a new selector <span class="math">q_P</span> and add the
        expression
        <span class="math">q_P \cdot P(\mathsf&#123;a&#125;, \mathsf&#123;b&#125;, \mathsf&#123;c&#125;)</span>
        to the identity. Another possibility offered by Turbo-PlonK is
        the addition of new identities of the form
        <span class="math">I(\mathsf&#123;a&#125;, \mathsf&#123;b&#125;, \mathsf&#123;c&#125;, \mathsf&#123;sels&#125;) = 0</span>.
      </p>
      <p class="text-gray-300">
        We can also extend the arithmetic identity by defining linear
        selectors referring to the next gate wires, representing
        identity:
      </p>
      <div class="math-block">
        q_&#123;L&#125; a_i + q_&#123;R&#125; b_i + q_&#123;O&#125; c_i + q_&#123;M&#125; a_i b_i + q_&#123;C&#125; + \widetilde&#123;q&#125;_&#123;L&#125; a_&#123;i+1&#125; + \widetilde&#123;q&#125;_&#123;R&#125; b_&#123;i+1&#125; + \widetilde&#123;q&#125;_&#123;O&#125; c_&#123;i+1&#125; = 0 \tag&#123;4&#125;
      </div>
      <p class="text-gray-300">
        where
        <span class="math">a_&#123;i+1&#125;, b_&#123;i+1&#125;, c_&#123;i+1&#125;</span>
        refer to the next-constraint wires. In the rest of this work,
        we consider all arithmetic selectors from (3), as well as an
        extra arithmetic selector
        <span class="math">q_&#123;x^5&#125; : \delta</span> that
        adds an extra term
        <span class="math">\delta \, a_i^5</span> to the identity
        from (4). This selector will be used to model Poseidon S-boxes
        with just 1 constraint.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 3. NEW OPTIMIZATIONS                                         -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">
        3. New Optimizations on PlonK&rsquo;s Arithmetization
      </h2>
      <p class="text-gray-300">
        A Turbo-PlonK constraint is simply a PlonK constraint inducing
        (possibly) more than one polynomial equality.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 1 (Turbo-PlonK Constraint)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            A Turbo-PlonK constraint is a tuple
            <span class="math">(\mathsf&#123;a&#125;, \mathsf&#123;b&#125;, \mathsf&#123;c&#125;, \mathsf&#123;sels&#125;)</span>
            where
            <span class="math">\mathsf&#123;a&#125;, \mathsf&#123;b&#125;, \mathsf&#123;c&#125;</span>
            are formal variables and
            <span class="math">\mathsf&#123;sels&#125;</span> is a set
            of selectors. A selector is a pair
            <span class="math">q : \alpha</span>, where
            <span class="math">q</span> is the selector&rsquo;s name
            and
            <span class="math">\alpha \in \mathbb&#123;Z&#125;_p</span>,
            its coefficient.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2 (Turbo-PlonK Constraint System)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            A Turbo-PlonK constraint system is an ordered list of
            Turbo-PlonK constraints. There exists a function
            <span class="math">\mathcal&#123;P&#125;</span> that maps
            each pair of consecutive constraints into a set of
            polynomial equations (each corresponding to a so-called
            identity), involving the formal variables of both
            constraints, but whose coefficients depend only on the
            selectors of the first.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">Remark 2</div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            One may ask why only the variables of a constraint and the
            next are involved in an equation. The reason is that
            accessing the next constraint variables comes &ldquo;for
            free&rdquo;. Indeed, PlonK&rsquo;s permutation argument
            requires evaluating the permutation polynomials on
            <span class="math">\xi</span>, but also on
            <span class="math">\xi\omega</span>, which corresponds to
            the next constraint values. Accessing further values, e.g.
            two constraints away, is possible but would incur the
            additional cost of opening polynomial commitments at a new
            evaluation point, e.g.
            <span class="math">\xi\omega^2</span>, making these gates
            less practical.
          </p>
        </div>
      </div>

      <!-- 3.1 Optimizing Turbo-PlonK constraint systems -->

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8 mb-3">
        3.1 Optimizing Turbo-PlonK Constraint Systems
      </h3>
      <p class="text-gray-300">
        <strong>Shared wires across constraints.</strong> Two linear
        combinations that involve common wires can be implemented more
        efficiently if they are handled together. For example, a linear
        combination of the form
        <span class="math">\mathsf&#123;out&#125; = \alpha_1 x + \alpha_2 y + \alpha_3 z</span>
        would require two constraints to be implemented (over a 3-wires
        architecture). Now, imagine we needed to encode an extra linear
        combination that depends on the same
        <span class="math">x, y, z</span>, say
        <span class="math">\mathsf&#123;out&#125;' = \beta_1 x + \beta_2 y + \beta_3 z</span>.
        We could model both linear combinations with 3 constraints
        instead of 4 by sharing wires across constraints using
        next-constraint selectors.
      </p>
      <p class="text-gray-300">
        <strong>Merging constraints.</strong> The use of
        next-constraint selectors can lead to constraints that have an
        empty set of selectors whose only purpose is to include wires
        that are used by the previous constraint. Such constraints can
        be combined with other constraints if the wires are not in
        conflict. For example, two groups of three constraints as above
        can be combined into simply one group of five.
      </p>
      <p class="text-gray-300">
        <strong>Gaussian elimination.</strong> It is advantageous to
        view constraints as the polynomial equalities that they induce
        and not think about what wires represent inputs and what wires
        represent outputs. That way, we can transform the polynomial
        equalities into an equivalent set of equalities that can be
        represented with simpler or fewer constraints. For example,
        imagine we want to compute
        <span class="math">r := 8x^5 + 2y^5</span> and
        <span class="math">s := 4x^5 - 3y^5</span>. The naive
        approach would require introducing two auxiliary variables and
        4 Turbo-PlonK constraints:
      </p>
      <div class="math-block">
        (x, \_, \mathsf&#123;aux&#125;_1, \&#123;q_&#123;x^5&#125;: 1, q_O: -1\&#125;) \quad (y, \_, \mathsf&#123;aux&#125;_2, \&#123;q_&#123;x^5&#125;: 1, q_O: -1\&#125;)
      </div>
      <div class="math-block">
        (\mathsf&#123;aux&#125;_1, \mathsf&#123;aux&#125;_2, r, \&#123;q_L: 8, q_R: 2, q_O: -1\&#125;) \quad (\mathsf&#123;aux&#125;_1, \mathsf&#123;aux&#125;_2, s, \&#123;q_L: 4, q_R: -3, q_O: -1\&#125;)
      </div>
      <p class="text-gray-300">
        Alternatively, we could simplify the polynomial equalities by
        considering linear combinations between them:
      </p>
      <div class="math-block">
        \begin&#123;cases&#125; 8x^5 + 2y^5 - r = 0 \\ 4x^5 - 3y^5 - s = 0 \end&#123;cases&#125; \iff \begin&#123;cases&#125; 32x^5 - 3r - 2s = 0 \\ -8y^5 - 2s + r = 0 \end&#123;cases&#125;
      </div>
      <p class="text-gray-300">
        Now, it is possible to model both equations with just two
        constraints, avoiding auxiliary variables:
      </p>
      <div class="math-block">
        (x, r, s, \&#123;q_&#123;x^5&#125;: 32, q_R: -3, q_O: -2\&#125;) \quad (y, r, s, \&#123;q_&#123;x^5&#125;: -8, q_R: 1, q_O: -2\&#125;)
      </div>

      <!-- 3.2 Automated optimizer of constraints -->

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8 mb-3">
        3.2 Automated Optimizer of Constraints
      </h3>
      <p class="text-gray-300">
        We propose an automated mechanism for applying the techniques
        presented in the previous section in order to simplify
        constraint systems. This method is less error-prone and can
        lead to more effective optimizations than the manual
        application of the simplification rules, e.g., by combining
        separated parts of the circuit that are compatible.
      </p>
      <p class="text-gray-300">
        Given a list of constraints
        <span class="math">\Gamma := ((\mathsf&#123;a&#125;_1, \mathsf&#123;b&#125;_1, \mathsf&#123;c&#125;_1, \mathsf&#123;sels&#125;_1), \ldots, (\mathsf&#123;a&#125;_n, \mathsf&#123;b&#125;_n, \mathsf&#123;c&#125;_n, \mathsf&#123;sels&#125;_n))</span>,
        we say <span class="math">\Gamma</span> is
        <em>admissible</em> if its last constraint does not contain
        next-constraint selectors. We define
        <span class="math">\mathcal&#123;P&#125;(\Gamma)</span> as the
        set:
      </p>
      <div class="math-block">
        \&#123;q_&#123;L\,i&#125; \mathsf&#123;a&#125;_i + q_&#123;R\,i&#125; \mathsf&#123;b&#125;_i + q_&#123;O\,i&#125; \mathsf&#123;c&#125;_i + q_&#123;M\,i&#125; \mathsf&#123;a&#125;_i \mathsf&#123;b&#125;_i + q_&#123;C\,i&#125; + \widetilde&#123;q&#125;_&#123;L\,i&#125; \mathsf&#123;a&#125;_&#123;i+1&#125; + \widetilde&#123;q&#125;_&#123;R\,i&#125; \mathsf&#123;b&#125;_&#123;i+1&#125; + \widetilde&#123;q&#125;_&#123;O\,i&#125; \mathsf&#123;c&#125;_&#123;i+1&#125;\&#125;_&#123;i \in [n]&#125;
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 3 (Satisfiability)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            We say an extended constraint system
            <span class="math">(\Gamma, L)</span>, with
            <span class="math">N</span> variables, is
            <em>satisfiable</em> if there exists an evaluation
            <span class="math">\boldsymbol&#123;x&#125; \in \mathbb&#123;Z&#125;_p^N</span>
            such that
            <span class="math">f(\boldsymbol&#123;x&#125;) = 0</span>
            for every polynomial
            <span class="math">f \in \mathcal&#123;P&#125;(\Gamma) \cup L</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        The rewriting rules are described as follows. The
        <strong>Constraint Rules</strong> (Figure 2) include:
        <em>Permute</em> (rearranging next-constraint wires by any
        permutation <span class="math">\sigma \in S_3</span>),
        <em>Reduce</em> (removing trivial next-constraint selectors
        with zero coefficients), and <em>Combine constraints</em>
        (merging an empty-selector constraint with an adjacent one if
        wires are compatible).
      </p>
      <p class="text-gray-300">
        The <strong>Optimizer Rules</strong> (Figure 3) include:
        <em>Collect linear</em> (moving purely linear constraints into
        a set <span class="math">L</span> of linear polynomials),
        <em>Free variable</em> (substituting a variable that does not
        appear in <span class="math">\Gamma</span> using a linear
        equation from <span class="math">L</span>),
        <em>Efficient sum</em> (encoding a linear equation over up to
        6 variables using a single constraint with next-constraint
        selectors),
        <em>Auxiliary variable</em> (splitting a large linear equation
        into smaller parts using a fresh variable), and
        <em>Constraint rule</em> (applying any of the constraint rules
        to a constraint within the system).
      </p>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">Theorem 1</div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let <span class="math">(\Gamma, L)</span> be an admissible
            extended constraint system and let
            <span class="math">(\Gamma', L')</span> be the result of
            applying any of the rules from Figure 3 to
            <span class="math">(\Gamma, L)</span>. Then,
            <span class="math">(\Gamma', L')</span> is admissible.
            Furthermore,
            <span class="math">(\Gamma, L)</span> is satisfiable if
            and only if
            <span class="math">(\Gamma', L')</span> is satisfiable.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        The optimizer applies the rules heuristically as follows:
        (1) It first applies <em>collect linear</em> on all
        constraints if possible. (2) It then applies the <em>free
        variable</em> rule on all polynomials in
        <span class="math">L</span> that contain at most two
        non-constant monomials. (3) It applies the <em>auxiliary
        variable</em> rule to partition polynomials with fewer than
        <span class="math">2N</span> monomials. (4) It moves the
        resulting polynomials from <span class="math">L</span> to
        <span class="math">\Gamma</span> by applying <em>efficient
        sum</em> one by one.
      </p>
      <p class="text-gray-300">
        The optimizer is particularly efficient for optimizing circuits
        that involve linear computations. For example, the naive
        implementation of the Poseidon circuit with
        <span class="math">w = 3</span> and
        <span class="math">N = 3</span>, using an S-box custom gate
        requires 464 constraints. It can be reduced to just 272
        constraints after the optimizer. The prototype implementation
        is open source [Nom22c].
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 4. OPTIMIZING POSEIDON HASH                                  -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">
        4. Optimizing Poseidon Hash
      </h2>

      <!-- 4.1 Optimized implementation -->

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8 mb-3">
        4.1 Optimized Implementation of Poseidon
      </h3>
      <p class="text-gray-300">
        We present an optimized Turbo-PlonK modelization of Poseidon
        for <span class="math">w = 3</span>. Our techniques can be
        generalized to other versions. We model (shifted) full rounds
        with 4 constraints where the last one has no selectors and is
        compatible with its successor. On the other hand, we can
        leverage the linear skip and model 4 (shifted) partial rounds
        with just 7 constraints where the last is compatible with its
        successor. Consequently we are effectively modeling every full
        round with 3 constraints and every partial round with 1.5
        constraints.
      </p>
      <p class="text-gray-300">
        <strong>Modelling (shifted) full rounds.</strong> Modelling a
        shifted full round involves capturing the constraints
        <span class="math">\mathbf&#123;y&#125; = M\mathbf&#123;x&#125;^5 + \boldsymbol&#123;\kappa&#125;</span>,
        or equivalently
        <span class="math">M^&#123;-1&#125;\mathbf&#123;y&#125; - \mathbf&#123;x&#125;^5 - M^&#123;-1&#125;\boldsymbol&#123;\kappa&#125; = 0</span>.
        Let <span class="math">M^&#123;-1&#125; = (\beta_&#123;ij&#125;)</span>.
        This can be modeled with 4 constraints, where the last
        constraint (with no selectors) is compatible with the first
        constraint of the next shifted full round. The last shifted
        full round of the first block of full rounds is also compatible
        with the first shifted partial round.
      </p>
      <p class="text-gray-300">
        <strong>Modelling (shifted) partial rounds.</strong> Ignoring
        the constraint coefficients and focusing on the variables that
        are involved, modeling 4 nested shifted partial rounds requires
        asserting six linear relations. Gaussian elimination can be
        applied to construct an equivalent system of six equations with
        at most one power of five per constraint. The last constraint
        with no selectors starts with
        <span class="math">y_3</span>, making it compatible with the
        subsequent partial round.
      </p>
      <p class="text-gray-300">
        As detailed in Table 1, the techniques presented above allow
        modeling one iteration of the Poseidon strategy with 3
        constraints per full round, plus 6 constraints per block of 4
        partial rounds and two extra constraints. This gives a total
        of
        <span class="math">1.5R_P + 3R_F + 2</span>
        constraints with an architecture of
        <span class="math">N = 3</span> wires per gate.
      </p>

      <!-- 4.2 Linear skip -->

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8 mb-3">
        4.2 Linear Skip
      </h3>
      <p class="text-gray-300">
        A naive implementation of Poseidon Hash would require including
        constraints that model <span class="math">w</span> additions
        (of <span class="math">w</span> terms) for every (full or
        partial) round; and constraints modelling
        <span class="math">w</span> S-boxes (per full round) plus one
        S-box per partial round.
      </p>
      <p class="text-gray-300">
        We propose an optimization, coined the <em>linear skip</em>,
        which can be used to reduce the number of constraints modelling
        partial rounds. In a nutshell, we leverage the fact that the
        composition of linear functions is again a linear function in
        order to &ldquo;skip&rdquo; the evaluation of certain wires.
      </p>
      <p class="text-gray-300">
        Consider two Poseidon partial rounds transforming state
        <span class="math">(x_1, \ldots, x_w)</span> into state
        <span class="math">(z_1, \ldots, z_w)</span>. The linear trick
        consists of ignoring certain intermediate equations, not
        creating variables nor constraints for intermediate wires
        <span class="math">y_i</span> and
        <span class="math">c_i</span> for any
        <span class="math">i \in [w-1]</span>. (Note that we must
        keep a variable for <span class="math">c_w</span>, which is
        the input to an S-box.) This way, the constraints modelling a
        pair of partial rounds can be reduced to:
      </p>
      <div class="math-block">
        \forall i \in [\mathbf&#123;w&#125;].\; a_i = x_i + \kappa_i
      </div>
      <div class="math-block">
        c_&#123;\mathbf&#123;w&#125;&#125; = \sum_&#123;j=1&#125;^&#123;\mathbf&#123;w&#125;-1&#125; \alpha_&#123;\mathbf&#123;w&#125;j&#125; a_j + \alpha_&#123;\mathbf&#123;w&#125;\mathbf&#123;w&#125;&#125; b_&#123;\mathbf&#123;w&#125;&#125; + \hat&#123;\kappa&#125;_&#123;\mathbf&#123;w&#125;&#125;
      </div>
      <div class="math-block">
        b_&#123;\mathbf&#123;w&#125;&#125; = a_&#123;\mathbf&#123;w&#125;&#125;^5 \qquad d_&#123;\mathbf&#123;w&#125;&#125; = c_&#123;\mathbf&#123;w&#125;&#125;^5 \qquad \forall i \in [\mathbf&#123;w&#125;].\; z_i = \sum_&#123;j=1&#125;^&#123;\mathbf&#123;w&#125;-1&#125; \alpha'_&#123;ij&#125; a_j + \alpha'_&#123;i\mathbf&#123;w&#125;&#125; b_&#123;\mathbf&#123;w&#125;&#125; + \alpha_&#123;i\mathbf&#123;w&#125;&#125; d_&#123;\mathbf&#123;w&#125;&#125; + \kappa'_i
      </div>
      <p class="text-gray-300">
        where the coefficients
        <span class="math">\alpha'_&#123;ij&#125;</span> and
        <span class="math">\kappa'_i</span> are the result of
        composing two linear functions. In particular:
      </p>
      <div class="math-block">
        \forall i,j \in [\mathbf&#123;w&#125;].\; \alpha'_&#123;ij&#125; := \sum_&#123;k=1&#125;^&#123;\mathbf&#123;w&#125;-1&#125; \alpha_&#123;ik&#125; \alpha_&#123;kj&#125; \qquad \forall i \in [\mathbf&#123;w&#125;].\; \kappa'_i := \sum_&#123;k=1&#125;^&#123;\mathbf&#123;w&#125;-1&#125; \alpha_&#123;ik&#125; \hat&#123;\kappa&#125;_i
      </div>
      <p class="text-gray-300">
        That is,
        <span class="math">M' = (\alpha'_&#123;ij&#125;)</span> is the
        result of multiplying the submatrix of
        <span class="math">M</span> without the last column by the
        submatrix of <span class="math">M</span> without the last row.
        Instead of having to perform
        <span class="math">2w</span> additions of
        <span class="math">w</span> terms to model the pair of partial
        rounds, the linear skip allows us to model them with simply 1
        addition of <span class="math">w</span> terms and
        <span class="math">w</span> additions of
        <span class="math">w+1</span> terms.
      </p>
      <p class="text-gray-300">
        <strong>Multiple skips.</strong> The above technique can be
        generalized to skipping multiple partial rounds. However,
        skipping too many rounds can be counterproductive, because the
        required sums become heavier as the number of skips increases.
        In particular, skipping <span class="math">n</span> partial
        rounds would require 1 addition of
        <span class="math">w+i</span> terms for every
        <span class="math">i = 0, \ldots, n-1</span>; plus
        <span class="math">w</span> extra additions of
        <span class="math">w+n</span> terms. The number of additions
        necessary to model <span class="math">n+1</span> partial
        rounds when skipping <span class="math">n</span> of them is:
      </p>
      <div class="math-block">
        t_&#123;n,w&#125; := w(w + n - 1) + \sum_&#123;i=1&#125;^&#123;n-1&#125; (w + i - 1) \tag&#123;14&#125;
      </div>
      <p class="text-gray-300">
        The optimal number of skips depends on the register size
        <span class="math">w</span>, but also on the constraint system
        being used, since some systems can handle several additions per
        constraint.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 5. RESULTS                                                   -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5. Results</h2>

      <!-- 5.1 Optimized PlonK circuits for Poseidon -->

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8 mb-3">
        5.1 Optimized PlonK Circuits for Poseidon
      </h3>
      <p class="text-gray-300">
        Table 1 presents a comparison with respect to the number of
        constraints and prover cost of the optimized circuits for
        Poseidon and other existing references. The most popular
        register sizes of <span class="math">w = 3</span> and
        <span class="math">w = 5</span> and three different
        Turbo-PlonK models are considered: (i) plain PlonK with no
        extra selectors, (ii) one extra selector,
        <span class="math">q_&#123;x^5&#125;</span>, for computing
        S-boxes in just one constraint, and (iii)
        <span class="math">q_&#123;x^5&#125;</span> combined with
        extra linear selectors that point to the next constraint.
      </p>
      <p class="text-gray-300">
        Key results from Table 1 for
        <span class="math">w = 3, N = 3</span> with
        <span class="math">R_F = 8, R_P = 56</span>: the estimated
        count [GKK+19] requires 624 constraints; using an S-box custom
        gate [GW19] reduces this to 464; applying a linear 1-skip plus
        the optimizer yields 216 constraints; and the full
        Section 4.1 approach plus the optimizer achieves 110
        constraints &mdash; a reduction of over 82% from the baseline.
      </p>
      <p class="text-gray-300">
        For <span class="math">N = 4</span>, the same techniques
        achieve as few as 98 constraints with
        <span class="math">w = 3</span> and 173 constraints with
        <span class="math">w = 5</span>. Other projects such as Zcash
        [Zca21] define specialized custom gates allowing
        <span class="math">R_P + R_F + 1</span> constraints (65
        constraints) and Mina [WS21] uses
        <span class="math">N = 15</span> wires per gate with very
        specialized custom gates. These models introduce significant
        overhead on both prover and verifier, but the reduction in
        constraints pays off.
      </p>

      <!-- 5.2 Optimized Poseidon on CPU -->

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8 mb-3">
        5.2 Optimized Poseidon on CPU
      </h3>
      <p class="text-gray-300">
        The linear skip essentially decreases the number of additions
        and multiplications in partial rounds, and it can be exploited
        to build a very efficient implementation of Poseidon on CPU.
        An OCaml script is provided, available in Mec [Nom21], that
        computes the number of additions and multiplications for a
        given instance of Poseidon and a given number of skipped
        partial rounds.
      </p>
      <p class="text-gray-300">
        A C implementation of HADES over the scalar field of BLS12-381
        is available under the MIT license in [Nom22a]. The
        implementation supports any security parameters and any number
        of skipped rounds. It uses the library blst [Sup21] as a
        backend for arithmetic operations.
      </p>
      <p class="text-gray-300">
        For <span class="math">w = 3</span>,
        <span class="math">R_F = 8</span>,
        <span class="math">R_P = 56</span>: the baseline (no skip)
        requires 579 additions and 816 multiplications at
        16.03 <span class="math">\mu</span>s; the optimal 2-skip
        requires 486 additions and 723 multiplications at
        13.97 <span class="math">\mu</span>s &mdash; a 13% reduction.
        For <span class="math">w = 5</span>,
        <span class="math">R_F = 8</span>,
        <span class="math">R_P = 59</span>: the baseline requires
        1680 additions and 1972 multiplications at
        40.14 <span class="math">\mu</span>s; the optimal 5-skip
        requires 1041 additions and 1333 multiplications at
        26.06 <span class="math">\mu</span>s &mdash; a 35% reduction.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 6. CONCLUSIONS                                               -->
    <!-- ============================================================ -->

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6. Conclusions</h2>
      <p class="text-gray-300">
        We have shown how simple, yet powerful, optimization techniques
        make it possible to express circuits in the most basic
        Turbo-PlonK model very compactly, whose number of constraints
        is comparable to the one obtained through more complex and
        expensive custom gates. Our automated optimizer of constraints,
        implemented in a prototype which is publicly available as open
        source, allows users to focus on the circuit design and obtain
        efficient implementations while avoiding error-prone and
        complex manual optimizations. This way, the construction of
        circuits can be more transparent and easier to audit.
      </p>
      <p class="text-gray-300">
        Our techniques have led to the most efficient and compact
        implementations of the Poseidon circuit in the Turbo-PlonK
        model with basic custom gates such as
        <span class="math">q_&#123;x^5&#125;</span> and
        next-constraint linear selectors. Other projects, such as the
        Dusk Network could benefit from our techniques (in particular
        the linear skip) to reduce the number of constraints of their
        Hades implementation [Dus21] by at least a factor of 25% for
        free (without any modifications of their model or additional
        custom gates). Furthermore, we believe our techniques nicely
        complement other works that aim at reducing the number of
        constraints by exploring additional PlonK identities and more
        complex custom gates [WS21, Zca21].
      </p>
      <p class="text-gray-300">
        An appealing direction for future work would be to explore
        additional heuristics and optimizer rules that can capture
        the most advanced optimizations presented in Section 4. Also,
        it would be very interesting to explore whether these
        techniques can be extended to other arithmetizations.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- ACKNOWLEDGMENTS                                              -->
    <!-- ============================================================ -->

    <section id="acknowledgments" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgments</h2>
      <p class="text-gray-300">
        We are very thankful to Marc Beunardeau, Victor Dumitrescu,
        Antonio Locascio, Marina Polubelova and Marco Stronati for
        very fruitful discussions about this project and for all their
        help and feedback.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>
      <ol class="list-decimal list-inside space-y-2 text-gray-400
        text-sm">
        <li>
          [ALSZ21] Behzad Abdolmaleki, Helger Lipmaa, Janno Siim, and
          Micha&#322; Zaj&#261;c. &ldquo;On Subversion-Resistant
          SNARKs&rdquo;. In: <em>Journal of Cryptology</em>,
          34(3):1&ndash;42, 2021.
        </li>
        <li>
          [Azt20] Aztec. Ignition ceremony, 2020.
          <a
            href="https://ignition.aztecprotocol.com/"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >ignition.aztecprotocol.com</a>.
        </li>
        <li>
          [BBB+18] Benedikt B&uuml;nz et al. &ldquo;Bulletproofs:
          Short Proofs for Confidential Transactions and More&rdquo;.
          In: <em>2018 IEEE Symposium on Security and Privacy</em>,
          pp. 315&ndash;334. IEEE, May 2018.
        </li>
        <li>
          [BCG+13] Eli Ben-Sasson et al. &ldquo;SNARKs for C:
          Verifying Program Executions Succinctly and in Zero
          Knowledge&rdquo;. In: <em>CRYPTO 2013, Part II</em>.
          Vol. 8043. LNCS. Springer, Aug. 2013, pp. 90&ndash;108.
        </li>
        <li>
          [BCG+14] Eli Ben-Sasson et al. &ldquo;Zerocash:
          Decentralized Anonymous Payments from Bitcoin&rdquo;. In:
          <em>2014 IEEE Symposium on Security and Privacy</em>,
          pp. 459&ndash;474. IEEE, May 2014.
        </li>
        <li>
          [BCG+17] Jonathan Bootle et al. &ldquo;Linear-Time
          Zero-Knowledge Proofs for Arithmetic Circuit
          Satisfiability&rdquo;. In: <em>ASIACRYPT 2017, Part
          III</em>. Vol. 10626. LNCS. Springer, Dec. 2017,
          pp. 336&ndash;365.
        </li>
        <li>
          [BCL+20] Tim Beyne et al. &ldquo;On the Security of the
          Rescue Hash Function&rdquo;. Cryptology ePrint Archive,
          Report 2020/820, 2020.
          <a
            href="https://eprint.iacr.org/2020/820"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2020/820</a>.
          <a href="/papers/security-rescue-hash-2020" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          [BCMS20] Benedikt B&uuml;nz et al. &ldquo;Recursive Proof
          Composition from Accumulation Schemes&rdquo;. In:
          <em>TCC 2020, Part II</em>. Vol. 12551. LNCS. Springer,
          Nov. 2020, pp. 1&ndash;18.
        </li>
        <li>
          [BCR+19] Eli Ben-Sasson et al. &ldquo;Aurora: Transparent
          Succinct Arguments for R1CS&rdquo;. In: <em>EUROCRYPT 2019,
          Part I</em>. Vol. 11476. LNCS. Springer, May 2019,
          pp. 103&ndash;128.
        </li>
        <li>
          [BDFG20] Dan Boneh et al. &ldquo;Efficient Polynomial
          Commitment Schemes for Multiple Points and
          Polynomials&rdquo;. Cryptology ePrint Archive, Report
          2020/081, 2020.
          <a
            href="https://eprint.iacr.org/2020/081"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2020/081</a>.
        </li>
        <li>
          [BDFG21] Dan Boneh et al. &ldquo;Halo Infinite:
          Proof-Carrying Data from Additive Polynomial
          Commitments&rdquo;. In: <em>CRYPTO 2021, Part I</em>.
          Vol. 12825. LNCS. Springer, Aug. 2021, pp. 649&ndash;680.
        </li>
        <li>
          [BFLS91] L&aacute;szl&oacute; Babai et al. &ldquo;Checking
          Computations in Polylogarithmic Time&rdquo;. In: <em>23rd
          ACM STOC</em>, pp. 21&ndash;31. ACM Press, May 1991.
        </li>
        <li>
          [BFM88] Manuel Blum, Paul Feldman, and Silvio Micali.
          &ldquo;Non-Interactive Zero-Knowledge and Its Applications
          (Extended Abstract)&rdquo;. In: <em>20th ACM STOC</em>,
          pp. 103&ndash;112. ACM Press, May 1988.
        </li>
        <li>
          [BGH] Sean Bowe, Jack Grigg, and Daira Hopwood. Halo2
          (2020). URL:
          <a
            href="https://github.com/zcash/halo2"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >github.com/zcash/halo2</a>.
        </li>
        <li>
          [BGH19] Sean Bowe, Jack Grigg, and Daira Hopwood.
          &ldquo;Halo: Recursive Proof Composition without a Trusted
          Setup&rdquo;. Cryptology ePrint Archive, Report 2019/1021,
          2019.
          <a
            href="https://eprint.iacr.org/2019/1021"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2019/1021</a>.
          <a href="/papers/halo-recursive-proofs-2019" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          [BGK+21] Mario Barbara et al. &ldquo;Reinforced Concrete:
          Fast Hash Function for Zero Knowledge Proofs and Verifiable
          Computation&rdquo;. Cryptology ePrint Archive, Report
          2021/1038, 2021.
          <a
            href="https://eprint.iacr.org/2021/1038"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2021/1038</a>.
          <a href="/papers/reinforced-concrete-2021" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          [BGM17] Sean Bowe, Ariel Gabizon, and Ian Miers.
          &ldquo;Scalable Multi-Party Computation for zk-SNARK
          Parameters in the Random Beacon Model&rdquo;. Cryptology
          ePrint Archive, Report 2017/1050, 2017.
          <a
            href="https://eprint.iacr.org/2017/1050"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2017/1050</a>.
          <a href="/papers/scalable-mpc-zksnark-2017" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          [BMRS20] Joseph Bonneau et al. &ldquo;Mina: Decentralized
          Cryptocurrency at Scale&rdquo;, 2020. Whitepaper.
          <a
            href="https://docs.minaprotocol.com/static/pdf/technicalWhitepaper.pdf"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >docs.minaprotocol.com</a>.
        </li>
        <li>
          [CDS94] Ronald Cramer, Ivan Damg&aring;rd, and Berry
          Schoenmakers. &ldquo;Proofs of Partial Knowledge and
          Simplified Design of Witness Hiding Protocols&rdquo;. In:
          <em>CRYPTO&rsquo;94</em>. Vol. 839. LNCS. Springer,
          Aug. 1994, pp. 174&ndash;187.
        </li>
        <li>
          [CGM16] Melissa Chase, Chaya Ganesh, and Payman Mohassel.
          &ldquo;Efficient Zero-Knowledge Proof of Algebraic and
          Non-Algebraic Statements with Applications to Privacy
          Preserving Credentials&rdquo;. In: <em>CRYPTO 2016,
          Part III</em>. Vol. 9816. LNCS. Springer, Aug. 2016,
          pp. 499&ndash;530.
        </li>
        <li>
          [CHM+20] Alessandro Chiesa et al. &ldquo;Marlin:
          Preprocessing zkSNARKs with Universal and Updatable
          SRS&rdquo;. In: <em>EUROCRYPT 2020, Part I</em>.
          Vol. 12105. LNCS. Springer, May 2020, pp. 738&ndash;768.
        </li>
        <li>
          [Com16] Electric Coin Company. &ldquo;The Design of the
          Ceremony&rdquo;, 2016.
          <a
            href="https://electriccoin.co/blog/the-design-of-the-ceremony/"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >electriccoin.co</a>.
        </li>
        <li>
          [Cra97] Ronald Cramer. &ldquo;Modular Design of Secure Yet
          Practical Cryptographic Protocols&rdquo;. 1997.
        </li>
        <li>
          [DFKP13] George Danezis et al. &ldquo;Pinocchio Coin:
          Building Zerocoin from a Succinct Pairing-Based Proof
          System&rdquo;. In: <em>PETShop &rsquo;13</em>,
          pp. 27&ndash;30. ACM, 2013.
        </li>
        <li>
          [DKP+19] Itai Dinur et al. &ldquo;Linear Equivalence of
          Block Ciphers with Partial Non-Linear Layers: Application to
          LowMC&rdquo;. In: <em>EUROCRYPT 2019, Part I</em>.
          Vol. 11476. LNCS. Springer, May 2019, pp. 343&ndash;372.
        </li>
        <li>
          [DMP90] Alfredo De Santis, Silvio Micali, and Giuseppe
          Persiano. &ldquo;Non-Interactive Zero-Knowledge with
          Preprocessing&rdquo;. In: <em>CRYPTO&rsquo;88</em>.
          Vol. 403. LNCS. Springer, Aug. 1990, pp. 269&ndash;282.
        </li>
        <li>
          [Dus21] Dusk Network. Hades252, 2021.
          <a
            href="https://github.com/dusk-network/Hades252"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >github.com/dusk-network/Hades252</a>.
        </li>
        <li>
          [EGL+20] Maria Eichlseder et al. &ldquo;An Algebraic Attack
          on Ciphers with Low-Degree Round Functions: Application to
          Full MiMC&rdquo;. In: <em>ASIACRYPT 2020, Part I</em>.
          Vol. 12491. LNCS. Springer, Dec. 2020, pp. 477&ndash;506.
        </li>
        <li>
          [Fil20] Filecoin. &ldquo;Trusted Setup Complete!&rdquo;,
          2020.
          <a
            href="https://filecoin.io/blog/posts/trusted-setup-complete/"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >filecoin.io</a>.
        </li>
        <li>
          [FLS90] Uriel Feige, Dror Lapidot, and Adi Shamir.
          &ldquo;Multiple Non-Interactive Zero Knowledge Proofs Based
          on a Single Random String (Extended Abstract)&rdquo;. In:
          <em>31st FOCS</em>, pp. 308&ndash;317. IEEE, Oct. 1990.
        </li>
        <li>
          [GGPR13] Rosario Gennaro et al. &ldquo;Quadratic Span
          Programs and Succinct NIZKs without PCPs&rdquo;. In:
          <em>EUROCRYPT 2013</em>. Vol. 7881. LNCS. Springer,
          May 2013, pp. 626&ndash;645.
        </li>
        <li>
          [GKK+19] Lorenzo Grassi et al. &ldquo;Starkad and Poseidon:
          New Hash Functions for Zero Knowledge Proof Systems&rdquo;.
          Cryptology ePrint Archive, Report 2019/458, 2019.
          <a
            href="https://eprint.iacr.org/2019/458"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2019/458</a>.
          <a href="/papers/poseidon-2019" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          [GKM+18] Jens Groth et al. &ldquo;Updatable and Universal
          Common Reference Strings with Applications to
          zk-SNARKs&rdquo;. In: <em>CRYPTO 2018, Part III</em>.
          Vol. 10993. LNCS. Springer, Aug. 2018, pp. 698&ndash;728.
        </li>
        <li>
          [GKR+19] Lorenzo Grassi et al. &ldquo;Poseidon: A New Hash
          Function for Zero-Knowledge Proof Systems&rdquo;. Cryptology
          ePrint Archive, Report 2019/458, 2019.
          <a
            href="https://ia.cr/2019/458"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >ia.cr/2019/458</a>.
          <a href="/papers/poseidon-2019" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          [GKR+21] Lorenzo Grassi et al. &ldquo;Poseidon: A New Hash
          Function for Zero-Knowledge Proof Systems&rdquo;. In:
          <em>USENIX Security 2021</em>, pp. 519&ndash;535. USENIX
          Association, Aug. 2021.
        </li>
        <li>
          [GMO16] Irene Giacomelli, Jesper Madsen, and Claudio
          Orlandi. &ldquo;ZKBoo: Faster Zero-Knowledge for Boolean
          Circuits&rdquo;. In: <em>USENIX Security 2016</em>,
          pp. 1069&ndash;1083. USENIX Association, Aug. 2016.
        </li>
        <li>
          [GMR85] Shafi Goldwasser, Silvio Micali, and Charles
          Rackoff. &ldquo;The Knowledge Complexity of Interactive
          Proof-Systems (Extended Abstract)&rdquo;. In: <em>17th ACM
          STOC</em>, pp. 291&ndash;304. ACM Press, May 1985.
        </li>
        <li>
          [Goo14] L.M. Goodman. &ldquo;Tezos: A Self-Amending
          Crypto-Ledger&rdquo;, 2014.
          <a
            href="https://tezos.com/whitepaper.pdf"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >tezos.com/whitepaper.pdf</a>.
        </li>
        <li>
          [Gro16] Jens Groth. &ldquo;On the Size of Pairing-Based
          Non-Interactive Arguments&rdquo;. In: <em>EUROCRYPT 2016,
          Part II</em>. Vol. 9666. LNCS. Springer, May 2016,
          pp. 305&ndash;326.
        </li>
        <li>
          [GS08] Jens Groth and Amit Sahai. &ldquo;Efficient
          Non-Interactive Proof Systems for Bilinear Groups&rdquo;.
          In: <em>EUROCRYPT 2008</em>. Vol. 4965. LNCS. Springer,
          Apr. 2008, pp. 415&ndash;432.
        </li>
        <li>
          [GW19] Ariel Gabizon and Zachary J. Williamson.
          &ldquo;The Turbo-PlonK Program Syntax for Specifying SNARK
          Programs&rdquo;, 2019. Preprint.
          <a
            href="https://docs.zkproof.org/pages/standards/accepted-workshop3/proposal-turbo_plonk.pdf"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >docs.zkproof.org</a>.
        </li>
        <li>
          [GW20] Ariel Gabizon and Zachary J. Williamson.
          &ldquo;plookup: A Simplified Polynomial Protocol for Lookup
          Tables&rdquo;. Cryptology ePrint Archive, Report 2020/315,
          2020.
          <a
            href="https://eprint.iacr.org/2020/315"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2020/315</a>.
          <a href="/papers/plookup-2020" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          [GW21a] Ariel Gabizon and Zachary J. Williamson.
          &ldquo;fflonk: A Fast-Fourier Inspired Verifier Efficient
          Version of PlonK&rdquo;. Cryptology ePrint Archive, Report
          2021/1167, 2021.
          <a
            href="https://eprint.iacr.org/2021/1167"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2021/1167</a>.
        </li>
        <li>
          [GW21b] Ariel Gabizon and Zachary J. Williamson.
          &ldquo;Public Inputs in PlonK&rsquo;s Permutation
          Argument&rdquo;, 2021.
          <a
            href="https://github.com/arielgabizon/plonk-addendum/blob/master/plonk-pubinputs.pdf"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >github.com/arielgabizon/plonk-addendum</a>.
        </li>
        <li>
          [GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana
          Ciobotaru. &ldquo;PLONK: Permutations over Lagrange-Bases
          for Oecumenical Noninteractive Arguments of
          Knowledge&rdquo;. Cryptology ePrint Archive, Report
          2019/953, 2019.
          <a
            href="https://eprint.iacr.org/2019/953"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2019/953</a>.
          <a href="/papers/plonk-2019" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          [GYB21] Christopher Goes, Awa Sun Yin, and Adrian Brink.
          &ldquo;Anoma: Undefining Money&rdquo;, 2021. Whitepaper.
          <a
            href="https://anoma.network/papers/whitepaper.pdf"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >anoma.network</a>.
        </li>
        <li>
          [HBHW22] Daira Hopwood et al. &ldquo;Zcash Protocol
          Specification&rdquo;, 2022. Documentation.
          <a
            href="https://zips.z.cash/protocol/protocol.pdf"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >zips.z.cash/protocol/protocol.pdf</a>.
        </li>
        <li>
          [HGB21] Ulrich Hab&ouml;ck, Alberto Garoffolo, and Daniele
          Di Benedetto. &ldquo;Darlin: Recursive Proofs Using
          Marlin&rdquo;. Cryptology ePrint Archive, Report 2021/930,
          2021.
          <a
            href="https://eprint.iacr.org/2021/930"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2021/930</a>.
        </li>
        <li>
          [JKO13] Marek Jawurek, Florian Kerschbaum, and Claudio
          Orlandi. &ldquo;Zero-Knowledge Using Garbled Circuits: How
          to Prove Non-Algebraic Statements Efficiently&rdquo;. In:
          <em>ACM CCS 2013</em>, pp. 955&ndash;966. ACM Press,
          Nov. 2013.
        </li>
        <li>
          [KZG10] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg.
          &ldquo;Constant-Size Commitments to Polynomials and Their
          Applications&rdquo;. In: <em>ASIACRYPT 2010</em>.
          Vol. 6477. LNCS. Springer, Dec. 2010, pp. 177&ndash;194.
        </li>
        <li>
          [Lab17] Protocol Labs. &ldquo;Filecoin: A Decentralized
          Storage Network&rdquo;, 2017.
          <a
            href="https://filecoin.io/filecoin.pdf"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >filecoin.io/filecoin.pdf</a>.
        </li>
        <li>
          [LMR19] Russell W. F. Lai, Giulio Malavolta, and Viktoria
          Ronge. &ldquo;Succinct Arguments for Bilinear Group
          Arithmetic: Practical Structure-Preserving
          Cryptography&rdquo;. In: <em>ACM CCS 2019</em>,
          pp. 2057&ndash;2074. ACM Press, Nov. 2019.
        </li>
        <li>
          [MBKM19] Mary Maller et al. &ldquo;Sonic: Zero-Knowledge
          SNARKs from Linear-Size Universal and Updatable Structured
          Reference Strings&rdquo;. In: <em>ACM CCS 2019</em>,
          pp. 2111&ndash;2128. ACM Press, Nov. 2019.
        </li>
        <li>
          [MKF21] Toghrul Maharramov, Dmitry Khovratovich, and
          Emanuele Francioni. &ldquo;The Dusk Network
          Whitepaper&rdquo;, 2021.
          <a
            href="https://dusk.network/uploads/The_Dusk_Network_Whitepaper_v3_0_0.pdf"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >dusk.network</a>.
        </li>
        <li>
          [Nom21] Nomadic Labs. Mec: Mini Elliptic Curve Library,
          2021.
          <a
            href="https://gitlab.com/dannywillems/ocaml-ec"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >gitlab.com/dannywillems/ocaml-ec</a>.
        </li>
        <li>
          [Nom22a] Nomadic Labs. C Implementation of Poseidon, 2022.
          <a
            href="https://gitlab.com/dannywillems/ocaml-bls12-381/-/blob/48cbc33a7dca01f6e6493c8a7edb1edfc74dcb77/src/primitives/poseidon/poseidon.c"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >gitlab.com/dannywillems/ocaml-bls12-381</a>.
        </li>
        <li>
          [Nom22b] Nomadic Labs&rsquo; Crypto Team. Library for ZK
          Proofs and ZK Rollups, 2022.
          <a
            href="https://gitlab.com/nomadic-labs/privacy-team/"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >gitlab.com/nomadic-labs/privacy-team</a>.
        </li>
        <li>
          [Nom22c] Nomadic Labs&rsquo; Crypto Team. Optimizer of
          PlonK-Constraints, 2022.
          <a
            href="https://gitlab.com/nomadic-labs/privacy-team/-/blob/master/nuplompiler/optimizer.ml"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >gitlab.com/nomadic-labs/privacy-team/optimizer.ml</a>.
        </li>
        <li>
          [PFM+22] Luke Pearson et al. &ldquo;Plonkup: Reconciling
          PlonK with Plookup&rdquo;. Cryptology ePrint Archive,
          Report 2022/086, 2022.
          <a
            href="https://ia.cr/2022/086"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >ia.cr/2022/086</a>.
        </li>
        <li>
          [PHGR13] Bryan Parno et al. &ldquo;Pinocchio: Nearly
          Practical Verifiable Computation&rdquo;. In: <em>2013 IEEE
          Symposium on Security and Privacy</em>, pp. 238&ndash;252.
          IEEE, May 2013.
        </li>
        <li>
          [pro20] Mina Protocol. &ldquo;A More Efficient Approach to
          Zero Knowledge for PlonK&rdquo;, 2020.
        </li>
        <li>
          [pro22] Mir Protocol. Plonky2, 2022.
        </li>
        <li>
          [Sch91] Claus-Peter Schnorr. &ldquo;Efficient Signature
          Generation by Smart Cards&rdquo;. In: <em>Journal of
          Cryptology</em>, 4(3):161&ndash;174, Jan. 1991.
        </li>
        <li>
          [Sha49] C. E. Shannon. &ldquo;Communication Theory of
          Secrecy Systems&rdquo;. In: <em>The Bell System Technical
          Journal</em>, 28(4):656&ndash;715, 1949.
        </li>
        <li>
          [Sup21] Supranational. blst (pronounced &lsquo;blast&rsquo;)
          is a BLS12-381 signature library focused on performance and
          security, 2021.
          <a
            href="https://github.com/supranational/blst"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >github.com/supranational/blst</a>.
        </li>
        <li>
          [WS21] David Wong and Joseph Spadavecchia. &ldquo;Poseidon
          Gate (Mina Protocol)&rdquo;, 2021. Kimchi Specification.
        </li>
        <li>
          [Zca21] Zcash. Poseidon128, 2021.
          <a
            href="https://github.com/zcash/halo2"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >github.com/zcash/halo2</a>.
        </li>
      </ol>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX A                                                   -->
    <!-- ============================================================ -->

    <section id="appendix-a" class="mb-10">
      <h2 class="text-2xl font-bold">
        Appendix A: Proofs of the Main Body
      </h2>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">
          Proof of Theorem 1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let <span class="math">(\Gamma, L)</span> be an admissible
            extended constraint system and let
            <span class="math">(\Gamma', L')</span> be the result of
            applying any of the rules from Figure 3 to
            <span class="math">(\Gamma, L)</span>. Then,
            <span class="math">(\Gamma', L')</span> is admissible.
            Furthermore,
            <span class="math">(\Gamma, L)</span> is satisfiable if
            and only if
            <span class="math">(\Gamma', L')</span> is satisfiable.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        The proof focuses on each rule individually:
      </p>

      <p class="text-gray-300">
        <strong>Collect linear.</strong> Since the last constraint of
        <span class="math">\Gamma_0</span> does not contain
        next-constraint selectors, we have that
        <span class="math">\mathcal&#123;P&#125;(\Gamma_0 \parallel (x_1, x_2, x_3, \&#123;q_L : \alpha_1, q_R : \alpha_2, q_O : \alpha_3, q_C : \alpha_0\&#125;) \parallel \Gamma_1)</span>
        is equal to
        <span class="math">\mathcal&#123;P&#125;(\Gamma_0) \cup \mathcal&#123;P&#125;(\Gamma_1) \cup \&#123;\alpha_0 + \sum_&#123;i=1&#125;^3 \alpha_i x_i = 0\&#125;</span>,
        and
        <span class="math">\mathcal&#123;P&#125;(\Gamma_0 \parallel \Gamma_1) = \mathcal&#123;P&#125;(\Gamma_0) \cup \mathcal&#123;P&#125;(\Gamma_1)</span>,
        from which the result follows immediately.
      </p>

      <p class="text-gray-300">
        <strong>Free variable.</strong> Say
        <span class="math">\boldsymbol&#123;x&#125;</span> is a
        satisfying assignment for
        <span class="math">(\Gamma, L)</span>. Since
        <span class="math">L</span> contains equation
        <span class="math">\alpha_0 + \sum_&#123;i \in S&#125; \alpha_i x_i = 0</span>
        with <span class="math">\alpha_j \neq 0</span>, and it is
        satisfied by
        <span class="math">\boldsymbol&#123;x&#125;</span>, it must be
        <span class="math">x_j = -(\alpha_0 + \sum_&#123;i \in S \setminus \&#123;j\&#125;&#125; \alpha_i x_i) \div \alpha_j</span>.
        So <span class="math">\boldsymbol&#123;x&#125;</span> must
        also be a satisfying assignment for
        <span class="math">(\Gamma, L[x_j \mapsto -(\alpha_0 + \sum_&#123;i \in S \setminus \&#123;j\&#125;&#125; \alpha_i x_i) \div \alpha_j])</span>.
        On the other hand, if
        <span class="math">\boldsymbol&#123;x&#125;'</span> is a
        satisfying assignment for
        <span class="math">(\Gamma', L')</span>, because
        <span class="math">x_j</span> is not in
        <span class="math">\Gamma'</span> (and not in
        <span class="math">L'</span>), we have that
        <span class="math">\boldsymbol&#123;x&#125;'</span> modified
        so that
        <span class="math">x_j := -(\alpha_0 + \sum_&#123;i \in S \setminus \&#123;j\&#125;&#125; \alpha_i x_i) \div \alpha_j</span>
        is a satisfying assignment for the original system.
      </p>

      <p class="text-gray-300">
        <strong>Efficient sum.</strong> Since
        <span class="math">\Gamma</span> is admissible, its last
        constraint does not include next-constraint selectors. In that
        case,
        <span class="math">\mathcal&#123;P&#125;(\Gamma) \cup L</span>
        equals
        <span class="math">\mathcal&#123;P&#125;(\Gamma') \cup L'</span>
        as desired.
      </p>

      <p class="text-gray-300">
        <strong>Auxiliary variable.</strong> If
        <span class="math">\boldsymbol&#123;x&#125;</span> is a
        satisfying assignment of
        <span class="math">t_1 + t_2 = 0</span>, then
        <span class="math">\boldsymbol&#123;x&#125;, s \mapsto t_1</span>
        is a satisfying assignment for
        <span class="math">t_1 - s = 0</span> and
        <span class="math">s + t_2 = 0</span>. On the other hand, if
        <span class="math">t_1 - s = 0</span> and
        <span class="math">s + t_2 = 0</span> are satisfiable at the
        same time, by adding both equations,
        <span class="math">t_1 + t_2 = 0</span> must also be
        satisfiable.
      </p>

      <p class="text-gray-300">
        <strong>Constraint rule.</strong> Note that
        <span class="math">L = L'</span> and for any
        <span class="math">t \in \mathsf&#123;ConstraintRules&#125;</span>
        we have
        <span class="math">\mathcal&#123;P&#125;(\mathsf&#123;g&#125; \parallel \Gamma_1) = \mathcal&#123;P&#125;(t(\mathsf&#123;g&#125;) \parallel \Gamma_1)</span>
        which implies that
        <span class="math">\mathcal&#123;P&#125;(\Gamma_0 \parallel \mathsf&#123;g&#125; \parallel \Gamma_1) = \mathcal&#123;P&#125;(\Gamma_0 \parallel t(\mathsf&#123;g&#125;) \parallel \Gamma_1)</span>
        given that <span class="math">\Gamma_0</span> is admissible,
        as desired.
      </p>
    </section>

  </article>
</BaseLayout>
