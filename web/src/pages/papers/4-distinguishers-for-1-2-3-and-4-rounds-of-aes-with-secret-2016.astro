---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/592';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-20';
const TITLE_HTML = '4 Distinguishers for 1, 2, 3 and 4 Rounds of AES with Secret Round-Keys';
const AUTHORS_HTML = 'In this section we describe a series of subspace trails for AES. Additionally we also describe how these trails can be used to formulate ways to detect non-randomness, often colloquially referred to a distinguishers. All distinguishers in this section, ranging from two up to four rounds, are independent of the round keys and are formulated without the knowledge of the key. From now on, we assume that any subspaces  $\\mathcal{D}_I$ ,  $\\mathcal{C}_I$  or  $\\mathcal{M}_I$  has nonzero dimension (that is,  $I \\subseteq \\{0,1,2,3\\}$  is not empty). Moreover, when we intersect two subspaces  $\\mathcal{D}_I$  and  $\\mathcal{M}_J$ , where both I and J are assumed non-empty, we always assume that the sum of their dimensions is not larger than 16. Typically, the sum of their dimensions will be exactly 16.';

const CONTENT = `    <h2 id="sec-1" class="text-2xl font-bold"><strong>Subspace Trail Cryptanalysis and its Applications to AES</strong></h2>

    <h4 id="sec-2" class="text-lg font-semibold mt-6"><strong>Extended Version</strong></h4>

    <p class="text-gray-300">Lorenzo Grassi&lt;sup&gt;1&lt;/sup&gt; , Christian Rechberger&lt;sup&gt;1&lt;/sup&gt;<em>,</em>&lt;sup&gt;3&lt;/sup&gt; and Sondre Rønjom&lt;sup&gt;2&lt;/sup&gt;<em>,</em>&lt;sup&gt;4&lt;/sup&gt;</p>

    <p class="text-gray-300">1 IAIK, Graz University of Technology, Austria &lt;sup&gt;2&lt;/sup&gt; Nasjonal sikkerhetsmyndighet, Norway &lt;sup&gt;3&lt;/sup&gt; DTU Compute, DTU, Denmark &lt;sup&gt;4&lt;/sup&gt; Department of Informatics, University of Bergen, Norway <a href="mailto:firstname.lastname@iaik.tugraz.at">firstname.lastname@iaik.tugraz.at</a>, <a href="mailto:Sondre.Ronjom@ii.uib.no">Sondre.Ronjom@ii.uib.no</a></p>

    <p class="text-gray-300"><strong>Abstract.</strong> We introduce subspace trail cryptanalysis, a generalization of invariant subspace cryptanalysis. With this more generic treatment of subspaces we do no longer rely on specific choices of round constants or subkeys, and the resulting method is as such a potentially more powerful attack vector. Interestingly, subspace trail cryptanalysis in fact includes techniques based on impossible or truncated differentials and integrals as special cases.</p>

    <p class="text-gray-300">Choosing AES-128 as the perhaps most studied cipher, we describe distinguishers up to 5-round AES with a single unknown key. We report (and practically verify) competitive key-recovery attacks with very low data-complexity on 2, 3 and 4 rounds of AES. Additionally, we consider AES with a secret S-Box and we present a (generic) technique that allows to directly recover the secret key without finding any information about the secret S-Box. This approach allows to use e.g. truncated differential, impossible differential and integral attacks to find the secret key. Moreover, this technique works also for other AES-like constructions, if some very common conditions on the S-Box and on the MixColumns matrix (or its inverse) hold. As a consequence, such attacks allow to better highlight the security impact of linear mappings inside an AES-like block cipher.</p>

    <p class="text-gray-300">Finally, we show that our impossible differential attack on 5 rounds of AES with secret S-Box can be turned into a distinguisher for AES in the same setting as the one recently proposed by Sun, Liu, Guo, Qu and Rijmen at CRYPTO 2016.</p>

    <p class="text-gray-300"><strong>Keywords:</strong> AES · Invariant Subspace · Subspace Trail · Secret-Key Distinguisher · Key-Recovery Attack · Truncated Differential · Impossible Differential · Integral · Secret S-Box</p>

    <h2 id="sec-3" class="text-2xl font-bold"><strong>Contents</strong></h2>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">1</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Introduction&lt;br&gt;1.1&lt;br&gt;High-Level Overview of Subspace-Trail Technique&lt;br&gt;1.2&lt;br&gt;Contributions&lt;br&gt;1.3&lt;br&gt;Secret-Key Distinguishers for AES&lt;br&gt;&lt;br&gt;1.4&lt;br&gt;Low Data-Complexity Key-Recovery Attacks on AES&lt;br&gt;&lt;br&gt;1.5&lt;br&gt;Attack on AES with a Single Secret S-Box&lt;br&gt;1.6&lt;br&gt;The 5-round Secret Key Distinguisher for AES-128&lt;br&gt;1.7&lt;br&gt;Practical Verification</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">2&lt;br&gt;2&lt;br&gt;3&lt;br&gt;3&lt;br&gt;5&lt;br&gt;7&lt;br&gt;8&lt;br&gt;9</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Subspace Trails</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Preliminaries&lt;br&gt;3.1&lt;br&gt;Description of AES&lt;br&gt;3.2&lt;br&gt;Subspaces through One Round of AES&lt;br&gt;3.3&lt;br&gt;Intersecting AES Subspaces&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11&lt;br&gt;11&lt;br&gt;12&lt;br&gt;14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Distinguishers for 1, 2, 3 and 4 Rounds of AES with Secret Round-Keys&lt;br&gt;4.1&lt;br&gt;2-Round Subspace Trail for AES&lt;br&gt;&lt;br&gt;4.2&lt;br&gt;Truncated Differential Key-Recovery Attacks for 3- and 4-round of AES&lt;br&gt;&lt;br&gt;4.3&lt;br&gt;3-Round Subspace Trail for AES&lt;br&gt;&lt;br&gt;4.4&lt;br&gt;4-Round Subspace Trail for AES&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">15&lt;br&gt;15&lt;br&gt;17&lt;br&gt;17&lt;br&gt;19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Key-recovery Attacks on AES with a Secret S-Box</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Truncated Differential Attacks on 3 and 4 Rounds of AES with a Secret&lt;br&gt;S-Box</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Impossible Differential Attack on 5-round of AES with a single Secret&lt;br&gt;S-Box&lt;br&gt;7.1&lt;br&gt;Key-Recovery Attack using Impossible Differential - General Idea&lt;br&gt;7.2&lt;br&gt;Data Complexity and Computational Cost</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25&lt;br&gt;25&lt;br&gt;26</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">The 5-Round Secret Key Distinguisher for AES&lt;br&gt;8.1&lt;br&gt;Comparison with 5-Round Distinguisher proposed by Sun, Liu, Guo, Qu&lt;br&gt;and Rijmen, and Possible Generalizations&lt;br&gt;&lt;br&gt;8.2&lt;br&gt;Critical Discussion of the Distinguisher Model and Open Problems&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28&lt;br&gt;28&lt;br&gt;30</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Conclusion</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">A</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Subspace Definition</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">35</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">B</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Intersecting AES Subspaces&lt;br&gt;37</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">C</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Secret-Key Distinguishers for 3 and 4 rounds of AES - Details&lt;br&gt;39&lt;br&gt;C.1&lt;br&gt;Another Explanation of the Truncated Differential Distinguisher on 3-Round&lt;br&gt;of AES&lt;br&gt;39&lt;br&gt;C.2&lt;br&gt;Description of the 4-round Zero-Sum Distinguisher using the Subspace Trail&lt;br&gt;40</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">D</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Relationship between 4-round Subspace Trail and Impossible Differen&lt;br&gt;tial Attacks</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">41</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">E</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Key Recovery Attacks on 3 and 4 Rounds of AES</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">42</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">E.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">The Attack on 3 Rounds of AES&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">43</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">E.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">The Attack on 1 and 2 Rounds of AES</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">E.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Relationship to Standard Truncated Differential Attack&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">49</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">E.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">The Attack on 4 Rounds of AES - Extending the 3 Rounds Attack at the End 50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">E.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Key-recovery Attack on 4 Rounds of AES - Extending the 3 Rounds Attack</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">at the Beginning&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">54</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">F</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Re-Order Algorithm - Details</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">58</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">G Key Recovery Attacks on 3 rounds of AES with a Single Secret S-Box</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">59</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">G.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Truncated Differential Attack on 3 rounds of AES with Secret S-Box</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">59</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">G.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Possible Variants of the Truncated Differential Attack on 3 Rounds of AES</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">with Secret S-Box</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">62</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">G.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Square Attack on 3 Rounds of AES with Secret S-Box&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">63</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">H</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Truncated Differential Attack on 4 rounds of AES with a single Secret</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">S-Box</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">65</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">I</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Impossible Differential Attack on 5-round AES with Single Secret S-Box</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">- Details</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">67</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">I.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Details of the Attack - Data Complexity and Computational Cost&lt;br&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">68</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">I.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">A possible Variant of the Impossible Differential Attack on 5-round AES</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">with Secret S-Box</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">70</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2 id="sec-4" class="text-2xl font-bold">&lt;span id=&quot;page-3-0&quot;&gt;&lt;/span&gt;<strong>1 Introduction</strong></h2>

    <p class="text-gray-300">If a cryptographic primitive succumbs to a particular non-random behavior, it might be possible to distinguish it from what one would expect from sufficiently generic behavior. Invariant subspace cryptanalysis is a cryptanalytic technique that is powerful for certain block ciphers. If there exists an invariant subspace for the round function and for the key schedule, then this technique can be used to mount fast distinguishers and key recovery. This technique was introduced in <a href="#page-35-0">[LAAZ11]</a> at CRYPTO 2011 for the cryptanalysis of PRINTcipher. Its efficiency has also been demonstrated on the CAESAR candidate iSCREAM, on the LS-design Robin and on the lightweight cipher Zorro in <a href="#page-35-1">[LMR15]</a>, and on the block cipher Midori64 <a href="#page-34-0">[GJN</a>&lt;sup&gt;+&lt;/sup&gt;15]. However, if such symmetries do not exist or are not found, invariant subspace cryptanalysis is not applicable. This leads to the natural question: <em>Can subspace properties still be used, even if no special symmetries or constants allow for invariant subspaces?</em> This paper will answer this question in the affirmative.</p>

    <h2 id="sec-5" class="text-2xl font-bold">&lt;span id=&quot;page-3-1&quot;&gt;&lt;/span&gt;<strong>1.1 High-Level Overview of Subspace-Trail Technique</strong></h2>

    <p class="text-gray-300">Our main contribution is the analysis of subspaces in SPNs (Substitution-Permutation Networks) constructions with a technique that can be seen as a generalization of invariant subspace attacks <a href="#page-35-0">[LAAZ11,</a> <a href="#page-35-1">LMR15]</a>. While invariant subspace cryptanalysis relies on iterative subspace structures, our analysis is concerned with <em>trails</em> of different subspaces<a href="#page-3-2">1</a> . To use an analogy, if invariant subspaces would correspond to iterative differential characteristics, then our method would be &quot;subspace-counterpart&quot; of differential characteristics.</p>

    <p class="text-gray-300">In particular, we study the propagation of subspaces trough various building blocks like S-Boxes and linear layers. In that sense it has similarities with SASAS cryptanalysis <a href="#page-33-0">[BS10]</a>, but also with Evertse's linear structures <a href="#page-34-1">[Eve87]</a>, while another way to generalize invariant subspaces - called &quot;nonlinear invariant attack&quot; - has recently been introduced in <a href="#page-36-1">[TLS16]</a>.</p>

    <p class="text-gray-300">In this paper we investigate the behavior of subspaces in keyed permutations. At a high level, we fix subspaces of the plaintext that maintain predictable properties after repeated applications of a key-dependent round function. First we identify what we call <em>subspace trails</em> which is essentially a coset of a plaintext subspace that encrypts to proper subspaces of the state space over several rounds. The trails are formed by the affine hulls of the intermediate ciphertexts. Subspace trails typically consist of subspaces that increase in dimension for each round, meaning that if the plaintext subspace has low dimension in comparison to the block length, the subsequent subspaces dimension increases for each round. For byte-based ciphers (like AES), a quick and dirty test for subspaces is to compute the affine hulls of a <em>n</em>-round encryption (for a certain <em>n</em> ≥ 1) of all values for each byte and then identify these subspaces. For bit-based ciphers, it is more important to determine what was coined a <em>nucleon</em> in <a href="#page-35-1">[LMR15]</a>, that is candidate plaintext subspaces that seem to fit symmetries in the round function. Trails of affine hulls of the intermediate ciphertexts that grow slowly in dimension for each round, typically reflect slow diffusion in the round function. This is often the case for ciphers that iterate simple round functions many times. In this paper we will focus on what we call <em>constant dimensional subspace trails</em>, which are trails of cosets that preserve dimension over several rounds. We show how to connect two or more trails and form longer trails that preserve predictable structure. In particular, when we connect two trails we typically seek to describe an output coset of a first trail in terms of cosets of the input coset for the second trail.</p>

    <p class="text-gray-300">To make the presentation more concrete, we focus on AES-128. The Rijndael block cipher <a href="#page-34-2">[DR02]</a> has been designed by Daemen and Rijmen in 1997 and accepted as the AES</p>

    <p class="text-gray-300">&lt;span id=&quot;page-3-2&quot;&gt;&lt;/span&gt;&lt;sup&gt;1&lt;/sup&gt;Note that since we don't look for subspaces trails that are restricted to be invariant, the algorithm provided in <a href="#page-35-1">[LMR15]</a> is not suitable for finding subspace trails.</p>

    <p class="text-gray-300">(Advanced Encryption Standard) since 2000 by NIST. Nowadays, it is probably the most used block cipher.</p>

    <h2 id="sec-6" class="text-2xl font-bold">&lt;span id=&quot;page-4-0&quot;&gt;&lt;/span&gt;<strong>1.2 Contributions</strong></h2>

    <p class="text-gray-300">There are four types of contributions in this paper. <em>Firstly</em> the <strong>definition and description of the subspace trails technique</strong>. As first examples, we describe it's application to secret-key distinguishers for up to 4 rounds of AES. In more details, the approach to the generalization of invariant subspace cryptanalysis to subspace trails is outlined in Sect. <a href="#page-11-0">2.</a> In Sect. <a href="#page-12-0">3</a> we give technical preliminaries with respect to AES-like permutations, and in Sect. <a href="#page-15-0">3.3</a> we state central theorems related to subspace trails and their intersections. When concretely applying it to AES, we describe in Sect. <a href="#page-16-0">4</a> distinguishers of round-reduced AES with a single unknown key up to 4 rounds. They correspond to known truncated differential, impossible differential, and integral distinguishers. From this it will become clear that these properties can be seen as special cases of subspace trails.</p>

    <p class="text-gray-300"><em>Secondly</em>, in App. <a href="#page-43-0">E</a> we describe <em>new low data-complexity key-recovery attacks on AES up to 4 rounds</em>, based on a combination of a truncated differential property (i.e. a relation among pairs of texts) and of properties of individual texts, which follows naturally from the proposed subspace trail approach.The relationship between these attacks and truncated differential cryptanalysis is discussed in App. <a href="#page-50-0">E.3.</a></p>

    <p class="text-gray-300"><em>Thirdly</em>, in Sect. <a href="#page-22-0">5</a> and <a href="#page-26-0">7</a> we describe a <strong>new and generic technique that can be used to attack AES with a</strong> <em>secret</em> <strong>S-Box</strong>. Even if we do not improve the current best results in this model by Tiesen <em>et al.</em> <a href="#page-36-2">[TKKL15]</a>, our technique allows (for the first time) to discover the secret key directly, without necessarily finding any equivalent representation or any other information about the S-Box. We show how not only integral attacks, but also truncated differential attacks and impossible differential attacks can exploit this technique. This technique can also be used to attack other AES-like block ciphers, if some very common conditions on the S-Box and on the MixColumns matrix (or its inverse) are guaranteed.</p>

    <p class="text-gray-300"><em>Finally</em>, starting from the impossible differential attack on 5 rounds of AES with a secret S-Box, in Sect. <a href="#page-29-0">8</a> we describe a <strong>new 5-round secret-key distinguisher for AES</strong> in the same setting as the one presented in <a href="#page-35-2">[SLG</a>&lt;sup&gt;+&lt;/sup&gt;16]. A critically discussion of that particular distinguisher setting is proposed in Sect. <a href="#page-31-0">8.2.</a></p>

    <p class="text-gray-300">Before starting with these detailed sections, we survey our concrete results: the distinguishers in the unknown (secret)-key model, and the key-recovery attacks in the cases of known and secret S-Box, and in both cases we compare them with earlier work.</p>

    <h2 id="sec-7" class="text-2xl font-bold">&lt;span id=&quot;page-4-1&quot;&gt;&lt;/span&gt;<strong>1.3 Secret-Key Distinguishers for AES</strong></h2>

    <p class="text-gray-300">The aim of a distinguishing attack is to find some properties of a cipher that random permutations don't have such that it is possible to distinguish a cipher from random permutations. In the usual security model, the adversary is given a <em>black box</em> (oracle) access to an instance of the encryption function associated with a random secret key and its inverse. The goal is to find the key or more generally to efficiently distinguish the encryption function from a random permutation.</p>

    <p class="text-gray-300">In Table <a href="#page-5-0">1</a> we summarize the secret-key distinguishers for 1 up to 5 rounds. Such results often serve as a basis for key recovery attacks in the most relevant single-key setting. The subspace trail cryptanalysis includes as special cases of differential cryptanalysis techniques (like truncated or impossible differentials) and integral cryptanalysis, hence the complexities for distinguishers up to 4 rounds is the same.</p>

    <p class="text-gray-300">The first distinguisher for five rounds of AES-128 has been proposed recently in CRYPTO 2016 <a href="#page-35-2">[SLG</a>&lt;sup&gt;+&lt;/sup&gt;16]. However, this distinguisher requires the <em>whole</em> input-output space to work, or less than the full codebooks if some knowledge of subkey bytes is assumed.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-5-0&quot;&gt;&lt;/span&gt;<strong>Table 1:</strong> <em>AES secret-key distinguishers, working independent of key schedule</em>. Data complexity is measured in minimum number of chosen plaintexts CP or/and chosen ciphertexts CC which are needed to distinguish the AES permutation from a random permutation with probability higher than 95%. The case in which the final MixColumns operation is omitted is denoted by &quot;<em>r.</em>5 rounds&quot;, that is <em>r</em> full rounds and the final round.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Rounds</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Data</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">CP CC</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Property</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Reference</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 - 1.5 - 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">×</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">×</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Truncated Differential</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[DR06a] - Sect. 4.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.5 - 3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.3&lt;br&gt;20 ' 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">×</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">×</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Truncated Differential</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BK07] - Sect. 4.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.5 - 3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">×</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">×</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Integral</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[DKR97] - Sect. 4.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.5 - 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16.25&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">×</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">×</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Impossible Differential</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BK01] - Sect. 4.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.5 - 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">×</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">×</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Integral</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[DKR97] - Sect. 4.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.5 - 5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">98.2&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">×</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Impossible Differential</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sect. 8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">×</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Integral</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[SLG+16]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">In the same setting of this distinguisher, in Sect. <a href="#page-29-0">8</a> we propose our secret key distinguisher for five rounds of AES, which requires (much) less than the whole input-output space without any knowledge about subkeys. Since we derive this distinguisher in a natural way from the impossible differential attack on five rounds of AES with a secret S-Box, we introduce it in Sect. <a href="#page-9-0">1.6</a> together with the mentioned attack, and we focus for the moment only on the distinguishers up to four rounds.</p>

    <p class="text-gray-300"><strong>Relation to other Distinguishers.</strong> The 1-, 2- and 3-round distinguishers presented in Sect. <a href="#page-16-1">4.1</a> and <a href="#page-18-1">4.3</a> exploit the same well-known structural properties that also truncated differentials exhibit. Using a different notation (namely the AES &quot;Super S-Box&quot;), 2-round subspace trails were already discovered and investigated in <a href="#page-34-3">[DR06a]</a> and <a href="#page-34-5">[DR06b]</a>, with the objective to understand how the components of the AES interact. In these papers, authors study the probability of differentials and characteristics over 2 rounds of AES, giving bound on the maximum differential probability.</p>

    <p class="text-gray-300">In <a href="#page-34-4">[DKR97]</a>, Daemen <em>et al.</em> proposed a new method that can break more rounds of SQUARE than differential and linear cryptanalysis, which is named the SQUARE attack consequently. In <a href="#page-35-3">[KW02]</a>, Knudsen and Wagner proposed the integral cryptanalysis as a generalized case of such attacks. The first key-recovery attacks on round-reduced AES were obtained by exploiting a 3-round integral distinguisher to attack up to 6 rounds. A reinterpretation of this integral distinguisher (also commonly labeled as square distinguisher) using the subspace trail notation is proposed in Sect. <a href="#page-20-0">4.4.</a></p>

    <p class="text-gray-300">Knudsen <a href="#page-35-4">[Knu98]</a> and Biham <em>et al.</em> <a href="#page-33-3">[BBS99]</a> independently proposed the impossibledifferential cryptanalysis. This distinguisher exploits differential with probability zero, and it is re-proposed using the subspace trail notation in Sect. <a href="#page-20-0">4.4.</a></p>

    <p class="text-gray-300">The subspace trail approach is mostly providing an alternative description of known properties under the umbrella of a single framework. However, there are other recent techniques that this approach does <em>not</em> seem to include. Recently integral distinguishers have been generalized by Todo <a href="#page-36-3">[Tod15b]</a> and in there also applied to AES-like primitives. Distinguishers for AES itself were not improved, but clear progress e.g. with MISTY cryptanalysis was demonstrated <a href="#page-36-4">[Tod15a]</a>. Todo's generalization can take S-Box properties into account, on the other hand the property exploited is still a type of zero-sum. Thus it complements our approach which is independent of the S-Box, but exploits properties more subtle than zero-sums. Subspace trails do not seem to capture other types of distinguisher. Among them are Polytopic distinguishers <a href="#page-35-5">[Tie16]</a>, DS-type distinguishers <a href="#page-34-6">[DS08a]</a>, or non-linear invariants <a href="#page-36-1">[TLS16]</a>.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-6-0&quot;&gt;&lt;/span&gt;<strong>1.4 Low Data-Complexity Key-Recovery Attacks on AES</strong></h4>

    <p class="text-gray-300">Since practical attacks on block ciphers became extremely rare in the last two decades, the approaches of the cryptanalysis community have been concentrating on attacking reduced-round variants of block ciphers and/or to allow the adversary more degrees of freedom in its control. In the first approach, the usual goal of the adversary is to maximize the number of rounds that can be broken, using less data than the entire codebook and less time than exhaustive key search. Attacks following such an approach are of importance, since they ensure that the block ciphers are strong enough and because they help to establish the security margins offered by the cipher. However, aiming for the highest number of rounds often leads cryptanalyst to attacks very close to brute force ones, or requiring completely impractical amounts of chosen/known inputs up to the full codebook. Practical attacks, especially those focusing on low data complexity, rightfully gained more attention recently, and this is also the focus of the key-recovery part in this paper.</p>

    <p class="text-gray-300"><strong>State of the Art.</strong> AES with its wide-trail strategy was designed to withstand <em>differential</em> and <em>linear cryptanalysis</em> <a href="#page-34-2">[DR02]</a>, so pure versions of these techniques have limited applications in attacks. Hence, it is widely believed that no regular differential attack can be mounted on more than 5 rounds of AES (see <a href="#page-35-6">[PSC</a>&lt;sup&gt;+&lt;/sup&gt;02] for details). For achieving the highest number of rounds, the most effective single-key recovery methods are <em>impossible differential cryptanalysis</em> (which yielded the first attack on the 7-round AES-128 <a href="#page-36-5">[ZWF07]</a> with non-marginal data complexity) and <em>integral attacks</em> <a href="#page-34-4">[DKR97]</a>. Another attack that initially has obtained less attention than the previous ones is the Meet-in-the-Middle attack <a href="#page-34-7">[DS08b]</a>, which has potential if enhanced by other techniques/attacks, as the differential attack <a href="#page-34-8">[DKS10,</a> <a href="#page-34-9">DFJ13,</a> <a href="#page-33-4">DF13]</a> or as the <em>bicliques technique</em> <a href="#page-33-5">[BKR11]</a>.</p>

    <p class="text-gray-300">In works like <a href="#page-33-6">[BDD</a>&lt;sup&gt;+&lt;/sup&gt;12] authors consider <em>Low-Data Complexity</em> attacks on reducedrounds of AES, that is they apply attacks assuming the attacker has limited resources, e.g. few plaintext/ciphertext pairs, which is often much more relevant in practice than attacks only aiming at the highest number of rounds. The results of this work have then been improved in <a href="#page-33-7">[BDF11]</a>. In that paper, authors set up tools which try to find attacks automatically by searching some classes of Guess-and-Determine and Meet-in-the-Middle attacks. These tools take as input a system of equations that describes the cryptographic primitive and some constraints on the plaintext and ciphertext variables. Then, they first run a search for an &quot;ad hoc&quot; solver for the equations to solve, build it, and then run it to obtain the actual solutions.</p>

    <p class="text-gray-300">Another work in the low-data complexity scenario is the <em>Polytopic Cryptanalysis</em> presented in <a href="#page-35-5">[Tie16]</a>, which is a generalization of differential cryptanalysis. In particular, the impossible polytopic cryptanalysis variant (that is, polytopic cryptanalysis that makes use of differentials with probability zero) was shown to allow competitive low-data attacks on round-reduced AES.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6"><strong>Our Key-Recovery Results</strong></h4>

    <p class="text-gray-300">In this paper, we present key-recovery truncated differential attacks on reduced-round variants of AES-128 based on subspace trail cryptanalysis. A comparison of all known and relevant attacks on AES and our attacks presented in this paper is given in Table <a href="#page-7-0">2.</a> To better understand this table, we highlight some aspects. Without going into the details here, AES is a key-iterated block cipher that consists of the repeated application of a round transformation on the state (called intermediate result). Each round transformation is a sequence of four steps. All the rounds are equal, except for the last one which is a slightly different. One of the steps that compose each round (the MixColumns operation) is omitted in the last round. The effect of the omission of the last round MixColumns has been studied in detail e.g. in <a href="#page-34-10">[DK10]</a>, and often doesn't affect the security of AES.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-7-0&quot;&gt;&lt;/span&gt;<strong>Table 2:</strong> Comparison of low-data attacks on round-reduced AES. Data complexity is measured in number of required known/chosen plaintexts (KP/CP). Time complexity is measured in round-reduced AES encryption equivalents (E) and in memory accesses (M). Memory complexity is measured in plaintexts (16 bytes). The case in which the MixColumns operation is omitted in the last round is denoted by &quot;r.5 rounds&quot;, that is r full rounds and the final round. New attacks are in bold.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Attack</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Rounds</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Data</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Computation (E)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Memory</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Reference</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">G&amp;D-MitM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 KP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{80}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{80}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BDF11]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">D-MitM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{32}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{1}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">[BDD^+12]</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">TrD</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.5 - 3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{32} \\mathrm{\\ M} + 2^{31.55} \\mathrm{\\ E} \\approx 2^{31.6}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">App. E</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">G&amp;D-MitM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{24}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{16}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BDF11]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">G&amp;D-MitM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{16}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{8}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BDF11]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">TrD</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.5 - 3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{11.2}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">App. E</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">G&amp;D-MitM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^8</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{8}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BDF11]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">TrD</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.5 - 3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{10} \\mathrm{\\ M} + 2^{5.1} \\mathrm{\\ E} \\approx 2^{5.7}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{12}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">App. E</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">D-MitM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{104}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BDD &lt;sup&gt;+&lt;/sup&gt; 12]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">TrD <span class="math">(EE)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.5 - 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{96}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">App. E.4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">G&amp;D-MitM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{88}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{8}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BDF11]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">G&amp;D-MitM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{80}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{80}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BDF11]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">G&amp;D-MitM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{72}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{72}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BDF11]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">TrD <span class="math">(EE)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.5 - 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{74.7}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">App. E.4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">G&amp;D-MitM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{72}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BDF11]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">TrD <span class="math">(EE)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.5 - 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">{\\bf 2^{76}~M} + {\\bf 2^{64}~E} \\approx {\\bf 2^{69.7}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{12}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">App. E.4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">G&amp;D-MitM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{32}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{24}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BDF11]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">D-MitM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{64}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{68}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">[BDD^+12]</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">I-Pol</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.5 - 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{38}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{15}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[Tie16]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">D-MitM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{40}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{43}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">[BDD^+12]</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">TrD <span class="math">(EB)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.5 - 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\boxed{2^{40.6}~\\mathrm{M}~+2^{33.9}~\\mathrm{E}\\approx2^{35.1}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{17}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">App. E.5</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">I</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.5 - 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^9</span> CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{14}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">small</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[DKR97]</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">G&amp;D: Guess &amp; Det., D: Diff., MitM: Meet-in-the-Middle, TrD: Truncated Differential, I: Integral, I-Pol: Imp. polytopic, EE: Extension at End, EB: Extension at Beginning.</p>

    <p class="text-gray-300">On the other hand, MitM-style attacks can sometimes work better when all rounds are the same. Since the attacks presented in  <span class="math">[BDD^+12]</span>  and found by the tool described in [BDF11] mainly exploit the MitM technique, they are sometimes affected by the presence of the final MixColumns, that is the data and the computational complexities are not equal if the final MixColumns is omitted&lt;sup&gt;2&lt;/sup&gt;. In contrast, note that our attack (based on the truncated differential technique) is independent of the presence of the last MixColumns.</p>

    <p class="text-gray-300">As the data complexity and number of rounds attacked is not always directly comparable, we re-ran the tool from [BDF11] in our settings. As a result, we are able to provide the computational cost of the best attack found by the tool for the case of 3.5 rounds (that is, 4 rounds of AES without the final MixColumns operation) using 2 chosen plaintexts.</p>

    <p class="text-gray-300">Our attack on 3 rounds as described in App. E is based on the property that a coset of a particular subspace  <span class="math">\\mathcal{D}</span>  of the plaintexts space is always mapped into a coset of another</p>

    <p class="text-gray-300">&lt;span id=&quot;page-7-1&quot;&gt;&lt;/span&gt; <span class="math">&lt;sup&gt;^2&lt;/sup&gt;</span> As an example, the attack on 3 rounds with 2 chosen plaintexts has lower computational complexity and memory requirements when the final MixColumns is not omitted ( <span class="math">2^{16}</span>  encryption and  <span class="math">2^8</span>  of memory) rather than omitted ( <span class="math">2^{24}</span>  encryption and  <span class="math">2^{16}</span>  memory).</p>

    <p class="text-gray-300">particular subspace M after two rounds. Exploiting the particular shape of the subspace M and given two ciphertexts (which plaintexts belong to the same coset of D), the right key is one of those such that these two ciphertexts belong to the same coset of M one round before. We show how to extend this approach in order to attack 4 rounds in App. <a href="#page-51-0">E.4</a> by extend our attack at the end, while in App. <a href="#page-55-0">E.5</a> we show how to extend it at the beginning.</p>

    <h2 id="sec-10" class="text-2xl font-bold">&lt;span id=&quot;page-8-0&quot;&gt;&lt;/span&gt;<strong>1.5 Attack on AES with a Single Secret S-Box</strong></h2>

    <p class="text-gray-300">The subspace trail framework also allows to consider attacks on AES with a <em>single secret</em> S-Box, i.e. the case in which the AES S-Box is replaced by a secret 8-bit one while keeping everything else unchanged. If the choice of the S-Box is made uniformly at random from all 8-bits S-Boxes, the size of the secret information increases from 128-256 bits (i.e. the key size in AES) to 1812-1940. Thus, this could be a good attempt to strengthen the cipher or all to reduce the number of rounds. Note that AES was designed in order to achieve good resistance against differential and linear cryptanalysis, and this includes the choice of the S-Box. However, a randomly chosen S-Box is very highly resistant against these attacks as well.</p>

    <p class="text-gray-300">In <a href="#page-36-2">[TKKL15]</a>, authors are able to attack up to 6-round of AES with identical and secret S-Box using techniques from integral cryptanalysis. Authors demonstrate that despite the increased size of the secret information in the cipher, they are able to recover both the secret key and the S-Box for the 4-round, 5-round and 6-round versions of AES-128. More precisely, authors are able to find the whitening key up to 256 variants, that is (<em>k</em>0<em>, k</em>&lt;sup&gt;0&lt;/sup&gt; ⊕ <em>k</em>1<em>, ..., k</em>&lt;sup&gt;0&lt;/sup&gt; ⊕ <em>k</em>15) (where <em>k&lt;sup&gt;i&lt;/sup&gt;</em> is the <em>i</em>-th byte of the whitening key) for unknown <em>k</em>0. We emphasize that to obtain this result, authors must determine the secret S-Box (up to an additive constant before and after the S-Box, i.e. S-Box(<em>x</em>) ∼ <em>a</em>⊕ S-Box(<em>b</em> ⊕ <em>x</em>)) in order to find the key. In other words, using their technique it is not possible to find the key independent of the S-Box. To the best of our knowledge, this is the only work in the literature regarding attacks on AES with a secret S-Box.</p>

    <p class="text-gray-300">However, several other results in literature consider (other) encryption schemes with secret part. PRESENT with a secret S-Box has for example been considered in <a href="#page-33-8">[BKLT11,</a> <a href="#page-35-7">LJQ14]</a>. One of the first work in this context has been presented by Biryukov and Shamir <a href="#page-33-9">[BS01]</a>, who applied integral cryptanalysis to a generalized SPN structure denoted SASAS, which consists of three substitution layers separated by two affine layers. In their paper, the attacker is assumed not to have any knowledge about the linear layer or the S-boxes which are all allowed to be chosen independently at random. The SASAS attack recovers an equivalent representation of this SPN and thus allows decryption of any ciphertext. The attack allows to break the equivalent of three rounds of AES. A follow up work is <a href="#page-32-1">[BBK14]</a>, where authors considered the ASASA scheme in order to design public key or white-box constructions using symmetric cipher components.</p>

    <p class="text-gray-300">In all the previous works, an attacker must work both on the secret S-Box and on the secret key, that is she has to first find information on the secret S-Box in order to discover the secret key. Thus, a natural questions arise: <em>Is it also possible to directly find the secret key without having to discover any information about the secret S-Box?</em> In this paper, we show that it's possible if some (very common) assumptions are guaranteed. Using the subspace-trail framework, we present a <em>generic</em> technique to discover <em>directly</em> (i.e. without working on the S-Box) the secret key of AES up to some variants, and we show how it is exploited by a truncated differential attack in Sect. <a href="#page-25-0">6</a> (in particular, we consider 3 rounds of AES in App. <a href="#page-60-1">G.1</a> and 4 rounds in App. <a href="#page-66-0">H)</a>, by an impossible differential attack in Sect. <a href="#page-26-0">7</a> and by an integral attack in App. <a href="#page-64-0">G.3.</a></p>

    <p class="text-gray-300">The assumptions required are that the S-Boxes are identical, that each row of the MixColumns matrix has two identical elements and that each row has these two identical element in different positions. An example is the MixColumns matrix of AES, or any</p>

    <p class="text-gray-300">&lt;span id=&quot;page-9-1&quot;&gt;&lt;/span&gt;<strong>Table 3:</strong> Comparison of attacks on round-reduced AES with secret S-Box. Data complexity is measured in number of required chosen plaintexts/ciphertexts (CP/CC). Time complexity is measured in round-reduced AES encryption equivalents (E), in memory accesses (M) or XOR operations (XOR). Memory complexity is measured in plaintexts (16 bytes). The case in which the final MixColumns operation is omitted is denoted by &quot;r.5 rounds&quot;, that is r full rounds and the final round. New attacks are in bold. The symbol * denotes an attack that can not work independently of the S-Box and the key.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Attack</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Rounds</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Data</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Computation</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Memory</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Reference</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SASAS</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{16}</span> CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{21} \\text{ E}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{16}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BS01]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">TrD</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.5 - 3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{13.6}</span> CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{13.2}~{\\rm XOR}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">small</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sect. 6 - App. G.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">I</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.5 - 3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{19.6}</span> CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{19.6}~{\\rm XOR}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">small</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">App. G.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">TrD</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.5 - 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{30}</span> CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{36}~\\mathrm{M}\\approx 2^{29.7}~\\mathrm{E}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{30}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sect. 6 - App. H</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathrm{I}^{\\star}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.5 - 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{16}</span> CC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{17.7} \\text{ E}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{16}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[TKKL15]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathrm{I}^{\\star}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.5 - 4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{16}</span> CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{28.7} E</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{16}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[TKKL15] (see Sect. 3.5)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">ImD</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.5 - 5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{102}</span> CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{107}~{\\rm M}\\approx 2^{100.4}~{\\rm E}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sect. 7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathrm{I}^{\\star}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.5 - 5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{40}</span> CC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{38.7} \\text{ E}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{40}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[TKKL15]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\mathrm{I}^{\\star}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4.5 - 5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{40} \\text{ CP}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{54.7} \\text{ E}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{40}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[TKKL15] (see Sect. 3.5)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">I</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{128} \\text{ CC}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{129.6} \\text{ XOR}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">small</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">[SLG^{+}16]</span> - Sect. 8.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">TrD: Truncated Differential, I: Integral, ImD: Impossible Differential.</p>

    <p class="text-gray-300">cyclic matrix with two identical elements.</p>

    <p class="text-gray-300">A comparison between this technique and the one presented in [TKKL15] is shown in Table 3. Even if the assumptions are the same (i.e. the assumption of secret and identical S-Box), our goals are different from the one of [TKKL15]. Similar to [TKKL15], using our attack it is only possible to find the whitening key up to  <span class="math">(256)^4 = 2^{32}</span>  variants, if no information about the S-Box are discovered and used. Anyway, these  <span class="math">2^{32}</span>  variants can be reduced up to 256, working also on the secret S-Box and using a strategy similar to the one of [TKKL15], as shown in detail in App. G.2.1.</p>

    <p class="text-gray-300">Finally, we recall the advice given in [SLG&lt;sup&gt;+&lt;/sup&gt;16] &quot;when design an AES-like cipher, it is better to choose those MDS matrices  <span class="math">M_{MC}</span>  such that both  <span class="math">M_{MC}</span>  and  <span class="math">M_{MC}^{-1}</span>  do not have identical elements in the same columns&quot;, which allows to protect the cipher against our attacks presented in this paper and in [SLG&lt;sup&gt;+&lt;/sup&gt;16].</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-9-0&quot;&gt;&lt;/span&gt;1.6 The 5-round Secret Key Distinguisher for AES-128</h4>

    <p class="text-gray-300">In [SLG&lt;sup&gt;+&lt;/sup&gt;16], authors presented the first 5-round secret key distinguisher for AES-128, based on the balanced property.</p>

    <p class="text-gray-300">This distinguisher is constructed in two steps. At first step, authors assume that some of the subkey bits are known. Using this knowledge, they show how to choose the ciphertexts such that the balanced property holds on 5 rounds of AES. This distinguisher requires  <span class="math">2^{120}</span>  texts if the difference of two bytes (i.e. 8 bits) of the subkey is known, or  <span class="math">2^{96}</span>  texts if the differences of four pairs of bytes (i.e. 32 bits) are known. In the second step, authors assume that no secret key material is known. The idea is basically to repeat the first step of the distinguisher for each possible values of the subkey bits used to choose the ciphertexts. For the AES case, when this guess is correct (i.e. when these guessed bits are equal to that of the secret key) the balanced property holds for 5 rounds, which surely occurs in an exhaustive search.</p>

    <p class="text-gray-300">Note that this distinguisher requires all the input-output space to work, that is the</p>

    <p class="text-gray-300">data complexity is 2 &lt;sup&gt;128&lt;/sup&gt; texts when no subkey byte is known<a href="#page-10-1">3</a> . Moreover, the distinguisher presented in <a href="#page-35-2">[SLG</a>&lt;sup&gt;+&lt;/sup&gt;16] doesn't exploit the details of the S-Box (which can be considered secret), that is the ciphertexts are chosen independently of the definition of the S-Box, but it requires some assumptions on the MixColumns matrix (which are the same ones we described for the key recovery attacks on AES with secret S-Box).</p>

    <p class="text-gray-300">As we show in Sect. <a href="#page-29-0">8,</a> our impossible differential attack on 5 rounds of AES with a secret S-Box can be turned into a distinguisher <em>in the same setting</em> of the one proposed by <a href="#page-35-2">[SLG</a>&lt;sup&gt;+&lt;/sup&gt;16]. In our case, we consider an impossible differential trail instead of the balance property. As in the CRYPTO paper, the idea is to check the existence of a key for which the impossible differential trail is satisfied. Note that with respect to a key recovery attack, <em>both our distinguisher and the one presented in the CRYPTO paper have the advantage that it is not necessary to find the entire key to distinguish the two cases</em>, since a limited number of bytes (e.g. the XOR difference of two bytes) is sufficient. Moreover, as in <a href="#page-35-2">[SLG</a>&lt;sup&gt;+&lt;/sup&gt;16], our distinguisher is independent by the details of the S-Box operation, but requires the same assumption on the MixColumn matrix <em>MMC</em> (i.e. at least one column must have two identical elements). A critical discussion of these distinguishers is provided in Sect. <a href="#page-31-0">8.2,</a> arguing that in some sense the quest for the first 5-round distinguisher is still open despite the recent results.</p>

    <p class="text-gray-300">As maybe the most interesting aspect, this distinguisher provides a counter-example to the conjectures made in <a href="#page-35-2">[SLG</a>&lt;sup&gt;+&lt;/sup&gt;16], besides the fact that it doesn't need the entire input-output space but only 2 98<em>.</em>2 chosen plaintexts. Indeed, the distinguisher presented in <a href="#page-35-2">[SLG</a>&lt;sup&gt;+&lt;/sup&gt;16] is constructed in the chosen-ciphertext mode, and only in the case in which MixColumns in the last round is not omitted. For this reason, authors claim that &quot;<em>since the 5-round distinguisher for AES can only be constructed in the chosen-ciphertexts mode, the security margin for the round-reduced AES under the chosen-plaintext attack may be different from that under the chosen-ciphertext attack</em>&quot;. However, our distinguisher is constructed in the chosen-plaintexts setting, and it works independent of the last MixColumns operation. Hence it seems <em>there is no clear evidence that chosen-ciphertext security is less than chosen-plaintext security in AES</em>.</p>

    <p class="text-gray-300">In Sect. <a href="#page-29-1">8.1</a> we show that also the distinguisher of <a href="#page-35-2">[SLG</a>&lt;sup&gt;+&lt;/sup&gt;16] can be turned into a key recovery attack, while in Sect. <a href="#page-31-0">8.2</a> we critically discuss the model in which these distinguishers work.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-10-0&quot;&gt;&lt;/span&gt;<strong>1.7 Practical Verification</strong></h3>

    <p class="text-gray-300">Almost all results in the paper have been verified using a C/C++ implementation:</p>

    <p class="text-gray-300"><strong>Secret-Key Distinguishers.</strong> We practically verified the secret-key distinguishers for up to 4 rounds, and we have found that the practical results are consistent with our theory. The source codes of the secret-key distinguishers can be found in <a href="#page-34-11">[git16c]</a>. Due to the huge data and computational complexity of the secret-key distinguishers on 5-round AES described in Sect. <a href="#page-29-0">8,</a> it can not be verified even on small-scale AES <a href="#page-33-10">[CMR05]</a> (more details are given in App. <a href="#page-71-1">I.1.3)</a>. Theoretically considerations are given to prove its correctness.</p>

    <p class="text-gray-300"><strong>Low-Data Complexity Key-Recovery Attacks on AES.</strong> We practically verified the lowdata complexity attacks on 1, 2, 3 and 4 rounds. For the 3 rounds attack, one or two pairs of plaintexts (that is two or three different plaintexts) are sufficient to discover the key of the final round, as predicted. Since the attack on 4 rounds described in App. <a href="#page-51-0">E.4</a> has a very high computational cost, we have tested it in a different way, which is explained in detail with the presentation of the attack. The source codes of the low-data complexity attacks can be found in <a href="#page-34-12">[git16b]</a>.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-10-1&quot;&gt;&lt;/span&gt;&lt;sup&gt;3&lt;/sup&gt;This was also confirmed with Bing Sun via personal communication.</p>

    <p class="text-gray-300">Key-Recovery Attacks on AES with a Secret S-Box. We practically verified the truncated differential attacks on AES with a secret S-Box on 3 and 4 rounds, and the integral attack on AES with a secret S-Box on 3 rounds. The experimental results are in according to our theory. In particular, considerations about the practical computational costs of these attacks (in comparison with the theoretical ones) are reported in Sect. 6. The source codes of the key-recovery attacks on AES with a single secret S-Box can be found in [git16a].</p>

    <h2 id="sec-13" class="text-2xl font-bold">&lt;span id=&quot;page-11-0&quot;&gt;&lt;/span&gt;2 Subspace Trails</h2>

    <p class="text-gray-300">In this section, we recall the invariant subspace cryptanalysis of [LAAZ11, LMR15] (depicted in Fig. 1), and then we introduce the concept of subspace trails (Fig. 2).</p>

    <p class="text-gray-300">Invariant subspace cryptanalysis can be a powerful cryptanalytic tool. Let F denote a round function in an iterative key-alternating block cipher  <span class="math">E_K(\\cdot)</span> :</p>

    <p class="text-gray-300"><span class="math">$E_K(m) = k_n \\oplus F(\\dots k_2 \\oplus F(k_1 \\oplus F(k_0 \\oplus m))),</span>$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-11-1&quot;&gt;&lt;/span&gt;where the round keys  <span class="math">k_0, ..., k_n</span>  are derived from the master key K using some key schedule  <span class="math">f: (k_0, ..., k_n) = f(K)</span> . Assume there exists a coset&lt;sup&gt;4&lt;/sup&gt;  <span class="math">V \\oplus a</span>  such that  <span class="math">F(V \\oplus a) = V \\oplus a&#x27;</span> . Then if the round key K resides in  <span class="math">V \\oplus (a \\oplus a&#x27;)</span> , it follows that  <span class="math">F(V \\oplus a) \\oplus K = V \\oplus a</span>  and we get an iterative invariant subspace.</p>

    <p class="text-gray-300">    <img src="_page_11_Figure_8.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 1: Invariant subspaces.</p>

    <p class="text-gray-300">A slightly more powerful property can occur if for each a, there exists unique b such that  <span class="math">F_K(V \\oplus a) := F(V \\oplus a) \\oplus K = V \\oplus b</span>  meaning that the subspace property is invariant, but not the initial coset. That is, for each initial coset  <span class="math">V \\oplus a</span> , its image under the application of  <span class="math">F_K</span>  is another coset of V, in general different from the initial one. Equivalently, the initial coset  <span class="math">V \\oplus a</span>  is mapped into another coset  <span class="math">V \\oplus b</span> , where b depends on a and on the round key. In this paper, we generalize this concept and search for trails of subspaces. In the simplest case we look for pairs of subspaces  <span class="math">V_1</span>  and  <span class="math">V_2</span>  such that</p>

    <p class="text-gray-300"><span class="math">$F(V_1 \\oplus a) \\oplus K = V_2 \\oplus b</span>$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-11-2&quot;&gt;&lt;/span&gt;holds for any constant a, that is for each a there exists unique b for which the previous equivalence is satisfied.</p>

    <p class="text-gray-300">    <img src="_page_11_Figure_13.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 2: Trail of subspaces.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-11-3&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;4&lt;/sup&gt;We recall the definition of coset, often used in the paper. Let W a vector space and V a subspace of W. If a is an element of W, a coset  <span class="math">V \\oplus a</span>  of V in W is a subset of the form  <span class="math">V \\oplus a = \\{v \\oplus a \\mid \\forall v \\in V\\}</span> .</p>

    <p class="text-gray-300">A subspace trail of length r is then simply a set of r+1 subspaces  <span class="math">(V_1,V_2,\\ldots,V_{r+1})</span>  that satisfy</p>

    <p class="text-gray-300"><span class="math">$F(V_i \\oplus a_i) \\oplus K \\subseteq V_{i+1} \\oplus a_{i+1}</span>$
.</p>

    <p class="text-gray-300">When the relation holds with equality, the trail is called a <em>constant-dimensional</em> subspace trail. In this case, if  <span class="math">F_K^t</span>  denotes the application of t rounds with fixed keys, it follows that</p>

    <p class="text-gray-300"><span class="math">$F_K^t(V_1 \\oplus a_1) = V_{t+1} \\oplus a_{t+1}.</span>$</p>

    <p class="text-gray-300"><strong>Definition 1.</strong> Let  <span class="math">(V_1, V_2, ..., V_{r+1})</span>  denote a set of r+1 subspaces with  <span class="math">\\dim(V_i) \\leq \\dim(V_{i+1})</span> . If for each i=1,...,r and for each  <span class="math">a_i \\in V_i^{\\perp}</span> , there exist (unique)  <span class="math">a_{i+1} \\in V_{i+1}^{\\perp}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$F_K(V_i \\oplus a_i) \\subseteq V_{i+1} \\oplus a_{i+1},</span>$</p>

    <p class="text-gray-300">then  <span class="math">(V_1, V_2, ..., V_{r+1})</span>  is subspace trail of length r for the function  <span class="math">F_K</span> . If all the previous relations hold with equality, the trail is called a constant-dimensional subspace trail.</p>

    <p class="text-gray-300">Note that  <span class="math">a_{i+1}</span>  depends on  <span class="math">a_i</span>  and on the secret round key, but to simplify notation we use  <span class="math">a_{i+1}</span>  instead of  <span class="math">a_{i+1}(a_i, k)</span> . With subspace structures at hand, we might ask questions about the probability that ciphertexts or sums of ciphertexts reside in certain subspaces, given that the plaintexts obey certain subspace structure (e.g. their sum is also in a fixed subspace). If the sum is over two texts this approaches resembles (truncated) differential cryptanalysis, if the sum is over more it can resemble integral cryptanalysis.</p>

    <p class="text-gray-300">For AES-type block ciphers, we are typically not able to construct very long trails. In this case we can connect trails together and depending on the intersection properties of the endpoints of the trails, get predictable subspace properties for longer trails. However, in general these are not necessarily simple constant dimensional trails. In the following we describe subspace trail cryptanalysis and later-on distinguishers based on it. For sake of concreteness and better exposition, we focus on the case of AES. We'd like to emphasize that the properties described here extend almost immediately to any AES-like cipher with little modifications.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-12-0&quot;&gt;&lt;/span&gt;3 Preliminaries</h4>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-12-1&quot;&gt;&lt;/span&gt;3.1 Description of AES</h4>

    <p class="text-gray-300">The Advanced Encryption Standard [DR02] is a Substitution-Permutation network that supports key size of 128, 192 and 256 bits. The 128-bit plaintext initializes the internal state as a  <span class="math">4 \\times 4</span>  matrix of bytes as values in the finite fields  <span class="math">\\mathbb{F}_{256}</span> , defined using the irreducible polynomial  <span class="math">x^8 + x^4 + x^3 + x + 1</span> . Depending on the version of AES,  <span class="math">N_r</span>  round are applied to the state:  <span class="math">N_r = 10</span>  for AES-128,  <span class="math">N_r = 12</span>  for AES-192 and  <span class="math">N_r = 14</span>  for AES-256. An AES round applies four operations to the state matrix:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>SubBytes (S-Box) applying the same 8-bit to 8-bit invertible S-Box 16 times in parallel on each byte of the state (it provides the non-linearity in the cipher);</li>
      <li>ShiftRows (SR) cyclic shift of each row (i-th row is shifted by i bytes to the left);</li>
      <li><span class="math">MixColumns\\ (MC)</span>  multiplication of each column by a constant  <span class="math">4\\times 4</span>  invertible matrix over the field  <span class="math">GF(2^8)</span>  (it and ShiftRows provide diffusion in the cipher&lt;sup&gt;5&lt;/sup&gt;);</li>
      <li>AddRoundKey (ARK) XORing the state with a 128-bit subkey.</li>
    </ul>

    <p class="text-gray-300">&lt;span id=&quot;page-12-2&quot;&gt;&lt;/span&gt; <span class="math">&lt;sup&gt;^5&lt;/sup&gt;</span> ShiftRows makes sure column values are spread and MixColumns makes sure each column is mixed.</p>

    <p class="text-gray-300">One round of AES can be described as  <span class="math">R(x) = K \\oplus MC \\circ SR \\circ S\\text{-Box}(x)</span> . In the first round an additional AddRoundKey operation (using a whitening key) is applied, and in the last round the MixColumns operation is omitted.</p>

    <p class="text-gray-300">As we consider only AES with 128-bit key, we shall describe only its key schedule algorithm. The key schedule of AES-128 takes the user key and transforms it into 11 subkeys of 128 bits each. The subkey array is denoted by W[0,...,43], where each word of  <span class="math">W[\\cdot]</span>  consists of 32 bits and where the first 4 words of  <span class="math">W[\\cdot]</span>  are loaded with the user secret key. The remaining words of  <span class="math">W[\\cdot]</span>  are updated according to the following rule:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>if  <span class="math">i \\equiv 0 \\mod 4</span> , then  <span class="math">W[i] = W[i-4] \\oplus RotByte(S-Box(W[i-1])) \\oplus RCON[i/4]</span> ,</li>
      <li>otherwise,  <span class="math">W[i] = W[i-1] \\oplus W[i-4]</span> ,</li>
    </ul>

    <p class="text-gray-300">where i=4,...,43, RotByte rotates the word by 8 bits to the left and  <span class="math">RCON[\\cdot]</span>  is an array of predetermined constant.</p>

    <p class="text-gray-300">The Notation Used in the Paper. Let x denote a plaintext, a ciphertext, an intermediate state or a key. Then  <span class="math">x_{i,j}</span>  with  <span class="math">i,j \\in \\{0,...,3\\}</span>  denotes the byte in the row i and in the column j. We denote by  <span class="math">k^r</span>  the key of the r-th round, where  <span class="math">k^0</span>  is the secret key. If only the key of the final round is used, then we denote it by k to simplify the notation. Finally, we denote by R one round of AES&lt;sup&gt;6&lt;/sup&gt;, while we denote i rounds of AES by  <span class="math">R^{(i)}</span> . If the MixColumns operation is omitted in the last round, then we denote it by  <span class="math">R_f</span> . As last thing, in the paper we often use the term &quot;partial collision&quot; (or, more simply, collision) when two texts belong to the same coset of a given subspace X.</p>

    <h2 id="sec-16" class="text-2xl font-bold">&lt;span id=&quot;page-13-0&quot;&gt;&lt;/span&gt;3.2 Subspaces through One Round of AES</h2>

    <p class="text-gray-300">For a vector space V and a function F on  <span class="math">\\mathbb{F}_{2^8}^{4\\times 4}</span> , let  <span class="math">F(V)=\\{F(v)\\,|\\,v\\in V\\}</span>  (as usual). For a subset  <span class="math">I\\subseteq\\{1,2,\\ldots,n\\}</span>  and a subset of vector spaces  <span class="math">\\{G_1,G_2,\\ldots,G_n\\}</span> , we define  <span class="math">G_I</span>  as  <span class="math">G_I:=\\bigoplus_{i\\in I}G_i</span> .</p>

    <p class="text-gray-300">In the following we define four families of subspaces essential to AES: the diagonal spaces  <span class="math">\\mathcal{D}_I</span> , the inverse-diagonal spaces  <span class="math">\\mathcal{I}\\mathcal{D}_I</span> , the column spaces  <span class="math">\\mathcal{C}_I</span>  and the mixed spaces  <span class="math">\\mathcal{M}_I</span> . All the subspace defined in the paper are subspaces of the space  <span class="math">\\mathbb{F}_{28}^{4\\times4}</span>  over the field  <span class="math">\\mathbb{F}_{28}</span>  defined as</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{F}_{2^8} := GF(2^8)[X]/(X^8 + X^4 + X^3 + X + 1).</span>$</p>

    <p class="text-gray-300">Moreover, we denote with  <span class="math">E = \\{e_{0,0}, ..., e_{3,3}\\}</span>  the unit vectors of  <span class="math">\\mathbb{F}_{28}^{4\\times4}</span>  (e.g.  <span class="math">e_{i,j}</span>  has a single 1 in row i and column j). In App. A we recall the main definitions regarding the subspaces, with concrete examples on the AES case.</p>

    <p class="text-gray-300"><strong>Definition 2.</strong> (Column spaces) The column spaces  <span class="math">C_i</span>  are defined as</p>

    <p class="text-gray-300"><span class="math">$C_i = \\langle e_{0,i}, e_{1,i}, e_{2,i}, e_{3,i} \\rangle.</span>$</p>

    <p class="text-gray-300">For instance, the column space  <span class="math">C_0</span>  corresponds to the symbolic matrix</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{C}_0 = \\left\\{ \\begin{bmatrix} x_1 &amp; 0 &amp; 0 &amp; 0 \\\\ x_2 &amp; 0 &amp; 0 &amp; 0 \\\\ x_3 &amp; 0 &amp; 0 &amp; 0 \\\\ x_4 &amp; 0 &amp; 0 &amp; 0 \\end{bmatrix} \\middle| \\forall x_1, x_2, x_3, x_4 \\in \\mathbb{F}_{2^8} \\right\\}.</span>$</p>

    <p class="text-gray-300"><strong>Definition 3.</strong> (Diagonal spaces) The diagonal spaces  <span class="math">\\mathcal{D}_i</span>  are defined as</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{D}_i = SR^{-1}(\\mathcal{C}_i) = \\langle e_{0,i}, e_{1,i+1}, e_{2,i+2}, e_{3,i+3} \\rangle</span>$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-13-1&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;6&lt;/sup&gt;Sometimes we use the notation  <span class="math">R_K</span>  instead of R to highlight that the round key is K.</p>

    <p class="text-gray-300">where the index i+j is computed modulo 4. For instance, the diagonal space  <span class="math">\\mathcal{D}_0</span>  corresponds to the symbolic matrix</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{D}_0 = \\left\\{ \\begin{bmatrix} x_1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; x_2 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; x_3 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; x_4 \\end{bmatrix} \\middle| \\forall x_1, x_2, x_3, x_4 \\in \\mathbb{F}_{2^8} \\right\\}.</span>$</p>

    <p class="text-gray-300"><strong>Definition 4.</strong> (Inverse-Diagonal spaces) The inverse-diagonal spaces  <span class="math">\\mathcal{ID}_i</span>  are defined as</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{ID}_i = SR(C_i) = \\langle e_{0,i}, e_{1,i-1}, e_{2,i-2}, e_{3,i-3} \\rangle.</span>$</p>

    <p class="text-gray-300">where the index i-j is computed modulo 4. For instance,  <span class="math">\\mathcal{ID}_0 = SR(\\mathcal{C}_0)</span>  corresponds to the symbolic matrix</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{ID}_0 = \\left\\{ \\begin{bmatrix} x_1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; x_2 \\\\ 0 &amp; 0 &amp; x_3 &amp; 0 \\\\ 0 &amp; x_4 &amp; 0 &amp; 0 \\end{bmatrix} \\middle| \\forall x_1, x_2, x_3, x_4 \\in \\mathbb{F}_{2^8} \\right\\}.</span>$</p>

    <p class="text-gray-300">The last type of subspaces we define are called mixed subspaces.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-14-1&quot;&gt;&lt;/span&gt;<strong>Definition 5.</strong> (Mixed spaces) The <em>i</em>-th mixed subspace  <span class="math">\\mathcal{M}_i</span>  is defined as</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{M}_i = MC(\\mathcal{ID}_i).</span>$</p>

    <p class="text-gray-300">These subspaces are formed by applying ShiftRows and then MixColumns to a column space. For instance,  <span class="math">\\mathcal{M}_0</span>  corresponds to symbolic matrix</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{M}_0 = \\left\\{ \\begin{bmatrix} \\alpha \\cdot x_1 &amp; x_4 &amp; x_3 &amp; (\\alpha+1) \\cdot x_2 \\\\ x_1 &amp; x_4 &amp; (\\alpha+1) \\cdot x_3 &amp; \\alpha \\cdot x_2 \\\\ x_1 &amp; (\\alpha+1) \\cdot x_4 &amp; \\alpha \\cdot x_3 &amp; x_2 \\\\ (\\alpha+1) \\cdot x_1 &amp; \\alpha \\cdot x_4 &amp; x_3 &amp; x_2 \\end{bmatrix} \\middle| \\forall x_1, x_2, x_3, x_4 \\in \\mathbb{F}_{2^8} \\right\\}.</span>$</p>

    <p class="text-gray-300">where  <span class="math">0x02 \\equiv \\alpha</span>  and  <span class="math">0x03 \\equiv \\alpha + 1</span> .</p>

    <p class="text-gray-300"><strong>Definition 6.</strong> Given  <span class="math">I \\subseteq \\{0, 1, 2, 3\\}</span>  where  <span class="math">0 &lt; |I| \\le 3</span> , we define:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{C}_I = \\bigoplus_{i \\in I} \\mathcal{C}_i, \\qquad \\mathcal{D}_I = \\bigoplus_{i \\in I} \\mathcal{D}_i, \\qquad \\mathcal{I}\\mathcal{D}_I = \\bigoplus_{i \\in I} \\mathcal{I}\\mathcal{D}_i \\qquad \\mathcal{M}_I = \\bigoplus_{i \\in I} \\mathcal{M}_i.</span>$</p>

    <p class="text-gray-300">The dimension&lt;sup&gt;7&lt;/sup&gt; of any of the spaces  <span class="math">\\mathcal{D}_I, \\mathcal{I}\\mathcal{D}_I, \\mathcal{C}_I</span>  and  <span class="math">\\mathcal{M}_I</span>  is  <span class="math">4 \\cdot |I|</span> . The essential subspaces in AES are built from diagonal spaces  <span class="math">\\mathcal{D}_i</span> , inverse-diagonal spaces  <span class="math">\\mathcal{I}\\mathcal{D}_i</span> , column spaces  <span class="math">\\mathcal{C}_j</span>  and mixed spaces  <span class="math">\\mathcal{M}_k</span> . There are four of each of these spaces, and direct sums of them result in higher-dimensional diagonal, inverse-diagonal, column and mixed spaces.</p>

    <p class="text-gray-300">It is easy to see that SubBytes maps cosets of diagonal and column spaces to cosets of diagonal and column spaces. Since SubBytes operates on each byte individually and it is bijective, and since the bytes of column and diagonal spaces are independent, its only effect is to change the coset. It is also easy to see that ShiftRows maps a coset of a diagonal space to a coset of a column space, since diagonals are mapped to columns, and it maps a coset of a column space to a coset of an inverse-diagonal space. The effect of MixColumns to a columns space  <span class="math">\\mathcal{C}_I \\oplus a</span>  is simply to change the coset, since applying the MixColumns matrix to a column space  <span class="math">\\mathcal{C}_i</span>  has no effect.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-14-0&quot;&gt;&lt;/span&gt; <span class="math">&lt;sup&gt;^7&lt;/sup&gt;</span> Since we are working over the field  <span class="math">\\mathbb{F}_{2^8}</span> , we consider the dimension of the subspace as the number of active and independent bytes. This implies for example that the dimension of the subspaces is constant through SubBytes and MixColumns operations. See App. A for more details about the dimension of a subspace.</p>

    <p class="text-gray-300">    <img src="_page_15_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 3: The essential subspaces in the AES round.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-1&quot;&gt;&lt;/span&gt;<strong>Lemma 1.</strong> Let  <span class="math">I \\subseteq \\{0, 1, 2, 3\\}</span>  where  <span class="math">0 &lt; |I| \\le 3</span>  and  <span class="math">a \\in \\mathcal{D}_I^{\\perp}</span> . There exists unique  <span class="math">b \\in \\mathcal{C}_I^{\\perp}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$R_K(\\mathcal{D}_I \\oplus a) = \\mathcal{C}_I \\oplus b.</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> As we have just seen, since SubBytes is bijective and operates on each byte independently, it simply changes the coset  <span class="math">\\mathcal{D}_I \\oplus a</span>  to  <span class="math">\\mathcal{D}_I \\oplus a&#x27;</span> , where  <span class="math">a&#x27;_{i,j} = \\text{S-Box}(a_{i,j})</span>  for each i, j = 0, ..., 3. ShiftRows simply moves the bytes of  <span class="math">\\mathcal{D}_I \\oplus a&#x27;</span>  to a column space  <span class="math">\\mathcal{C}_I \\oplus b&#x27;</span> , where b' = SR(a'). MixColumns affects only the constant columns, thus  <span class="math">MC(\\mathcal{C}_I \\oplus b&#x27;) = \\mathcal{C}_I \\oplus MC(b&#x27;) = \\mathcal{C}_I \\oplus b&#x27;&#x27;</span> . Key addition then changes the coset to  <span class="math">\\mathcal{C}_I \\oplus b</span> .</p>

    <p class="text-gray-300">This simply states that a coset of a sum of diagonal spaces  <span class="math">\\mathcal{D}_I</span>  encrypt to a coset of a corresponding sum of column spaces  <span class="math">\\mathcal{C}_I</span>  through one round. We recall that two different cosets  <span class="math">V \\oplus a</span>  and  <span class="math">V \\oplus b</span>  (i.e.  <span class="math">a \\neq b</span> ) of the same generic subspace V are equivalent (i.e.  <span class="math">V \\oplus a \\sim V \\oplus b</span> ) if and only if  <span class="math">a \\oplus b \\in V</span> . Thus, in the previous lemma (similarly in the following), b is unique with respect to this equivalence relationship.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-2&quot;&gt;&lt;/span&gt;<strong>Lemma 2.</strong> Let  <span class="math">I \\subseteq \\{0, 1, 2, 3\\}</span>  where  <span class="math">0 &lt; |I| \\le 3</span>  and  <span class="math">a \\in C_I^{\\perp}</span> . There exists unique  <span class="math">b \\in \\mathcal{M}_I^{\\perp}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$R_K(\\mathcal{C}_I \\oplus a) = \\mathcal{M}_I \\oplus b.</span>$</p>

    <p class="text-gray-300">Proof. By definition 5, the mixed spaces  <span class="math">\\mathcal{M}_I</span>  are defined as the application of the Mix-Columns operation to inverse-diagonal space  <span class="math">\\mathcal{ID}_I</span> . Since a ShiftRows operation maps a column space to an inverse-diagonal space, a mixed space  <span class="math">\\mathcal{M}_I</span>  is equivalently defined as the application of the linear layer in AES to column spaces  <span class="math">\\mathcal{C}_I</span> . Since the SubBytes layer only moves a coset  <span class="math">\\mathcal{C}_I \\oplus a</span>  to a coset  <span class="math">\\mathcal{C}_I \\oplus a&#x27;</span> , it follows that for any fixed coset  <span class="math">\\mathcal{C}_I \\oplus a</span> , there exists  <span class="math">b \\in \\mathcal{M}_I^{\\perp}</span>  such that  <span class="math">MC \\circ SR \\circ S\\text{-Box}(\\mathcal{C}_I \\oplus a) \\oplus K = \\mathcal{M}_I \\oplus b</span> , where  <span class="math">b = MC \\circ SR(a&#x27;) \\oplus K</span>  and  <span class="math">a&#x27;_{i,j} = S\\text{-Box}(a_{i,j})</span>  for each i, j = 0, ..., 3.</p>

    <p class="text-gray-300">Similarly to before, this simply states that a coset of a sum of column spaces  <span class="math">C_I</span>  encrypts to a coset of the corresponding sum of mixed spaces  <span class="math">\\mathcal{M}_I</span>  over one round.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-15-0&quot;&gt;&lt;/span&gt;3.3 Intersecting AES Subspaces</h4>

    <p class="text-gray-300">We continue with useful properties of AES subspaces. In this section we show the following: diagonal spaces and column spaces have non-trivial intersection, column spaces and mixed spaces have non-trivial intersection, but diagonal spaces and mixed spaces have only trivial intersection. This will be useful for creating subspace trails covering a higher number of rounds. For the following, let  <span class="math">I, J \\subseteq \\{0,1,2,3\\}</span>  and we assume that all the indexes are taken modulo 4. All the proofs are given in App. B.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-3&quot;&gt;&lt;/span&gt;<strong>Lemma 3.</strong>
<span class="math">$\\mathcal{D}_i \\cap \\mathcal{C}_j = \\langle e_{i+j,j} \\rangle</span>$
and  <span class="math">\\mathcal{ID}_i \\cap \\mathcal{C}_j = \\langle e_{i-j,j} \\rangle</span> .</p>

    <p class="text-gray-300">It follows that  <span class="math">\\mathcal{D}_I \\cap \\mathcal{C}_J = \\langle e_{j+i,j} | i \\in I, j \\in J \\rangle</span>  and  <span class="math">\\mathcal{I}\\mathcal{D}_I \\cap \\mathcal{C}_J = \\langle e_{i-j,j} | i \\in I, j \\in J \\rangle</span>  (j+i and i-j are taken modulo 4), where the intersections have dimension  <span class="math">|I| \\cdot |J|</span> .</p>

    <p class="text-gray-300">Lemma 4.  <span class="math">C_i \\cap \\mathcal{M}_j = \\langle MC(e_{i+i.i}) \\rangle</span> .</p>

    <p class="text-gray-300">It follows that  <span class="math">C_I \\cap \\mathcal{M}_J = \\langle MC(e_{j+i,i}) | i \\in I, j \\in J \\rangle</span>  (i+j) is taken modulo 4), which has dimension  <span class="math">|I| \\cdot |J|</span> .</p>

    <p class="text-gray-300">While the spaces  <span class="math">\\mathcal{D}_I</span>  and  <span class="math">\\mathcal{C}_J</span> ,  <span class="math">\\mathcal{I}\\mathcal{D}_I</span>  and  <span class="math">\\mathcal{C}_J</span> , and  <span class="math">\\mathcal{C}_I</span>  and  <span class="math">\\mathcal{M}_J</span>  intersect non-trivially, the spaces  <span class="math">\\mathcal{D}_I</span>  and  <span class="math">\\mathcal{M}_J</span>  and the spaces  <span class="math">\\mathcal{I}\\mathcal{D}_I</span>  and  <span class="math">\\mathcal{M}_J</span>  intersect trivially. In particular:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-16-2&quot;&gt;&lt;/span&gt;<strong>Lemma 5.</strong>  <span class="math">\\mathcal{D}_I \\cap \\mathcal{M}_J = \\mathcal{I}\\mathcal{D}_I \\cap \\mathcal{M}_J = \\{0\\}</span>  for all I and J such that  <span class="math">|I| + |J| \\leq 4</span> .</p>

    <p class="text-gray-300">In this section we describe a series of subspace trails for AES. Additionally we also describe how these trails can be used to formulate ways to detect non-randomness, often colloquially referred to a distinguishers. All distinguishers in this section, ranging from two up to four rounds, are independent of the round keys and are formulated without the knowledge of the key. From now on, we assume that any subspaces  <span class="math">\\mathcal{D}_I</span> ,  <span class="math">\\mathcal{C}_I</span>  or  <span class="math">\\mathcal{M}_I</span>  has nonzero dimension (that is,  <span class="math">I \\subseteq \\{0,1,2,3\\}</span>  is not empty). Moreover, when we intersect two subspaces  <span class="math">\\mathcal{D}_I</span>  and  <span class="math">\\mathcal{M}_J</span> , where both I and J are assumed non-empty, we always assume that the sum of their dimensions is not larger than 16. Typically, the sum of their dimensions will be exactly 16.</p>

    <h2 id="sec-18" class="text-2xl font-bold">&lt;span id=&quot;page-16-1&quot;&gt;&lt;/span&gt;4.1 2-Round Subspace Trail for AES</h2>

    <p class="text-gray-300">It follows directly from Section 3.2 that plaintexts from diagonal spaces are encrypted over two rounds to ciphertexts in mixed subspaces. Let  <span class="math">R^{(2)}</span>  denote two AES rounds with fixed random round keys  <span class="math">K = K_1, K_2</span> . Let  <span class="math">I \\subseteq \\{1, 2, 3, 4\\}</span>  nonzero and fixed. By Lemma 1, a coset  <span class="math">\\mathcal{D}_I \\oplus a</span>  of dimension  <span class="math">4 \\cdot |I|</span>  encrypts to a coset  <span class="math">R_{K_1}(\\mathcal{D}_I \\oplus a) = \\mathcal{C}_I \\oplus a&#x27;</span>  over one round. By Lemma 2, there exists unique b (relative to the round keys and the constant a') such that  <span class="math">R_{K_2}(\\mathcal{C}_I \\oplus a&#x27;) = \\mathcal{M}_I \\oplus b</span> . By combining the two rounds, we get that for each  <span class="math">a \\in \\mathcal{D}_I^{\\perp}</span> , there exists unique  <span class="math">b \\in \\mathcal{M}_I^{\\perp}</span>  such that  <span class="math">R^{(2)}(\\mathcal{D}_I \\oplus a) = \\mathcal{M}_I \\oplus b</span> .</p>

    <p class="text-gray-300">Consequently, we get the following properties. If two plaintexts belong to the same coset of a diagonal space  <span class="math">\\mathcal{D}_I</span> , then their encryption belongs to the same coset of a mixed space  <span class="math">\\mathcal{M}_I</span> . In particular, for a two round encryption  <span class="math">R^2</span>  with fixed keys, we have that</p>

    <p class="text-gray-300">&lt;span id=&quot;page-16-4&quot;&gt;&lt;/span&gt;
<span class="math">$Pr(R^{(2)}(u) \\oplus R^{(2)}(v) \\in \\mathcal{M}_I \\mid u \\oplus v \\in \\mathcal{D}_I) = 1</span>$
(1)</p>

    <p class="text-gray-300">for nonzero set I of  <span class="math">\\{0, 1, 2, 3\\}</span>  (i.e.  <span class="math">|I| \\neq 0</span> ). The opposite follows directly: if two plaintexts belong to different cosets of a diagonal space  <span class="math">\\mathcal{D}_I</span> , then their encryption belongs to different cosets of a mixed space  <span class="math">\\mathcal{M}_I</span> . In other words</p>

    <p class="text-gray-300"><span class="math">$Pr(R^{(2)}(u) \\oplus R^{(2)}(v) \\in \\mathcal{M}_I \\mid u \\oplus v \\notin \\mathcal{D}_I) = 0.</span>$</p>

    <p class="text-gray-300">These properties are used to set up the distinguisher for two rounds. However, other interesting properties hold when one considers two rounds of encryption. In particular, by Lemma 5, the intersection between a mixed space  <span class="math">\\mathcal{M}_I</span>  space and a diagonal space  <span class="math">\\mathcal{D}_J</span>  space contains only zero, if |I| + |J| is less than 4. Thus, if two plaintexts are in the same coset of  <span class="math">\\mathcal{M}_I</span> , they must belong to different cosets of  <span class="math">\\mathcal{D}_J</span> . In other words, for  <span class="math">\\mathcal{D}_I</span>  and  <span class="math">\\mathcal{D}_J</span>  such that  <span class="math">\\dim(\\mathcal{D}_I) + \\dim(\\mathcal{D}_J) \\leq 16</span>  (and  <span class="math">|I|, |J| \\neq 0</span> )</p>

    <p class="text-gray-300">&lt;span id=&quot;page-16-3&quot;&gt;&lt;/span&gt;
<span class="math">$Pr(R^{(2)}(u) \\oplus R^{(2)}(v) \\in \\mathcal{D}_J \\mid u \\oplus v \\in \\mathcal{D}_I) = 0</span>$
(2)</p>

    <p class="text-gray-300">    <img src="_page_17_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 4: Subspaces over 2 rounds of AES.</p>

    <pre><code class="language-text">Data: Pair of texts c^1 and c^2.
Result: i such that c^1 \\oplus c^2 \\in \\mathcal{M}_i, -1 otherwise.
c \\leftarrow MC^{-1}(c^1 \\oplus c^2);
for i from \\theta to 3 do
    if c_{(i+1)\\%4,0} = 0 AND c_{(i+2)\\%4,0} = 0 AND c_{(i+3)\\%4,0} = 0
     AND \\ c_{i,1} = 0 \\ AND \\ c_{(i+1)\\%4,1} = 0 \\ AND \\ c_{(i+2)\\%4,1} = 0
     AND \\ c_{i,2} = 0 \\ AND \\ c_{(i+1)\\%4,2} = 0 \\ AND \\ c_{(i+3)\\%4,2} = 0
     AND \\ c_{i,3} = 0 \\ AND \\ c_{(i+2)\\%4,3} = 0 \\ AND \\ c_{(i+3)\\%4,3} = 0 \\ \\mathbf{then}
     return i;
    end
end
return -1.
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-17-1&quot;&gt;&lt;/span&gt;<strong>Algorithm 1:</strong> Pseudo-code for distinguisher of 2 rounds of AES.</p>

    <p class="text-gray-300">where  <span class="math">u \\neq v</span> , since  <span class="math">R^{(2)}(u)</span>  and  <span class="math">R^{(2)}(v)</span>  are both in the same coset of  <span class="math">\\mathcal{M}_I</span>  and thus are always in different cosets of  <span class="math">\\mathcal{D}_{I}</span> . We can get similar results for the mixed spaces  <span class="math">\\mathcal{M}_{I}</span> . In particular, if two plaintexts belong to the same coset of a mixed space  <span class="math">\\mathcal{M}_I</span> , then their two round encryptions belong to different cosets of any mixed space  <span class="math">\\mathcal{M}_I</span> . Indeed, two (different) elements of  <span class="math">\\mathcal{M}_I</span>  belong to different cosets of  <span class="math">\\mathcal{D}_J</span>  (since  <span class="math">\\mathcal{M}_I \\cap \\mathcal{D}_J = \\{0\\}</span> ). Since  <span class="math">R^{(2)}(u) \\oplus R^{(2)}(v) \\in \\mathcal{M}_J</span>  if and only if  <span class="math">u \\oplus v \\in \\mathcal{D}_J</span> , we obtain the desired result. Thus, for  <span class="math">\\mathcal{M}_I</span>  and  <span class="math">\\mathcal{M}_J</span>  such that  <span class="math">0 &lt; \\dim(\\mathcal{M}_I) + \\dim(\\mathcal{M}_J) \\le 16</span> , we have that</p>

    <p class="text-gray-300">&lt;span id=&quot;page-17-0&quot;&gt;&lt;/span&gt;
<span class="math">$Pr(R^{(2)}(u) \\oplus R^{(2)}(v) \\in \\mathcal{M}_J \\mid u \\oplus v \\in \\mathcal{M}_I) = 0</span>$
(3)</p>

    <p class="text-gray-300">if  <span class="math">u \\neq v</span> . We'll use these probabilities to set up an efficient 4 rounds distinguisher.</p>

    <p class="text-gray-300">A Concrete Distinguisher for 2 Rounds. As we have seen, if two plaintexts belong to the same coset of  <span class="math">\\mathcal{D}_I</span> , then they belong to the same coset of  <span class="math">\\mathcal{M}_I</span>  with probability 1 after two rounds - for each I. Consider instead two random texts. By simple computation, the probability that there exists I such that they belong to the same cosets of  <span class="math">\\mathcal{M}_I</span>  is  <span class="math">\\binom{4}{|I|} \\cdot (2^8)^{-16+4\\cdot |I|}</span>  (note that there are  <span class="math">\\binom{4}{|I|}</span>  different subspaces  <span class="math">\\mathcal{M}_I</span> ). Setting |I| = 1, this probability is equal to  <span class="math">2^{-94}</span> .</p>

    <p class="text-gray-300">Thus, one pair of plaintexts (that is two texts) is sufficient to distinguish the random case from the other one. Indeed, on average in the random case we expect  <span class="math">2^{-94} \\cdot 2 = 2^{-93} \\simeq 0</span> collisions (a &quot;collision&quot; occurs when two elements belong to the same coset of  <span class="math">\\mathcal{M}_I</span> ), while this number is always equal to 1 in the other case. The cost of this distinguisher is hence two texts. An equivalent distinguisher over 2 rounds was already introduced in [DR06b], where authors investigated how the components of the AES interact over 2 rounds.</p>

    <p class="text-gray-300">Finally, note that a similar distinguisher can be used for the 1 round case. Indeed, note that if two plaintexts belong to the same coset of  <span class="math">\\mathcal{D}_I</span>  (equivalently  <span class="math">\\mathcal{C}_I</span> ), then they belong to the same coset of  <span class="math">\\mathcal{C}_I</span>  (equivalently  <span class="math">\\mathcal{M}_I</span> ) with probability 1 for each I after 1 round. Moreover, observe that it also is possible to set up a 2 rounds distinguisher using the impossible differential properties defined in (2) or (3).</p>

    <h2 id="sec-19" class="text-2xl font-bold">&lt;span id=&quot;page-18-0&quot;&gt;&lt;/span&gt;4.2 Truncated Differential Key-Recovery Attacks for 3- and 4-round of AES</h2>

    <p class="text-gray-300">Before to go on, we highlight that in App. E we present new key-recovery attacks for 3-and 4-round of AES that exploit the 2-round subspace trail of AES just presented.</p>

    <p class="text-gray-300">For 3 rounds, the idea is simply to exploit the fact that two elements in the same coset of a diagonal space  <span class="math">\\mathcal{D}_I</span>  belong to the same coset of a mixed space  <span class="math">\\mathcal{M}_I</span>  after 2 rounds - see Prob. (1). Thus, given two plaintexts  <span class="math">p^1</span>  and  <span class="math">p^2</span>  in the same coset of  <span class="math">\\mathcal{D}_I</span>  (that is  <span class="math">p^1 \\oplus p^2 \\in \\mathcal{D}_I</span> ) and the corresponding ciphertexts  <span class="math">c^1</span>  and  <span class="math">c^2</span>  after 3 rounds, the final key k must satisfy the following relationship:</p>

    <p class="text-gray-300"><span class="math">$R_k^{-1}(c^1) \\oplus R_k^{-1}(c^2) \\in \\mathcal{M}_I</span>$</p>

    <p class="text-gray-300">In order to find the secret key and to minimize the data and the computational costs, these attacks exploit the shape of the mixed space  <span class="math">\\mathcal{M}_I</span> , that is the facts that the columns of a coset of a mixed space  <span class="math">\\mathcal{M}_I</span>  depend on different and independent variables and the relationships that hold among the bytes of the same column of  <span class="math">\\mathcal{M}_I</span> . The attacks on 4 rounds are obtained extending at the end or at the beginning this attack on 3 rounds.</p>

    <p class="text-gray-300">As highlight in App. E.3, these attacks are truncated differential in nature, and are competitive with the other low-data complexity attacks present in literature, as the ones proposed in [BDF11] and  <span class="math">[BDD^+12]</span> . We refer to App. E for a detailed analysis.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-18-1&quot;&gt;&lt;/span&gt;4.3 3-Round Subspace Trail for AES</h3>

    <p class="text-gray-300">There are several techniques that can be used to set up a 3-round distinguisher for AES, as for example (1) truncated differential, (2) balance property and (3) impossible differential. In this section, we only describe the truncated differential distinguisher using the subspace trail, which we'll be used to set up the attack on 4-round of AES with secret S-Box. The other two distinguishers based on the balance property and on the impossible differential are presented in details using the subspace trail in the next section. Note that the arguments in next section used for 4 rounds of AES holds also for the 3-round case.</p>

    <p class="text-gray-300">The most competitive distinguisher on 3-round of AES is based on truncated differential trails, and an example of it is depicted in Fig. 5. In the following, we re-interpret it using the subspace trail.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-18-2&quot;&gt;&lt;/span&gt;    <img src="_page_18_Picture_11.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Figure 5:</strong> Truncated differential characteristic over 3-round AES. White box denotes a byte with a zero difference, while black box denotes a byte with a non-zero difference.</p>

    <p class="text-gray-300">Consider a coset of  <span class="math">\\mathcal{D}_I</span>  as starting point. After two rounds, this coset is mapped into a coset of  <span class="math">\\mathcal{M}_I</span>  with probability 1. Indeed, as we have seen in Lemma 1, a coset of  <span class="math">\\mathcal{D}_I</span>  is mapped into a coset of  <span class="math">\\mathcal{C}_I</span>  with probability 1 after one round, and, as we have seen in Lemma 2, a coset of  <span class="math">\\mathcal{C}_I</span>  is mapped into a coset of  <span class="math">\\mathcal{M}_I</span>  with probability 1 after one round. Thus, if we consider two elements that belong to the same cosets of  <span class="math">\\mathcal{D}_I</span> , after two rounds they belong in the same coset of  <span class="math">\\mathcal{M}_I</span>  for sure. However, at the same time and with a certain probability, it is possible that these two elements belong to the same coset of  <span class="math">\\mathcal{C}_J \\cap \\mathcal{M}_I \\subseteq \\mathcal{C}_J</span>  for a certain J after two rounds. In particular, the following proposition holds:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-18-3&quot;&gt;&lt;/span&gt;<strong>Proposition 1.</strong> For any  <span class="math">\\mathcal{M}_I</span>  and  <span class="math">\\mathcal{C}_J</span> , we have that  <span class="math">Pr(x \\in \\mathcal{C}_J \\mid x \\in \\mathcal{M}_I) = (2^8)^{-4|I|+|I|\\cdot|J|}</span> .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-19-0&quot;&gt;&lt;/span&gt;    <img src="_page_19_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Figure 6:</strong> 3-round distinguishers for AES (the index n is defined as  <span class="math">n := (2^8)^{4 \\cdot |I| - |I| \\cdot |J|}</span> ).</p>

    <p class="text-gray-300">The proof can be found in App. B. That is, if two elements belong to the same coset of  <span class="math">\\mathcal{M}_I</span> , then they belong to the same coset of  <span class="math">\\mathcal{C}_J</span>  with probability  <span class="math">(2^8)^{-4|I|+|I|\\cdot|J|}</span> . More precisely, given two texts in the same coset of  <span class="math">\\mathcal{D}_I</span> , after two rounds they belong to the same coset of  <span class="math">\\mathcal{M}_I \\cap \\mathcal{C}_J</span>  with probability  <span class="math">(2^8)^{-4|I|+|I|\\cdot|J|}</span>  (where  <span class="math">\\mathcal{M}_I \\cap \\mathcal{C}_J \\subseteq \\mathcal{C}_J</span> ). As we have just seen, a coset of  <span class="math">\\mathcal{C}_J</span>  is mapped into a coset of  <span class="math">\\mathcal{M}_J</span>  after one round. It follows that if two elements belong to the same coset of  <span class="math">\\mathcal{D}_I</span> , the probability that they belong to the same coset of  <span class="math">\\mathcal{M}_J</span>  after three rounds is equal to  <span class="math">(2^8)^{-4|I|+|I|\\cdot|J|}</span> . The case |I|=1 and |J|=3 is depicted in Fig. 5.</p>

    <p class="text-gray-300">For a more detailed explanation using subspace trail, consider the following argument. Given a coset of  <span class="math">\\mathcal{M}_I</span> , it can be seen as a union of coset of  <span class="math">\\mathcal{C}_J</span> , that is:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{M}_I \\oplus a = \\bigcup_{x \\in \\mathcal{M}_I \\oplus a \\setminus \\mathcal{C}_J} \\mathcal{C}_J \\oplus x,</span>$</p>

    <p class="text-gray-300">as depicted in Fig. 6. In particular, note that the number of  <span class="math">x \\in \\mathcal{M}_I \\oplus a \\setminus \\mathcal{C}_J</span>  is exactly  <span class="math">(2^8)^{4\\cdot |I|-|I|\\cdot |J|}</span> . Given two elements in the same coset of  <span class="math">\\mathcal{D}_I</span> , then after two rounds they belong to the same coset of  <span class="math">\\mathcal{M}_I</span> . Since a coset of  <span class="math">\\mathcal{M}_I</span>  can be seen as the union of  <span class="math">(2^8)^{4\\cdot |I|-|I|\\cdot |J|}</span>  cosets of  <span class="math">\\mathcal{C}_J</span> , the probability that these two elements belong to the same coset of  <span class="math">\\mathcal{C}_J</span>  after two rounds is exactly  <span class="math">(2^8)^{-4\\cdot |I|+|I|\\cdot |J|}</span> . Also in this way, one obtains the previous result.</p>

    <p class="text-gray-300">Moreover, note the a similar result can be obtained in the decryption direction. That is, if two elements belong to the same coset of  <span class="math">\\mathcal{M}_I</span> , then they belong to the same coset of  <span class="math">\\mathcal{D}_J</span>  three rounds before with probability  <span class="math">(2^8)^{4\\cdot |I|-|I|\\cdot |J|}</span> . Finally and only for completeness, it is possible to obtain the same result considering the intersection of  <span class="math">\\mathcal{C}_I</span>  and  <span class="math">\\mathcal{D}_J</span>  after one round, instead of the intersection of  <span class="math">\\mathcal{M}_I</span>  and  <span class="math">\\mathcal{C}_J</span>  after two rounds. All the details of this (analogous) case are given in App. C.1.</p>

    <p class="text-gray-300">A Concrete Distinguisher for 3 Rounds. In order to set up the distinguisher, we exploit the difference of probability to have a collision in the ciphertexts set between the case in which two plaintexts are taken in a random way and the case in which two plaintexts belong to the same coset of  <span class="math">\\mathcal{D}_I</span> .</p>

    <p class="text-gray-300">The probabilities that two elements drawn randomly from  <span class="math">\\mathbb{F}_{2^8}^{4\\times 4}</span>  (denoted by  <span class="math">p_1</span> ) and that two plaintexts drawn from a coset of  <span class="math">\\mathcal{D}_I</span>  (denoted by  <span class="math">p_2</span> ) belong to the same coset of  <span class="math">\\mathcal{M}_J</span>  are respectively:</p>

    <p class="text-gray-300"><span class="math">$p_1 = \\begin{pmatrix} 4 \\\\ |J| \\end{pmatrix} \\cdot (2^8)^{-16+4|J|}, \\qquad p_2 = \\begin{pmatrix} 4 \\\\ |J| \\end{pmatrix} \\cdot (2^8)^{-4|I|+|I||J|}.</span>$</p>

    <p class="text-gray-300">It is very easy to observe that the probability to have a collision in the second case is higher than in the random case. In particular, for |J| = 3 and |I| = 1, we obtain that</p>

    <pre><code class="language-text">Data: 20 texts c
                 i
                   (for i = 1, ..., 20).
Result: number of collisions.
n ← 0;
for each pair (c
                i
                 , cj
                    ) with i 6= j do
   c ← MC−1
               (c
                 i ⊕ c
                      j
                       );
   for k from 0 to 3 do
       if ck,0 = 0 AND c(3+k)%4,1 = 0 AND c(2+k)%4,2 = 0 AND c(1+k)%4,3 = 0
        then
           n ← n + 1;
           next pair
       end
   end
end
</code></pre>

    <p class="text-gray-300"><strong>return</strong> <em>n</em>. <strong>Algorithm 2:</strong> <em>Distinguisher for 3-round of AES - Pseudo-code</em>.</p>

    <p class="text-gray-300"><em>p</em>&lt;sup&gt;2&lt;/sup&gt; = 2&lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;6&lt;/sup&gt; while <em>p</em>&lt;sup&gt;1&lt;/sup&gt; = 2&lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;30&lt;/sup&gt;. Thus, the idea is to look for the minimum number of texts <em>m</em> in order to guarantee at least one collision in the &quot;subspace case&quot; and zero in the random case (with high probability).</p>

    <p class="text-gray-300">To do this, we recall the <em>birthday paradox</em>. Given <em>d</em> (equally likely) values and <em>n</em> variables, the probability that at least two of them have the same value is given by:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-20-1&quot;&gt;&lt;/span&gt;
<span class="math">$p = 1 - \\frac{n!}{(n-d)! \\cdot n^d} = 1 - \\frac{(d)!}{n^d} \\cdot \\binom{n}{d} \\simeq 1 - e^{\\frac{-d(d-1)}{2n}},\\tag{4}</span>$</p>

    <p class="text-gray-300">where the last one is an useful approximation.</p>

    <p class="text-gray-300">Since if we encrypt two plaintexts from a coset of D<em>&lt;sup&gt;I&lt;/sup&gt;</em> , each of them can only belong to one of the 2 8 cosets of M<em>&lt;sup&gt;J&lt;/sup&gt;</em> defined as before, the probability that there is at least one collision in a coset is equal to the probability that two elements belong to the same cosets of M<em>&lt;sup&gt;J&lt;/sup&gt;</em> , that is <em>p</em> = 1 − <em>e</em> −<em>m</em>(<em>m</em>−1)<em>/</em>(2·2 8 . However, this property holds if we choose any of the four 12-dimensional space M<em>&lt;sup&gt;J&lt;/sup&gt;</em> as a target distinguisher space, each yielding an independent experiment. Since this experiments are independent, we have that the probability to have at least one collision in the subspace case given <em>m</em> texts is:</p>

    <p class="text-gray-300"><span class="math">$p = 1 - \\left(\\frac{2^8!}{(2^8 - m)! \\cdot (2^8)^d}\\right)^4 \\simeq 1 - \\left(e^{\\frac{-m(m-1)}{2 \\cdot 2^8}}\\right)^4 = 1 - e^{\\frac{-m(m-1)}{2 \\cdot 2^6}}.</span>$</p>

    <p class="text-gray-300">Thus, if we set <em>m</em> = 20, the probability to have at least one collision in one of the four different M<em>&lt;sup&gt;J&lt;/sup&gt;</em> spaces (with |<em>J</em>| = 1) is 95<em>.</em>25% (14 texts are sufficient to have at least one collision with probability greater than 75%). In order to distinguish the two sets (that is, the random one and the &quot;subspace&quot; one), the verifier has to construct all the possible pairs of texts and to count the number of collisions, for each of them. In particular, given 20 texts (that is, 190 different pairs), we expect 190 · 2 −6 ' 3 collisions in the subspace case and 190 · 2 &lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;30&lt;/sup&gt; = 2&lt;sup&gt;−&lt;/sup&gt;22<em>.</em>&lt;sup&gt;4&lt;/sup&gt; ' 0 in the random case. Finally, observe that the distinguisher works in similar way in the decryption direction, with the same complexity.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-20-0&quot;&gt;&lt;/span&gt;<strong>4.4 4-Round Subspace Trail for AES</strong></h4>

    <p class="text-gray-300">As for 3-round of AES, there are several techniques that can be used to set up a 4-round distinguisher for AES, as (1) impossible differential and (2) balance property. In the following, we present the 4-round impossible differential distinguisher in details, while the description of the distinguisher based on the balance property is provided in App. <a href="#page-41-0">C.2.</a> In both cases, the same analysis holds also for 3-round of AES.</p>

    <p class="text-gray-300">    <img src="_page_21_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Figure 7:</strong> 4-round distinguishers for AES (where the index <em>n</em> is defined as <em>n</em> := (2&lt;sup&gt;8&lt;/sup&gt; ) 4|<em>I</em>| and the indexes <em>I</em> and <em>J</em> satisfy the condition 0 <em>&lt;</em> |<em>I</em>| + |<em>J</em>| ≤ 4).</p>

    <p class="text-gray-300">From now on, we assume that <em>I</em> and <em>J</em> satisfy the condition 0 <em>&lt;</em> |<em>I</em>| + |<em>J</em>| ≤ 4 (in order to use Lemma <a href="#page-16-2">5)</a>. To set up the 4-round impossible differential distinguisher, we start from the 2-round differential ones. Fix D<em>&lt;sup&gt;I&lt;/sup&gt;</em> and D<em>&lt;sup&gt;J&lt;/sup&gt;</em> such that 0 <em>&lt;</em> dim(D<em>&lt;sup&gt;I&lt;/sup&gt;</em> ) + dim(D<em>&lt;sup&gt;J&lt;/sup&gt;</em> ) ≤ 16. We can construct a four round trail by simply combining two-round subspaces properties. Indeed, we have seen that</p>

    <p class="text-gray-300"><span class="math">$Pr(R^{(2)}(u) \\oplus R^{(2)}(v) \\in \\mathcal{M}_I \\mid u \\oplus v \\in \\mathcal{D}_I) = 1, Pr(R^{(2)}(u) \\oplus R^{(2)}(v) \\in \\mathcal{M}_J \\mid u \\oplus v \\in \\mathcal{M}_I) = 0</span>$</p>

    <p class="text-gray-300">if <em>u</em> 6= <em>v</em>. Combining these two probabilities for 2-round yields a 4-round probability</p>

    <p class="text-gray-300">&lt;span id=&quot;page-21-0&quot;&gt;&lt;/span&gt;
<span class="math">$Pr(R^{(4)}(u) \\oplus R^{(4)}(v) \\in \\mathcal{M}_J \\mid u \\oplus v \\in \\mathcal{D}_I) = 0</span>$
(5)</p>

    <p class="text-gray-300">where <em>u</em> 6= <em>v</em>. This means that the adversary can pick any coset of a non-zero plaintext space D<em>&lt;sup&gt;I&lt;/sup&gt;</em> and a non-zero ciphertext space M<em>&lt;sup&gt;J&lt;/sup&gt;</em> , as long as 0 <em>&lt;</em> dim(D<em>&lt;sup&gt;I&lt;/sup&gt;</em> ) + dim(M<em>&lt;sup&gt;J&lt;/sup&gt;</em> ) ≤ 16, and distinguish on the fact that the probability that two plaintexts encrypt to the same coset of the ciphertext space is zero over four rounds.</p>

    <p class="text-gray-300"><strong>A Concrete Distinguisher for 4 Rounds.</strong> The idea is pick parameters that maximize probability in the random case. The best minimal data complexity is found if we choose |<em>J</em>| = 3. This implies that |<em>I</em>| = 1, since we have the condition that |<em>I</em>| + |<em>J</em>| ≤ 4. In this case, the probability that two random elements belong to the same coset of M<em>&lt;sup&gt;J&lt;/sup&gt;</em> for a certain <em>J</em> with |<em>J</em>| = 3 is 2 &lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;30&lt;/sup&gt; (as we have already seen). Instead, the probability that two elements, that belong to the same coset of D<em>&lt;sup&gt;I&lt;/sup&gt;</em> , belong to the same coset of M<em>&lt;sup&gt;J&lt;/sup&gt;</em> after four rounds is 0.</p>

    <p class="text-gray-300">Exactly as before, the idea is to look for the minimum number of texts <em>m</em> in order to guarantee at least one collision in the random case with high probability. Since there are four 12-dimensional space M<em>&lt;sup&gt;J&lt;/sup&gt;</em> and using the birthday paradox, the probability to have at least one collision in the random case given <em>m</em> texts is well approximated by <em>p</em> = 1 − <em>e</em> −<em>m</em>(<em>m</em>−1)<em>/</em>(2·2 &lt;sup&gt;30&lt;/sup&gt;) <em>.</em> Thus, <em>m</em> ' 2 &lt;sup&gt;16&lt;/sup&gt;<em>.</em>&lt;sup&gt;25&lt;/sup&gt; texts are sufficient to set up a 4-round distinguisher (in this case, the probability to have a collision in the random case is approximately 95% - note that 2 &lt;sup&gt;15&lt;/sup&gt;<em>.</em>&lt;sup&gt;75&lt;/sup&gt; texts are sufficient to have at least one collision with probability of 75%). Indeed, given 2 &lt;sup&gt;16&lt;/sup&gt;<em>.</em>&lt;sup&gt;25&lt;/sup&gt; texts (that is about 2 &lt;sup&gt;31&lt;/sup&gt;<em>.</em>&lt;sup&gt;5&lt;/sup&gt; pairs), the number of collision in the random case is on average 2 31<em>.</em>5 · 2 &lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;30&lt;/sup&gt; = 2&lt;sup&gt;1&lt;/sup&gt;<em>.</em>&lt;sup&gt;5&lt;/sup&gt; ≈ 3, while the number of collision in the other case is 2 31<em>.</em>5 · 0 = 0. That is, 2 &lt;sup&gt;16&lt;/sup&gt;<em>.</em>&lt;sup&gt;25&lt;/sup&gt; chosen plaintexts are sufficient for this distinguisher.</p>

    <p class="text-gray-300">Note that this distinguisher exploits the Impossible Differential property presented in <a href="#page-33-2">[BK01]</a>. Thus, it is not a surprise that the computational complexity of these two distinguishers is the same. Only for completeness, note that it is possible to set up a</p>

    <pre><code class="language-text">Data: 2
        16.25 texts c
                     i
                      (for i = 1, ..., 2
                                     16.25).
Result: 1 if there is at least one collision, 0 otherwise.
for each pair (c
                i
                 , cj
                    ) with i 6= j do
   c ← MC−1
               (c
                 i ⊕ c
                      j
                       );
   for k from 0 to 3 do
       if ck,0 = 0 AND c(3+k)%4,1 = 0 AND c(2+k)%4,2 = 0 AND c(1+k)%4,3 = 0
        then
           return 1;
       end
   end
end
return 0.
         Algorithm 3: Pseudocode for Distinguisher for 4-round AES.
</code></pre>

    <p class="text-gray-300">0-probability distinguishers also for the 3-round case:</p>

    <p class="text-gray-300"><span class="math">$Pr(R^{(3)}(x) \\oplus R^{(3)}(y) \\in \\mathcal{M}_I \\mid x \\oplus y \\in \\mathcal{C}_J) = Pr(R^{(3)}(x) \\oplus R^{(3)}(y) \\in \\mathcal{C}_I \\mid x \\oplus y \\in \\mathcal{D}_J) = 0</span>$</p>

    <p class="text-gray-300">where 0 <em>&lt;</em> |<em>I</em>| + |<em>J</em>| ≤ 4. Since in the random case, the probability that two elements belong to the same coset of C<em>&lt;sup&gt;I&lt;/sup&gt;</em> or M<em>&lt;sup&gt;I&lt;/sup&gt;</em> is upper bounded by 2 &lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;30&lt;/sup&gt; for each <em>I</em> and <em>J</em>, one needs at least 2 &lt;sup&gt;15&lt;/sup&gt;<em>.</em>&lt;sup&gt;75&lt;/sup&gt; chosen plaintexts to set up this distinguisher. That is, in the case of 3-round AES, the 0-probability distinguisher is worse than the one described in the previous section<a href="#page-22-1">8</a> .</p>

    <p class="text-gray-300">Moreover, note that this 4-round distinguisher (as also the 3-round one) works also in the decryption direction. In this case, using the same argument as before, if we two texts belong to the same coset of M<em>&lt;sup&gt;I&lt;/sup&gt;</em> , then they belong to two different cosets of D<em>&lt;sup&gt;J&lt;/sup&gt;</em> four rounds before for |<em>I</em>| + |<em>J</em>| ≤ 4.</p>

    <p class="text-gray-300">Finally, starting from this 4-round impossible subspace trail, it is possible to re-define the impossible differential attack in a very natural way. We highlight this relationship in App. <a href="#page-42-0">D,</a> giving all the details.</p>

    <h2 id="sec-22" class="text-2xl font-bold">&lt;span id=&quot;page-22-2&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-22-0&quot;&gt;&lt;/span&gt;<strong>5 Key-recovery Attacks on AES with a Secret S-Box</strong></h2>

    <p class="text-gray-300">From now on, we focus on AES with a single secret S-Box, and we show how to exploit subspace trails in order to set up key-recovery attacks. More precisely, assume to consider <em>AES with secret and identical</em> (bijective) <em>S-Box</em>. Here we present a generic strategy related to the presented subspace trail that can be used to recover directly the secret key (that is, without finding any information or equivalent representation of the secret S-Box). In particular, in the following we show how truncated differential, impossible differential, and square attacks can exploit this strategy to attack 3- up to 5-round of AES.</p>

    <p class="text-gray-300">The main idea of our attack on AES with a secret S-Box is the following. As we have seen, a coset of D<em>&lt;sup&gt;i&lt;/sup&gt;</em> is mapped into a coset of C<em>&lt;sup&gt;i&lt;/sup&gt;</em> after one round. Using some particular (but very common) properties of the MixColumns matrix, it is possible to choose a subset of a coset of D<em>&lt;sup&gt;i&lt;/sup&gt;</em> which depends on the secret key, such that it is mapped after one round into a subset of a coset of D<em>&lt;sup&gt;J&lt;/sup&gt;</em> ∩ C<em>&lt;sup&gt;i&lt;/sup&gt;</em> ⊆ D<em>&lt;sup&gt;J&lt;/sup&gt;</em> with probability 1. That is, consider a subset of a coset of D<em>&lt;sup&gt;i&lt;/sup&gt;</em> which depends on the guessed values of some bytes of the secret key. If these guessed values are wrong, then after one round this subset of D<em>&lt;sup&gt;i&lt;/sup&gt;</em> is mapped into a subset of a coset of C<em>&lt;sup&gt;i&lt;/sup&gt;</em> . Instead, if these guessed values are correct, then after one round this subset of D<em>&lt;sup&gt;i&lt;/sup&gt;</em> is mapped into a subset of a coset of D<em>&lt;sup&gt;J&lt;/sup&gt;</em> with probability 1. Note that also when the guessed values are wrong it is possible that the initial subset is mapped into a subset of a</p>

    <p class="text-gray-300">&lt;span id=&quot;page-22-1&quot;&gt;&lt;/span&gt;&lt;sup&gt;8&lt;/sup&gt;Only for completeness, a similar result can also be obtained for the 2-round case, exploiting the probability <em>P r</em>(<em>R</em>(2)(<em>x</em>) ⊕ <em>R</em>(2)(<em>y</em>) ∈ C<em>&lt;sup&gt;I&lt;/sup&gt;</em> | <em>x</em> ⊕ <em>y</em> ∈ C<em>&lt;sup&gt;J&lt;/sup&gt;</em> ) = 0 where 0 <em>&lt;</em> |<em>I</em>| + |<em>J</em>| ≤ 4.</p>

    <p class="text-gray-300">coset of  <span class="math">\\mathcal{D}_J</span>  after one round, but this happens with probability strictly less than 1. Using this property together with other considerations, the attacker can identify the right key.</p>

    <p class="text-gray-300">This attack exploits some particular (but very common) properties of the MixColumns matrix  <span class="math">M_{MC}</span> . However, before to list these properties of  <span class="math">M_{MC}</span>  used for the attack, we define the concepts of (two) consecutive-row bytes and of (two) consecutive-diagonal bytes.</p>

    <p class="text-gray-300"><strong>Definition 7.</strong> Let  <span class="math">t \\in \\mathbb{F}_{2^8}^{4 \\times 4}</span>  a text. Given two different bytes  <span class="math">t_{i,j}</span>  and  <span class="math">t_{l,k}</span>  (where the indexes are taken modulo 4):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>if they lie in the same row, they are &quot;consecutive-row bytes&quot; if i = l, and if j + 1 = k for  <span class="math">j &lt; k \\le 3</span>  or k + 1 = j otherwise;</li>
      <li>if they lie in the same diagonal, they are &quot;consecutive-diagonal bytes&quot; if i + 1 = l for  <span class="math">i &lt; l \\le 3</span>  or l + 1 = i otherwise, and if j + 1 = k for  <span class="math">j &lt; k \\le 3</span>  or k + 1 = j otherwise.</li>
    </ul>

    <p class="text-gray-300">Examples of two consecutive-row bytes are  <span class="math">(t_{0,0}, t_{0,1})</span>  or  <span class="math">(t_{0,0}, t_{0,3})</span> , while examples of two consecutive-diagonal bytes are  <span class="math">(t_{0,0}, t_{1,1})</span>  or  <span class="math">(t_{0,0}, t_{3,3})</span> . Using this definition, the two properties of the MixColumns matrix  <span class="math">M_{MC}</span>  that we are going to use are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>each row of  <span class="math">M_{MC}</span>  has two <em>identical</em> consecutive-row bytes;</li>
      <li>each row of  <span class="math">M_{MC}</span>  has these two identical consecutive-row bytes in different positions, that is two different rows can not have the two identical consecutive-row bytes in the same columns.</li>
    </ul>

    <p class="text-gray-300">Note that a cyclic matrix&lt;sup&gt;9&lt;/sup&gt; with two identical elements for each row satisfies these conditions. Moreover, these conditions can be a little generalized, since for example it is not necessary that the two identical byte are consecutive.</p>

    <p class="text-gray-300">Using this properties of  <span class="math">M_{MC}</span> , our attack is based on the following proposition.</p>

    <p class="text-gray-300"><strong>Proposition 2.</strong> Let  <span class="math">p^1</span>  and  <span class="math">p^2</span>  two texts such that  <span class="math">p_{i,j}^1 = p_{i,j}^2</span>  for each  <span class="math">(i,j) \\neq \\{(0,0), (1,1)\\}</span>  and  <span class="math">p_{0,0}^1 \\oplus p_{1,1}^1 = p_{0,0}^2 \\oplus p_{1,1}^2</span> . If  <span class="math">p_{0,0}^1 \\oplus p_{1,1}^1 = p_{0,0}^2 \\oplus p_{1,1}^2 = k_{0,0} \\oplus k_{1,1}</span>  (where k is the secret key of the first round), then after one round they belong to the same coset of  <span class="math">\\mathcal{C}_0 \\cap \\mathcal{D}_{0,1,3} \\subseteq \\mathcal{D}_{0,1,3}</span> , that is  <span class="math">R(p^1) \\oplus R(p^2) \\in \\mathcal{C}_0 \\cap \\mathcal{D}_{0,1,3} \\subseteq \\mathcal{D}_{0,1,3}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> First of all, note that these two texts  <span class="math">p^1</span>  and  <span class="math">p^2</span>  belong in the same coset of  <span class="math">\\mathcal{D}_0 \\cap \\mathcal{C}_{0,1} \\subseteq \\mathcal{D}_0</span>  (by definition of  <span class="math">\\mathcal{D}_0</span> ). As we have already seen, if two elements belong to the same coset of  <span class="math">\\mathcal{D}_0</span> , then after one round they belong to the same coset of  <span class="math">\\mathcal{C}_0</span> . Thus, it is sufficient to prove that  <span class="math">R(p^1) \\oplus R(p^2) \\in \\mathcal{D}_{0,1,3}</span> .</p>

    <p class="text-gray-300">Since  <span class="math">R(p^1) \\oplus R(p^2) \\in \\mathcal{C}_0</span> , in order to prove that  <span class="math">R(p^1) \\oplus R(p^2) \\in \\mathcal{D}_{0,1,3}</span>  it is sufficient to prove that  <span class="math">R(p^1)_{2,0} \\oplus R(p^2)_{2,0} = 0</span> . By simple computation:</p>

    <p class="text-gray-300"><span class="math">$R(p^{1})_{2,0} = \\text{S-Box}(p_{0,0}^{1} \\oplus k_{0,0}^{0}) \\oplus \\text{S-Box}(p_{1,1}^{1} \\oplus k_{1,1}^{0}) \\oplus \\oplus \\alpha \\cdot \\text{S-Box}(p_{2,2}^{1} \\oplus k_{2,2}) \\oplus (\\alpha + 1) \\cdot \\text{S-Box}(p_{3,3}^{1} \\oplus k_{3,3}).</span>$</p>

    <p class="text-gray-300">First of all observe that S-Box <span class="math">(p_{0,0}^1 \\oplus k_{0,0}^0) \\oplus</span>  S-Box <span class="math">(p_{1,1}^1 \\oplus k_{1,1}^0) = 0</span> . Indeed, since  <span class="math">p_{0,0}^1 \\oplus p_{1,1}^1 = k_{0,0} \\oplus k_{1,1}</span>  by definition, then  <span class="math">p_{0,0}^1 \\oplus k_{0,0}^0 = p_{1,1}^1 \\oplus k_{1,1}^0</span> , that is S-Box <span class="math">(p_{0,0}^1 \\oplus k_{0,0}^0) =</span>  S-Box <span class="math">(p_{1,1}^1 \\oplus k_{1,1}^0)</span> , or equivalently S-Box <span class="math">(p_{0,0}^1 \\oplus k_{0,0}^0) \\oplus</span>  S-Box <span class="math">(p_{1,1}^1 \\oplus k_{1,1}^0) = 0</span> . Thus:</p>

    <p class="text-gray-300"><span class="math">$R(p^1)_{2,0} = \\alpha \\cdot \\text{S-Box}(p^1_{2,2} \\oplus k_{2,2}) \\oplus (\\alpha + 1) \\cdot \\text{S-Box}(p^1_{3,3} \\oplus k_{3,3})</span>$</p>

    <p class="text-gray-300"><span class="math">$circ(c_0, c_1, ..., c_{n-1}) = \\begin{bmatrix} c_0 &amp; c_1 &amp; \\dots &amp; c_{n-1} \\\\ c_{n-1} &amp; c_0 &amp; \\dots &amp; c_{n-2} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ c_1 &amp; c_2 &amp; \\dots &amp; c_0 \\end{bmatrix}.</span>$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-23-0&quot;&gt;&lt;/span&gt; <span class="math">&lt;sup&gt;^{9}&lt;/sup&gt;</span> A circulant or cyclic matrix is a matrix where each row vector is rotated one element to the right relative to the preceding row vector, that is:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-24-0&quot;&gt;&lt;/span&gt;    <img src="_page_24_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Figure 8:</strong> Strategy of the attacks on AES with a secret S-Box. Starting with a subset of a coset of  <span class="math">\\mathcal{D}_i</span>  which depends on the guessed values of the secret key, it is mapped after one round into a subset of a coset of  <span class="math">\\mathcal{D}_J</span>  if the guessed values is correct - case (1), or into a subset of a coset of  <span class="math">\\mathcal{C}_i</span>  if the guessed values is wrong - case (2). As a consequence, the subspace trails up to the 5-th round are different for the two cases, and this allows to set up various key-recovery attacks.</p>

    <p class="text-gray-300">and in a similar way:</p>

    <p class="text-gray-300"><span class="math">$R(p^2)_{2,0} = \\alpha \\cdot \\text{S-Box}(p_{2,2}^2 \\oplus k_{2,2}) \\oplus (\\alpha + 1) \\cdot \\text{S-Box}(p_{3,3}^2 \\oplus k_{3,3}).</span>$</p>

    <p class="text-gray-300">Since  <span class="math">p_{2,2}^1 = p_{2,2}^2</span>  and  <span class="math">p_{3,3}^1 = p_{3,3}^2</span>  by definition, it follows that  <span class="math">R(p^1)_{2,0} = R(p^2)_{2,0}</span> , and so the thesis.</p>

    <p class="text-gray-300">Note that no information on the S-Box is used, and, as shown in the following, this fact allows to discover directly the secret key. This proposition can be easily generalized for each possible combination of consecutive-diagonal bytes.</p>

    <p class="text-gray-300"><strong>Proposition 3.</strong> Let  <span class="math">p^1</span>  and  <span class="math">p^2</span>  two texts such that</p>

    <p class="text-gray-300"><span class="math">$p_{i,j}^1 = p_{i,j}^2 \\qquad \\forall (i,j) \\neq \\{(n,m),(k,l)\\}</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$p_{k,l}^1 \\oplus p_{n,m}^1 = p_{k,l}^2 \\oplus p_{n,m}^2,</span>$</p>

    <p class="text-gray-300">where  <span class="math">p_{k,l}</span>  and  <span class="math">p_{n,m}</span>  are two consecutive-diagonal bytes. If  <span class="math">p_{k,l}^1 \\oplus p_{n,m}^1 = p_{k,l}^2 \\oplus p_{n,m}^2 = k_{k,l} \\oplus k_{n,m}</span>  (where k is the secret key of the first round), then after one round they belong to the same coset of  <span class="math">C_{l-k} \\cap \\mathcal{D}_{\\{0,1,2,3\\}\\setminus r} \\subseteq \\mathcal{D}_{\\{0,1,2,3\\}\\setminus r}</span>  (the indexes are taken modulo 4), where r is defined as the row of the MixColumn matrix  <span class="math">M_{MC}</span>  such that  <span class="math">MC_{r,n} = MC_{r,k}</span> . Equivalently,  <span class="math">R(p^1) \\oplus R(p^2) \\in \\mathcal{C}_{k-l} \\cap \\mathcal{D}_{\\{0,1,2,3\\}\\setminus r}</span> .</p>

    <p class="text-gray-300">Note that  <span class="math">l - k \\equiv_4 m - n</span>  since they are two consecutive-diagonal bytes. We refer to Fig. 9 for an example of application of this Proposition.</p>

    <p class="text-gray-300">The idea is to exploit this property in order to set up attacks on AES. Indeed, consider a subset of a coset of  <span class="math">\\mathcal{D}_i</span>  related to the guess secret key as plaintexts. If the guess value is correct - case (1) of Fig. 8 (that is, if the difference of two consecutive-diagonal bytes of the plaintexts is equal to the difference of the same bytes of the secret key), then this set is mapped into a subset of a coset of  <span class="math">\\mathcal{C}_i \\cap \\mathcal{D}_J \\subseteq \\mathcal{D}_J</span>  for a certain J with |J| = 3. If the guess value is wrong - case (2) of Fig. 8, then this set is mapped into a subset of a coset of  <span class="math">\\mathcal{C}_i</span> . Using the subspace trails of Sect. 4, this implies for example that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>after 3 rounds, two plaintexts in the set  <span class="math">V_{\\delta}</span>  are mapped into a subset of a coset of  <span class="math">\\mathcal{M}_J</span>  with probability 1 in case (1), while this happens only with probability  <span class="math">2^{-8}</span>  i.e. strictly less than 1 in case (2);</li>
      <li>after 4 rounds, the probability that two texts in the previous set  <span class="math">V_{\\delta}</span>  are mapped into the same coset of  <span class="math">\\mathcal{M}_J</span>  is higher in case (1) approximately  <span class="math">2^{-22}</span>  than in case (2) approximately  <span class="math">2^{-30}</span> ;</li>
    </ul>

    <p class="text-gray-300">• after 5 rounds, the probability that two texts in the previous set  <span class="math">V_{\\delta}</span>  are mapped into the same coset of  <span class="math">\\mathcal{M}_{j}</span>  is equal to zero in case (1), while is strictly different from zero in case (2) - approximately  <span class="math">2^{-94}</span> .</p>

    <p class="text-gray-300">These different subspace trails allow to recover information about the secret key. In particular, in the following we show how to exploits it to set up a truncated differential attack on 3- and 4- rounds, an impossible differential attack on 5-round and a square attack on 3-round of AES with a secret S-Box.</p>

    <p class="text-gray-300">Finally, observe that a similar strategy can be used to set up attacks on AES-like block ciphers, with identical (secret) S-Box and with a MixColumns matrix that satisfies the previous requirement. Moreover, we stress that, with respect to other attacks present in literature in the same setting (i.e. AES with a secret S-Box), for the first time we show that it is possible to discover the secret key directly, that is without discovering any information (e.g. an equivalent class) about the secret S-Box.</p>

    <p class="text-gray-300">In this section, we briefly show how to exploit the previous strategy to set up truncated differential attacks on 3- and 4-round of AES with a secret S-Box. We limit here to give the idea of these attacks, and we refer to App. G and H for all the details together with the presentation of the square attack on AES with a secret S-Box (see App. G.3).</p>

    <p class="text-gray-300">Truncated Diff. Attack on 3 rounds of AES with Secret S-Box The attack on 3-rounds - illustrated in Fig. 9 - works as follows. Consider a pair of plaintexts  <span class="math">p^1</span>  and  <span class="math">p^2</span>  with the condition  <span class="math">p_{i,j}^1 = p_{i,j}^2</span>  for each  <span class="math">(i,j) \\neq \\{(0,0),(1,1)\\}</span>  and  <span class="math">p_{0,0}^1 \\oplus p_{1,1}^1 = p_{0,0}^2 \\oplus p_{1,1}^2</span> . As we have seen, if  <span class="math">p_{0,0}^1 \\oplus p_{1,1}^1 = p_{0,0}^2 \\oplus p_{1,1}^2 = k_{0,0} \\oplus k_{1,1}</span> , then  <span class="math">p^1</span>  and  <span class="math">p^2</span>  belong to the same coset of  <span class="math">\\mathcal{D}_{0,1,3}</span>  after one round with probability 1. Consequently, after three rounds they belong to the same coset of  <span class="math">\\mathcal{M}_{0,1,3}</span>  with probability 1 (or of  <span class="math">\\mathcal{ID}_{0,1,3}</span>  if the final MixColumns is omitted), since a coset of  <span class="math">\\mathcal{D}_{0,1,3}</span>  is mapped into a coset of  <span class="math">\\mathcal{M}_{0,1,3}</span>  with probability 1. Instead, if  <span class="math">p_{0,0}^1 \\oplus p_{1,1}^1 = p_{0,0}^2 \\oplus p_{1,1}^2 \\neq k_{0,0} \\oplus k_{1,1}</span> , then  <span class="math">p^1</span>  and  <span class="math">p^2</span>  belong to the same coset of  <span class="math">\\mathcal{D}_{0,1,3}</span>  after one round only with probability  <span class="math">2^{-8}</span>  (that is, only if  <span class="math">R(p^1)_{2,0} \\oplus R(p^2)_{2,0} = 0</span> ). Thus, after three rounds they belong to the same coset of  <span class="math">\\mathcal{M}_{0,1,3}</span>  only with probability  <span class="math">2^{-8}</span> . Our attack exploits these different probabilities in order to find  <span class="math">k_{0,0} \\oplus k_{1,1}</span> . More details are given in App. G.1.</p>

    <p class="text-gray-300">Truncated Diff. Attack on 4 rounds of AES with Secret S-Box. The truncated differential attack on 4 rounds of AES works in a similar way, and it exploits the subspace trail described in Sect. 4.3. In particular, if two texts belong to the same coset of  <span class="math">\\mathcal{D}_J</span>  for |J|=3 fixed, then after three rounds they belong to the same coset of  <span class="math">\\mathcal{M}_I</span>  for |I|=3 with probability  <span class="math">4\\cdot 2^{-24}=2^{-22}</span>  in the AES case and with probability  <span class="math">4\\cdot 2^{-32}=2^{-30}</span>  in the random case. Exploiting these different probabilities and the fact that a coset of a subset of  <span class="math">\\mathcal{D}_i</span>  (which depends on the guessed values of the key) is mapped into a subset of a coset of  <span class="math">\\mathcal{D}_{0,1,3}</span>  only for the correct guessed values of the key, it is possible to discover the whitening key of 4-rounds of AES with a secret S-Box up to  <span class="math">2^{32}</span>  variants. More details are given in App. H.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-26-2&quot;&gt;&lt;/span&gt;    <img src="_page_26_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Figure 9:</strong> 3-rounds Truncated Differential Attack on AES with a single secret S-Box. The choice of the plaintexts (i.e.  <span class="math">p_{0,0} \\oplus p_{1,1} = k_{0,0} \\oplus k_{1,1}</span> ) guarantees that after one round there are only three bytes with non-zero difference instead of four, that is the plaintexts belong to the same coset of  <span class="math">\\mathcal{C}_0 \\cap \\mathcal{D}_{0,1,3}</span> . White box denotes a byte with a zero-difference, while a black box denotes a byte with non-zero difference.</p>

    <p class="text-gray-300">Using the strategy presented in the previous section, it is possible to set up an impossible differential attack on 5 rounds of AES with a secret S-Box. As before, the goal is to find the secret key without needing to discover any information about the S-Box.</p>

    <p class="text-gray-300">Starting from this attack, we show how to turn it into a secret key distinguisher for AES, and we compare it in details with the distinguisher presented in  <span class="math">[SLG^+16]</span>  at CRYPTO 2016. As we have already said, also the key recovery attack can be used as distinguisher. However, we show that in order to distinguish a random permutation from an AES one, it is not necessary to find the entire key.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-26-1&quot;&gt;&lt;/span&gt;7.1 Key-Recovery Attack using Impossible Differential - General Idea</h3>

    <p class="text-gray-300">&lt;span id=&quot;page-26-3&quot;&gt;&lt;/span&gt;For the following, we define the set of plaintexts-ciphertexts  <span class="math">V_{\\delta}</span>  with  <span class="math">|V_{\\delta}| = 2^8</span> :</p>

    <p class="text-gray-300"><span class="math">$V_{\\delta} = \\{ (p^{i}, c^{i}) \\text{ for } i = 0, ..., 2^{8} - 1 \\mid p_{0,0}^{i} \\oplus p_{1,1}^{i} = \\delta \\quad \\forall i \\text{ and}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\text{and} \\quad p_{k,l}^{i} = p_{k,l}^{j} \\quad \\forall (k,l) \\neq \\{ (0,0), (1,1) \\} \\text{ and } i \\neq j \\},</span>$</p>

    <p class="text-gray-300"><span class="math">$(6)</span>$</p>

    <p class="text-gray-300">i.e. plaintexts with 14 constants bytes and with the difference on the other two bytes fixed. Consider two different pairs  <span class="math">(p^1,c^1)</span>  and  <span class="math">(p^2,c^2)</span>  that belong to the same  <span class="math">V_\\delta</span> . By Prop. 7, we know that if  <span class="math">\\delta = k_{0,0} \\oplus k_{1,1}</span> , then  <span class="math">p^1</span>  and  <span class="math">p^2</span>  belong to the same coset of  <span class="math">\\mathcal{D}_{0,1,3} \\cap \\mathcal{C}_0 \\subseteq \\mathcal{D}_{0,1,3}</span>  after one round (that is,  <span class="math">R(p^1) \\oplus R(p^2) \\in \\mathcal{D}_{0,1,3} \\cap \\mathcal{C}_0 \\subseteq \\mathcal{D}_{0,1,3}</span> ) with probability 1. If  <span class="math">\\delta \\neq k_{0,0} \\oplus k_{1,1}</span> , they belong to the same coset of  <span class="math">\\mathcal{C}_0</span>  after one round with probability 1, and to the same coset of  <span class="math">\\mathcal{D}_{0,1,3} \\cap \\mathcal{C}_0 \\subseteq \\mathcal{D}_{0,1,3}</span>  with probability  <span class="math">2^{-8}</span>  (or to the same coset of  <span class="math">\\mathcal{D}_J</span>  for |J| = 3 after one round with probability  <span class="math">4 \\cdot 2^{-8} = 2^{-6}</span> ).</p>

    <p class="text-gray-300">Consider first the case  <span class="math">\\delta = k_{0,0} \\oplus k_{1,1}</span> . Since  <span class="math">R(p^1) \\oplus R(p^2) \\in \\mathcal{D}_{0,1,3}</span>  for each pair of plaintexts  <span class="math">p^1</span>  and  <span class="math">p^2</span>  in  <span class="math">V_{\\delta}</span> , then  <span class="math">R^{(4)} \\circ R(p^1) \\oplus R^{(4)} \\circ R(p^2) = R^{(5)}(p^1) \\oplus R^{(5)}(p^2) \\notin \\mathcal{M}_J</span>  for  <span class="math">|I| + |J| \\leq 4</span>  with probability 1 due to the 4-round impossible differential distinguisher</p>

    <pre><code class="language-text">Data: 2^{98.5} collections (2^{90.2} one for each possible value of \\delta, or equivalently 2^{82.2}
           different sets V_{\\delta} as defined in (6).
  Result: k_{0.0} \\oplus k_{1.1}.
  for \\Delta from 0 to 2^8 - 1 do
      flaq \\leftarrow 0;
      divide the 2^{90.2} ciphertexts in the corresponding 2^{82.2} different sets V_{\\delta};
      for each one of the 2^{82.2} different sets V_{\\Delta} do
          let (p^i, c^i) for i = 0, ..., 2^8 - 1 the 2^8 (plaintexts, ciphertexts) of a single set V_{\\delta};
          re-order this set of elements as described in App. F;
          for i from 0 to 2^8 - 2 do
              if c^i \\oplus c^{i+1} \\in \\mathcal{M}_k for |k| = 1 then
                                                             // e.g. see Algorithm 1
                   flag \\leftarrow 1;
                  next collection (i.e. next \\delta);
              end
          end
          if flag = 0 then
           | identify \\delta as candidates of k_{0,0} \\oplus k_{1,1};
      end
  end
  return Candidates of k_{0,0} \\oplus k_{1,1}.
Algorithm 4: Attack for 5-round of AES using Impossible Differential - Pseudo Code.
</code></pre>

    <p class="text-gray-300">of Sect. 4.4. That is, for each  <span class="math">(p^1, c^1) \\neq (p^2, c^2)</span></p>

    <p class="text-gray-300"><span class="math">$Pr(R^{(5)}(p^1) \\oplus R^{(5)}(p^2) \\in \\mathcal{M}_J | (p^1, c^1), (p^2, c^2) \\in V_\\delta) = 0,</span>$</p>

    <p class="text-gray-300">The same attack can be use to find the remaining part of the key.</p>

    <p class="text-gray-300">for each J with |J|=1 and where  <span class="math">\\delta:=k_{0,0}\\oplus k_{1,1}</span>  is known. As usual, a similar result holds also in the case in which the final MixColumns operation is omitted (in this case,  <span class="math">\\mathcal{M}_J</span>  is replaced by  <span class="math">\\mathcal{ID}_J</span> ).</p>

    <p class="text-gray-300">Instead, if  <span class="math">\\delta \\neq k_{0,0} \\oplus k_{1,1}</span> , note that it's possible that two elements of  <span class="math">V_{\\delta}</span>  belong to the same coset of  <span class="math">\\mathcal{M}_J</span>  for |J|=1 after 5-round. In particular, the probability that two elements p and q in  <span class="math">V_{\\delta}</span>  belong to the same coset of  <span class="math">\\mathcal{M}_J</span>  after 5-round for a certain J with |J|=1 is approximately  <span class="math">^{10} 4 \\cdot 2^{-96} = 2^{-94}</span> .</p>

    <p class="text-gray-300">The idea is to exploit these different probabilities in order to find the key. In particular, a key candidate  <span class="math">\\delta</span>  can be declared wrong if there is at least one collision, i.e. two different pairs of texts  <span class="math">(p^1,c^1)</span>  and  <span class="math">(p^2,c^2)</span>  such that  <span class="math">p^1\\oplus p^2\\in V_\\delta</span>  and  <span class="math">c^1\\oplus c^2\\in \\mathcal{M}_J</span>  for |J|=1. Thus, in the following we look for the minimum number of texts necessary to have at least one collision for each  <span class="math">\\delta\\neq k_{0,0}\\oplus k_{1,1}</span>  with high probability.</p>

    <p class="text-gray-300">Before to proceed, note that a similar impossible differential attack can be set up for 4-round AES with secret S-Box, exploiting the fact that two elements in the same coset of  <span class="math">\\mathcal{D}_J</span>  can not belong to the same coset of  <span class="math">\\mathcal{C}_I</span>  after three rounds for  <span class="math">|I| + |J| \\leq 4</span> .</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-27-0&quot;&gt;&lt;/span&gt;7.2 Data Complexity and Computational Cost</h4>

    <p class="text-gray-300">The attack is constructed in two steps. First we focus on a single difference among two bytes of the secret key, and then we show how to find the entire key. In this section, we limit to report the results for the data and the computational complexity of the attack,</p>

    <p class="text-gray-300">&lt;span id=&quot;page-27-1&quot;&gt;&lt;/span&gt;The exact probability for a wrong  <span class="math">\\delta \\neq k_{0,0} \\oplus k_{1,1}</span>  is given by  <span class="math">Pr(R^{(5)}(p^1) \\oplus R^{(5)}(p^2) \\in \\mathcal{M}_J \\mid p^1 \\oplus p^2 \\in V_{\\delta}) = 2^{-6} \\cdot 0 + (1 - 2^{-6}) \\cdot 4 \\cdot 2^{-96} = 2^{-94} - 2^{-100} \\simeq 2^{-94}</span> , which is derived considering the two cases  <span class="math">R(p^1) \\oplus R(p^2) \\in \\mathcal{D}_J</span>  and  <span class="math">R(p^1) \\oplus R(p^2) \\notin \\mathcal{D}_J</span>  for |J| = 3.</p>

    <p class="text-gray-300">    <img src="_page_28_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Figure 10:</strong> <em>5-Round Secret Key Distinguisher for AES with a single secret S-Box</em> with data complexity 2 &lt;sup&gt;98&lt;/sup&gt;<em>.</em>&lt;sup&gt;2&lt;/sup&gt; based on the Impossible Subspace Trail on 4-Round (from Sect. <a href="#page-20-0">4.4)</a>. The choice of the plaintexts (i.e. <em>p</em>0<em>,</em>&lt;sup&gt;0&lt;/sup&gt; ⊕ <em>p</em>1<em>,</em>&lt;sup&gt;1&lt;/sup&gt; = <em>k</em>0<em>,</em>&lt;sup&gt;0&lt;/sup&gt; ⊕ <em>k</em>1<em>,</em>1) guarantees that after one round there are only three bytes with non-zero difference instead of four, that is the plaintexts belong to the same coset of C&lt;sup&gt;0&lt;/sup&gt; ∩ D0<em>,</em>1<em>,</em>3. The probability the two ciphertexts belong to the same coset of M<em>&lt;sup&gt;k&lt;/sup&gt;</em> for |<em>k</em>| = 1 is zero. White box denotes denotes a byte with a zero-difference, while a black box denotes a byte with non-zero difference.</p>

    <p class="text-gray-300">and we refer to App. <a href="#page-69-0">I.1</a> for a complete discussion.</p>

    <p class="text-gray-300"><strong>Data Complexity.</strong> First of all, we consider the case in which the goal is to find only <em>one byte of the secret key</em> (i.e. the difference of two fixed bytes of the key). As we have seen, given two texts in the same set <em>V&lt;sup&gt;δ&lt;/sup&gt;</em> defined as in Prop. <a href="#page-26-3">6,</a> after 5 rounds they can not belong to the same coset of M<em>&lt;sup&gt;J&lt;/sup&gt;</em> for |<em>J</em>| = 1 if <em>δ</em> = <em>k</em>0<em>,</em>&lt;sup&gt;0&lt;/sup&gt; ⊕ <em>k</em>1<em>,</em>1. Instead, if <em>δ</em> 6= <em>k</em>0<em>,</em>&lt;sup&gt;0&lt;/sup&gt; ⊕ <em>k</em>1<em>,</em>&lt;sup&gt;1&lt;/sup&gt; then they belong to the same coset of M<em>&lt;sup&gt;J&lt;/sup&gt;</em> for |<em>J</em>| = 1 with probability 2 &lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;94&lt;/sup&gt;. Thus, in order to find the difference of these two bytes of the key, one needs at least one collision in the same coset of M<em>&lt;sup&gt;J&lt;/sup&gt;</em> for |<em>J</em>| = 1 <em>for each</em> one of the 2 &lt;sup&gt;8&lt;/sup&gt; − 1 ' 2 8 <em>δ</em> =6 <em>k</em>0<em>,</em>&lt;sup&gt;0&lt;/sup&gt; ⊕ <em>k</em>1<em>,</em>1. As shown in details in App. <a href="#page-69-0">I.1,</a> to find this byte with probability higher than 95%, for each possible <em>δ</em> one needs approximately 2 &lt;sup&gt;82&lt;/sup&gt;<em>.</em>&lt;sup&gt;2&lt;/sup&gt; different sets <em>Vδ</em>, for a total cost of 2 98<em>.</em>2 plaintextexts/ciphertexts.</p>

    <p class="text-gray-300">In order to find <em>the entire key</em> (up to 2 &lt;sup&gt;32&lt;/sup&gt; variants), the idea is simply to repeat the previous attack 12 times (i.e. three times for each possible diagonal). As shown in details in App. <a href="#page-69-0">I.1,</a> to find this byte with probability higher than 95%, for each possible <em>δ</em> one needs approximately  <span class="math">2^{82.4}</span>  different sets  <span class="math">V_{\\delta}</span>  (not  <span class="math">2^{82.2}</span>  as before - see App. I.1 for details), for a total cost of approximately,  <span class="math">2^{102}</span>  plaintextexts/ciphertexts, which is lower than the entire input-output space.</p>

    <p class="text-gray-300">Computational Complexity. Using a re-ordering algorithm, the computational cost of the attack to find one byte of the key is well approximated by  <span class="math">2^{103.2}</span>  table-look ups, or  <span class="math">2^{96.56}</span>  five rounds AES encryption, while the cost to find the entire key is approximately  <span class="math">2^{107}</span>  table-look ups, or  <span class="math">2^{100.35}</span>  five rounds AES encryption.</p>

    <h2 id="sec-25" class="text-2xl font-bold">&lt;span id=&quot;page-29-0&quot;&gt;&lt;/span&gt;8 The 5-Round Secret Key Distinguisher for AES</h2>

    <p class="text-gray-300">Next we show how to turn the previous key recovery attack into a distinguisher for AES, in the same setting of the distinguisher presented in [SLG&lt;sup&gt;+&lt;/sup&gt;16]. The idea is simply to consider only the first part of the attack, i.e. it is sufficient to recover one byte of the key as  <span class="math">k_{0,0} \\oplus k_{1,1}</span> .</p>

    <p class="text-gray-300">Consider the previous key recovery attack, and let the set  <span class="math">V_{\\delta}</span>  defined as before. For each one of the  <span class="math">2^8</span>  possible values of  <span class="math">\\delta</span> , the idea is to consider  <span class="math">2^{82.2}</span>  different sets  <span class="math">V_{\\delta}</span> , for a total of  <span class="math">2^{98.2}</span>  chosen plaintexts. As we have just seen, for the AES permutation, there exists one  <span class="math">\\delta</span>  (which is equal to  <span class="math">k_{0,0} \\oplus k_{1,1}</span> ) for which there are no collisions. That is, for the AES permutation and for  <span class="math">\\delta = k_{0,0} \\oplus k_{1,1}</span> , no pairs  <span class="math">(p^1, c^1)</span>  and  <span class="math">(p^2, c^2)</span>  can satisfy  <span class="math">p^1, p^2 \\in V_{\\delta}</span>  and  <span class="math">c^1 \\oplus c^2 \\in \\mathcal{M}_J</span>  for |J| = 1. Instead, for the random permutation and with probability 95%, for each  <span class="math">\\delta</span>  there is at least one pair with the previous property. Thus, it is possible to distinguish the random permutation from an AES one.</p>

    <p class="text-gray-300">To summarize, suppose to have  <span class="math">2^8</span>  collections (one for each  <span class="math">\\delta</span> ), each one with  <span class="math">2^{82.2}</span>  different sets  <span class="math">V_{\\delta}</span> , where each of this set contains  <span class="math">2^8</span>  texts, for a total of  <span class="math">2^{98.2}</span>  texts. In the random case and with probability 95%, we expect that in each one of these  <span class="math">2^8</span>  collections there is at least one collision. Note that the average number of collisions for each collection (i.e. for each  <span class="math">\\delta</span> ) is about  <span class="math">2^{-94} \\cdot 2^{97.2} = 2^{3.2} \\simeq 9</span> . For the AES permutation, we expect that there exists one  <span class="math">\\delta</span>  for which there is no collision with probability 1 in the corresponding collection of sets. For all the other collections, we expect to have at least one collision with probability 95%. We highlight that given the  <span class="math">2^{98.2}</span>  texts defined as before, it is always possible to divide them in  <span class="math">2^8</span>  collections (one for each  <span class="math">\\delta</span> ), and that each collection can be divided in a very simple way in  <span class="math">2^{82.2}</span>  different sets  <span class="math">V_{\\delta}</span>  (simply using the definition of  <span class="math">V_{\\delta}</span> ). Finally, using the argument of our impossible differential key recovery attack, the computational cost of this distinguisher (i.e. the cost to check if there exists at least one pair of ciphertexts that belong to the same coset of  <span class="math">\\mathcal{M}_J</span>  for a certain J with |J| = 1 for all possible values of  <span class="math">\\delta</span> ) is  <span class="math">2^{103.2}</span>  table look-ups, using the ordering algorithm.</p>

    <h2 id="sec-26" class="text-2xl font-bold">&lt;span id=&quot;page-29-1&quot;&gt;&lt;/span&gt;8.1 Comparison with 5-Round Distinguisher proposed by Sun, Liu, Guo, Qu and Rijmen, and Possible Generalizations</h2>

    <p class="text-gray-300">In [SLG&lt;sup&gt;+&lt;/sup&gt;16], authors presented a similar secret key distinguisher to the one just presented, using the balance property instead of our impossible differential trail.</p>

    <p class="text-gray-300">In order to construct the secret key distinguisher presented in [SLG&lt;sup&gt;+&lt;/sup&gt;16], authors simply consider all the input-output space, and divide it in the  <span class="math">2^8</span>  subsets  <span class="math">\\tilde{V}_{\\Delta}</span>  defined as  <span class="math">\\tilde{V}_{\\Delta} = \\{(p,c) \\mid c_{0,0} \\oplus c_{1,3} = \\Delta\\}</span>  for each possible  <span class="math">\\Delta \\in \\mathbb{F}_{2^8}</span> , and without any other assumptions on the other bytes. Note that  <span class="math">|\\tilde{V}_{\\Delta}| = 2^{120}</span> . Then, using the link between zero-correlation linear hulls and the integral/balance property, they are able to prove that for an AES permutation and for  <span class="math">\\Delta = k_{0,0} \\oplus k_{1,3}</span>  the sum of the plaintexts of the corresponding set  <span class="math">\\tilde{V}_{\\Delta}</span>  is equal to zero, that is the balance property holds&lt;sup&gt;11&lt;/sup&gt;. Instead, for a random permutation,</p>

    <p class="text-gray-300">&lt;span id=&quot;page-29-2&quot;&gt;&lt;/span&gt; <span class="math">&lt;sup&gt;\\&lt;/sup&gt;overline{\\ }^{11}</span> In [SLG&lt;sup&gt;+&lt;/sup&gt;16], authors presented also a similar distinguisher always based on balance property. In this case, the idea is to divide the entire input-output space in  <span class="math">2^{32}</span>  subsets  <span class="math">\\tilde{W}_{\\Delta}</span>  defined as  <span class="math">\\tilde{W}_{\\Delta}</span>  =</p>

    <p class="text-gray-300">the probability that there exists one  <span class="math">\\Delta</span>  with the previous property is only  <span class="math">2^{-120}</span> . This distinguisher works only in the decryption direction (i.e. using chosen ciphertexts) and only if the final MixColumns operation is not omitted. Moreover, there is no evidence that this distinguisher can work with less than the entire input-output space&lt;sup&gt;12&lt;/sup&gt;. We refer to [SLG&lt;sup&gt;+&lt;/sup&gt;16] for more details. To summarize, this distinguisher requires the full codebook (i.e.  <span class="math">2^{128}</span>  texts), and the verification cost is well approximated by  <span class="math">2^{128}</span>  XOR operations.</p>

    <p class="text-gray-300">For comparison, our distinguisher requires only 2&lt;sup&gt;98.2&lt;/sup&gt; different (plaintexts, ciphertexts), works in the encryption direction (i.e. using chosen plaintexts) independently by the presence of the final MixColumns operation. Thus, as we said in the introduction, this provides a counter-example to the claims made in [SLG&lt;sup&gt;+&lt;/sup&gt;16]. That is, as we have already discussed in details in the introduction, this distinguisher provides a counter-example to the conjecture made by these authors that the security margin for round-reduced AES under the chosen plaintext attack is different from that under the chosen-ciphertexts attack.</p>

    <p class="text-gray-300">Only for completeness, we prove that if our distinguisher uses all the input-output space, the probability of success is  <span class="math">1-2^{-2^{25.5}}</span> . If all the texts are used, then for each  <span class="math">\\delta</span>  there are  <span class="math">2^{112}</span>  different sets  <span class="math">V_{\\delta}</span> . Thus, it is possible to construct approximately  <span class="math">2^{15} \\cdot 2^{112} = 2^{127}</span>  different pairs. The probability that for a (wrong)  <span class="math">\\delta</span>  no one of these pairs satisfy the required property is approximately  <span class="math">1-(1-2^{-94})^{2^{127}} \\simeq 1-e^{-2^{33}} \\simeq 1-2^{-2^{33.5}}</span> . Thus, the probability of success is approximately  <span class="math">(1-2^{-2^{33.5}})^{2^8} \\simeq 1-2^{-2^{25.5}}</span>  if all the input-output space is used, which is much higher than for the integral distinguisher (which is approximately  <span class="math">1-2^{-120}</span> ). We stress that our distinguisher works even using a less data complexity that the entire input-output space, and that  <span class="math">2^{110.5}</span>  different (plaintexts, ciphertexts) (or equivalently  <span class="math">2^{94.5}</span>  different sets  <span class="math">V_{\\delta}</span>  for each  <span class="math">\\delta</span> ) are sufficient to have approximately the same probability of success of [SLG&lt;sup&gt;+&lt;/sup&gt;16].</p>

    <p class="text-gray-300">Finally, in [SLG&lt;sup&gt;+&lt;/sup&gt;16] authors exploit the link between zero-correlation linear hulls and the integral property to set up our distinguisher, while our distinguisher presented in this paper exploits the impossible differential trails. For completeness, we recall that Impossible Differential, Integral and Zero-Linear Correlation are not independent, as shown in details in [SLR&lt;sup&gt;+&lt;/sup&gt;15]. In particular, the presence of a zero correlation linear hull distinguisher (very likely) implies the existence of an Impossible Differential distinguisher and of an Integral one.</p>

    <p class="text-gray-300">Turn the CRYPTO Distinguisher into a Key-Recovery Attack. As we have turned our key recovery attack into a distinguisher, it is also possible to turn the distinguisher of [SLG&lt;sup&gt;+&lt;/sup&gt;16] into an attack, as also the authors observed in their paper. The idea is to repeat the distinguisher three times (using the version presented in Corollary 5 of [SLG&lt;sup&gt;+&lt;/sup&gt;16] and reported in the footnote, it is possible to recover four bytes of the key), in order to recover the secret key up to  <span class="math">2^{32}</span>  variants. Note that also in this case as for our attacks, it is not possible to eliminate more variants of the key without using any information about the secret S-Box. This attack requires the entire input-output space, and it has a cost of  <span class="math">3 \\cdot 2^{128} = 2^{129.6}</span>  XOR operations.</p>

    <p class="text-gray-300">Final Observations. Finally, it is very easy to generalize our distinguisher and the one proposed in [SLG&lt;sup&gt;+&lt;/sup&gt;16] to any AES-like block cipher with the following properties: (1) the encryption scheme adopts identical S-Boxes and (2) at least one row of the MixColumns matrix  <span class="math">M_{MC}</span>  (or its inverse) contains (at least) two identical elements. If one of these two assumptions is missing, the above distinguishers don't work. As a consequence, note that</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;\\{(&lt;/sup&gt;p,c)\\,|\\,c_{0,0}\\oplus c_{1,3}=\\delta_0,c_{0,1}\\oplus c_{3,2}=\\delta_1,c_{1,2}\\oplus c_{2,1}=\\delta_2,c_{2,0}\\oplus c_{3,3}=\\delta_3\\}</span> , where  <span class="math">\\Delta=(\\delta_0,\\ldots,\\delta_3)</span> . Also in this case, for an AES permutation there exists one  <span class="math">\\Delta</span>  for which the balance property holds among the plaintexts, while for a random permutation this happens only with probability  <span class="math">2^{-96}</span></p>

    <p class="text-gray-300">&lt;span id=&quot;page-30-0&quot;&gt;&lt;/span&gt; <span class="math">&lt;sup&gt;^{12}&lt;/sup&gt;</span> It may be possibile to use the recently proposed statistical integral distinguisher [WCC&lt;sup&gt;+&lt;/sup&gt;16] to modify the distinguisher presented in [SLG&lt;sup&gt;+&lt;/sup&gt;16] into a statistical integral one, with the goal to reduce the data complexity at the cost of success probability.</p>

    <p class="text-gray-300">the distinguisher described in this section can not work in the decryption mode (that is, with chosen ciphertexts instead of chosen plaintexts), since no one of the columns of the inverse MixColumns  <span class="math">M_{MC}^{-1}</span>  has two equal elements. Actually, the first requirement can be relaxed. Indeed, it is sufficient that only the two S-Boxes that are in the positions in which the MixColumns matrix has identical elements are equal.</p>

    <p class="text-gray-300">Note that these assumptions are similar but not equal to the ones required for a key recovery attacks. Indeed, for our key recovery attacks on an AES-like block cipher with secret S-Box, all the S-Boxes must be identical and each row of the MixColumns matrix  <span class="math">M_{MC}</span>  must contain (at least) two identical elements in different positions.</p>

    <p class="text-gray-300">We emphasize that these assumptions are quite common for the construction of AES-like ciphers (or more in general, for SPNs ciphers). Indeed, symmetric encryption schemes are usually a trade-off between the security and computational efficiency. Thus, to enhance the performance of an encryption scheme (especially for lightweight cryptography), designers usually use identical S-Box and a diffusion layer which maximize the number of 1's (or elements with relatively low hamming weights).</p>

    <h2 id="sec-27" class="text-2xl font-bold">&lt;span id=&quot;page-31-0&quot;&gt;&lt;/span&gt;8.2 Critical Discussion of the Distinguisher Model and Open Problems</h2>

    <p class="text-gray-300">In this section, we have shown how to interpret the 5-round secret S-Box attack from the section before as a distinguisher for 5-round AES which corresponds to the model used in [SLG&lt;sup&gt;+&lt;/sup&gt;16], with our main point being to give a counter-example to the conjecture motivated by the results therein. By doing that we also significantly improved the complexity of such a distinguisher.</p>

    <p class="text-gray-300">Since any key recovery attack can be used as a distinguisher, the natural question that arises is if such a distinguisher is actually meaningful. Both ours and the distinguisher from  <span class="math">[SLG^{+}16]</span>  have two properties that set them apart from &quot;any&quot; key recovery-attack:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>for both distinguishers it is sufficient to find <em>only part of the key</em> (e.g. one byte) to distinguish an AES permutation with a secret S-Box from a random one. In other words, it is not necessary finding the entire secret key but only part of it;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>both distinguishers don't need any information/details about the S-Box (i.e. they don't find or/and exploit any information/details of the secret S-Box) in order to find part of the key.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">In order to better highlight this sub-class of attacks/distinguishers, we denote them by &quot;weak&quot; secret-key distinguishers. In contrast, we refer to (pure) secret-key distinguisher when a property which is independently of the secret key is exploited, and to key-recovery attack when (at least) one of the two previous properties is not satisfied.</p>

    <p class="text-gray-300">We emphasize that all the secret-key distinguishers currently present in literature - and presented in this paper in Sect. 4 - exploit a property which is independent of the key and of the details of the S-Box. In particular, it is not necessary to know the details of the S-Box to check the integral property or verify is two texts belong or not to the same coset of a mixed space  <span class="math">\\mathcal{M}_I</span>  (that is, the property exploited by the truncated and the impossible differential distinguishers). This second property is in common with the &quot;weak&quot; secret-key distinguishers just defined. On the opposite, a key-recovery attack (e.g. an integral attack, a truncated differential one, ...) usually exploits such details to find the key. As an example, we highlight that also the attacks presented in [TKKL15] on AES with a single secret S-Box don't satisfy the second requirement (i.e. it exploits the details of the S-Box to find the secret key). Indeed, even if the S-Box is secret, such attacks necessarily need to find/know the details of the S-Box (up to an equivalent class) before to discover the secret key, or in other words they can not discover the secret key without exploiting the details of the secret S-Box. Thus, such attacks can not be considered as</p>

    <p class="text-gray-300">&quot;weak&quot; secret-key distinguishers with respect to categorization just defined, but falls in the generic category of the key-recovery attacks.</p>

    <p class="text-gray-300">Even if there are key-recovery attacks on up to 7 rounds for AES-128 <a href="#page-35-9">[MDRM10]</a> with known S-Box, and up to 6 rounds for AES-128 with a secret S-Box <a href="#page-36-2">[TKKL15]</a>, it seems for example not possible to find a distinguisher with properties (1) and (2) for even 6 rounds. We leave this as an open problem for future investigation.</p>

    <h2 id="sec-28" class="text-2xl font-bold">&lt;span id=&quot;page-32-0&quot;&gt;&lt;/span&gt;<strong>9 Conclusion</strong></h2>

    <p class="text-gray-300">We have generalized invariant subspace cryptanalysis to subspace trails and have seen that it includes truncated differential-, impossible differential- and integral attacks. For concrete applications we focused on AES-128, and this led to a method that can use <em>all</em> the aforementioned techniques to recovery the secret key for up to 5 rounds without needing to know the S-Box apart from assuming it being a permutation. When the S-Box is known we described new truncated-differential attacks with very low data complexity that are competitive with the best known attacks. It is conceivable that such attacks are also found without the subspace trail approach (truncated differential + ad-hoc optimizations of the key-recovery method that go beyond looking at the differences only), but the combination of properties of individual texts and sums of text follows more naturally from the subspace trail approach.</p>

    <p class="text-gray-300">As one of the major results, we have proposed a new strategy to attack SPNs cipher with a single secret S-Box, if some very generic assumptions on the MixColumns matrix are satisfied. In particular, we showed how several techniques like truncated differential, impossible differential and integral attack can exploit it to recover directly (i.e. without discovering anything of the secret S-Box) the secret key for 1- up to 5- rounds of AES</p>

    <p class="text-gray-300">We also used this approach to give a counter-example to the conjecture of Sun et al. <a href="#page-35-2">[SLG</a>&lt;sup&gt;+&lt;/sup&gt;16] related to 5-round distiguishers. By doing that we also significantly improved the complexity of a distinguisher in their model, arguing however that the quest for a real 5-round distinguisher (that is, a 5-round secret key distinguisher for an AES permutation which is not derived from a key recovery attack but exploits a property which is independent of the secret key) is still open. Future work includes trying to exploit the subspace properties in other ways to get more efficient or longer distinguishers, perhaps by considering also S-Box properties, to use this approach to devise more key-recovery attacks and to apply the approach to other schemes.</p>

    <p class="text-gray-300"><strong>Acknowledgments.</strong> The work in this paper has been partially supported by the Austrian Science Fund (project P26494-N15). We thank Bing Sun for helpful discussions on <a href="#page-35-2">[SLG</a>&lt;sup&gt;+&lt;/sup&gt;16]. We thank Charles Bouillaguet for helping us with the tool described in <a href="#page-33-7">[BDF11]</a> to find attacks that better match the settings we consider. We also thank Friedrich Wiemer who contributed to improve and correct the implementations of the distinguishers proposed in this paper. We finally thank anonymous reviewers for their comments.</p>

    <h2 id="sec-29" class="text-2xl font-bold"><strong>References</strong></h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">&lt;span id=&quot;page-32-2&quot;&gt;&lt;/span&gt;[BA08] Behnam Bahrak and Mohammad Reza Aref. Impossible differential attack on seven-round AES-128. <em>IET Information Security</em>, 2(2):28–32, 2008.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-32-1&quot;&gt;&lt;/span&gt;[BBK14] Alex Biryukov, Charles Bouillaguet, and Dmitry Khovratovich. <em>Cryptographic Schemes Based on the ASASA Structure: Black-Box, White-Box, and Public-Key</em>, pages 63–84. Springer Berlin Heidelberg, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-33-3&quot;&gt;&lt;/span&gt;[BBS99] Eli Biham, Alex Biryukov, and Adi Shamir. Cryptanalysis of Skipjack Reduced to 31 Rounds Using Impossible Differentials. In Jacques Stern, editor, <em>Advances in Cryptology — EUROCRYPT 1999: International Conference on the Theory and Application of Cryptographic Techniques, Czech Republic. Proceedings</em>, pages 12–23, 1999.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-33-6&quot;&gt;&lt;/span&gt;[BDD&lt;sup&gt;+&lt;/sup&gt;12] Charles Bouillaguet, Patrick Derbez, Orr Dunkelman, Pierre-Alain Fouque, Nathan Keller, and Vincent Rijmen. Low-Data Complexity Attacks on AES. <em>IEEE Trans. Information Theory</em>, 58(11):7002–7017, 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-33-7&quot;&gt;&lt;/span&gt;[BDF11] Charles Bouillaguet, Patrick Derbez, and Pierre-Alain Fouque. Automatic search of attacks on round-reduced AES and applications. In <em>Advances in Cryptology - CRYPTO 2011 - 31st Annual Cryptology Conference, Santa Barbara, CA, USA. Proceedings</em>, pages 169–187, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-33-2&quot;&gt;&lt;/span&gt;[BK01] Eli Biham and Nathan Keller. Cryptanalysis of Reduced Variants of Rijndael. unpublished, 2001. <a href="http://csrc.nist.gov/archive/aes/round2/conf3/papers/35-ebiham.pdf">http://csrc.nist.gov/archive/aes/round2/conf3/</a> <a href="http://csrc.nist.gov/archive/aes/round2/conf3/papers/35-ebiham.pdf">papers/35-ebiham.pdf</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-33-1&quot;&gt;&lt;/span&gt;[BK07] Alex Biryukov and Dmitry Khovratovich. Two New Techniques of Side-Channel Cryptanalysis. In <em>Cryptographic Hardware and Embedded Systems - CHES 2007: 9th International Workshop, Austria. Proceedings</em>, pages 195–208, 2007.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-33-8&quot;&gt;&lt;/span&gt;[BKLT11] Julia Borghoff, Lars R. Knudsen, Gregor Leander, and Søren S. Thomsen. Cryptanalysis of PRESENT-Like Ciphers with Secret S-Boxes. In <em>Fast Software Encryption - FSE 2011: 18th International Workshop, Denmark. Revised Selected Papers</em>, pages 270–289, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-33-5&quot;&gt;&lt;/span&gt;[BKR11] Andrey Bogdanov, Dmitry Khovratovich, and Christian Rechberger. Biclique cryptanalysis of the full AES. In <em>Advances in Cryptology – ASIACRYPT 2011: 17th International Conference on the Theory and Application of Cryptology and Information Security, South Korea. Proceedings</em>, pages 344–371, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-33-11&quot;&gt;&lt;/span&gt;[BS91] Eli Biham and Adi Shamir. Differential cryptanalysis of DES-like cryptosystems. <em>Journal of Cryptology</em>, 4(1):3–72, 1991.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-33-9&quot;&gt;&lt;/span&gt;[BS01] Alex Biryukov and Adi Shamir. Structural Cryptanalysis of SASAS. In <em>Advances in Cryptology - EUROCRYPT 2001: International Conference on the Theory and Application of Cryptographic Techniques, Austria. Proceeding</em>, pages 394–405, 2001.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-33-0&quot;&gt;&lt;/span&gt;[BS10] Alex Biryukov and Adi Shamir. Structural Cryptanalysis of SASAS. <em>Journal of Cryptology</em>, 23(4):505–518, 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-33-12&quot;&gt;&lt;/span&gt;[CLRS09] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. <em>Introduction to Algorithms, Third Edition</em>. The MIT Press, 3rd edition, 2009.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-33-10&quot;&gt;&lt;/span&gt;[CMR05] Carlos Cid, Sean Murphy, and Matthew J. B. Robshaw. Small Scale Variants of the AES. In <em>Fast Software Encryption - FSE 2005: 12th International Workshop, France: Revised Selected Papers</em>, volume 3557, pages 145–162, 2005.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-33-4&quot;&gt;&lt;/span&gt;[DF13] Patrick Derbez and Pierre-Alain Fouque. Exhausting Demirci-Selçuk Meet-inthe-Middle Attacks Against Reduced-Round AES. In <em>Fast Software Encryption - FSE 2013: 20th International Workshop, Singapore. Revised Selected Papers</em>, pages 541–560, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-34-9&quot;&gt;&lt;/span&gt;[DFJ13] Patrick Derbez, Pierre-Alain Fouque, and Jérémy Jean. Improved key recovery attacks on reduced-round AES in the single-key setting. In <em>Advances in Cryptology - EUROCRYPT 2013: 32nd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Greece. Proceedings</em>, pages 371–387. 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-34-10&quot;&gt;&lt;/span&gt;[DK10] Orr Dunkelman and Nathan Keller. The Effects of the Omission of Last Round's MixColumns on AES. <em>Inf. Process. Lett.</em>, 110(8-9):304–308, 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-34-4&quot;&gt;&lt;/span&gt;[DKR97] Joan Daemen, Lars R. Knudsen, and Vincent Rijmen. The block cipher square. In <em>Fast Software Encryption, 4th International Workshop, FSE '97, Haifa, Israel, January 20-22, 1997, Proceedings</em>, pages 149–165, 1997.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-34-8&quot;&gt;&lt;/span&gt;[DKS10] Orr Dunkelman, Nathan Keller, and Adi Shamir. Improved single-key attacks on 8-round AES-192 and AES-256. In <em>Advances in Cryptology - ASIACRYPT 2010: 16th International Conference on the Theory and Application of Cryptology and Information Security, Singapore. Proceedings</em>, pages 158–176, 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-34-2&quot;&gt;&lt;/span&gt;[DR02] Joan Daemen and Vincent Rijmen. <em>The Design of Rijndael: AES - The Advanced Encryption Standard</em>. Information Security and Cryptography. Springer, 2002.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-34-3&quot;&gt;&lt;/span&gt;[DR06a] Joan Daemen and Vincent Rijmen. Two-Round AES Differentials. Cryptology ePrint Archive, Report 2006/039, 2006. <a href="http://eprint.iacr.org/2006/039">http://eprint.iacr.org/2006/039</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-34-5&quot;&gt;&lt;/span&gt;[DR06b] Joan Daemen and Vincent Rijmen. Understanding Two-Round Differentials in AES. In <em>Security and Cryptography for Networks 2006</em>, volume 4116, pages 78 – 94, 2006.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-34-6&quot;&gt;&lt;/span&gt;[DS08a] Hüseyin Demirci and Ali Aydın Selçuk. <em>A Meet-in-the-Middle Attack on 8-Round AES</em>, pages 116–126. 2008.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-34-7&quot;&gt;&lt;/span&gt;[DS08b] Hüseyin Demirci and Ali Aydin Selçuk. A meet-in-the-middle attack on 8 round AES. In <em>Fast Software Encryption - FSE 2008: 15th International Workshop, Switzerland. Revised Selected Papers</em>, pages 116–126. 2008.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-34-1&quot;&gt;&lt;/span&gt;[Eve87] Jan-Hendrik Evertse. Linear Structures in Blockciphers. In <em>Advances in Cryptology - EUROCRYPT 1987: Workshop on the Theory and Application of of Cryptographic Techniques, Netherlands. Proceedings</em>, pages 249–266, 1987.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-34-13&quot;&gt;&lt;/span&gt;[git16a] Key-recovery attacks on up to 4-round AES with a single secret S-Box, 2016. [https://github.com/Krypto-iaik/AttacksAESSecretSBox](https://github.com/Krypto-iaik/Attacks AES SecretSBox).</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-34-12&quot;&gt;&lt;/span&gt;[git16b] Low data-complexity attacks on up to 4-round AES, 2016. <a href="https://github.com/Krypto-iaik/LowDataAttacks_AES">https://github.</a> <a href="https://github.com/Krypto-iaik/LowDataAttacks_AES">com/Krypto-iaik/LowDataAttacks\\_AES</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-34-11&quot;&gt;&lt;/span&gt;[git16c] Verification of all distinguishers up to 4-rounds AES, 2016. <a href="https://github.com/Krypto-iaik/Distinguishers_AES">https://github.</a> <a href="https://github.com/Krypto-iaik/Distinguishers_AES">com/Krypto-iaik/Distinguishers\\_AES</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-34-0&quot;&gt;&lt;/span&gt;[GJN&lt;sup&gt;+&lt;/sup&gt;15] Jian Guo, Jérémy Jean, Ivica Nikolic, Kexin Qiao, Yu Sasaki, and Siang Meng Sim. Invariant Subspace Attack Against Full Midori64. Cryptology ePrint Archive, Report 2015/1189, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-34-14&quot;&gt;&lt;/span&gt;[Knu95] Lars R. Knudsen. Truncated and higher order differentials. In <em>Fast Software Encryption - FSE 1994: Second International Workshop Leuven, Belgium. Proceedings</em>, pages 196–211, 1995.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-4&quot;&gt;&lt;/span&gt;[Knu98] Lars Ramkilde Knudsen. DEAL - a 128-bit block cipher. Technical Report 151, Department of Informatics, University of Bergen, Norway, Feb. 1998.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-10&quot;&gt;&lt;/span&gt;[KR07] Lars R. Knudsen and Vincent Rijmen. Known-Key Distinguishers for Some Block Ciphers. In <em>Advances in Cryptology – ASIACRYPT 2007: 13th International Conference on the Theory and Application of Cryptology and Information Security, Malaysia, 2007. Proceedings</em>, pages 315–324, 2007.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-3&quot;&gt;&lt;/span&gt;[KW02] Lars R. Knudsen and David Wagner. Integral Cryptanalysis. In <em>Fast Software Encryption - FSE 2002: 9th International Workshop, Belgium. Revised Papers</em>, pages 112–127, 2002.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-0&quot;&gt;&lt;/span&gt;[LAAZ11] Gregor Leander, Mohamed Ahmed Abdelraheem, Hoda AlKhzaimi, and Erik Zenner. A Cryptanalysis of PRINTcipher: The Invariant Subspace Attack. In <em>Advances in Cryptology – CRYPTO 2011: 31st Annual Cryptology Conference, Santa Barbara, CA, USA, 2011. Proceedings</em>, pages 206–221, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-11&quot;&gt;&lt;/span&gt;[LDKK08] Jiqiang Lu, Orr Dunkelman, Nathan Keller, and Jongsung Kim. <em>Progress in Cryptology - INDOCRYPT 2008: 9th International Conference on Cryptology in India, India. Proceedings</em>, chapter New Impossible Differential Attacks on AES, pages 279–293. 2008.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-7&quot;&gt;&lt;/span&gt;[LJQ14] Guo-qiang Liu, Chen-Hui Jin, and Chuan-Da Qi. Improved Slender-Set Linear Cryptanalysis. In <em>Fast Software Encryption - FSE 2014: 21st International Workshop, UK. Revised Selected Papers</em>, pages 431–450, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-1&quot;&gt;&lt;/span&gt;[LMR15] Gregor Leander, Brice Minaud, and Sondre Rønjom. A Generic Approach to Invariant Subspace Attacks: Cryptanalysis of Robin, iSCREAM and Zorro. In <em>Advances in Cryptology - EUROCRYPT 2015: 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Bulgaria. Proceedings, Part I</em>, pages 254–283, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-9&quot;&gt;&lt;/span&gt;[MDRM10] Hamid Mala, Mohammad Dakhilalian, Vincent Rijmen, and Mahmoud Modarres-Hashemi. Improved impossible differential cryptanalysis of 7-round AES-128. In <em>Progress in Cryptology - INDOCRYPT 2010: 11th International Conference on Cryptology in India, India. Proceedings</em>, pages 282–291. 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-6&quot;&gt;&lt;/span&gt;[PSC&lt;sup&gt;+&lt;/sup&gt;02] Sangwoo Park, Soo Hak Sung, Seongtaek Chee, E-Joong Yoon, and Jongin Lim. On the Security of Rijndael-Like Structures against Differential and Linear Cryptanalysis. In <em>Advances in Cryptology - ASIACRYPT 2002: 8th International Conference on the Theory and Application of Cryptology and Information Security, New Zealand. Proceedings</em>, pages 176–191. 2002.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-2&quot;&gt;&lt;/span&gt;[SLG&lt;sup&gt;+&lt;/sup&gt;16] Bing Sun, Meicheng Liu, Jian Guo, Longjiang Qu, and Vincent Rijmen. New Insights on AES-Like SPN Ciphers. In <em>Advances in Cryptology – CRYPTO 2016: 36th Annual International Cryptology Conference, Santa Barbara, CA, USA. Proceedings, Part I</em>, pages 605–624, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-8&quot;&gt;&lt;/span&gt;[SLR&lt;sup&gt;+&lt;/sup&gt;15] Bing Sun, Zhiqiang Liu, Vincent Rijmen, Ruilin Li, Lei Cheng, Qingju Wang, Hoda Alkhzaimi, and Chao Li. Links Among Impossible Differential, Integral and Zero Correlation Linear Cryptanalysis. In <em>Advances in Cryptology – CRYPTO 2015: 35th Annual Cryptology Conference, Santa Barbara, CA, USA. Proceedings, Part I</em>, pages 95–115, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-35-5&quot;&gt;&lt;/span&gt;[Tie16] Tyge Tiessen. Polytopic Cryptanalysis. In <em>Advances in Cryptology - EU-ROCRYPT 2016 - 35th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Austria. Proceedings, Part I</em>, pages 214–239, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-2&quot;&gt;&lt;/span&gt;[TKKL15] Tyge Tiessen, Lars R. Knudsen, Stefan Kölbl, and Martin M. Lauridsen. Security of the AES with a Secret S-Box. In <em>Fast Software Encryption - FSE 2015: 22nd International Workshop, Turkey. Revised Selected Papers</em>, pages 175–189, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-1&quot;&gt;&lt;/span&gt;[TLS16] Yosuke Todo, Gregor Leander, and Yu Sasaki. Nonlinear Invariant Attack - Practical Attack on Full SCREAM, iSCREAM, and Midori64. In <em>Advances in Cryptology - ASIACRYPT 2016 - 22nd International Conference on the Theory and Application of Cryptology and Information Security, Hanoi, Vietnam, December 4-8, 2016, Proceedings, Part II</em>, pages 3–33, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-4&quot;&gt;&lt;/span&gt;[Tod15a] Yosuke Todo. Integral cryptanalysis on full MISTY1. In <em>Advances in Cryptology - CRYPTO 2015: 35th Annual Cryptology Conference, Santa Barbara, CA, USA. Proceedings, Part I</em>, pages 413–432, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-3&quot;&gt;&lt;/span&gt;[Tod15b] Yosuke Todo. Structural evaluation by generalized integral property. In <em>Advances in Cryptology - EUROCRYPT 2015: 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Bulgaria. Proceedings, Part I</em>, pages 287–314, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-6&quot;&gt;&lt;/span&gt;[WCC&lt;sup&gt;+&lt;/sup&gt;16] Meiqin Wang, Tingting Cui, Huaifeng Chen, Ling Sun, Long Wen, and Andrey Bogdanov. Integrals Go Statistical: Cryptanalysis of Full Skipjack Variants. In <em>Fast Software Encryption - FSE 2016: 23rd International Conference, Germany. Revised Selected Papers</em>, pages 399–415, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-36-5&quot;&gt;&lt;/span&gt;[ZWF07] Wentao Zhang, Wenling Wu, and Dengguo Feng. New Results on Impossible Differential Cryptanalysis of Reduced AES. In Kil-Hyun Nam and Gwangsoo Rhee, editors, <em>Information Security and Cryptology - ICISC 2007: 10th International Conference, Korea. Proceedings</em>, pages 239–250, 2007.</p></li>
    </ul>

    <h2 id="sec-30" class="text-2xl font-bold">&lt;span id=&quot;page-36-0&quot;&gt;&lt;/span&gt;<strong>A Subspace Definition</strong></h2>

    <p class="text-gray-300">Let (<em>K,</em> +<em>,</em> ·) be a <em>field</em> and (<em>V,</em> +) be a <em>linear (vector) space</em><a href="#page-36-7">13</a> over <em>K</em>. Let <em>W</em> be a subset of <em>V</em> , i.e. <em>W</em> ⊆ <em>V</em> . <em>W</em> is a subspace if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the operation + is &quot;well&quot; defined in <em>W</em>, i.e. ∀<em>x, y</em> ∈ <em>W</em> and ∀<em>α, β</em> ∈ <em>K</em> then <em>α</em> × <em>x</em> + <em>β</em> × <em>y</em> ∈ <em>W</em>;</li>
      <li><em>W</em> is a linear space.</li>
    </ul>

    <h4 id="sec-31" class="text-lg font-semibold mt-6"><strong>Subspaces of AES over</strong> *GF***(2&lt;sup&gt;8&lt;/sup&gt; ).**</h4>

    <p class="text-gray-300">For the case of AES, we consider the field <em>K</em> ≡ F(2&lt;sup&gt;8&lt;/sup&gt; ) defined as</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{F}(2^8) = GF(2^8)[X]/(X^8 + X^4 + X^3 + X + 1)</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the operation + is &quot;well&quot; defined in <em>V</em> , i.e. ∀<em>x, y</em> ∈ <em>V</em> then <em>x</em> + <em>y</em> ∈ <em>V</em> ;</li>
      <li>the operation + is associative;</li>
      <li>∃0 ∈ <em>V</em> such that ∀<em>x</em> ∈ <em>V</em> : <em>x</em> + 0 = 0 + <em>x</em> = <em>x</em>;</li>
      <li>∀<em>x</em> ∈ <em>V</em> exists an inverse <em>y</em> ∈ <em>V</em> such that <em>x</em> + <em>y</em> = <em>y</em> + <em>x</em> = 0;</li>
      <li><em>V</em> is linear over <em>K</em>, i.e. ∀<em>α</em> ∈ <em>K</em> and ∀<em>x, y</em> ∈ <em>V</em> then <em>α</em> × <em>x</em> ∈ <em>V</em> and <em>α</em> × (<em>x</em> + <em>y</em>) = <em>α</em> × <em>x</em> + <em>α</em> × <em>y</em>.</li>
    </ul>

    <p class="text-gray-300">We emphasize that it is not required that the operation + is commutative.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-36-7&quot;&gt;&lt;/span&gt;&lt;sup&gt;13&lt;/sup&gt;Given × : <em>K</em> × <em>V</em> → <em>V</em> , (<em>V,</em> +) is a linear space over (<em>K,</em> +<em>,</em> ·) if:</p>

    <p class="text-gray-300">where the choice of the irreducible polynomial  <span class="math">X^8 + X^4 + X^3 + X + 1</span>  is given by the definition of the MixColumns matrix. It is simple to prove that the operations + and  <span class="math">\\cdot</span>  are well defined in K, and that  <span class="math">(K, +, \\cdot)</span>  is a field (in particular, a Galois Field).</p>

    <p class="text-gray-300">The space (V, +) corresponds  <span class="math">V \\equiv \\mathbb{F}(2^8)^{4 \\times 4}</span> . For each  <span class="math">x^1, x^2 \\in \\mathbb{F}(2^8)^{4 \\times 4}</span></p>

    <p class="text-gray-300"><span class="math">$x^i \\equiv \\begin{bmatrix} x^i_{00} &amp; x^i_{01} &amp; x^i_{02} &amp; x^i_{03} \\\\ x^i_{10} &amp; x^i_{11} &amp; x^i_{12} &amp; x^i_{13} \\\\ x^i_{20} &amp; x^i_{21} &amp; x^i_{22} &amp; x^i_{23} \\\\ x^i_{30} &amp; x^i_{31} &amp; x^i_{32} &amp; x^i_{33} \\end{bmatrix}</span>$</p>

    <p class="text-gray-300">for i = 1, 2, where  <span class="math">x_{jk}^i \\in \\mathbb{F}(2^8)</span>  for each  <span class="math">j, k \\in \\{0, 1, 2, 3\\}</span> , the operation + is defined as</p>

    <p class="text-gray-300"><span class="math">$x^{1} + x^{2} := \\begin{bmatrix} y_{00} &amp; y_{01} &amp; y_{02} &amp; y_{03} \\\\ y_{10} &amp; y_{11} &amp; y_{12} &amp; y_{13} \\\\ y_{20} &amp; y_{21} &amp; y_{22} &amp; y_{23} \\\\ y_{30} &amp; y_{31} &amp; y_{32} &amp; y_{33} \\end{bmatrix}, \\qquad y_{jk} = x_{jk}^{1} + x_{jk}^{2} \\quad \\forall j, k \\in \\{0, 1, 2, 3\\}</span>$</p>

    <p class="text-gray-300">where  <span class="math">x_{ik}^1 + x_{ik}^2</span>  is defined in  <span class="math">\\mathbb{F}_{2^8}</span> , and  <span class="math">\\forall \\alpha \\in \\mathbb{F}_{2^8}</span>  the scalar product  <span class="math">\\times</span>  is defined as</p>

    <p class="text-gray-300"><span class="math">$\\alpha \\times x^{1} := \\begin{bmatrix} y_{00} &amp; y_{01} &amp; y_{02} &amp; y_{03} \\\\ y_{10} &amp; y_{11} &amp; y_{12} &amp; y_{13} \\\\ y_{20} &amp; y_{21} &amp; y_{22} &amp; y_{23} \\\\ y_{30} &amp; y_{31} &amp; y_{32} &amp; y_{33} \\end{bmatrix}, \\qquad y_{jk} = \\alpha * x_{jk}^{1} \\quad \\forall j, k \\in \\{0, 1, 2, 3\\}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\alpha * x_{jk}^1 := \\alpha \\cdot x_{jk}^1</span>  is defined as in  <span class="math">\\mathbb{F}_{2^8}</span> . With these definitions, it is simple to prove that (V, +) is a linear space over  <span class="math">(K, +, \\cdot)</span> . Moreover, it is simple to prove that each subspace defined in the paper satisfies all the required property.</p>

    <p class="text-gray-300">Using these definitions, it follows that the dimension of  <span class="math">\\mathbb{F}_{2^8}^{4\\times 4}</span>  is 16, i.e.  <span class="math">\\dim(\\mathbb{F}_{2^8}^{4\\times 4}) = 16</span> . To show this fact, it is sufficient to prove that the set of (unit) vectors  <span class="math">\\{e^{i,j}\\}_{i,j=0,1,2,3}</span> (where  <span class="math">e^{i,j} \\in \\mathbb{F}_{2^8}^{4 \\times 4}</span>  for each i,j) defined as</p>

    <p class="text-gray-300"><span class="math">$e^{i,j} \\equiv \\begin{bmatrix} \\delta_{0i} \\cdot \\delta_{0j} &amp; \\delta_{0i} \\cdot \\delta_{1j} &amp; \\delta_{0i} \\cdot \\delta_{2j} &amp; \\delta_{0i} \\cdot \\delta_{3j} \\\\ \\delta_{1i} \\cdot \\delta_{0j} &amp; \\delta_{1i} \\cdot \\delta_{1j} &amp; \\delta_{1i} \\cdot \\delta_{2j} &amp; \\delta_{1i} \\cdot \\delta_{3j} \\\\ \\delta_{2i} \\cdot \\delta_{0j} &amp; \\delta_{2i} \\cdot \\delta_{1j} &amp; \\delta_{2i} \\cdot \\delta_{2j} &amp; \\delta_{2i} \\cdot \\delta_{3j} \\\\ \\delta_{3i} \\cdot \\delta_{0j} &amp; \\delta_{3i} \\cdot \\delta_{1j} &amp; \\delta_{3i} \\cdot \\delta_{2j} &amp; \\delta_{3i} \\cdot \\delta_{3j} \\end{bmatrix}, \\qquad \\delta_{xy} = \\begin{cases} 1 \\text{ if } x = y \\\\ 0 \\text{ if } x \\neq y \\end{cases}</span>$</p>

    <p class="text-gray-300">are a basis&lt;sup&gt;14&lt;/sup&gt; for  <span class="math">\\mathbb{F}_{28}^{4\\times4}</span> .</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">Subspaces of AES over GF(2).</h4>

    <p class="text-gray-300">Another possibility is to consider the field  <span class="math">K = (GF(2), +, \\cdot)</span> , i.e. the field of two elements  <span class="math">\\{0,1\\}</span>  where</p>

    <p class="text-gray-300"><span class="math">$0+0=1+1=0</span>$
,  <span class="math">0+1=1+0=1</span> ,  <span class="math">0\\cdot 0=0\\cdot 1=1\\cdot 0=0</span> ,  <span class="math">1\\cdot 1=1</span> .</p>

    <p class="text-gray-300">•  <span class="math">\\{b_i\\}</span>  are linear independent, i.e.  <span class="math">\\forall \\alpha_i \\in K</span>  for i = 0, ..., n</p>

    <p class="text-gray-300"><span class="math">$\\alpha_0 \\times b_0 + \\alpha_1 \\times b_1 + \\dots + \\alpha_n \\times b_n \\neq 0;</span>$</p>

    <p class="text-gray-300">• each element x of V can be written as a linear combination of  <span class="math">\\{b_i\\}_{i=0,\\ldots,n}</span> , i.e.  <span class="math">\\forall x \\in V</span>  there exist  <span class="math">\\alpha_i \\in K</span>  for i = 0, ..., n such that</p>

    <p class="text-gray-300"><span class="math">$x = \\alpha_0 \\times b_0 + \\alpha_1 \\times b_1 + \\dots + \\alpha_n \\times b_n.</span>$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-37-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;14&lt;/sup&gt;A set  <span class="math">\\{b_i\\}_{i=0,\\dots,n}</span>  (where  <span class="math">b_i \\in V</span>  for all i) is a basis of a linear subspace (V,+) over  <span class="math">(K,+,\\cdot)</span>  if</p>

    <p class="text-gray-300">The space  <span class="math">(\\mathbb{F}(2^8)^{4\\times 4}, +)</span>  over  <span class="math">(GF(2), +, \\cdot)</span>  is defined exactly as before, where  <span class="math">\\forall x \\in \\mathbb{F}_{2^8}</span> : 15</p>

    <p class="text-gray-300"><span class="math">$0 * x := 0</span>$
<span class="math">1 * x := x</span> .</p>

    <p class="text-gray-300">Note that in this case the dimension of  <span class="math">\\mathbb{F}(2^8)^{4\\times 4}</span>  over the field GF(2) is 128 and not 16. Without going into the details, observe that the only linear combinations of two elements  <span class="math">x,y\\in\\mathbb{F}(2^8)^{4\\times 4}</span>  over the field GF(2) are</p>

    <p class="text-gray-300"><span class="math">$0, \\quad x, \\quad y, \\quad x+y.</span>$</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">Subspaces of AES over other field.</h4>

    <p class="text-gray-300">Only for completeness, we remember that one can use other fields than GF(2) and  <span class="math">GF(2^8)</span> . As an example, it is possible to define the space  <span class="math">(\\mathbb{F}(2^8)^{4\\times 4}, +)</span>  over the field  <span class="math">(\\mathbb{F}_{2^2}, +, \\cdot)</span>  where</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{F}_4 = GF(2^2)[X]/(X^2 + X + 1).</span>$</p>

    <p class="text-gray-300">This can be done exploiting the fact that there exists a subfield of  <span class="math">\\mathbb{F}_{2^8}</span>  which is isomorphic to  <span class="math">\\mathbb{F}_4</span> . In particular, let  <span class="math">\\mathcal{F} \\subseteq \\mathbb{F}_{2^8}</span>  the subfield defined as</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{F} = \\{0, 1, X^7 + X^5 + X^4 + X^3 + X^2, X^7 + X^5 + X^4 + X^3 + X^2 + 1\\}.</span>$</p>

    <p class="text-gray-300">Given the isomorphism  <span class="math">\\Pi : \\mathbb{F}_4 \\to \\mathcal{F}</span>  defined as</p>

    <p class="text-gray-300"><span class="math">$\\Pi(0) = 0</span>$
,  <span class="math">\\Pi(1) = 1</span> ,  <span class="math">\\Pi(X) = X^7 + X^5 + X^4 + X^3 + X^2</span> ,  <span class="math">\\Pi(X+1) = X^7 + X^5 + X^4 + X^3 + X^2 + 1</span> ,</p>

    <p class="text-gray-300">the operation  <span class="math">*: \\mathbb{F}_4 \\times \\mathbb{F}_{2^8} \\to \\mathbb{F}_{2^8}</span>  can be defined as</p>

    <p class="text-gray-300"><span class="math">$*: x \\in \\mathbb{F}_4 \\times y \\in \\mathbb{F}_{2^8} \\mapsto x * y \\equiv \\Pi(x) \\cdot y.</span>$</p>

    <h2 id="sec-34" class="text-2xl font-bold">&lt;span id=&quot;page-38-0&quot;&gt;&lt;/span&gt;<strong>B</strong> Intersecting AES Subspaces</h2>

    <p class="text-gray-300">In this section, we give all the proofs of the Lemmas presented in Sect. 3.3, that is: diagonal spaces and column spaces have non-trivial intersection, column spaces and mixed spaces have non-trivial intersection, but diagonal spaces and mixed spaces have only trivial intersection.</p>

    <p class="text-gray-300"><strong>Lemma 6.</strong>
<span class="math">$\\mathcal{D}_i \\cap \\mathcal{C}_j = \\langle e_{i+j,j} \\rangle</span>$
and  <span class="math">\\mathcal{ID}_i \\cap \\mathcal{C}_j = \\langle e_{i-j,j} \\rangle</span> .</p>

    <p class="text-gray-300"><em>Proof.</em>  <span class="math">\\mathcal{D}_i</span>  space corresponds to a symbolic matrix with variables along the <em>i</em>-th diagonal, while  <span class="math">\\mathcal{C}_j</span>  has variables in the <em>j</em>-th column. Any diagonal and column meets in exactly one byte, precisely in row j+i and column <em>j</em>. The proof is equivalent for the intersection  <span class="math">\\mathcal{ID}_i \\cap \\mathcal{C}_j</span> .</p>

    <p class="text-gray-300">It follows that  <span class="math">\\mathcal{D}_I \\cap \\mathcal{C}_J = \\langle e_{j+i,j} | i \\in I, j \\in J \\rangle</span>  and  <span class="math">\\mathcal{I}\\mathcal{D}_I \\cap \\mathcal{C}_J = \\langle e_{i-j,j} | i \\in I, j \\in J \\rangle</span>  where j+i and i-j are taken modulo 4, where the intersections have dimension  <span class="math">|I| \\cdot |J|</span> .</p>

    <p class="text-gray-300">Lemma 7.
<span class="math">$C_i \\cap \\mathcal{M}_j = \\langle MC(e_{j+i,i}) \\rangle</span>$
.</p>

    <p class="text-gray-300">Proof. We have that  <span class="math">MC \\circ SR(\\mathcal{D}_i) = \\mathcal{C}_i</span>  and by definition 5,  <span class="math">\\mathcal{M}_i = MC(\\mathcal{ID}_i) = MC \\circ SR(\\mathcal{C}_i)</span> . By Lemma 3,  <span class="math">\\mathcal{D}_i \\cap \\mathcal{C}_j = \\langle e_{j+i,j} \\rangle</span> . Thus it follows that  <span class="math">\\langle MC(e_{j+i,j}) \\rangle = MC \\circ SR(\\mathcal{D}_i) \\cap MC \\circ SR(\\mathcal{C}_j) = \\mathcal{D}_i \\cap \\mathcal{M}_j</span> . Finally, since  <span class="math">SR(e_{r,c}) = e_{r,c-r}</span> , we obtain that  <span class="math">\\langle MC \\circ SR(e_{j+i,j}) \\rangle = \\langle MC(e_{j+i,i}) \\rangle</span> .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-38-1&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;15&lt;/sup&gt;Observe that 0,1 are elements of GF(2) while x is in  <span class="math">\\mathbb{F}_{28}</span> .</p>

    <p class="text-gray-300">Thus, for two subspaces C<em>&lt;sup&gt;I&lt;/sup&gt;</em> and M<em>&lt;sup&gt;J&lt;/sup&gt;</em> for non-empty subsets <em>I</em> and <em>J</em> of {0<em>,</em> 1<em>,</em> 2<em>,</em> 3}, it follows that C<em>&lt;sup&gt;I&lt;/sup&gt;</em> ∩ M<em>&lt;sup&gt;J&lt;/sup&gt;</em> = h<em>MC</em>(<em>ej</em>+<em>i,i</em>)|<em>i</em> ∈ <em>I, j</em> ∈ <em>J</em>i (where <em>i</em> + <em>j</em> is taken modulo 4) which has dimension |<em>I</em>| · |<em>J</em>|. While the spaces D<em>&lt;sup&gt;I&lt;/sup&gt;</em> and C<em>&lt;sup&gt;J&lt;/sup&gt;</em> , ID<em>&lt;sup&gt;I&lt;/sup&gt;</em> and C<em>&lt;sup&gt;J&lt;/sup&gt;</em> , and C<em>&lt;sup&gt;I&lt;/sup&gt;</em> and M<em>&lt;sup&gt;J&lt;/sup&gt;</em> intersect non-trivially, the spaces D<em>&lt;sup&gt;I&lt;/sup&gt;</em> and M<em>&lt;sup&gt;J&lt;/sup&gt;</em> and the spaces ID<em>&lt;sup&gt;I&lt;/sup&gt;</em> and M<em>&lt;sup&gt;J&lt;/sup&gt;</em> intersect trivially. In particular:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-39-0&quot;&gt;&lt;/span&gt;<strong>Lemma 8.</strong> D<em>&lt;sup&gt;i&lt;/sup&gt;</em> ∩ M<em>&lt;sup&gt;j&lt;/sup&gt;</em> = ID<em>&lt;sup&gt;i&lt;/sup&gt;</em> ∩ M<em>&lt;sup&gt;j&lt;/sup&gt;</em> = {0} <em>for all i and j.</em></p>

    <p class="text-gray-300"><em>Proof.</em> A basis for M<em>&lt;sup&gt;j&lt;/sup&gt;</em> is given by:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{M}_j = \\langle MC(e_{0,j}), MC(e_{1,j-1}), MC(e_{2,j-2}), MC(e_{3,j-3}) \\rangle,</span>$</p>

    <p class="text-gray-300">while a basis for D<em>&lt;sup&gt;i&lt;/sup&gt;</em> is given by D<em>&lt;sup&gt;i&lt;/sup&gt;</em> = hh<em>e</em>0<em>,i, e</em>1<em>,i</em>+1<em>, e</em>2<em>,i</em>+2<em>, e</em>3<em>,i</em>+3i, where in both cases the indexes are taken modulo 4.</p>

    <p class="text-gray-300">Suppose by contradiction that D<em>&lt;sup&gt;i&lt;/sup&gt;</em> and M<em>&lt;sup&gt;j&lt;/sup&gt;</em> has a nonzero intersection. This implies that there exist <em>x&lt;sup&gt;k&lt;/sup&gt;</em> and <em>y&lt;sup&gt;k&lt;/sup&gt;</em> for <em>k</em> = 0<em>, ...,</em> 3 such that</p>

    <p class="text-gray-300"><span class="math">$\\bigoplus_{k=0}^{3} x_k \\cdot e_{k,i+k} \\oplus \\bigoplus_{k=0}^{3} y_k \\cdot MC(e_{k,j-k}) =</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\bigoplus_{k=0}^{3} \\left[ x_{k-i} \\cdot e_{k-i,k} \\oplus y_{k+j} \\cdot MC(e_{k+j,k}) \\right] = 0.</span>$</p>

    <p class="text-gray-300">has a nontrivial solution (where at least one <em>x&lt;sup&gt;k&lt;/sup&gt;</em> or/and <em>y&lt;sup&gt;k&lt;/sup&gt;</em> is different from zero). The only possible solution of the previous equivalence is given by</p>

    <p class="text-gray-300"><span class="math">$x_{k-i} \\cdot e_{k-i,k} \\oplus y_{k+j} \\cdot MC(e_{k+j,k}) = 0</span>$</p>

    <p class="text-gray-300">for each <em>k</em> (note that <em>e</em>·<em>,n</em> and <em>e</em>·<em>,m</em> lie on different columns for <em>n</em> 6= <em>m</em> - similar for <em>MC</em>(<em>e</em>·<em>,n</em>) and <em>MC</em>(<em>e</em>·<em>,m</em>)). This is clearly impossible since <em>ek</em>−<em>i,k</em> and <em>MC</em>(<em>ek</em>+<em>j,k</em>) are linearly independent for each <em>k</em> = 0<em>, ...,</em> 3. Thus, D<em>&lt;sup&gt;i&lt;/sup&gt;</em> and M<em>&lt;sup&gt;j&lt;/sup&gt;</em> intersect only in zero.</p>

    <p class="text-gray-300">The proof is equivalent for the intersection ID<em>&lt;sup&gt;i&lt;/sup&gt;</em> ∩ M<em>&lt;sup&gt;j&lt;/sup&gt;</em> .</p>

    <p class="text-gray-300">As long as |<em>I</em>| + |<em>J</em>| ≤ 4, we have that any combinations of subspaces D<em>&lt;sup&gt;I&lt;/sup&gt;</em> (or ID<em>&lt;sup&gt;I&lt;/sup&gt;</em> ) and M<em>&lt;sup&gt;J&lt;/sup&gt;</em> only intersect in the zero vector. Indeed, consider the sum over <em>k</em> defined in Eq. <a href="#page-39-0">(B)</a>. If |<em>I</em>| + |<em>J</em>| ≤ 4, then for each <em>k</em> (i.e. for each column) there are at most four terms. Among them, there is at least one term of the form h<em>e</em>·<em>,k</em>i and at least one of the form h<em>MC</em>(<em>e</em>·<em>,k</em>)i. Thus, equation <a href="#page-39-0">(B)</a> has only trivial solutions. Instead, note that this is not true if |<em>I</em>| + |<em>J</em>| <em>&gt;</em> 4. Indeed, in this case for each <em>k</em> (i.e. for each column), the equation <a href="#page-39-0">(B)</a> has at least 5 terms. Since there are only 4 rows, it is always possible to find non trivial solutions<a href="#page-39-1">16</a> .</p>

    <p class="text-gray-300"><strong>Lemma 9.</strong> D<em>&lt;sup&gt;I&lt;/sup&gt;</em> ∩ M<em>&lt;sup&gt;J&lt;/sup&gt;</em> = ID<em>&lt;sup&gt;I&lt;/sup&gt;</em> ∩ M<em>&lt;sup&gt;J&lt;/sup&gt;</em> = {0} <em>for all I and J such that</em> |<em>I</em>| + |<em>J</em>| ≤ 4<em>.</em></p>

    <p class="text-gray-300">Finally, we prove the following proposition of Sect. <a href="#page-18-1">4.3.</a></p>

    <p class="text-gray-300"><strong>Proposition 4.</strong> <em>For any</em> M<em>&lt;sup&gt;I&lt;/sup&gt; and</em> C<em>&lt;sup&gt;J&lt;/sup&gt; , we have that P r</em>(<em>x</em> ∈ C<em>&lt;sup&gt;J&lt;/sup&gt;</em> | <em>x</em> ∈ M<em>&lt;sup&gt;I&lt;/sup&gt;</em> ) = (2&lt;sup&gt;8&lt;/sup&gt; ) −4|<em>I</em>|+|<em>I</em>|·|<em>J</em>| <em>.</em></p>

    <p class="text-gray-300"><span class="math">$(\\mathcal{D}_{0,1,2}\\cap\\mathcal{M}_{0,1})_{col(0)}\\equiv MC\\left(\\begin{bmatrix}x\\\\(\\alpha+1)\\cdot x\\\\0\\\\0\\end{bmatrix}\\right)\\equiv\\begin{bmatrix}(\\alpha^2+\\alpha+1)\\cdot x\\\\(\\alpha^2+\\alpha+1)\\cdot x\\\\\\alpha\\cdot x\\\\0\\end{bmatrix}\\qquad\\forall x\\in\\mathbb{F}_{2^8}.</span>$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-39-1&quot;&gt;&lt;/span&gt;&lt;sup&gt;16&lt;/sup&gt;For example, the first column (i.e. <em>k</em> = 0) of the intersection D0<em>,</em>1<em>,</em>&lt;sup&gt;2&lt;/sup&gt; ∩ M0<em>,</em>&lt;sup&gt;1&lt;/sup&gt; is equal to:</p>

    <p class="text-gray-300"><em>Proof.</em> Let Z = M<em>I</em>∩C<em>&lt;sup&gt;J&lt;/sup&gt;</em> . In Sect. <a href="#page-15-0">3.3,</a> we have seen that dim(Z) = dim(M<em>I</em>∩C<em>&lt;sup&gt;J&lt;/sup&gt;</em> ) = |<em>I</em>|·|<em>J</em>|. Let Y the subspace of dimension 4 · |<em>I</em>| − |<em>I</em>| · |<em>J</em>| such that M<em>&lt;sup&gt;I&lt;/sup&gt;</em> = Y ⊕ Z, and let <em>π</em>&lt;sup&gt;Y&lt;/sup&gt; and <em>π</em>&lt;sup&gt;Z&lt;/sup&gt; the projection of M<em>&lt;sup&gt;I&lt;/sup&gt;</em> on Y and Z respectively:</p>

    <p class="text-gray-300"><span class="math">$\\pi_{\\mathcal{Y}}: \\mathcal{M}_I \\to \\mathcal{Y}, \\qquad \\qquad \\pi_{\\mathcal{Y}}(x) = x_y, \\\\ \\pi_{\\mathcal{Z}}: \\mathcal{M}_I \\to \\mathcal{Z}, \\qquad \\qquad \\pi_{\\mathcal{Z}}(x) = x_z.</span>$</p>

    <p class="text-gray-300">That is, ∀<em>x</em> ∈ M<em>&lt;sup&gt;I&lt;/sup&gt;</em> , there exists unique <em>x&lt;sup&gt;y&lt;/sup&gt;</em> ∈ Y and <em>x&lt;sup&gt;z&lt;/sup&gt;</em> ∈ Z such that <em>x</em> = <em>x&lt;sup&gt;z&lt;/sup&gt;</em> ⊕ <em>xy</em>. It follows that <em>P r</em>(<em>x</em> ∈ C<em>&lt;sup&gt;J&lt;/sup&gt;</em> | <em>x</em> ∈ M<em>&lt;sup&gt;I&lt;/sup&gt;</em> ) = <em>P r</em>(<em>π</em>&lt;sup&gt;Y&lt;/sup&gt; (<em>x</em>) = 0 | <em>x</em> ∈ M<em>&lt;sup&gt;I&lt;/sup&gt;</em> ). Since Y has dimension 4 · |<em>I</em>| − |<em>I</em>| · |<em>J</em>|, we obtain:</p>

    <p class="text-gray-300"><span class="math">$Pr(x \\in \\mathcal{C}_J \\mid x \\in \\mathcal{M}_I) = Pr(\\pi_{\\mathcal{Y}}(x) = 0 \\mid x \\in \\mathcal{M}_I) = (2^8)^{-4 \\cdot |I| + |I| \\cdot |J|}.</span>$</p>

    <h2 id="sec-35" class="text-2xl font-bold">&lt;span id=&quot;page-40-0&quot;&gt;&lt;/span&gt;<strong>C Secret-Key Distinguishers for 3 and 4 rounds of AES - Details</strong></h2>

    <p class="text-gray-300">In this section, we provide more details about the secret key distinguisher presented in Sect. using the subspace trail notation. In the following, we present an alternative description of the truncated differential distinguisher on 3-round of AES using the subspace trail notation, and we re-propose a distinguisher based on the balance property using the subspace trail notation.</p>

    <h2 id="sec-36" class="text-2xl font-bold">&lt;span id=&quot;page-40-1&quot;&gt;&lt;/span&gt;<strong>C.1 Another Explanation of the Truncated Differential Distinguisher on 3-Round of AES</strong></h2>

    <p class="text-gray-300">A possible explanation of the truncated differential distinguisher on 3-round of AES is given in Sect. <a href="#page-18-1">4.3.</a> Here we show that it is possible to obtain the same result considering the intersection of C<em>&lt;sup&gt;I&lt;/sup&gt;</em> and D<em>&lt;sup&gt;J&lt;/sup&gt;</em> after one round, instead of the intersection of M<em>&lt;sup&gt;I&lt;/sup&gt;</em> and C<em>&lt;sup&gt;J&lt;/sup&gt;</em> after two rounds.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-40-2&quot;&gt;&lt;/span&gt;    <img src="_page_40_Picture_10.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Figure 11:</strong> Truncated differential characteristic over 3-round AES. White box denotes a byte with a zero difference, while black box denotes a byte with a non-zero difference.</p>

    <p class="text-gray-300">Consider a coset of D<em>&lt;sup&gt;I&lt;/sup&gt;</em> as starting point. As we have seen in Lemma <a href="#page-15-1">1,</a> a coset of D<em>&lt;sup&gt;I&lt;/sup&gt;</em> is mapped into a coset of C<em>&lt;sup&gt;I&lt;/sup&gt;</em> with probability 1 after one round. Thus, if we consider two elements that belong to the same cosets of D<em>&lt;sup&gt;I&lt;/sup&gt;</em> , after one round they belong in the same coset of C<em>&lt;sup&gt;I&lt;/sup&gt;</em> for sure. However, at the same time and with a certain probability, it is possible that these two elements belong to the same coset of D<em>&lt;sup&gt;J&lt;/sup&gt;</em> ∩ C<em>&lt;sup&gt;I&lt;/sup&gt;</em> ⊆ D<em>&lt;sup&gt;J&lt;/sup&gt;</em> for a certain <em>J</em>. In particular, the following proposition holds:</p>

    <p class="text-gray-300"><strong>Proposition 5.</strong> <em>For any</em> C<em>&lt;sup&gt;I&lt;/sup&gt; and</em> D<em>&lt;sup&gt;J&lt;/sup&gt; , we have that P r</em>(<em>x</em> ∈ D<em>&lt;sup&gt;J&lt;/sup&gt;</em> | <em>x</em> ∈ C<em>&lt;sup&gt;I&lt;/sup&gt;</em> ) = (2&lt;sup&gt;8&lt;/sup&gt; ) −4|<em>I</em>|+|<em>I</em>|·|<em>J</em>| <em>.</em></p>

    <p class="text-gray-300"><em>Proof.</em> Let Z = C<em>&lt;sup&gt;I&lt;/sup&gt;</em> ∩ D<em>&lt;sup&gt;J&lt;/sup&gt;</em> . In Sect. <a href="#page-15-0">3.3,</a> it is shown that dim(Z) = dim(C<em>&lt;sup&gt;I&lt;/sup&gt;</em> ∩ D<em>&lt;sup&gt;J&lt;/sup&gt;</em> ) = |<em>I</em>| · |<em>J</em>|. Let Y the subspace of dimension 4 · |<em>I</em>| − |<em>I</em>| · |<em>J</em>| such that C<em>&lt;sup&gt;I&lt;/sup&gt;</em> = Y ⊕ Z, and let <em>π</em>&lt;sup&gt;Y&lt;/sup&gt; and <em>π</em>&lt;sup&gt;Z&lt;/sup&gt; the projection of C<em>&lt;sup&gt;I&lt;/sup&gt;</em> on Y and Z respectively:</p>

    <p class="text-gray-300"><span class="math">$\\pi_{\\mathcal{Y}}: \\mathcal{C}_I \\to \\mathcal{Y}, \\qquad \\qquad \\pi_{\\mathcal{Y}}(x) = x_y,</span>$</p>

    <p class="text-gray-300"><span class="math">$\\pi_{\\mathcal{Z}}: \\mathcal{C}_I \\to \\mathcal{Z}, \\qquad \\qquad \\pi_{\\mathcal{Z}}(x) = x_z.</span>$</p>

    <p class="text-gray-300">    <img src="_page_41_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Figure 12:</strong> 3-round distinguishers for AES (the index n is defined as  <span class="math">n := (2^8)^{4 \\cdot |I| - |I| \\cdot |J|}</span> ).</p>

    <p class="text-gray-300">That is,  <span class="math">\\forall x \\in \\mathcal{C}_I</span> , there exists unique  <span class="math">x_y \\in \\mathcal{Y}</span>  and  <span class="math">x_z \\in \\mathcal{Z}</span>  such that  <span class="math">x = x_z \\oplus x_y</span> . It follows that  <span class="math">Pr(x \\in \\mathcal{D}_J \\mid x \\in \\mathcal{C}_I) = Pr(\\pi_{\\mathcal{Y}}(x) = 0 \\mid x \\in \\mathcal{C}_I)</span> . Since  <span class="math">\\mathcal{Y}</span>  has dimension  <span class="math">4 \\cdot |I| - |I| \\cdot |J|</span> , we obtain:</p>

    <p class="text-gray-300"><span class="math">$Pr(x \\in \\mathcal{D}_J \\mid x \\in \\mathcal{C}_I) = Pr(\\pi_{\\mathcal{Y}}(x) = 0 \\mid x \\in \\mathcal{C}_I) = (2^8)^{-4 \\cdot |I| + |I| \\cdot |J|}.</span>$</p>

    <p class="text-gray-300">That is, if two elements belong to the same coset of  <span class="math">\\mathcal{C}_I</span> , then they belong to the same coset of  <span class="math">\\mathcal{D}_J</span>  with probability  <span class="math">(2^8)^{-4|I|+|I|\\cdot|J|}</span> . More precisely, given two texts in the same coset of  <span class="math">\\mathcal{D}_I</span> , after one round they belong to the same coset of  <span class="math">\\mathcal{C}_I \\cap \\mathcal{D}_J</span>  with probability  <span class="math">(2^8)^{-4|I|+|I|\\cdot|J|}</span>  (where  <span class="math">\\mathcal{C}_I \\cap \\mathcal{D}_J \\subseteq \\mathcal{D}_J</span> ). As we have just seen, a coset of  <span class="math">\\mathcal{D}_J</span>  is mapped into a coset of  <span class="math">\\mathcal{M}_J</span>  after two rounds. It follows that if two elements belong to the same coset of  <span class="math">\\mathcal{D}_I</span> , the probability that they belong to the same coset of  <span class="math">\\mathcal{M}_J</span>  after three rounds is equal to  <span class="math">(2^8)^{-4|I|+|I|\\cdot|J|}</span> . The case |I|=1 and |J|=3 is depicted in Fig. 11.</p>

    <p class="text-gray-300">For a more detailed explanation using subspace trail, consider the following argument. Given a coset of  <span class="math">C_I</span> , it can be seen as a union of coset of  <span class="math">D_J</span> , that is:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{C}_I \\oplus a = \\bigcup_{x \\in \\mathcal{C}_I \\oplus a \\setminus \\mathcal{D}_J} \\mathcal{D}_J \\oplus x,</span>$</p>

    <p class="text-gray-300">as depicted in Fig. C.1. In particular, note that the number of  <span class="math">x \\in \\mathcal{C}_I \\oplus a \\setminus \\mathcal{D}_J</span>  is exactly  <span class="math">(2^8)^{4\\cdot|I|-|I|\\cdot|J|}</span> . If we take two elements in the same coset of  <span class="math">\\mathcal{D}_I</span> , then after one round they belong to the same coset of  <span class="math">\\mathcal{C}_I</span> . Since a coset of  <span class="math">\\mathcal{C}_I</span>  can be seen as the union of  <span class="math">(2^8)^{4\\cdot|I|-|I|\\cdot|J|}</span>  cosets of  <span class="math">\\mathcal{D}_J</span> , the probability that these two elements belong to the same coset of  <span class="math">\\mathcal{D}_J</span>  after one round is exactly  <span class="math">(2^8)^{-4\\cdot|I|+|I|\\cdot|J|}</span> . In this way, it is possible to obtain the previous result.</p>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-41-0&quot;&gt;&lt;/span&gt;C.2 Description of the 4-round Zero-Sum Distinguisher using the Subspace Trail</h3>

    <p class="text-gray-300">Integral cryptanalysis [DKR97, KW02] is a cryptanalytic attack that is particularly applicable to block ciphers based on substitution-permutation networks, like AES. Unlike differential cryptanalysis, which uses pairs of chosen plaintexts with a fixed XOR difference, integral cryptanalysis uses sets (or multi-sets) of chosen plaintexts in which one part is held constant and another part varies through <em>all</em> possibilities. For example, an attack might use 256 chosen plaintexts that have all but 1 of its byte the same, and all differ in that 1 byte. Such a set has a XOR sum of 0, and it is possible to prove that the XOR sum of the corresponding sets after three rounds is equal to 0.</p>

    <p class="text-gray-300">An integral distinguisher can also be constructed for four rounds of AES. In particular, a 4-round integral distinguisher for AES exploits the fact that summing over all  <span class="math">2^{32}</span>  ciphertexts (formed by encrypting a coset of a diagonal space  <span class="math">\\mathcal{D}_i</span>  four rounds) is zero (e.g. [KR07] for details). Here we show how this zero-sum distinguisher can be re-interpreted in terms of subspace trails. The same analysis can also be done for 3-round AES.</p>

    <p class="text-gray-300">First of all, note that the entire space  <span class="math">\\mathbb{F}_{28}^{4\\times4}</span>  can be decomposed as  <span class="math">\\mathbb{F}_{28}^{4\\times4} = \\mathcal{M}_0 \\oplus \\mathcal{M}_1 \\oplus \\mathcal{M}_2 \\oplus \\mathcal{M}_3</span> , where  <span class="math">\\mathcal{M}_j</span>  is the j-th mixed space defined above. Let  <span class="math">\\mathcal{M}_I = \\mathcal{M}_0 \\oplus \\mathcal{M}_1 \\oplus \\mathcal{M}_2</span> . If we encrypt the  <span class="math">2^{32}</span>  plaintexts of a coset of  <span class="math">\\mathcal{D}_i</span>  (for four round with the final MixColumns), we get a set of  <span class="math">2^{32}</span>  ciphertexts  <span class="math">C = \\{c_1, c_2, \\ldots, c_{2^{32}}\\}</span> , where each  <span class="math">c_i</span>  belongs to a different coset of  <span class="math">\\mathcal{M}_I</span> . If we decompose these vectors with respect to the subspaces  <span class="math">\\mathcal{M}_i</span> , each  <span class="math">c_i</span>  can be written as  <span class="math">c_i = c_{i,0} \\oplus c_{i,1} \\oplus c_{i,2} \\oplus c_{i,3}</span>  where  <span class="math">c_{i,j} \\in \\mathcal{M}_j</span> . Since each  <span class="math">c_i</span>  belongs to a different coset of  <span class="math">\\mathcal{M}_I</span> , it means that the components  <span class="math">c_{i,3}</span>  are all different; thus their sum must be zero since it amounts to summing over all vectors in  <span class="math">\\mathcal{M}_3</span> . Since this property holds for all four choices of  <span class="math">\\mathcal{M}_I</span> , it means that all of the components  <span class="math">c_{i,j}</span>  must be different with respect to the same subspace  <span class="math">\\mathcal{M}_j</span> , thus the sum over all the vectors in C is zero.</p>

    <p class="text-gray-300">For completeness, another explanation of the 4-round zero-sum distinguisher is possible, and exploits the subspace trail and the zero-sum property over 3 rounds. As we have seen, a coset of a diagonal space  <span class="math">\\mathcal{D}_i \\oplus a</span>  is mapped after one round into a coset of a column space  <span class="math">\\mathcal{C}_i \\oplus b</span> . Let i=0 for simplicity. By definition,  <span class="math">\\mathcal{C}_0 \\oplus b = (\\mathcal{C}_0 \\cap \\mathcal{D}_0) \\oplus (\\mathcal{C}_0 \\cap \\mathcal{D}_{1,2,3}) \\oplus b</span> , that is:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{C}_0 \\oplus b = \\bigcup_{x \\in (\\mathcal{C}_0 \\cap \\mathcal{D}_{1,2,3}) \\oplus b} (\\mathcal{C}_0 \\cap \\mathcal{D}_0) \\oplus x,</span>$</p>

    <p class="text-gray-300">where  <span class="math">|\\mathcal{C}_0 \\cap \\mathcal{D}_{1,2,3}| = 2^{24}</span> . Since each coset  <span class="math">(\\mathcal{C}_0 \\cap \\mathcal{D}_0) \\oplus x</span>  corresponds to a set with only one active bytes, the sum of corresponding ciphertexts after three rounds is equal to zero (due to the three-round zero sum property of AES). Note that this property holds for each coset  <span class="math">(\\mathcal{C}_0 \\cap \\mathcal{D}_0) \\oplus x</span> , that is for each  <span class="math">x \\in (\\mathcal{C}_0 \\cap \\mathcal{D}_{1,2,3}) \\oplus b</span> . Thus, the sum over all  <span class="math">2^{32}</span>  ciphertexts formed by encrypting a coset of a diagonal space  <span class="math">\\mathcal{D}_i</span>  four rounds is equal to zero.</p>

    <p class="text-gray-300">Finally, note that the integral distinguisher works exactly in the same way also in the decryption direction (independently of the presence of the final MixColumns operation). In particular, for the 4-round case and if the final MixColumns operation is not omitted, given  <span class="math">2^{32}</span>  ciphertexts that belong to the same coset of  <span class="math">\\mathcal{M}_i</span>  with |i|=1, then the sum of the corresponding plaintexts is equal to zero. Instead, if the final MixColumns operation is omitted, given  <span class="math">2^{32}</span>  ciphertexts in the same coset of  <span class="math">\\mathcal{ID}_i</span>  with |i|=1, then the sum of the corresponding plaintexts is zero.</p>

    <p class="text-gray-300">In this section, we highlight the relationship between the 4-round subspace trails found in Sect. 4.4 and impossible differential cryptanalysis. As we have seen, if  <span class="math">0 &lt; \\dim(\\mathcal{D}_I) + \\dim(\\mathcal{M}_J) \\le 16</span>  then  <span class="math">Pr(R^{(4)}(x) \\oplus R^{(4)}(y) \\in \\mathcal{M}_J \\mid x \\oplus y \\in \\mathcal{D}_I) = 0</span> . We define this subspace trail as a &quot;0-Probability Subspace Trail&quot; or &quot;Impossible subspace trail&quot;. In the following, we'd like to show the relationship between (5) and Impossible Differential Analysis [BK01], [BBS99], which is a generalization of Differential Analysis [BS91]. Differential cryptanalysis traditionally considers characteristics or differentials with relatively high probabilities and uses them to distinguish the correct unknown keys from the wrong keys. The idea is that the difference predicted by the differential appears frequently only when the correct key is used to decrypt the last few rounds of many pairs of ciphertexts. Impossible differential analysis exploits instead the differences which should not occur (i.e., that have probability exactly zero). In this case, a key that decrypts a pair of ciphertexts to that difference is certainly wrong.</p>

    <p class="text-gray-300">Using arguments similar to Sect. 4.4, if  <span class="math">|I| + |J| \\le 4</span>  and if the final MixColumns operation is omitted, then  <span class="math">Pr(R_f \\circ R^{(3)}(x) \\oplus R_f \\circ R^{(3)}(y) \\in \\mathcal{ID}_J \\mid x \\oplus y \\in \\mathcal{D}_I) = 0</span> . Thus, consider 5 rounds of AES:</p>

    <p class="text-gray-300"><span class="math">$p^h \\xrightarrow{R(\\cdot)} s^h \\xrightarrow{R_f \\circ R^{(3)}(\\cdot)} c^h</span>$</p>

    <p class="text-gray-300">for h = 1, 2. If there exists a pair of ciphertexts  <span class="math">c^1</span>  and  <span class="math">c^2</span>  that belong to the same coset of  <span class="math">\\mathcal{ID}_J</span>  (that is  <span class="math">c^1 \\oplus c^2 \\in \\mathcal{ID}_J</span> ), then all the keys of the first round such that  <span class="math">s^1 \\oplus s^2 = R(p^1) \\oplus R(p^2) \\in \\mathcal{D}_I</span>  for  <span class="math">0 &lt; \\dim(\\mathcal{D}_I) + \\dim(\\mathcal{ID}_J) \\le 16</span>  are certainly wrong.</p>

    <p class="text-gray-300">To exploit this fact in order to discover the key, the idea is to choose plaintexts with a particular shape. For simplicity, let  <span class="math">I = \\{0\\}</span>  fixed. Suppose to considers pair of plaintexts  <span class="math">p^1, p^2</span>  such that  <span class="math">p^1_{i,j} = p^2_{i,j}</span>  for each i, j = 0, ...3 with  <span class="math">(i,j) \\neq \\{(0,0), (1,3), (2,2), (3,1)\\}</span>  (that is  <span class="math">SR^{-1}(p^1)_{col(i)} = SR^{-1}(p^2)_{col(i)}</span>  for i = 1, 2, 3). This choice implies that for each key K:</p>

    <p class="text-gray-300"><span class="math">$R(p^1)_{col(i)} = R(p^2)_{col(i)}</span>$
<span class="math">\\forall i = 1, 2, 3,</span></p>

    <p class="text-gray-300">that is the second, the third and the fourth columns of the two texts are equal after one round&lt;sup&gt;17&lt;/sup&gt;. Given  <span class="math">c^1</span>  and  <span class="math">c^2</span>  such that  <span class="math">c^1 \\oplus c^2 \\in \\mathcal{ID}_J</span>  (with  <span class="math">\\dim(Y_J) \\geq 12</span> ), in order to guarantee that  <span class="math">R(p^1) \\oplus R(p^2) \\in \\mathcal{D}_I</span> , the attacker has to work only on the first column of  <span class="math">R(p^1)</span>  and  <span class="math">R(p^2)</span> , that is only on the first column of  <span class="math">SR^{-1}(k)</span>  (for the other columns, all the values are fine). Thus, all the keys such that  <span class="math">R(p^1) \\oplus R(p^2) \\in \\mathcal{D}_I</span>  are certainly wrong.</p>

    <p class="text-gray-300">There are three possibilities that can be exploited for an impossible differential attack, which are  <span class="math">\\dim(\\mathcal{D}_I) = 4</span>  and  <span class="math">\\dim(\\mathcal{D}_J) = 12</span> ,  <span class="math">\\dim(\\mathcal{D}_I) = 12</span>  and  <span class="math">\\dim(\\mathcal{D}_J) = 4</span> , and finally  <span class="math">\\dim(\\mathcal{D}_I) = \\dim(\\mathcal{D}_J) = 8</span> . For each of these combinations, using the definitions of  <span class="math">\\mathcal{D}_I</span>  and  <span class="math">\\mathcal{I}\\mathcal{D}_J</span>  it is possible to obtain and to list all the impossible input/output combinations of difference that can be exploited to set up the attack. In particular, the first combination is exploited for example in [LDKK08] and in [BA08], while the second one is exploited in [MDRM10]. Interestingly, in literature there isn't any attack that exploits the last (impossible) input/output combination of differences. A possible reason of this fact is that using this combination it is not possible to attack 7 rounds of AES-128 as for the other combinations. Moreover, even if it is possible to attack 7 rounds of AES-192 and 8 rounds of AES-256 using it, our results (omitted due to page limit) show that in this case the data and the computational complexity is not better than the other attacks already present in literature that exploit the first and the second impossible combinations.</p>

    <h2 id="sec-38" class="text-2xl font-bold">&lt;span id=&quot;page-43-0&quot;&gt;&lt;/span&gt;E Key Recovery Attacks on 3 and 4 Rounds of AES</h2>

    <p class="text-gray-300">Starting from the subspace trails of AES found in the previous section, in the following we show how to exploit them to set up low-data complexity attacks. In particular, in the following we focus only on the subspace trail distinguisher on 2 rounds presented in Sect. 4.1 and on AES-128. The following attack is a truncated differential attack, where the attacker exploits the relationship among the differences of bytes in different positions to recover the key. The attack on 3 rounds can be extended at the end - App. E.4 - or at the beginning - App. E.5 - in order to set up competitive attacks on 4 rounds of AES. Moreover, it is also possible to attack 5 rounds of AES using both the extensions, but such an attack is no more competitive with respect to the others present in literature.</p>

    <p class="text-gray-300"><span class="math">$R(SR^{-1}(p^j)_{col(i)} = [k^1 \\oplus MC \\circ S\\text{-Box}(p^j \\oplus k^0)]_{col(i)},</span>$</p>

    <p class="text-gray-300">where we use the fact that she ShiftRows, the SubBytes and the AddRoundKey operations can be switched positions. Thus, since the MixColumns operation works on each column independently by the others and since  <span class="math">SR \\circ SR^{-1}(p^1)_{col(i)} = p^1_{col(i)} = p^2_{col(i)} = SR \\circ SR^{-1}(p^1)_{col(i)}</span>  for each i=1,2,3, it follows that the second, the third and the fourth columns of the two texts are equal after one round.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-43-1&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;17&lt;/sup&gt;For completeness, to show this fact we compute the <em>i</em>-th column of  <span class="math">SR^{-1}(p^1)</span>  and  <span class="math">SR^{-1}(p^2)</span>  after one round for i = 1, 2, 3. By simple computation, we have that for each j = 1, 2:</p>

    <p class="text-gray-300">Consider  <span class="math">\\mathcal{D}_I</span>  with dim( <span class="math">\\mathcal{D}_I</span> ) = 4 (that is |I| = 1). For simplicity, we show our attack only for the case  <span class="math">I = \\{0\\}</span> . In this case,  <span class="math">\\mathcal{D}_I</span>  and  <span class="math">\\mathcal{M}_I</span>  are the subsets of dimension 4 corresponding to the following symbolic matrix:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{D}_{I} \\equiv \\begin{bmatrix} x_{1} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; x_{2} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; x_{3} &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; x_{4} \\end{bmatrix} \\qquad \\mathcal{M}_{I} \\equiv \\begin{bmatrix} a_{1}(x_{1}) &amp; a_{2}(x_{4}) &amp; a_{2}(x_{3}) &amp; a_{3}(x_{2}) \\\\ a_{2}(x_{1}) &amp; a_{2}(x_{4}) &amp; a_{3}(x_{3}) &amp; a_{1}(x_{2}) \\\\ a_{2}(x_{1}) &amp; a_{3}(x_{4}) &amp; a_{1}(x_{3}) &amp; a_{2}(x_{2}) \\\\ a_{3}(x_{1}) &amp; a_{1}(x_{4}) &amp; a_{2}(x_{3}) &amp; a_{2}(x_{2}) \\end{bmatrix}, \\tag{7}</span>$</p>

    <p class="text-gray-300">where  <span class="math">a_i(\\cdot)</span>  are linear functions defined as follow:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-44-2&quot;&gt;&lt;/span&gt;
<span class="math">$a_1(x) = \\alpha x,</span>$
<span class="math">a_2(x) = x,</span>   <span class="math">a_3(x) = (\\alpha + 1)x.</span>  (8)</p>

    <p class="text-gray-300">As we have seen, for all  <span class="math">a \\in \\mathcal{D}_I^{\\perp}</span>  there exists one and only one  <span class="math">b \\in \\mathcal{M}_I^{\\perp}</span>  such that  <span class="math">R^{(2)}(\\mathcal{D}_I \\oplus a) = \\mathcal{M}_I \\oplus b</span> . The attack that we are going to present is based on this property and on probability from Eq. (1). Moreover, the following low-data complexity attack can be applied exactly in the same way also on 1- and 2-round of AES. All details are given in App. E.2.</p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-44-0&quot;&gt;&lt;/span&gt;E.1 The Attack on 3 Rounds of AES</h4>

    <p class="text-gray-300">Consider 3 rounds of AES:</p>

    <p class="text-gray-300"><span class="math">$p \\xrightarrow{R^{(2)}(\\cdot)} s \\xrightarrow{R_f(\\cdot)} c</span>$</p>

    <p class="text-gray-300">where  <span class="math">p \\in \\mathcal{D}_I \\oplus a</span>  (for a fixed  <span class="math">a \\in \\mathcal{D}_I^{\\perp}</span> ), and where MixColumns operation is omitted in the final round for simplicity. However, adding the MixColumns operation in the last round would not increase the resistance (see App. E.1.4 for more details).</p>

    <p class="text-gray-300">Let  <span class="math">p^1</span>  and  <span class="math">p^2</span>  two different plaintexts that belong to the same coset of  <span class="math">\\mathcal{D}_I</span> , and let  <span class="math">c^1</span>  and  <span class="math">c^2</span>  the corresponding ciphertexts. The idea of the attack is to find all the keys of the final round such that</p>

    <p class="text-gray-300">&lt;span id=&quot;page-44-1&quot;&gt;&lt;/span&gt;
<span class="math">$R_f^{-1}(c^1) \\oplus R_f^{-1}(c^2) = s^1 \\oplus s^2 \\in \\mathcal{M}_I,</span>$
(9)</p>

    <p class="text-gray-300">that is such that  <span class="math">s^1</span>  and  <span class="math">s^2</span>  belong to the same coset of  <span class="math">\\mathcal{M}_I</span> .</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> Let  <span class="math">p^1</span>  and  <span class="math">p^2</span>  be two plaintexts of the same coset of  <span class="math">\\mathcal{D}_I</span> , and let  <span class="math">c^1</span>  and  <span class="math">c^2</span>  the respective ciphertexts. Let k be the secret round-key of the final round. If there exists a pair of ciphertexts  <span class="math">(c^1, c^2)</span>  such that k doesn't satisfy (9), then k is certainly wrong.</p>

    <p class="text-gray-300"><em>Proof.</em> Suppose by contradiction that k is the right key.</p>

    <p class="text-gray-300">If there exists a pair  <span class="math">(c^1, c^2)</span>  such that k doesn't satisfy (9), then  <span class="math">R_f^{-1}(c^1) \\oplus R_f^{-1}(c^2) \\notin \\mathcal{M}_I</span>  (i.e.  <span class="math">R_f^{-1}(c^1)</span>  and  <span class="math">R_f^{-1}(c^2)</span>  belong to two different cosets of  <span class="math">\\mathcal{M}_I</span> ), that is</p>

    <p class="text-gray-300"><span class="math">$Pr(R_f^{-1}(c^1) \\oplus R_f^{-1}(c^2) \\in \\mathcal{M}_I | p^1 \\oplus p^2 \\in \\mathcal{D}_I) \\neq 1.</span>$</p>

    <p class="text-gray-300">Since k is the right key, then</p>

    <p class="text-gray-300"><span class="math">$Pr(R_f^{-1}(c^1) \\oplus R_f^{-1}(c^2) \\in \\mathcal{M}_I | p^1 \\oplus p^2 \\in \\mathcal{D}_I) = 1,</span>$</p>

    <p class="text-gray-300">(see (1)) which is a contradiction.</p>

    <p class="text-gray-300">By the previous Theorem, it follows that the secret key is certainly one of those that satisfy the equivalence (9). In order to find all the keys that satisfy (9), the idea is to take advantage of the particular form of  <span class="math">\\mathcal{M}_I</span> . In particular, observe that the columns of the subspace  <span class="math">\\mathcal{M}_I</span>  depend on different and independent variables, and that each element of a fixed column depends on a single variable in a very particular form.</p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> Let  <span class="math">a, b \\in \\mathcal{M}_I^{\\perp}</span> , and let  <span class="math">s^1 \\in \\mathcal{M}_I \\oplus a</span>  and  <span class="math">s^2 \\in \\mathcal{M}_I \\oplus b</span> . Denote s as the sum of  <span class="math">s^1</span>  and  <span class="math">s^2</span> , i.e.  <span class="math">s = s^1 \\oplus s^2</span> .</p>

    <p class="text-gray-300">Then, a = b if and only if all the following equivalences are satisfied:</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{lll} s_{0,0} = \\alpha s_{1,0}, &amp; s_{2,0} = s_{1,0}, &amp; s_{3,0} = (\\alpha+1)s_{1,0}; \\\\ s_{0,1} = s_{1,1}, &amp; s_{2,1} = (\\alpha+1)s_{1,1}, &amp; s_{3,1} = \\alpha s_{1,1}; \\\\ s_{1,2} = (\\alpha+1)s_{0,2}, &amp; s_{2,2} = \\alpha s_{0,2}, &amp; s_{3,2} = s_{0,2}; \\\\ s_{0,3} = (\\alpha+1)s_{2,3}, &amp; s_{1,3} = \\alpha s_{2,3}, &amp; s_{3,3} = s_{2,3}. \\end{array}</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> If a = b, it is straightforward to prove that all the previous equivalences are satisfied. Suppose instead that all the previous equivalences are satisfied. Then, working on the first column (analogous for the others), it follows that:</p>

    <p class="text-gray-300"><span class="math">$a_{0,0} \\oplus b_{0,0} = \\alpha[a_{1,0} \\oplus b_{1,0}]; \\quad a_{2,0} \\oplus b_{2,0} = a_{1,0} \\oplus b_{1,0}; \\quad a_{3,0} \\oplus b_{3,0} = (\\alpha+1)[a_{1,0} \\oplus b_{1,0}].</span>$</p>

    <p class="text-gray-300">That is, there exist  <span class="math">x_1</span>  and  <span class="math">y_1</span>  such that:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} s^1_{0,0} &amp;= \\alpha x_1 \\oplus a_{0,0}, &amp; s^2_{0,0} &amp;= \\alpha y_1 \\oplus a_{0,0} \\oplus \\alpha [a_{1,0} \\oplus b_{1,0}]; \\\\ s^1_{1,0} &amp;= x_1 \\oplus a_{1,0}, &amp; s^2_{1,0} &amp;= y_1 \\oplus b_{1,0}; \\\\ s^1_{2,0} &amp;= x_1 \\oplus a_{2,0}, &amp; s^2_{2,0} &amp;= y_1 \\oplus a_{2,0} \\oplus a_{1,0} \\oplus b_{1,0}; \\\\ s^1_{3,0} &amp;= (\\alpha + 1) x_1 \\oplus a_{3,0}, &amp; s^2_{3,0} &amp;= (\\alpha + 1) y_1 \\oplus a_{3,0} \\oplus (\\alpha + 1) [a_{1,0} \\oplus b_{1,0}]. \\end{split}</span>$</p>

    <p class="text-gray-300">Let  <span class="math">y_1&#x27; = y_1 \\oplus a_{1,0} \\oplus b_{1,0}</span>  and observe that  <span class="math">b_{1,0} = b_{1,0} \\oplus a_{1,0} \\oplus a_{1,0}</span> . Rewriting  <span class="math">s_{\\cdot,0}^2</span>  using  <span class="math">y_1&#x27;</span>  instead of  <span class="math">y_1</span>  and working in a similar way on all the other columns, it is easy to prove that  <span class="math">s^1</span>  and  <span class="math">s^2</span>  belong to the same coset of  <span class="math">\\mathcal{M}_I</span> , that is a = b.</p>

    <p class="text-gray-300">Using the previous Theorem and the fact that the columns of  <span class="math">\\mathcal{M}_I</span>  depend on different and independent variables, the attacker can work independently on each column of  <span class="math">\\mathcal{M}_I</span>  and so on each column of  <span class="math">SR^{-1}(k)</span> . Thus, we show our attack only on the first column (it is completely equivalent for the others).</p>

    <p class="text-gray-300">Given  <span class="math">c^1</span>  and  <span class="math">c^2</span> , the attacker guesses (for example) the bytes  <span class="math">k_{1,3}</span>  and finds all the values of bytes  <span class="math">k_{0,0}, k_{2,2}</span>  and  <span class="math">k_{3,1}</span>  of the key of the final round such that  <span class="math">s^1</span>  and  <span class="math">s^2</span>  belong to the same coset of  <span class="math">\\mathcal{M}_I</span> . Using the previous Theorem and given  <span class="math">k_{1,3}</span> , the other bytes of the first column of  <span class="math">SR^{-1}(k)</span>  have to satisfy the following equalities:</p>

    <p class="text-gray-300"><span class="math">$S-Box^{-1}(c_{0,0}^{1} \\oplus k_{0,0}) \\oplus S-Box^{-1}(c_{0,0}^{2} \\oplus k_{0,0}) =</span>$</p>

    <p class="text-gray-300"><span class="math">$=\\alpha[S-Box^{-1}(c_{1,3}^{1} \\oplus k_{1,3}) \\oplus S-Box^{-1}(c_{1,3}^{2} \\oplus k_{1,3})];</span>$</p>

    <p class="text-gray-300"><span class="math">$S-Box^{-1}(c_{2,2}^{1} \\oplus k_{2,2}) \\oplus S-Box^{-1}(c_{2,2}^{2} \\oplus k_{2,2}) =</span>$</p>

    <p class="text-gray-300"><span class="math">$=S-Box^{-1}(c_{1,3}^{1} \\oplus k_{1,3}) \\oplus S-Box^{-1}(c_{1,3}^{2} \\oplus k_{1,3})];</span>$</p>

    <p class="text-gray-300"><span class="math">$S-Box^{-1}(c_{3,1}^{1} \\oplus k_{3,1}) \\oplus S-Box^{-1}(c_{3,1}^{2} \\oplus k_{3,1}) =</span>$</p>

    <p class="text-gray-300"><span class="math">$=(\\alpha+1)[S-Box^{-1}(c_{1,3}^{1} \\oplus k_{1,3}) \\oplus S-Box^{-1}(c_{1,3}^{2} \\oplus k_{1,3})].</span>$</p>

    <p class="text-gray-300"><span class="math">$(10)</span>$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-45-0&quot;&gt;&lt;/span&gt;Suppose to guess one value of  <span class="math">k_{1,3}</span> . Then, it is very easy to observe that each equality of (10) can be rewritten in the following way</p>

    <p class="text-gray-300">&lt;span id=&quot;page-45-1&quot;&gt;&lt;/span&gt;
<span class="math">$S-Box^{-1}(\\alpha \\oplus x) \\oplus S-Box^{-1}(x) = \\beta(k_{1,3}), \\tag{11}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\alpha = c_{i,j}^1 \\oplus c_{i,j}^2</span> ,  <span class="math">\\beta</span>  depends on  <span class="math">k_{1,3}</span>  and on two ciphertexts bytes, and  <span class="math">x = c_{i,j}^2 \\oplus k_{i,j}</span>  is the unknown variable. First of all, note that if  <span class="math">\\alpha = 0</span>  then this equality is impossible if  <span class="math">\\beta \\neq 0</span> , while it is always satisfied if  <span class="math">\\beta = 0</span> .</p>

    <p class="text-gray-300">The solutions of equation (11) are related to the differential uniformity of the S-Box. Since the inverse function S-Box&lt;sup&gt;-1&lt;/sup&gt; is differential 4-uniform, there are at most four different solutions&lt;sup&gt;18&lt;/sup&gt;. In particular, there are two solutions with probability 126/256, four solutions with probability 1/256 and zero solutions with probability 129/256. That is, on average there exist about 2.016 different values that satisfy equation (11) with probability 49.6%.</p>

    <p class="text-gray-300">Suppose for the moment that  <span class="math">c^1</span>  and  <span class="math">c^2</span>  are two ciphertexts such that  <span class="math">c^1_{i,j} \\neq c^2_{i,j}</span>  for each  <span class="math">i, j \\in \\{0, ..., 3\\}</span> . Guessed the byte key  <span class="math">k_{1,3}</span> , then the attacker finds  <span class="math">2.016^3 \\simeq 8.194</span>  possible combinations  <span class="math">(k_{0,0}, k_{2,2}, k_{3,1})</span>  that satisfy the equivalence (10) with probability  <span class="math">(49.6\\%)^3 \\simeq 12.2\\%</span> . Since there are 256 values of  <span class="math">k_{1,3}</span> , we have in total  <span class="math">0.122 \\times 256 \\times (2.016)^3 \\simeq 255.95</span>  combinations  <span class="math">(k_{0,0}, k_{1,3}, k_{2,2}, k_{3,1})</span>  for the first column (analogous for the others).</p>

    <p class="text-gray-300">The computational cost to find these 256 combinations  <span class="math">(k_{0,0}, k_{1,3}, k_{2,2}, k_{3,1})</span>  for the first column (and analogous for the other ones) can be estimated at 3 (conditions)×2&lt;sup&gt;8&lt;/sup&gt; (values of  <span class="math">k_{1,3}</span> )×[2 + 2 × 2&lt;sup&gt;8&lt;/sup&gt; (values of  <span class="math">k_{0,0}, k_{2,2}, k_{3,1}</span>  for each condition)]= 2&lt;sup&gt;18.59&lt;/sup&gt; S-Box look-ups and 2&lt;sup&gt;17.59&lt;/sup&gt; XOR operations.</p>

    <p class="text-gray-300">Actually, it is possible to improve this result. Indeed, observe that if the value  <span class="math">k_{0,0}</span>  satisfies (or not) equation (10) for a given value  <span class="math">k_{1,3}</span> , then this equation is also satisfied (or not) by the value  <span class="math">k_{0,0} \\oplus c_{0,0}^1 \\oplus c_{0,0}^2</span> . That is, for each  <span class="math">k_{1,3}</span>  the attacker has to test only 128 values of  <span class="math">k_{0,0}</span>  and not 256. The same consideration holds for the other bytes of the key. Thus, the computational cost to find the 256 combinations  <span class="math">(k_{0,0}, k_{1,3}, k_{2,2}, k_{3,1})</span>  for the first column (and analogous for other columns) can be estimated at  <span class="math">2^{16.59}</span>  S-Box look-ups.</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">E.1.1 Recover the Secret Key using only 2 Chosen Plaintexts</h4>

    <p class="text-gray-300">Using the previous procedure, the attacker is able to find  <span class="math">2^8</span>  combinations for each column, that is  <span class="math">(2^8)^4 = 2^{32}</span>  candidates of the keys in total. A first possibility is simple to store them in the memory and to do a brute force attack on these  <span class="math">2^{32}</span>  possible keys, that is to check for which of these keys the condition  <span class="math">c^1 = R^{(3)}(p^1)</span>  (or equivalently  <span class="math">c^2 = R^{(3)}(p^2)</span> ) is satisfied. In this case, the total cost of the attack is approximately  <span class="math">2^{32}</span>  executions of the three-round cipher (observe that this second step is more expensive than the first one),  <span class="math">2^{32}</span>  memory access and the memory cost is approximately  <span class="math">2^{56} \\times 4</span>  (byte)×4 (columns) =  <span class="math">2^{12}</span>  byte.</p>

    <p class="text-gray-300">This result can be a little improved if the plaintexts belong to the same coset of  <span class="math">\\mathcal{D}_0 \\cap \\mathcal{C}_0</span>  (where  <span class="math">\\mathcal{D}_0 \\cap \\mathcal{C}_0</span>  has dimension 4 since  <span class="math">\\mathcal{D}_0 \\cap \\mathcal{C}_0 = \\langle e_{0,0} \\rangle</span>  - Lemma 5). In particular, using only 2 chosen plaintexts that belong to the same coset of  <span class="math">\\mathcal{D}_0</span> , the total cost of the attack is approximately of  <span class="math">2^{32}</span>  executions of the three-round cipher,  <span class="math">2^{32}</span>  memory access and the memory cost is approximately  <span class="math">256 \\times 4</span>  (byte)×4 (columns) =  <span class="math">2^{12}</span>  byte.</p>

    <p class="text-gray-300">By definition,  <span class="math">\\mathcal{D}_0 \\cap \\mathcal{C}_0</span>  and  <span class="math">\\mathcal{C}_0 \\cap \\mathcal{M}_0</span>  correspond to symbolic matrix:</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{D}_0 \\cap \\mathcal{C}_0 \\equiv \\begin{bmatrix} x &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0</span>$</p>

    <p class="text-gray-300">where  <span class="math">a_i(\\cdot)</span>  are defined as in (8). Using similar arguments as before, for each  <span class="math">a \\in (\\mathcal{D}_0 \\cap \\mathcal{C}_0)^{\\perp}</span>  there exist unique  <span class="math">b \\in (\\mathcal{C}_0 \\cap \\mathcal{M}_0)^{\\perp}</span>  and unique  <span class="math">c \\in \\mathcal{M}_0^{\\perp}</span>  such that:</p>

    <p class="text-gray-300"><span class="math">$R((\\mathcal{D}_0 \\cap \\mathcal{C}_0) \\oplus a) = (\\mathcal{C}_0 \\cap \\mathcal{M}_0) \\oplus b</span>$
and  <span class="math">R^{(2)}((\\mathcal{D}_0 \\cap \\mathcal{C}_0) \\oplus a) \\subseteq \\mathcal{M}_0 \\oplus c</span> .</p>

    <p class="text-gray-300">Thus, suppose that the attacker has found  <span class="math">2^8</span>  possible combinations for each column of the secret key. Instead to attack by brute force all the  <span class="math">2^{32}</span>  possible keys, the idea is the following. Given  <span class="math">c^1</span>  and  <span class="math">c^2</span>  and a (possible) key  <span class="math">k^3</span>  of the final round, the idea is to compute  <span class="math">s^1 = R^{-1}(c^1)</span>  and  <span class="math">s^2 = R^{-1}(c^2)</span> , that is to decrypt one round  <span class="math">c^1</span>  and  <span class="math">c^2</span> , with a</p>

    <p class="text-gray-300">&lt;span id=&quot;page-46-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;18&lt;/sup&gt;Observe that if x satisfies (11), then also  <span class="math">x \\oplus \\alpha</span>  satisfies it, so the number of solutions can not be odd.</p>

    <p class="text-gray-300">cost of  <span class="math">16 \\times 2 = 32</span>  S-Box look-ups. Then, the attacker can easily compute  <span class="math">k^2</span>  using the inverse key schedule (cost of 4 S-Box look-ups). Finally, she checks if  <span class="math">R^{-1}(s^1)</span>  and  <span class="math">R^{-1}(s^2)</span>  belong to the same coset of  <span class="math">\\mathcal{C}_0 \\cap \\mathcal{M}_0</span> , that is if the first columns of  <span class="math">R^{-1}(s^1)</span>  and  <span class="math">R^{-1}(s^2)</span>  satisfied conditions similar to (10). The cost of this last operation is 8 S-Box look-ups. Since these conditions are verified with probability  <span class="math">2^{-24}</span> , only  <span class="math">2^8</span>  possible keys of  <span class="math">k^3</span>  satisfy these conditions. The cost of this step is  <span class="math">2^{32} \\times (32 + 4 + 8) = 2^{37.46}</span>  S-Box look-ups, that is  <span class="math">2^{31.55}</span>  executions of the three-round cipher. Using a brute force attack, the attacker can find the right key among the last  <span class="math">2^8</span>  candidates.</p>

    <p class="text-gray-300">For this attack, the attacker needs about 2 chosen plaintexts in the same coset of  <span class="math">\\mathcal{D}_0 \\cap \\mathcal{C}_0</span> , the total computational cost is about  <span class="math">2^{10.7}</span>  (first step)  <span class="math">+2^{31.55}</span>  (check)  <span class="math">+2^8</span>  (brute force)  <span class="math">=2^{31.55}</span>  executions of the three-round cipher and  <span class="math">2^{32}</span>  memory access, and a memory cost of about  <span class="math">2^{12}</span>  bytes of memory (to store the combinations of the columns of the key found in the first step). In a 32-bit implementation, each round of AES can be implemented by 20 memory accesses, that is 16 look-ups table for S-Box +SR + MC and 4 look-ups table for the key schedule. Thus, one can declare that the total complexity of the attack is approximately  <span class="math">(20 \\cdot 3)^{-1} \\times 2^{32} + 2^{31.55} = 2^{31.58}</span>  executions of the three-round encryption.</p>

    <p class="text-gray-300">approximately  <span class="math">(20 \\cdot 3)^{-1} \\times 2^{32} + 2^{31.55} = 2^{31.58}</span>  executions of the three-round encryption. Remember that these results are based on the hypothesis that  <span class="math">c_{i,j}^1 \\neq c_{i,j}^2</span>  for each  <span class="math">i,j \\in \\{0,...,3\\}</span> . By simple computation, the probability that this condition is satisfied is  <span class="math">(255/256)^{16} = 0.9393</span> , so everything works with high probability.</p>

    <h4 id="sec-41" class="text-lg font-semibold mt-6">E.1.2 Recover the Secret Key using 3 Chosen Plaintexts</h4>

    <p class="text-gray-300">Another possibility is to use a third plaintext  <span class="math">p^3</span>  that belongs to the same coset of  <span class="math">\\mathcal{D}_I</span>  of  <span class="math">p^1</span>  and  <span class="math">p^2</span>  (i.e.  <span class="math">p^1 \\oplus p^3 \\in \\mathcal{D}_I</span> ), and such that the corresponding ciphertexts satisfy the following conditions:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-47-0&quot;&gt;&lt;/span&gt;
<span class="math">$c_{i,j}^1 \\neq c_{i,j}^2, \\quad c_{i,j}^1 \\neq c_{i,j}^3, \\quad c_{i,j}^2 \\neq c_{i,j}^3 \\qquad \\forall i, j \\in \\{0, ..., 3\\}.</span>$
(12)</p>

    <p class="text-gray-300">The idea is simply to repeat the first step of the attack, on the combinations of key columns that satisfy condition (10) for the first pair of texts, using a second pair of texts composed of  <span class="math">p^3</span>  and one of the first two plaintexts. That is, to eliminate the wrong keys checking the keys found previously (at the first step) with this second pair. As before, the idea is to work again on each column independently. Remember that, for each column, the right combination is the only one that satisfies the condition (10) for each pair of ciphertexts such that the corresponding plaintexts belong to the same coset of  <span class="math">\\mathcal{D}_I</span> .</p>

    <p class="text-gray-300">Using 3 chosen plaintexts and to improve the total computational cost, the attack should be a little modified. Working independently for each column, the best idea is to work only on one of the equations of (10), e.g. the first one. Given the first pair of plaintexts, the attacker is able to recover 256 possible combinations for the pair  <span class="math">(k_{0,0}, k_{1,3})</span> . For each one of them, the attacker checks if it verifies the condition (10) also for the second pair of plaintexts. Since on average each equation of the condition (10) is satisfied with probability  <span class="math">2^{-8}</span> , the attacker finds the correct combination of  <span class="math">(k_{0,0}, k_{1,3})</span> . In this way, the attacker knows  <span class="math">k_{1,3}</span>  and so she knows the right part of equations (10). Thus, in the same way of before, she can easily discover  <span class="math">k_{2,2}</span>  and  <span class="math">k_{3,1}</span> . However, since the attacker knows the right part of the equations, only two texts pass the first step. Indeed, observe that there are  <span class="math">2^8</span>  possible values and that each equation is satisfied only with probability  <span class="math">2^{-8}</span> , thus only one text passes the test. Anyway, if x satisfies (11), then also  <span class="math">x \\oplus \\alpha</span>  satisfies it. Using the second pair of texts, the attacker finds the right bytes of the key.</p>

    <p class="text-gray-300">Working independently on each column, a good idea is to perform these two steps at the same time, that is to check the combination found with the first pair of plaintexts immediately using the second one: in this way, the attacker doesn't need to store anything (except the right combination for each column).</p>

    <p class="text-gray-300">Remember that this result is based on the hypothesis that condition (12) is satisfied. By simple computation, this happens with probability  <span class="math">(255 \\cdot 254/256^2)^{16} = 82.85\\%</span> . Actually,</p>

    <pre><code class="language-text">Data: 2 ciphertexts pairs (c^1, c^2) and (c^1, c^3), whose corresponding plaintexts
        belong in the same coset of \\mathcal{D}_0.
Result: First diagonal of the secret key k^3 (i.e. k_{i,i}^3 for each i = 0, ..., 3).
(Note: the same procedure with the same ciphertexts can be used to recover the
other diagonals of the key.)
for all values of k_{1,3}^3 do
    for all values of k_{0,0}^3 do
       check if 1-st equivalence of (10) is satisfied for both pairs of ciphertexts
       If satisfied, then identify candidates for k_{1,3}^3 and k_{0,0}^3
   end
end
                                          // on average only 1 candidate for k_{1,3}^3
for all candidates k_{1,3}^3 do
   for all values of k_{2,2}^3 do
       check if 2-nd equivalence of (10) is satisfied for both pairs of ciphertexts
       If satisfied, then identify candidate for k_{2,2}^3
       else reject k_{1,3}^3 as candidate
    for all values of k_{3,1}^3 do
       check if 3-rd equivalence of (10) is satisfied for both pairs of ciphertexts
       If satisfied, then identify candidate for k_{3,1}^3
       else reject k_{1,3}^3 as candidate
end
return k_{i,i}^3 for each i = 0, ..., 3.
</code></pre>

    <p class="text-gray-300"><strong>Algorithm 5:</strong> Attack on 3 rounds of AES-128 - Pseudo Code. For simplicity, in this pseudo-code, we show how to find only the first diagonal of the secret key of the last round, and we don't use the following optimization: if x satisfies (11) then also  <span class="math">x \\oplus \\alpha</span>  satisfies it. To recover the entire key, it is sufficient to repeat exactly the same attack for the other diagonals using the same pairs of ciphertexts.</p>

    <p class="text-gray-300">the condition (12) can be (a little) relaxed. For example, three chosen plaintext such that  <span class="math">c_{0,0}^1 = c_{0,0}^2 \\neq c_{0,0}^3</span>  and  <span class="math">c_{1,3}^1 \\neq c_{1,3}^2 \\neq c_{1,3}^3</span>  can also be used to find the key. Thus, using 3 chosen plaintexts the probability of success is:  <span class="math">\\left[\\sum_{i=0}^3 \\binom{4}{i} \\left(\\frac{255 \\cdot 254}{256^2}\\right)^{4-i} \\left(\\frac{255}{256^2}\\right)^i\\right]^4 = 88.83\\%</span> .</p>

    <p class="text-gray-300">chosen plaintexts the probability of success is:  <span class="math">\\left[\\sum_{i=0}^{3} \\binom{4}{i} \\left(\\frac{255 \\cdot 254}{256^2}\\right)^{4-i} \\left(\\frac{255}{256^2}\\right)^i\\right]^4 = 88.83\\%</span> . The computational cost for the first step can be approximated by  <span class="math">2^{-1} \\cdot 2^8</span>  (values of  <span class="math">k_{1,3}</span> ) ×(2 + 2 × 2&lt;sup&gt;-1&lt;/sup&gt; · 2&lt;sup&gt;8&lt;/sup&gt; (values of  <span class="math">k_{0,0}</span> ) + 4 × 256 (check with 2-nd pair) =  <span class="math">2^{15.055}</span>  S-Box look-ups, while the cost for the second step is  <span class="math">2 \\times 2^{-1} \\cdot 2^8</span>  (values of  <span class="math">k_{2,2}</span>  and  <span class="math">k_{3,1}</span> ) +2 × 2 (check with 2-nd pair) =  <span class="math">2^8</span>  S-Box look-ups. In conclusion, our attack needs 3 chosen plaintexts (one plaintext is in common for the two pairs) and the total computational cost is approximately 4 (columns) ×( <span class="math">2^{15.055} + 2 \\times 2^8</span> ) =  <span class="math">2^{17.08}</span>  S-Box look-ups, that is about  <span class="math">2^{11.2}</span>  executions of the three-round cipher (the memory cost is negligible).</p>

    <p class="text-gray-300">Finally, note that after the identification of a subspace trail the previous attack can be easily generalized to other AES-like ciphers.</p>

    <h4 id="sec-42" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-48-1&quot;&gt;&lt;/span&gt;E.1.3 Perform the Attack using Table Look-ups</h4>

    <p class="text-gray-300">It is also possible to perform the previous attack in a slight different way, that is using look-ups table. First of all, for each values of  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span> , the idea is to precompute the values of x that satisfy condition (11) and to store them in a table. The cost of this precomputation is approximately  <span class="math">2^{16}</span>  S-Box look-ups&lt;sup&gt;19&lt;/sup&gt;, that is about  <span class="math">2^{10.1}</span>  executions of</p>

    <p class="text-gray-300">&lt;span id=&quot;page-48-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;19&lt;/sup&gt;For each of the  <span class="math">2^8</span>  values of  <span class="math">\\beta</span>  and of the  <span class="math">2^7</span>  values of x (remember that if x satisfies (11), then also  <span class="math">x \\oplus \\alpha</span>  satisfies it), the attacker finds the value of  <span class="math">\\alpha</span>  that satisfies the equality (11), and stores this</p>

    <p class="text-gray-300">three-round AES. The memory cost to store this table is approximately  <span class="math">(2^8)^2 = 2^{16}</span>  bytes. Then, for each column, the attacker is able to discover the 256 key combinations with  <span class="math">3 \\cdot 2^8</span>  look-ups table (that is, 3 look-ups table for each values of  <span class="math">k_{1,3}</span> ). In order to find the right key among these combinations, she can use the same techniques described previously, or she can use another pair of plaintexts and again the look-ups table. On average, using 3 chosen plaintexts and working in the same way described previously, for each column the attacker needs  <span class="math">2^8</span>  look-ups table and  <span class="math">2^8 \\cdot 4 = 2^{10}</span>  S-Box look-ups to discover  <span class="math">k_{0,0}</span>  and  <span class="math">k_{1,3}</span> (i.e. the attacker finds the 256 possible values of  <span class="math">(k_{0.0}, k_{1.3})</span>  using look-ups table, and then tests them with the second pair of texts), and 2 look-ups table to discover the other 2 bytes. Thus, the total computational cost is of  <span class="math">4 \\cdot (2^8 + 2) = 2^{10.02}</span>  look-ups table (with a memory cost of  <span class="math">2^{16}</span>  bytes) and  <span class="math">2^{10} \\cdot 2 = 2^{11}</span>  S-Box look-ups (since she needs  <span class="math">2^{10}</span>  S-Box look-ups to compute the value of  <span class="math">\\beta</span>  for each value of  <span class="math">k_{1,3}</span> ), that is  <span class="math">2^{5.1}</span>  executions of three-round AES (the precomputation cost is about  <span class="math">2^{10.1}</span>  executions of three-round AES). Since 1 round of AES can be approximated by  <span class="math">20 \\simeq 2^{4.32}</span>  memory accesses&lt;sup&gt;20&lt;/sup&gt;, one can declare that the total complexity of the attack is approximately  <span class="math">(20 \\cdot 3)^{-1} \\times 2^{10} + 2^{5.1} = 2^{5.68}</span>  executions of the three-round encryption.</p>

    <h4 id="sec-43" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-49-1&quot;&gt;&lt;/span&gt;E.1.4 3-Round Attacks - Final Round with MixColumns Operation</h4>

    <p class="text-gray-300">For sake of completeness, the attacks on 3 rounds described in App. E.1 work exactly in the same way in the case in which the MixColumns operation is <em>not</em> omitted in the last round. In this case, the idea (very common in the literature) is simply to change the position of the final MixColumns operation with the final AddRoundKey operation (remember that these operations are linear). In this case, the major difference is that the attacker has to work with  <span class="math">\\tilde{k}</span>  defined as:</p>

    <p class="text-gray-300"><span class="math">$\\tilde{k} := MC^{-1}(k), \\tag{13}</span>$</p>

    <p class="text-gray-300">instead of k (the secret key of the final round). Moreover, in this case  <span class="math">s^h = R^{-1}(c^h)</span>  (for h = 1, 2) are defined as  <span class="math">s^h_{i,j} = \\text{S-Box}^{-1}(\\tilde{c}^h_{i,j+i} \\oplus \\tilde{k}_{i,j+i})</span>  where i, j = 0, ..., 3 (and i + j is taken modulo 4) and where  <span class="math">\\tilde{c}^h := MC^{-1}(c^h)</span> . Note that when all bytes of  <span class="math">\\tilde{k}</span>  have been determined, the secret key k can be recovered by  <span class="math">k = MC(\\tilde{k})</span> .</p>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-49-0&quot;&gt;&lt;/span&gt;E.2 The Attack on 1 and 2 Rounds of AES</h4>

    <p class="text-gray-300">Finally, note that the same attack can be used to attack 1 and 2 round of AES. In the case of 2 rounds of AES, consider the following situation:</p>

    <p class="text-gray-300"><span class="math">$p \\xrightarrow{R(\\cdot)} s \\xrightarrow{R_f(\\cdot)} c</span>$
,</p>

    <p class="text-gray-300">where  <span class="math">p \\in \\mathcal{C}_I \\oplus a</span>  (for a fixed  <span class="math">a \\in \\mathcal{C}_I^{\\perp}</span> ) and MixColumns operation is omitted in the final round (for simplicity). The attack is completely equivalent to the previous one using the following probability&lt;sup&gt;21&lt;/sup&gt;:</p>

    <p class="text-gray-300"><span class="math">$Pr(R(x) \\oplus R(y) \\in \\mathcal{M}_I \\mid x \\oplus y \\in \\mathcal{C}_I) = 1.</span>$</p>

    <p class="text-gray-300">In this case, our attack needs 3 chosen plaintexts (in the same coset of  <span class="math">C_I</span> ) and the total computational cost is approximately at  <span class="math">2^{17.08}</span>  S-Box look-ups, that is about  <span class="math">2^{11.8}</span>  executions of the two-round cipher. As before, it is possible to perform the attack using memory</p>

    <p class="text-gray-300">combination in the memory. For the remaining pairs  <span class="math">(\\alpha, \\beta)</span> , the equality (11) has no solutions.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-49-2&quot;&gt;&lt;/span&gt; <span class="math">&lt;sup&gt;^{20}&lt;/sup&gt;</span> This approximation has been proposed and used for example in [MDRM10]. For comparison, note that in [TKKL15] authors approximate 1 rounds of AES with  <span class="math">2^5</span>  memory accesses.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-49-3&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;21&lt;/sup&gt;Note that it is not possible to use the probability  <span class="math">Pr(R(x) \\oplus R(y) \\in \\mathcal{C}_I \\mid x \\oplus y \\in \\mathcal{D}_I) = 1</span> , since  <span class="math">Pr(R_f(x) \\oplus R_f(y) \\in \\mathcal{ID}_I \\mid x \\oplus y \\in \\mathcal{C}_I) = 1</span>  for each possible candidate of the secret key.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-50-1&quot;&gt;&lt;/span&gt;<strong>Table 4:</strong> <em>Comparison table of low-data attacks on round-reduced AES.</em> Data complexity is measured in number of required known/chosen plaintexts (KP/CP). Time complexity is measured in round-reduced AES encryption equivalents (E) and in memory accesses (M). Memory complexity is measured in plaintexts (16 bytes). The case in which the MixColumns operation is omitted in the last round is denoted by &quot;<em>r.</em>5 rounds&quot;, that is <em>r</em> full rounds and the final round. The attacks of this paper are in bold. We recall that the G&amp;D tool exploits (mainly) the Meet-in-the-Middle (MitM) attack.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Attack</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Rounds Data</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Computation (E)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Memory Reference</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">G&amp;D</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 KP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">56&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BDF11]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">G&amp;D-MitM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 KP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BDF11]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">G&amp;D-MitM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 KP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BDF11]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">G&amp;D-MitM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 KP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BDF11]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">G&amp;D-MitM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BDF11]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">D</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.5 - 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 KP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BDD+12]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">TrD</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.5 - 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 CP 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32 M&lt;br&gt;31.55 E&lt;br&gt;31.6&lt;br&gt;+2&lt;br&gt;≈ 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">App. E.2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">D</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.5 - 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BDD+12]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">TrD</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.5 - 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">11.8&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">App. E.2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">TrD</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.5 - 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">10 M&lt;br&gt;6.3 E&lt;br&gt;6.6&lt;br&gt;2&lt;br&gt;+2&lt;br&gt;≈ 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">App. E.2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">D</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.5 - 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3 KP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32&lt;br&gt;2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[BDD+12]</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">G&amp;D: Guess &amp; Det., TrD: Truncated Differential, D: Diff.</p>

    <p class="text-gray-300">access instead of S-Box look-ups. By simple computation and with the approximation of 1 round of AES with 20 memory accesses, the complexity of the attack is approximately (20 · 2)&lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;1&lt;/sup&gt; × 2 &lt;sup&gt;10&lt;/sup&gt; + 2&lt;sup&gt;6&lt;/sup&gt;<em>.</em>&lt;sup&gt;32&lt;/sup&gt; = 2&lt;sup&gt;6&lt;/sup&gt;<em>.</em>&lt;sup&gt;6&lt;/sup&gt; executions of the two-round encryption, the cost of the precomputation is about 2 10<em>.</em>7 executions of two-round AES, and a memory cost of 2 16 bytes. As for the attack on 3-round, it is also possible to set up an attack using only 2 chosen plaintexts. The complexity of the attack in this case is well approximated by 2 31<em>.</em>6 executions of two-round AES, choosing the two plaintexts in the same coset of D<em>&lt;sup&gt;i&lt;/sup&gt;</em> ∩ C<em>&lt;sup&gt;j&lt;/sup&gt;</em> for |<em>i</em>| = |<em>j</em>| = 1. A comparison between our attack and the other present in literature is provided in Table <a href="#page-50-1">4.</a></p>

    <p class="text-gray-300">The attack on 1 round (where MixColumns operation is not omitted) is completely equivalent to the previous one. In this case, the idea is simply to choose plaintexts that belong to the same coset of M<em>&lt;sup&gt;I&lt;/sup&gt;</em> .</p>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-50-0&quot;&gt;&lt;/span&gt;<strong>E.3 Relationship to Standard Truncated Differential Attack</strong></h3>

    <p class="text-gray-300">Differential cryptanalysis <a href="#page-33-11">[BS91]</a> is a general form of cryptanalysis applicable to block ciphers. It studies how differences in information input can affect the resulting difference at the output. Differential attacks exploit the fact that pairs of plaintexts with certain differences yield other differences in the corresponding ciphertexts with a non-uniformity probability distribution. Statistical key information is deduced from ciphertext blocks obtained by encrypting pairs of plaintext block with a specific (bitwise) difference under the target key. In particular, for a pair of plaintexts related by a constant (bitwise) difference, one tries for all values of the round key in the last round if the expected difference in the ciphertexts occurs. This is repeated several times and the most suggested values are assumed to be the value of the secret key of the last round. Attacks following this basic attack vector can not be described without considering the details of the S-Boxes of the cipher as it affects the probability of events. A variant of this attack is the <em>truncated differential attack</em> <a href="#page-34-14">[Knu95]</a>, in which the attacker considers only part of the difference</p>

    <p class="text-gray-300">between pairs of texts, i.e. it is a differential attack where only part of the difference in the ciphertexts can be predicted. As truncated differential cryptanalysis can be described without considering details of S-Box and since subspace trail cryptanalysis is largely independent of concrete choices of an S-Box, truncated differential cryptanalysis is hence much closer in nature to subspace trail cryptanalysis.</p>

    <p class="text-gray-300">Our attack falls into the category of truncated differential cryptanalysis attacks. Indeed, the attacker considers plaintexts which belong to the same coset of a diagonal space  <span class="math">\\mathcal{D}_I</span> , that is plaintexts where the input differences in 4-|I| diagonals are equal to zero (the difference in the others diagonal are instead not fixed). Then, she looks for a key such that the bytes differences one round before satisfy certain relationships. That is, the attacker exploits the relationship between bytes differences which are in different positions. As we have seen, if  <span class="math">I = \\{0\\}</span>  and for the first column, the relationships among this differences are given in (11). This guarantees that the two ciphertexts  <span class="math">c^1</span>  and  <span class="math">c^2</span>  belong to the same coset of  <span class="math">\\mathcal{M}_I</span>  one round before, that is  <span class="math">R^{-1}(c^1) \\oplus R^{-1}(c^2) \\in \\mathcal{M}_I</span> . This last condition is equivalent to the following one:</p>

    <p class="text-gray-300"><span class="math">$MC^{-1} \\circ R^{-1}(c^1) \\oplus MC^{-1} \\circ R^{-1}(c^2) \\in \\mathcal{ID}_I,</span>$</p>

    <p class="text-gray-300">where an Inverse MixColumns operation is applied on both sides and where  <span class="math">MC^{-1}(\\mathcal{M}_I) = \\mathcal{I}\\mathcal{D}_I</span>  by definition (note that  <span class="math">MC^{-1}</span>  is linear and that  <span class="math">MC^{-1}(R_{k^3}^{-1}(c^1) \\oplus k^2 \\oplus R_{k^3}^{-1}(c^2) \\oplus k^2) = MC^{-1} \\circ R^{-1}(c^1) \\oplus MC^{-1} \\circ R^{-1}(c^2)</span> , where  <span class="math">k^2</span>  and  <span class="math">k^3</span>  are respectively the keys of the second and of the third/final round). By definition of  <span class="math">\\mathcal{I}\\mathcal{D}_I</span> , the attacker is looking for a key such that the differences in  <span class="math">16 - 4 \\cdot |I|</span>  bytes are equal to zero (4 - |I|) for each column), while no condition is imposed on the difference in the other  <span class="math">4 \\cdot |I|</span>  bytes. For example, the condition (11) for the first column can be re-written as:</p>

    <p class="text-gray-300"><span class="math">$MC^{-1} \\times \\begin{bmatrix} \\alpha \\cdot [\\text{S-Box}^{-1}(c_{0,0}^{1} \\oplus k_{0,0}) \\oplus \\text{S-Box}^{-1}(c_{0,0}^{2} \\oplus k_{0,0})] \\\\ \\text{S-Box}^{-1}(c_{1,3}^{1} \\oplus k_{1,3}) \\oplus \\text{S-Box}^{-1}(c_{1,3}^{2} \\oplus k_{1,3})] \\\\ \\text{S-Box}^{-1}(c_{2,2}^{1} \\oplus k_{2,2}) \\oplus \\text{S-Box}^{-1}(c_{2,2}^{2} \\oplus k_{2,2}) \\\\ (\\alpha + 1) \\cdot [\\text{S-Box}^{-1}(c_{3,1}^{1} \\oplus k_{3,1}) \\oplus \\text{S-Box}^{-1}(c_{3,1}^{2} \\oplus k_{3,1})] \\end{bmatrix} = \\begin{bmatrix} \\cdot \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix},</span>$</p>

    <p class="text-gray-300">where no restriction holds on the first byte. Solving this equality, one obtains the relationships among the bytes differences given in (11). That is, the attacker looks for a key that guarantees certain differences (zero in this case) for certain bytes, while she doesn't care of the differences in the other bytes, as by definition of Truncated Differential Attack.</p>

    <h2 id="sec-46" class="text-2xl font-bold">&lt;span id=&quot;page-51-0&quot;&gt;&lt;/span&gt;E.4 The Attack on 4 Rounds of AES - Extending the 3 Rounds Attack at the End</h2>

    <p class="text-gray-300">Starting from the previous attack on 3 rounds, in this section we show how to extend it at the end in order to attack 4 rounds of AES. In a similar way, in App. E.5 we show how to attack 4 rounds of AES extending the previous attack on 3 rounds at the beginning. Consider the following situation:</p>

    <p class="text-gray-300"><span class="math">$p \\xrightarrow{R^{(2)}(\\cdot)} s \\xrightarrow{R(\\cdot)} z \\xrightarrow{R_f(\\cdot)} c</span>$</p>

    <p class="text-gray-300">where  <span class="math">p \\in \\mathcal{D}_I \\oplus a</span>  (for a fixed  <span class="math">a \\in \\mathcal{D}_I^{\\perp}</span> ) and MixColumns operation is omitted (only for simplicity) in the final round.</p>

    <p class="text-gray-300">As we have seen, if  <span class="math">p^1 \\oplus p^2 \\in \\mathcal{D}_I</span> , then  <span class="math">s^1 \\oplus s^2 \\in \\mathcal{M}_I</span> . The idea of the attack is simply to guess part of the key of the final round, in order to partially decrypt c and obtain (part of) z. Then the attacker can repeat the attack on 3 rounds, working on z and exploiting the relationships that hold between the bytes of  <span class="math">s^1 \\oplus s^2</span> . In this case, the attacker founds on average one values of  <span class="math">k^3</span>  for each guessed value of  <span class="math">k^4</span> . Thus, she can not say anything</p>

    <p class="text-gray-300">about  <span class="math">k^3</span>  a priori, since it depends on the guessed value of  <span class="math">k^4</span> . That is, she has to check that the key of the third round  <span class="math">k^3</span>  and of the final round  <span class="math">k^4</span>  satisfy the key schedule. If they satisfy the key schedule, then the attacker has found the right key, otherwise she has to repeat the previous procedure for the other values of  <span class="math">k^4</span> .</p>

    <p class="text-gray-300">In the following, we give all the details of the attack. In the first part, the attacker guesses two columns of the last key  <span class="math">k^4</span> , partial decrypts the pairs of ciphertexts and discovers part of the key of the third round  <span class="math">k^3</span> , using the attack on 3 rounds described previously. Then she checks that the found key satisfies the key schedule with the guessed key  <span class="math">k^4</span> . In the second part of the attack, for the key candidates that satisfy the key schedule, the attacker is able to recover other bytes of  <span class="math">k^4</span>  and  <span class="math">k^3</span>  (using again the key schedule). In order to find the complete secret key, the attacker has to guess the remaining unknown bytes of the secret key and to do a brute force attack. The attack can be performed using three or only two chosen plaintexts.</p>

    <h4 id="sec-47" class="text-lg font-semibold mt-6">E.4.1 Details of the Attack</h4>

    <p class="text-gray-300"><strong>Details of the First Part of the Attack.</strong> In order to show our attack, suppose that the attacker guesses the following eight bytes of the key of the final round  <span class="math">k^4</span> :</p>

    <p class="text-gray-300">&lt;span id=&quot;page-52-0&quot;&gt;&lt;/span&gt;
<span class="math">$SR(k_{i,3}^4) = k_{i,3-i}^4</span>$
and  <span class="math">SR(k_{i,0}^4) = k_{i,-i}^4</span>   <span class="math">\\forall i \\in \\{0,1,2,3\\},</span>  (14)</p>

    <p class="text-gray-300">that is the first and the fourth columns of  <span class="math">k^4</span>  after the ShiftRows operation (the index -i is taken module 4). Observe that there are  <span class="math">(2^8)^8 = 2^{64}</span>  possibilities in total. Note that since the attacker can not impose any restriction/condition on the secret key, she has to repeat the following steps for each possible values of these eight bytes of  <span class="math">k^4</span> .</p>

    <p class="text-gray-300">Using these guessed key bytes of  <span class="math">k^4</span>  and three given ciphertexts  <span class="math">c^1, c^2, c^3</span>  (which plaintexts  <span class="math">p^1, p^2, p^3</span>  belong to the same coset of  <span class="math">\\mathcal{D}_I</span> ), the attacker is able to compute:</p>

    <p class="text-gray-300"><span class="math">$z_{i,j}^h = \\text{S-Box}^{-1}(c_{i,j+i \\text{ mod } 4}^h \\oplus k_{i,j+i \\text{ mod } 4}^4) \\qquad \\forall h \\in \\{1,2,3\\}, \\, \\forall j \\in \\{0,3\\}, \\, \\forall i.</span>$</p>

    <p class="text-gray-300">The cost of this step is  <span class="math">2^{64} \\cdot 8 \\cdot 3 = 2^{68.6}</span>  S-Box look-ups. Note that the positions of the guessed bytes of the key  <span class="math">k^4</span>  can not be chosen in an arbitrary way, since in the following step the attacker has to apply the InverseMixColumns operation on two columns of z.</p>

    <p class="text-gray-300">Using  <span class="math">z^1, z^2</span>  and  <span class="math">z^3</span>  (instead of  <span class="math">c^1, c^2, c^3</span> ), the attacker can repeat the previous attack on 3 rounds and finds eight bytes (i.e. first and fourth columns) of the key  <span class="math">k^3</span> , in order to guarantee that  <span class="math">s^i \\oplus s^j \\in \\mathcal{M}_I</span>  for each i, j = 1, 2, 3. In this case, note that for each column the attacker can impose only one relationship that involves two bytes, and not three relationships as in the previous attack on 3 round. For example, the only relationship that holds for the first column is the following (analogous for the others):</p>

    <p class="text-gray-300"><span class="math">$S-Box^{-1}(\\hat{z}_{0,0}^1 \\oplus \\tilde{k}_{0,0}^3) \\oplus S-Box^{-1}(\\hat{z}_{0,0}^2 \\oplus \\tilde{k}_{0,0}^3) = \\alpha[S-Box^{-1}(\\hat{z}_{1,0}^1 \\oplus \\tilde{k}_{1,0}^3) \\oplus S-Box^{-1}(\\hat{z}_{1,0}^2 \\oplus \\tilde{k}_{1,0}^3)],</span>$</p>

    <p class="text-gray-300">where
<span class="math">$\\tilde{k}^3 = SR^{-1}(MC^{-1}(k^3))</span>$
and  <span class="math">\\hat{z} = SR^{-1}(MC^{-1}(z))</span> .</p>

    <p class="text-gray-300">Thus, given eight byte of  <span class="math">k^4</span> , the computational cost to find 8 bytes of  <span class="math">k^3</span>  is approximately  <span class="math">4 \\times 2^7 \\times (2 + 2 \\cdot 2^7) = 2^{17}</span>  S-Box look-ups and  <span class="math">2^5</span>  byte of memory. That is, the computational cost to find the  <span class="math">2^{64}</span>  combinations of all the eight bytes of  <span class="math">k^3</span>  (equivalently  <span class="math">\\tilde{k}^3</span>  - note that we are working with columns of  <span class="math">SR(k^3)</span> ) and  <span class="math">k^4</span>  is  <span class="math">2^{64} \\times 2^{17} = 2^{81}</span>  S-Box look-ups.</p>

    <p class="text-gray-300">When the attacker has found eight bytes of  <span class="math">k^3</span> , she has to check if they satisfy the key schedule. In particular, the following three conditions between the eight bytes of  <span class="math">k^3</span>  and the eight bytes of  <span class="math">k^4</span>  hold:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-52-1&quot;&gt;&lt;/span&gt;
<span class="math">$k_{0,0}^4 = \\text{S-Box}(k_{1,3}^3) \\oplus k_{0,0}^3 \\oplus 0x08, \\quad k_{3,0}^4 = \\text{S-Box}(k_{0,3}^3) \\oplus k_{3,0}^3, \\quad k_{1,3}^4 = k_{1,3}^3 \\oplus k_{1,2}^4.</span>$
(15)</p>

    <p class="text-gray-300">Since these conditions are satisfied with probability  <span class="math">2^{-24}</span> , only  <span class="math">2^{64} \\times 2^{-24} = 2^{40}</span>  possible combinations of the 8 bytes of  <span class="math">k^3</span>  (equivalently  <span class="math">\\tilde{k}^3</span> ) and  <span class="math">k^4</span>  satisfied them. The cost of this</p>

    <pre><code class="language-text">Data: 2 ciphertexts pairs (c^1, c^2) and (c^1, c^3), whose corresponding plaintexts
       belong in the same coset of \\mathcal{D}_0.
Result: Secret key k^4.
for all 2^{64} values of two columns of k^4 defined as in (14) do
   partial decrypt
   3-Round Attack (see Algorithm 5): identify candidates for eight bytes of k^3 (two
    per column)
                                                  // on average only 1 candidate
   check key schedule conditions given in (15)
                                                    // probability equal to 2^{-24}
   if key schedule satisfied then
       find other four bytes of k^4 using (16)
       for all 2^{24} values of the four remaining bytes of k^4 (see (17)-(18)) do
          Brute Force attack on all possible candidates
          if key k^4 found then return k^4.
end
</code></pre>

    <p class="text-gray-300">Algorithm 6: Pseudo-code for key-recovery attack on 4 rounds (EE) of AES-128.</p>

    <p class="text-gray-300">step is  <span class="math">2 \\times 2^{64} \\times 2^{-8} = 2^{57}</span>  S-Box look-ups (since one condition doesn't involve any S-Box, and the probability that it is satisfied is  <span class="math">2^{-8}</span> ).</p>

    <p class="text-gray-300"><strong>Details of the Second Part of the Attack.</strong> In order to find the right key, the idea is to test the  <span class="math">2^{40}</span>  found combinations using a brute force attack. Observe that for each of these combinations (composed of eight bytes of  <span class="math">k^4</span>  and 8 bytes of  <span class="math">k^3</span> ), the attacker can compute other four bytes of  <span class="math">k^4</span>  using the key schedule, that is:</p>

    <p class="text-gray-300"><span class="math">$k_{1,0}^4 = \\text{S-Box}(k_{2,3}^3) \\oplus k_{1,0}^3,</span>$
<span class="math">k_{2,3}^4 = k_{2,3}^3 \\oplus k_{2,2}^4,</span>   <span class="math">k_{2,0}^4 = \\text{S-Box}(k_{3,3}^3) \\oplus k_{2,0}^3,</span>   <span class="math">k_{0,2}^4 = k_{0,3}^3 \\oplus k_{0,3}^4.</span>  (16)</p>

    <p class="text-gray-300">and (in an analogous way) three bytes of  <span class="math">k^3</span> , which are  <span class="math">k_{2,1}^3, k_{2,2}^3</span>  and  <span class="math">k_{3,1}^3</span> . Thus, four bytes of the key of the final round  <span class="math">k^4</span>  are still unknown, which are:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-53-1&quot;&gt;&lt;/span&gt;
<span class="math">$k_{0,1}^4 k_{1,1}^4 k_{3,2}^4 k_{3,3}^4, (17)</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300">&lt;span id=&quot;page-53-2&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-53-0&quot;&gt;&lt;/span&gt;
<span class="math">$k_{3,2}^4 \\oplus k_{3,3}^4 = k_{3,0}^3 \\tag{18}</span>$</p>

    <p class="text-gray-300">and  <span class="math">k_{3,0}^3</span>  is known. To do the brute force attack, the idea is simply to guess those three bytes. That is, the attacker has to test  <span class="math">2^{40} \\cdot (2^8)^3 = 2^{64}</span>  possible keys by brute force. The cost of this step is  <span class="math">2^{64}</span>  four-round AES. Only for completeness, note that another possibility is to consider plaintexts that belong to the same coset of  <span class="math">\\mathcal{D}_0 \\cap \\mathcal{C}_0</span> , and to use the fact that after one round they belong to the same coset of  <span class="math">\\mathcal{C}_0 \\cap \\mathcal{M}_0</span> .</p>

    <p class="text-gray-300">As for the attack on 3 rounds, a good idea is to perform these two steps at the same time, that is to test the keys found in the first step by the brute force attack. In this way, the attacker doesn't need to store anything.</p>

    <p class="text-gray-300">In conclusion, for this attack the attacker needs 3 different chosen plaintexts and the computational cost is approximately  <span class="math">2^{68.6} + 2^{81} \\simeq 2^{81}</span>  S-Box look-ups for the first part of the attack, that is about  <span class="math">2^{74.7}</span>  four-round AES, and then a further  <span class="math">2^{64}</span>  four-round AES for the brute force attack of the second part, that is in total  <span class="math">2^{74.7} + 2^{64} \\simeq 2^{74.7}</span>  four-round AES (the memory cost is negligible).</p>

    <p class="text-gray-300">Observe that the first step of this attack can be performed using only table look-ups, in the same way of the attack described in App. E. In this case, the cost of the first step of the attack becomes  <span class="math">2^{64} \\cdot 2^{12} = 2^{76}</span>  memory access, since the cost of the attack on 3 rounds is  <span class="math">2^{12}</span>  memory access and the attacker has to repeat this step for all the  <span class="math">2^{64}</span>  possible values of the 8 bytes of the key of the final rounds. Thus, in this case the attacker needs 3 different chosen plaintexts, the computational cost is approximately  <span class="math">2^{76}</span>  memory accesses and  <span class="math">2^{64}</span>  four-round AES encryptions, and the memory cost is about  <span class="math">2^{16}</span>  bytes. Using a previous observation (1 round of AES  <span class="math">\\approx</span>  20 memory accesses), one can declare that the total complexity of the attack is approximately  <span class="math">(20 \\cdot 4)^{-1} \\times 2^{76} + 2^{64} = 2^{69.71}</span>  executions of the four-round encryption.</p>

    <h4 id="sec-48" class="text-lg font-semibold mt-6">E.4.2 Attack with only 2 Chosen Plaintexts (or more than 3)</h4>

    <p class="text-gray-300">It is also possible to mount this attack using only 1 pair of chosen plaintexts, that is 2 chosen plaintexts are sufficient to discover the secret key. At the first step, using a single pair of chosen plaintexts, the attacker is able to discover  <span class="math">2^{32}</span>  combinations for the eight bytes of  <span class="math">k^3</span>  for each combination of the eight bytes of  <span class="math">k^4</span> . Instead to use a third chosen plaintext to find the right combination, the idea is simply to do a brute force attack. In particular, using the conditions (15), the attacker is able to eliminate  <span class="math">2^{24}</span>  wrong combinations. Then, for each of the  <span class="math">2^8</span>  survived combinations, she can easily find other four bytes of  <span class="math">k^4</span>  using the conditions (16), and (in the same way as before) she guesses the remaining four bytes of  <span class="math">k^4</span>  (remember that it is sufficient to guess only three of them). Thus, for each combination of the eight bytes of  <span class="math">k^4</span> , the attacker has to test by brute force  <span class="math">2^{32}</span>  values. This means that in total she has to test by brute force  <span class="math">2^{32} \\times (2^8)^8 = 2^{96}</span>  possible values. In conclusion, for this attack, the attacker needs 2 different chosen plaintexts and the computational cost is  <span class="math">2^{96}</span>  four-round AES (the memory cost is negligible).</p>

    <p class="text-gray-300">We also show that it is not possible to improve the computational cost of the attack using more chosen plaintexts. Indeed, in the second step of the attack with three chosen plaintexts, suppose to check the  <span class="math">2^{40}</span>  survived combinations with other two pairs of plaintexts that belong to the same coset  <span class="math">\\mathcal{D}_I \\oplus a</span> . That is, given  <span class="math">p^4</span>  and  <span class="math">p^5</span> , the attacker check for which combinations of the 8 bytes of the keys  <span class="math">k^3</span>  and  <span class="math">k^4</span> , the conditions  <span class="math">s^1 \\oplus s^4 \\in \\mathcal{M}_I</span>  and  <span class="math">s^1 \\oplus s^5 \\in \\mathcal{M}_I</span>  are satisfied. Observe that the probability that both these conditions are satisfied is  <span class="math">2^{-64}</span> , thus only one key (the right one) survived. Anyway, the total computational cost of this variant is again approximately  <span class="math">2^{74.7}</span>  four-round AES, since the most expensive step of the attack is the first one, which doesn't change if the attacker uses more than three chosen plaintexts.</p>

    <p class="text-gray-300">Finally, these two versions of this attack work in a similar way if MixColumns operation is not omitted in the last round. In this case, the idea is simply to change the position of MixColumns operation with the final AddRoundKey operation. As these operations are linear they can be interchanged, by first XORing the data with an equivalent version of the key (that is  <span class="math">\\tilde{k}^4 := MC^{-1}(k^4)</span> ) and only then applying the MixColumns operation.</p>

    <p class="text-gray-300"><strong>Practical Verification.</strong> Since this attack on 4 rounds with the extension at the end has a very high computational cost, we tested it in a different way. As we have seen, the attacker has to guess eight bytes of the final key, for a total of  <span class="math">2^{64}</span>  possibilities. In our experiments, the attacker guesses only two bytes of the final key instead of eight, where the remaining six bytes are fixed and equal to those of the secret key. In this way, the total complexity of the attack becomes more feasible for a real test and allows us to have a practical verification of the attack.</p>

    <h2 id="sec-49" class="text-2xl font-bold">&lt;span id=&quot;page-55-0&quot;&gt;&lt;/span&gt;E.5 Key-recovery Attack on 4 Rounds of AES - Extending the 3 Rounds Attack at the Beginning</h2>

    <p class="text-gray-300">In the previous section, we have showed how to extend at the end the attack on 3 rounds presented in App. E. In this section, we show how to attack 4 rounds extending at the beginning the attack on 3 rounds. As we'll show, both from the computational point of view and from the data complexity point of view, this attack on 4 rounds is better if  <span class="math">\\dim(\\mathcal{D}_I) = 12</span>  than  <span class="math">\\dim(\\mathcal{D}_I) = 4</span> . Since the attack on 3 rounds given in Sect. E works the same when  <span class="math">\\dim(\\mathcal{D}_I) = 12</span> , we present it in details in the end of this section. We limit ourselves to report the data and the computational complexity of this attack. In the case in which  <span class="math">\\dim(\\mathcal{D}_I) = 12</span> , the attack on 3 rounds needs 4 pairs of plaintexts, that is 5 chosen plaintexts, and the total computational cost is approximately at  <span class="math">2^{31.09}</span>  S-Box look-ups, that is about  <span class="math">2^{25.18}</span>  executions of the three-round cipher (the memory consumption is negligible), or  <span class="math">2^{24.6}</span>  memory access and  <span class="math">2^{24.18}</span>  S-Box look-ups (with a memory cost of approximately  <span class="math">2^{16}</span>  bytes).</p>

    <p class="text-gray-300">In order to attack 4 rounds of AES, the idea is to extend the attack on 3 rounds (described in App. E.5.2) adding an initial round. Consider two plaintexts  <span class="math">p^1</span>  and  <span class="math">p^2</span> :</p>

    <p class="text-gray-300"><span class="math">$p^h \\xrightarrow{R(\\cdot)} R(p^h) \\xrightarrow{R^{(2)}(\\cdot)} s^h \\xrightarrow{R_f(\\cdot)} c^h.</span>$</p>

    <p class="text-gray-300">where h=1,2. If the attacker is able to guarantee that after one round they belong to the same coset of  <span class="math">\\mathcal{D}_I</span> , then she can repeat the attack on 3 rounds, using  <span class="math">R(p^h)</span>  instead of  <span class="math">p^h</span> . Observe that if  <span class="math">p^1 \\oplus p^2 \\in \\mathcal{C}_J</span> , then  <span class="math">R(p^1) \\oplus R(p^2) \\in \\mathcal{M}_J</span>  and (Lemma 5)  <span class="math">R(p^1) \\oplus R(p^2) \\notin \\mathcal{D}_I</span> , for each I and J such that  <span class="math">\\dim(\\mathcal{M}_J) + \\dim(\\mathcal{D}_I) \\leq 16</span> . Thus,  <span class="math">p^1</span>  and  <span class="math">p^2</span>  have to be chosen such that  <span class="math">p^1 \\oplus p^2</span>  doesn't belong to  <span class="math">\\mathcal{C}_J</span>  for each J such that  <span class="math">|J| + |I| \\leq 4</span> , in order to guarantee that  <span class="math">R(p^1) \\oplus R(p^2) \\in \\mathcal{D}_I</span> .</p>

    <p class="text-gray-300">We present our attack in the case in which  <span class="math">\\dim(\\mathcal{D}_I) = 12</span> , and only for simplicity, we suppose that MixColumns operation is omitted in the last round (however, our attack works in the same way in the case in which it is not omitted).</p>

    <p class="text-gray-300">Given pairs of plaintexts  <span class="math">p^1</span>  and  <span class="math">p^2</span> , our main goal is to minimize the number of bytes of  <span class="math">k^0</span>  that the attacker has to guess in order to guarantee the condition</p>

    <p class="text-gray-300">&lt;span id=&quot;page-55-1&quot;&gt;&lt;/span&gt;
<span class="math">$R(p^1) \\oplus R(p^2) \\in \\mathcal{D}_I \\tag{19}</span>$</p>

    <p class="text-gray-300">for a certain I with |I| = 3. For the following, it is important to note that we don't fix a particular I. A possible choice for the pair of plaintexts  <span class="math">p^1</span>  and  <span class="math">p^2</span>  can be the following:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-55-2&quot;&gt;&lt;/span&gt;
<span class="math">$p_{i,j}^1 = p_{i,j}^2</span>$
for all  <span class="math">(i,j) \\neq \\{(0,3),(2,1)\\}.</span>  (20)</p>

    <p class="text-gray-300">As we show in the following, this choice allows the attacker to guess only 2 bytes of  <span class="math">k^0</span> . Due to the previous choice of  <span class="math">p^1</span>  and  <span class="math">p^2</span> , it follows that</p>

    <p class="text-gray-300"><span class="math">$R(p^1)_{i,j} = R(p^2)_{i,j} \\qquad \\forall i, \\forall j \\neq 3.</span>$</p>

    <p class="text-gray-300">independent of the secret key. Thus, to guarantee that  <span class="math">R(p^1) \\oplus R(p^2) \\in \\mathcal{D}_I</span>  for a certain I with |I|=3, it is sufficient for the attacker to guess only two bytes of the secret key (that is,  <span class="math">k_{0,3}^0</span>  and  <span class="math">k_{2,1}^0</span> ), since it is sufficient that one byte of the first column of  <span class="math">R(p^1) \\oplus R(p^2)</span>  is equal to zero to guarantee (19). For example, for the case  <span class="math">I=\\{0,1,2\\}</span>  (studied in App. E.5.2), the condition  <span class="math">R(p^1) \\oplus R(p^2) \\in \\mathcal{D}_I</span>  is satisfied if and only if  <span class="math">R(p^1)_{3,0} \\oplus R(p^2)_{3,0} = 0</span> , that is if the following equivalence is satisfied</p>

    <p class="text-gray-300"><span class="math">$\\alpha \\cdot [\\operatorname{S-Box}(p_{0,3}^1 \\oplus k_{0,3}^0) \\oplus \\operatorname{S-Box}(p_{0,3}^2 \\oplus k_{0,3}^0)] = \\ \\operatorname{S-Box}(p_{2,1}^1 \\oplus k_{2,1}^0) \\oplus \\operatorname{S-Box}(p_{2,1}^2 \\oplus k_{2,1}^0).</span>$</p>

    <p class="text-gray-300">Thus, for each bytes  <span class="math">k_{0,3}^0</span>  and  <span class="math">k_{2,1}^0</span>  of the secret key, the attacker has to find pairs of plaintexts  <span class="math">p^1</span>  and  <span class="math">p^2</span>  that satisfy Eq.(20) and such that  <span class="math">R(p^1) \\oplus R(p^2) \\in \\mathcal{D}_I</span>  for that key and for a certain I with |I| = 3, in order to repeat the attack on 3 rounds.</p>

    <p class="text-gray-300">On average, for a fixed I (with |I|=3), there exist  <span class="math">2^{24}</span>  combinations  <span class="math">(p_{0,3}^1, p_{2,1}^1, p_{0,3}^2, p_{2,1}^2)</span>  that satisfy Eq. (19) and Eq. (20). On the other hand, given a particular combination  <span class="math">(p_{0,3}^1, p_{2,1}^1, p_{0,3}^2, p_{2,1}^2)</span>  and for a fixed I, on average there are  <span class="math">2^8</span>  different pair of key bytes that satisfy (20). Since there are four possible I with |I|=3, for each combination  <span class="math">(p_{0,3}^1, p_{2,1}^1, p_{0,3}^2, p_{2,1}^2)</span>  on average there are  <span class="math">2^8 \\times 2^2 = 2^{10}</span>  different pair of key bytes such that  <span class="math">R(p^1) \\oplus R(p^2) \\in \\mathcal{D}_I</span>  for a certain I with |I|=3.</p>

    <p class="text-gray-300">Note that since the attacker can not impose any restriction on the secret key, she has to repeat this (and the next steps) for all the possible pairs  <span class="math">(k_{0.3}^0, k_{2.1}^0)</span> .</p>

    <p class="text-gray-300"><strong>Proposition 6.</strong> Let  <span class="math">(k_{0,3}, k_{2,1})</span>  and  <span class="math">(p_{0,3}^1, p_{2,1}^1, p_{0,3}^2, p_{2,1}^2)</span>  be a pair of key bytes and a combination of plaintexts bytes that satisfy (20). If  <span class="math">(\\hat{k}_{0,3}, \\hat{k}_{2,1})</span>  denote another pair of key bytes, then the combination  <span class="math">(q_{0,3}^1, q_{2,1}^1, q_{0,3}^2, q_{2,1}^2)</span>  of plaintext bytes defined as  <span class="math">q_{i,j}^h := p_{i,j}^h \\oplus \\hat{k}_{i,j} \\oplus k_{i,j}</span>  where h = 1, 2 and  <span class="math">(i, j) \\in \\{(0, 3), (2, 1)\\}</span>  satisfies (19) for that key.</p>

    <p class="text-gray-300">Finally, observe that if  <span class="math">\\dim(\\mathcal{D}_I) = 4</span> , the condition such that  <span class="math">R(p^1) \\oplus R(p^2) \\in \\mathcal{D}_I</span>  becomes more complicated, since the attacker has to guess 4 bytes of the initial key instead of 2. This justifies the initial choice of  <span class="math">\\dim(\\mathcal{D}_I) = 12</span> .</p>

    <p class="text-gray-300">Suppose that for each pair of key bytes  <span class="math">(k_{0,3}^0, k_{2,1}^0)</span>  the attacker knows a combination  <span class="math">(p_{0,3}^1, p_{2,1}^1, p_{0,3}^2, p_{2,1}^2)</span>  such that  <span class="math">R(p^1) \\oplus R(p^2) \\in \\mathcal{D}_I</span>  for that key and for a certain I with |I|=3. The general idea of the attack is simply to repeat the previous attack on 3 rounds described in Appendix E.5.2, that is to use 4 pairs of plaintexts (that satisfy (19) and (20)) in order to discover the key  <span class="math">k^4</span>  such that  <span class="math">R_f^{-1}(c^1) \\oplus R_f^{-1}(c^2) \\in \\mathcal{M}_I</span> . As for the attack on 4 rounds with the extension at the end, when the attacker has found  <span class="math">k^4</span> , she has to check if it is compatible with  <span class="math">k^0</span>  (i.e. that they satisfy the key schedule), in order to verify that it is the right key. If they are compatible, then she has discovered the secret key, otherwise she has to repeat this procedure for another pair of key bytes  <span class="math">(k_{0,3}^0, k_{2,1}^0)</span> .</p>

    <p class="text-gray-300">In order to check if  <span class="math">k^4</span>  is compatible with  <span class="math">k^0</span> , we recall the following useful theorem (see [BDD+12] for more details):</p>

    <p class="text-gray-300">&lt;span id=&quot;page-56-0&quot;&gt;&lt;/span&gt;<strong>Theorem 3.</strong> For each round r and for each i = 0, ..., 3:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} k_{i,1}^r &amp;= k_{i,1}^{r+2} \\oplus v_i^{r+1}, \\qquad k_{i,2}^r &amp;= k_{i,3}^{r+2} \\oplus k_{i,0}^{r+2}, \\\\ k_{i,3}^r &amp;= k_{i,3}^{r+2} \\oplus k_{i,1}^{r+2} = k_{i,3}^{r+4} \\oplus v_i^{r+3}, \\end{split}</span>$</p>

    <p class="text-gray-300">where  <span class="math">v_i^r = \\text{S-Box } (k_{(i+1) \\mod 4,3}^r) \\oplus RCON[r+1].</span></p>

    <p class="text-gray-300">By simple computation:</p>

    <p class="text-gray-300"><span class="math">$k_{0,3}^0 = k_{0,3}^4 \\oplus \\text{S-Box}(k_{1,2}^4 \\oplus k_{1,3}^4) \\oplus 0\\text{x}08,</span>$</p>

    <p class="text-gray-300"><span class="math">k_{2,1}^0 = k_{2,1}^4 \\oplus \\text{S-Box}(k_{3,0}^4 \\oplus k_{3,1}^4 \\oplus k_{3,2}^4 \\oplus k_{3,3}^4) \\oplus \\text{S-Box}(k_{3,2}^4 \\oplus k_{3,3}^4).</span></p>

    <p class="text-gray-300">Thus, only 3 S-Box look-ups are sufficient to check if  <span class="math">k^4</span>  is compatible with  <span class="math">k^0</span>  (the choice of (20) is also due to the simplicity of this check operation). Note that since the probability that the key schedule is satisfied is  <span class="math">2^{-16}</span>  and since there are only  <span class="math">2^{16}</span>  possible combinations of  <span class="math">(k_{0,3}^0, k_{2,1}^0)</span> , on average only one key satisfied the key schedule (which is the right one), that is the attacker certainly finds the right key.</p>

    <p class="text-gray-300">In the following, we show in details how to implement the attack in order to minimize the data complexity (together with the pseudo-code). As a result, this attack needs  <span class="math">24 \\simeq 2^{4.55}</span>  chosen plaintexts and has a total computational cost of  <span class="math">2^{40.7}</span>  executions of the four-round cipher, or of  <span class="math">2^{35.08}</span>  executions of the four-round encryption using a precomputation phase.</p>

    <h4 id="sec-50" class="text-lg font-semibold mt-6">E.5.1 Details of the Attack - Minimal Data Complexity</h4>

    <p class="text-gray-300">As we have seen, the attacker needs on average 4 pairs of plaintexts (that satisfy Eq.(20)) for each pair of key bytes  <span class="math">(k_{0,3}, k_{2,1})</span> .</p>

    <p class="text-gray-300">Data: 24 ciphertexts such that for each keys bytes  <span class="math">(k_{0,3}^0, k_{2,1}^0)</span>  there exist 4 different pairs of chosen plaintexts that satisfy (20) and such that there exists I with |I|=3 such that  <span class="math">R(p^1)\\oplus R(p^2)\\in \\mathcal{D}_I</span> .</p>

    <p class="text-gray-300">Result: Secret key  <span class="math">k^4</span> .</p>

    <p class="text-gray-300">for all  <span class="math">2^{16}</span>  values of two bytes  <span class="math">(k_{0,3}^0, k_{2,1}^0)</span>  do</p>

    <p class="text-gray-300">for the guessed key, pick up the 4 different pairs of chosen plaintexts stored in memory (and corresponding I)</p>

    <p class="text-gray-300">3-Rounds Attack (see App. E.5.2): identify candidates for  <span class="math">k^4</span>  // on average only 1 candidate check key schedule conditions given in (E.5)
\\nif key schedule satisfied then // probability equal to  <span class="math">2^{-16}</span>  end</p>

    <p class="text-gray-300"><strong>Algorithm 7:</strong> Attack on 4 rounds (EB) of AES-128 - Pseudo Code. For simplicity, we assume that the attacker has already found 24 texts defined as in the text.</p>

    <p class="text-gray-300">Observe that given n plaintexts  <span class="math">p^i</span>  for i=0,...,n-1 that satisfy condition (20), then it is possible to construct  <span class="math">n\\cdot (n-1)/2</span>  pairs of plaintexts that satisfy the condition (20). On average for each of these pairs of plaintexts  <span class="math">(p^1,p^2)</span> , there are  <span class="math">2^{10}</span>  pairs of key bytes that satisfy  <span class="math">R(p^1)\\oplus R(p^2)\\in \\mathcal{D}_I</span>  for |I|=3. Since the number of pair of keys bytes  <span class="math">(k_{0,3}^0,k_{2,1}^0)</span>  is  <span class="math">2^{16}</span> , then the attacker needs on average  <span class="math">2^{16}\\times 4\\times 2^{-10}=2^8</span>  pairs of chosen plaintexts for the attack. That is&lt;sup&gt;22&lt;/sup&gt;, she needs about  <span class="math">2^{4.55}\\simeq 24</span>  chosen plaintexts.</p>

    <p class="text-gray-300">These chosen plaintexts can be precomputed in advance. For each of the  <span class="math">2^{16}</span>  keys bytes  <span class="math">(k_{0,3}^0, k_{2,1}^0)</span> , the idea is to store the four pairs of chosen plaintexts and for each pair  <span class="math">(p^1, p^2)</span>  the corresponding I such that  <span class="math">R(p^1) \\oplus R(p^2) \\in \\mathcal{D}_I</span>  (in order to implement the attack), using a predetermined order&lt;sup&gt;23&lt;/sup&gt;. By simple computation, the attacker needs 4 (pairs of CP)  <span class="math">\\times 2 \\times 4</span>  (bytes to store)  <span class="math">\\times 2^{16}</span>  (number of keys) =  <span class="math">2^{21}</span>  bytes to store the plaintexts and 2 (bits of I)  <span class="math">\\times 2^{16} = 2^{17}</span>  bits =  <span class="math">2^{14}</span>  bytes to store the corresponding I, that is approximately  <span class="math">2^{21} + 2^{14} = 2^{21.01}</span>  bytes of memory. Thus, our attack needs  <span class="math">2^{4} \\times 2^{4.55}</span>  chosen plaintexts and the total computational cost is approximately at  <span class="math">(2^8)^2</span>  (2 guessed bytes of  <span class="math">k^0</span> )  <span class="math">\\times 2^{31.09}</span>  (cost of the attack on 3 rounds)  <span class="math">+3 \\times 2^{16}</span>  (check the key schedule) =  <span class="math">2^{47.09}</span>  S-Box look-ups, that is about  <span class="math">2^{40.7}</span>  executions of the four-round cipher and  <span class="math">2^{16}</span>  (sequential) memory access.</p>

    <p class="text-gray-300">In the same way as before, it is also possible to perform this attack using memory access. In this case, the total computational cost is approximately at  <span class="math">2^{16} \\times 2^{24.6}</span>  (cost of the attack on 3 rounds)=  <span class="math">2^{40.6}</span>  memory access and  <span class="math">2^{16} \\times 2^{24.18}</span>  (cost of the attack on 3 rounds)+3 ×  <span class="math">2^{16}</span>  (check the key schedule) =  <span class="math">2^{40.18}</span>  S-Box look-ups, that is  <span class="math">2^{33.86}</span>  executions of the four-round AES. With the approximation of 1 round of AES with 20 memory accesses, one can declare that the total complexity of the attack is approximately  <span class="math">(20 \\cdot 4)^{-1} \\times 2^{40.6} + 2^{33.86} = 2^{35.08}</span>  executions of the four-round encryption.</p>

    <p class="text-gray-300"><span class="math">$m = \\log_2\\left((2^{n+3}+1)^{\\frac{1}{2}}+1\\right) - 1 \\simeq (n+1)/2.</span>$
(21)</p>

    <p class="text-gray-300">&lt;span id=&quot;page-57-0&quot;&gt;&lt;/span&gt; <span class="math">&lt;sup&gt;2^{2}&lt;/sup&gt;</span> Given  <span class="math">2^{n}</span>  elements, the number of different pairs are  <span class="math">2^{n-1} \\cdot (2^{n}-1)</span> . Viceversa, in order to have  <span class="math">2^{n}</span>  different pairs, we need  <span class="math">2^{m}</span>  elements, where</p>

    <p class="text-gray-300">&lt;span id=&quot;page-57-1&quot;&gt;&lt;/span&gt; <span class="math">&lt;sup&gt;^{23}&lt;/sup&gt;</span> For example, let  <span class="math">f: \\mathbb{Z}_{28} \\times \\mathbb{Z}_{28} \\to \\mathbb{Z}_{216}</span>  the (bijective) function defined as  <span class="math">f(x_1, x_2) = 4 \\cdot (x_1 + 256 \\cdot x_2)</span> . The combination of plaintexts for the key  <span class="math">(k_1, k_2)</span>  are in positions  <span class="math">f(k_1, k_2), f(k_1, k_2) + 1, f(k_1, k_2) + 2</span>  and  <span class="math">f(k_1, k_2) + 3</span> .</p>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-58-0&quot;&gt;&lt;/span&gt;E.5.2 Key-Recovery Attacks on 3 Rounds of AES - <span class="math">\\dim(\\mathcal{D}_I) = 12</span></h4>

    <p class="text-gray-300">In this section, we present the attack on 3 rounds of AES in the case in which  <span class="math">\\dim(\\mathcal{D}_I) = 12</span> . The computational cost of the attack on 3 rounds for this case is higher than for the case in which  <span class="math">\\dim(\\mathcal{D}_I) = 4</span> . However, the 4-round attack presented in Sect. E.5 is obtained extending the attack on 3 rounds of this section at the beginning. Indeed, it is possible to prove that the situation is completely different (in particular, it is the opposite) when we consider the extension to 4 rounds, adding an initial round.</p>

    <p class="text-gray-300">For simplicity, we consider only the case  <span class="math">I = \\{0, 1, 2\\}</span> . By definition,  <span class="math">\\mathcal{D}_I</span>  is the subspace with zero-elements on the fourth diagonal. For all  <span class="math">a \\in \\mathcal{D}_I^{\\perp}</span>  there exists unique  <span class="math">b \\in \\mathcal{M}_I^{\\perp}</span>  such that  <span class="math">R^{(2)}(\\mathcal{D}_I \\oplus a) = \\mathcal{M}_I \\oplus b</span> , where</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{M}_I \\equiv \\begin{bmatrix} a_1(x_1, x_6, x_{11}) &amp; a_2(x_4, x_5, x_{10}) &amp; a_3(x_3, x_8, x_9) &amp; a_4(x_2, x_7, x_{12}) \\\\ a_2(x_1, x_6, x_{11}) &amp; a_3(x_4, x_5, x_{10}) &amp; a_4(x_3, x_8, x_9) &amp; a_1(x_2, x_7, x_{12}) \\\\ a_3(x_1, x_6, x_{11}) &amp; a_4(x_4, x_5, x_{10}) &amp; a_1(x_3, x_8, x_9) &amp; a_2(x_2, x_7, x_{12}) \\\\ a_4(x_1, x_6, x_{11}) &amp; a_1(x_4, x_5, x_{10}) &amp; a_2(x_3, x_8, x_9) &amp; a_3(x_2, x_7, x_{12}) \\end{bmatrix},</span>$</p>

    <p class="text-gray-300">and where  <span class="math">a_i(\\cdot,\\cdot,\\cdot)</span>  are defined in the following way  <span class="math">(\\forall i=1,2,3,4)</span> :</p>

    <p class="text-gray-300"><span class="math">$a_1(x, y, z) = \\alpha x \\oplus (\\alpha + 1)y \\oplus z,</span>$</p>

    <p class="text-gray-300"><span class="math">$a_2(x, y, z) = x \\oplus \\alpha y \\oplus (\\alpha + 1)z,</span>$</p>

    <p class="text-gray-300"><span class="math">$a_3(x, y, z) = x \\oplus y \\oplus \\alpha z,</span>$</p>

    <p class="text-gray-300"><span class="math">$a_4(x, y, z) = (\\alpha + 1)x \\oplus y \\oplus z.</span>$</p>

    <p class="text-gray-300">As before, given two ciphertexts  <span class="math">c^1</span>  and  <span class="math">c^2</span> , the idea is to find all the keys of the final round such that  <span class="math">R_f^{-1}(c^1) \\oplus R_f^{-1}(c^2) \\in \\mathcal{M}_I</span> . As we've seen, the right key is the only one that satisfies this previous condition for each pair  <span class="math">p^1</span>  and  <span class="math">p^2</span>  such that  <span class="math">p^1 \\oplus p^2 \\in \\mathcal{D}_I</span> . The idea is to work again independently on each column, but in this case the attacker has to guess 3 bytes for each column. Thus, the number of possible keys found at each step is higher than before: this explains why the total computational cost and the number of requested chosen plaintexts is higher.</p>

    <p class="text-gray-300">Since the attack is equivalent to the previous one, we only show which conditions the key bytes have to satisfy in order to guarantee that  <span class="math">R_f^{-1}(c^1) \\oplus R_f^{-1}(c^2) \\in \\mathcal{M}_I</span>  for the first column. Suppose the attacker guesses (for example) the bytes  <span class="math">k_{0,0}, k_{1,3}</span>  and  <span class="math">k_{2,2}</span> . By simple computation,  <span class="math">R_f^{-1}(c^1) \\oplus R_f^{-1}(c^2) \\in \\mathcal{M}_I</span>  if  <span class="math">k_{3,1}</span>  satisfies the following equivalence:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-58-1&quot;&gt;&lt;/span&gt;
<span class="math">$S-Box^{(-1)}(c_{3,1}^{1} \\oplus k_{3,1}) \\oplus S-Box^{(-1)}(c_{3,1}^{2} \\oplus k_{3,1}) =</span>$</p>

    <p class="text-gray-300"><span class="math">$= (\\alpha^{6} + \\alpha^{4} + \\alpha^{3} + \\alpha^{2} + 1) \\cdot [S-Box^{(-1)}(c_{0,0}^{1} \\oplus k_{0,0}) \\oplus S-Box^{(-1)}(c_{0,0}^{2} \\oplus k_{0,0})] \\oplus</span>$</p>

    <p class="text-gray-300"><span class="math">$\\oplus (\\alpha^{5} + \\alpha^{4} + \\alpha^{2} + 1) \\cdot [S-Box^{(-1)}(c_{1,3}^{1} \\oplus k_{1,3}) \\oplus S-Box^{(-1)}(c_{1,3}^{2} \\oplus k_{1,3})] \\oplus</span>$</p>

    <p class="text-gray-300"><span class="math">$\\oplus (\\alpha^{7} + \\alpha^{3} + \\alpha^{2}) \\cdot [S-Box^{(-1)}(c_{2,2}^{1} \\oplus k_{2,2}) \\oplus S-Box^{(-1)}(c_{2,2}^{2} \\oplus k_{2,2})].</span>$</p>

    <p class="text-gray-300"><span class="math">$(22)</span>$</p>

    <p class="text-gray-300">If ciphertexts satisfy conditions similar to (12), the attacker is able to reduce the number of possible keys to  <span class="math">2^{128} \\times (2^8)^{-4} = 2^{96}</span> , with a total computational cost of about  <span class="math">2^{31}</span>  S-Box look-ups.</p>

    <p class="text-gray-300">As before, the idea is to eliminate some of the keys found in the previous step using other pairs of ciphertexts, and the attacker can take advantage of the independence of the columns to perform this step with a low computational cost. In particular, the probability that each column of the key found previously satisfies (22) for another pair of ciphertexts is on average  <span class="math">2^{-8}</span> . Thus, using a second pair of plaintexts, the attacker reduces the keys to  <span class="math">2^{96} \\times (2^8)^{-4} = 2^{64}</span>  with a computational cost of  <span class="math">2^{27}</span>  S-Box look-ups. Thus, the attacker needs other two pairs of plaintexts to discover the secret key (with a total computational cost of about  <span class="math">2^{19} + 2^{11}</span>  S-Box look-ups). Performing these steps at the same time, that is checking the combinations found with the first pair of plaintexts immediately with the other ones, allows to save memory.</p>

    <p class="text-gray-300">Note that using 5 chosen plaintexts the attacker can construct 10 different pairs, but only 4 of them are useful for the attack. For example, suppose that the attacker uses a (first) pair formed by the first and the by second ciphertext, and a (second) that formed by the first and by the third ciphertext. Then the keys that satisfy (22) for these two pairs, automatically satisfy (22) for the pair formed by the second and by the third ciphertext. However, using four pairs of plaintexts with one plaintext in common (that is, 5 different chosen plaintexts), the probability of success is greater than 99.9%.</p>

    <p class="text-gray-300">In conclusion, this attack needs 4 pairs of plaintexts, that is 5 chosen plaintexts, the total computational cost is approximately at  <span class="math">2^{31.09}</span>  S-Box look-ups, that is about  <span class="math">2^{25.18}</span>  executions of the three-round cipher (the memory cost is negligible). Performing the attack using memory access, the total computational cost is approximately at  <span class="math">2^{24.6}</span>  memory access,  <span class="math">2^{24.18}</span>  S-Box look-ups (that is about  <span class="math">2^{18.27}</span>  executions of the three-round cipher) and the memory cost is approximately  <span class="math">2^{16}</span>  bytes, and the cost of the precomputation is about  <span class="math">2^{10.1}</span>  executions of three-round AES.</p>

    <h2 id="sec-52" class="text-2xl font-bold">&lt;span id=&quot;page-59-0&quot;&gt;&lt;/span&gt;F Re-Order Algorithm - Details</h2>

    <p class="text-gray-300">Both for the truncated differential attack on 4 rounds of AES with a secret S-Box of App. H and for the impossible differential attack/distinguisher on 5 rounds of AES of Sect. 7 - 8, one has to count the number of &quot;collisions&quot; (that is, the number of texts that belong to the same coset of  <span class="math">\\mathcal{M}_I</span>  for |I|=3) in order to find the secret key or to distinguish a random permutation from an AES one.</p>

    <p class="text-gray-300">As first possibility, one can construct all the possible pairs of texts and to count the number of collisions. First of all, we compute the cost to check that a given pair of texts belong to the same coset of  <span class="math">\\mathcal{M}_I</span> . Without loss of generality (w.l.o.g) we consider  <span class="math">I=\\{1,2,3\\}</span>  (it is analogous to the other cases). Only for example, given a pair  <span class="math">(c_1,c_2)</span>  this operation can be simple reduced to check if  <span class="math">MC^{-1}(c_1 \\oplus c_2)_{i,i} = MC^{-1}(c_1)_{i,i} \\oplus MC^{-1}(c_2)_{i,i} = 0</span>  for each i=0,...,3 (note that  <span class="math">c_1 \\oplus c_2 \\in \\mathcal{M}_I</span>  if and only if  <span class="math">MC^{-1}(c_1 \\oplus c_2) \\in MC^{-1}(\\mathcal{M}_I) = \\mathcal{ID}_I</span> ). Thus, for each possible pair, this operation can be reduced to a XOR and to an inverse MixColumns operation.</p>

    <p class="text-gray-300">As we show in the following, this cost is negligible compared to the cost regarding the construction of all the possible pairs. Given n texts, it is possible to construct</p>

    <p class="text-gray-300"><span class="math">$\\binom{n}{2} = \\frac{n \\cdot (n-1)}{2} \\simeq \\frac{n^2}{2}</span>$</p>

    <p class="text-gray-300">different pairs. Thus, the simplest way to construct them requires approximately  <span class="math">n^2/2</span>  table look-ups.</p>

    <p class="text-gray-300">In order to reduce this cost of table look-ups (which is the most expensive step) to  <span class="math">n \\cdot \\log n</span>  table look-ups for each coset, the basic idea is to re-order the ciphertexts. Our goal is to check if two texts belong to the same coset of  <span class="math">\\mathcal{M}_I</span>  for |I|=3. The idea is to re-order the texts using a particular numerical order which depends by I, and then to work only on consecutive ordered elements in order to compute the total number of collisions. To do this, we define the following  <span class="math">partial\\ order^{24} \\leq</span> :</p>

    <p class="text-gray-300"><strong>Definition 8.</strong> Let  <span class="math">I \\subset \\{0,1,2,3\\}</span>  with |I| = 3 and let  <span class="math">l \\in \\{0,1,2,3\\} \\setminus I</span> . Let  <span class="math">t^1, t^2 \\in \\mathbb{F}_{2^8}^{4 \\times 4}</span>  with  <span class="math">t^1 \\neq t^2</span> . The text  <span class="math">t^1</span>  is less or equal than the text  <span class="math">t^2</span>  (i.e.  <span class="math">t^1 \\leq t^2</span> ) if and only if one of the two following conditions is satisfied:</p>

    <p class="text-gray-300">• there exists  <span class="math">j \\in \\{0, 1, 2, 3\\}</span>  such that for all i &lt; j:</p>

    <p class="text-gray-300"><span class="math">$MC^{-1}(t^1)_{i,l-i} = MC^{-1}(t^2)_{i,l-i}</span>$
and  <span class="math">MC^{-1}(t^1)_{j,l-j} &lt; MC^{-1}(t^2)_{j,l-j}</span></p>

    <p class="text-gray-300">&lt;span id=&quot;page-59-1&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;24&lt;/sup&gt;Suppose that P is an order set with respect to the relation  <span class="math">\\leq</span> . Then, the following relationship hold: (1) reflexivity  <span class="math">\\forall a \\in P</span>  then  <span class="math">a \\leq a</span> ; (2) antisymmetry  <span class="math">\\forall a, b \\in P</span>  such that  <span class="math">a \\leq b</span>  and  <span class="math">b \\leq a</span> , then a = b; (3) transitivity  <span class="math">\\forall a, b \\in P</span>  such that  <span class="math">a \\leq b</span>  and  <span class="math">b \\leq c</span> , then  <span class="math">a \\leq c</span> .</p>

    <p class="text-gray-300">• for all
<span class="math">$i = 0, ...., 3</span>$
:</p>

    <p class="text-gray-300"><span class="math">$MC^{-1}(t^1)_{i,l-i} = MC^{-1}(t^2)_{i,l-i}</span>$</p>

    <p class="text-gray-300">where the indexes are taken modulo 4.</p>

    <p class="text-gray-300">Note that this order relationship satisfies all the antisymmetry properties. Indeed, given  <span class="math">t^1</span>  and  <span class="math">t^2</span>  such that  <span class="math">MC^{-1}(t^1)_{i+l,i} = MC^{-1}(t^2)_{i+l,i}</span>  for each i=0,...,3, then we have  <span class="math">t^1 \\leq t^2</span>  and  <span class="math">t^2 \\leq t^1</span>  using the previous relationship, that is  <span class="math">t^1</span>  &quot;=&quot;  <span class="math">t^2</span>  in the sense that  <span class="math">t^1</span>  and  <span class="math">t^2</span>  belong to the same coset of  <span class="math">\\mathcal{M}_I</span>  (that is,  <span class="math">t^1 \\oplus t^2 \\in \\mathcal{M}_I</span> ). Thus, if  <span class="math">MC^{-1}(t^1)_{i+l,i} = MC^{-1}(t^2)_{i+l,i}</span>  for each i=0,...,3, for our purpose it is completely equivalent to consider  <span class="math">t^1 \\leq t^2</span>  or  <span class="math">t^2 \\leq t^1</span>  (i.e. the user can choose in an arbitrary way).</p>

    <p class="text-gray-300">Given the partial order  <span class="math">\\leq</span> , as first thing, one has to re-order the elements using the order relationship given before. Given a set of ordered ciphertexts  <span class="math">\\{c^i\\}_{i=1,\\dots,n}</span> , we show now how to compute the total number of collisions working only on consecutive elements. For the following, w.l.o.g. we assume  <span class="math">I = \\{0, 1, 2\\}</span>  and  <span class="math">l = \\{3\\}</span>  (it is analogous for the other cases).</p>

    <p class="text-gray-300">In order to count the number of pairs of texts that belong to the same coset of  <span class="math">\\mathcal{M}_I</span> , the verifier can work only on two consecutive elements. That is, suppose to consider three consecutive elements  <span class="math">c^{i-1}, c^i, c^{i+1}</span> . The idea is to work as follows. First, one checks if  <span class="math">c^{i-1}, c^i</span>  belong to the same coset of  <span class="math">\\mathcal{M}_I</span>  (equivalently, if  <span class="math">MC^{-1}(c^{i-1}), MC^{-1}(c^i)</span>  belong to the same coset of  <span class="math">MC^{-1}(\\mathcal{M}_I) = SR(\\mathcal{C}_I)</span> ), and repeats this operation also for  <span class="math">c^i, c^{i+1}</span> . Then one can use the following observation: if  <span class="math">c^{i-1} \\oplus c^i \\in \\mathcal{M}_I</span>  and  <span class="math">c^i \\oplus c^{i+1} \\in \\mathcal{M}_I</span>  for the same I, then also  <span class="math">c^{i-1} \\oplus c^{i+1} \\in \\mathcal{M}_I</span>  (remember that  <span class="math">\\mathcal{M}_I</span>  is a subspace). The same argumentation can be generalized for any number of consecutive order elements. In particular, given r consecutive elements that belong to the same coset of  <span class="math">\\mathcal{M}_I</span> , note that it is possible to construct  <span class="math">r \\cdot (r+1)/2</span>  different pairs&lt;sup&gt;25&lt;/sup&gt;, that is the counter has to be increase of  <span class="math">r \\cdot (r+1)/2</span> .</p>

    <p class="text-gray-300">Note that given a set of n order elements, the computational cost to count the number of pairs that belong to the same coset of  <span class="math">\\mathcal{M}_I</span>  can be approximated in O(n) look-ups table. To order the set, one possibility is to use a <em>merge sort</em> algorithm (e.g. see [CLRS09] for details), which has a complexity cost of  <span class="math">O(n \\log n)</span>  memory access. Thus, the total computational cost for the verifier is approximately of</p>

    <p class="text-gray-300"><span class="math">$4 \\cdot n \\cdot (1 + \\log n)</span>$</p>

    <p class="text-gray-300">table look-ups, that is  <span class="math">n \\cdot (1 + \\log n)</span>  for each possible I with |I| = 3.</p>

    <h2 id="sec-53" class="text-2xl font-bold">&lt;span id=&quot;page-60-0&quot;&gt;&lt;/span&gt;G Key Recovery Attacks on 3 rounds of AES with a Single Secret S-Box</h2>

    <p class="text-gray-300">In Sect. 5 we have presented a (generic) strategy that can be used to attack an AES-like cipher with a single secret S-Box, if some very common assumptions on the MixColumns matrix are satisfied. Using this strategy, in this section we present a truncated differential attack and a square attack on 3-round of AES with a single secret S-Box.</p>

    <h2 id="sec-54" class="text-2xl font-bold">&lt;span id=&quot;page-60-1&quot;&gt;&lt;/span&gt;G.1 Truncated Differential Attack on 3 rounds of AES with Secret S-Box</h2>

    <p class="text-gray-300">In this section, we present an attack on 3 rounds of AES with a secret S-Box. The attack - illustrated in Fig. 13 - works as follows. Consider a pair of plaintexts  <span class="math">p^1</span>  and  <span class="math">p^2</span>  with the condition  <span class="math">p^1_{i,j} = p^2_{i,j}</span>  for each  <span class="math">(i,j) \\neq \\{(0,0),(1,1)\\}</span>  and  <span class="math">p^1_{0,0} \\oplus p^1_{1,1} = p^2_{0,0} \\oplus p^2_{1,1}</span> . As we</p>

    <p class="text-gray-300">&lt;span id=&quot;page-60-2&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;25&lt;/sup&gt;For example, for two consecutive elements a and b it is possible to construct only one pair (a,b). For three consecutive elements a,b,c, it is possible to construct only three different pairs (a,b),(a,c),(b,c), and so on.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-61-0&quot;&gt;&lt;/span&gt;    <img src="_page_61_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Figure 13:</strong> 3-round Truncated Differential Attack on AES with secret S-Box. The choice of the plaintexts (i.e.  <span class="math">p_{0,0} \\oplus p_{1,1} = k_{0,0} \\oplus k_{1,1}</span> ) guarantees that after one round there are only three bytes with non-zero difference instead of four, that is the plaintexts belong to the same coset of  <span class="math">\\mathcal{C}_0 \\cap \\mathcal{D}_{0,1,3}</span> . White box denotes a byte with a zero-difference, while a black box denotes a byte with non-zero difference.</p>

    <p class="text-gray-300">have seen, if  <span class="math">p_{0,0}^1 \\oplus p_{1,1}^1 = p_{0,0}^2 \\oplus p_{1,1}^2 = k_{0,0} \\oplus k_{1,1}</span> , then  <span class="math">p^1</span>  and  <span class="math">p^2</span>  belong to the same coset of  <span class="math">\\mathcal{D}_{0,1,3}</span>  after one round with probability 1. Consequently, after three rounds they belong to the same coset of  <span class="math">\\mathcal{M}_{0,1,3}</span>  with probability 1 (or of  <span class="math">\\mathcal{ID}_{0,1,3}</span>  if the final MixColumns is omitted), since a coset of  <span class="math">\\mathcal{D}_{0,1,3}</span>  is mapped into a coset of  <span class="math">\\mathcal{M}_{0,1,3}</span>  with probability 1. Instead, if  <span class="math">p_{0,0}^1 \\oplus p_{1,1}^1 = p_{0,0}^2 \\oplus p_{1,1}^2 \\neq k_{0,0} \\oplus k_{1,1}</span> , then  <span class="math">p^1</span>  and  <span class="math">p^2</span>  belong to the same coset of  <span class="math">\\mathcal{D}_{0,1,3}</span>  after one round only with probability  <span class="math">2^{-8}</span>  (that is, only if  <span class="math">R(p^1)_{2,0} \\oplus R(p^2)_{2,0} = 0</span> ). Thus, after three rounds they belong to the same coset of  <span class="math">\\mathcal{M}_{0,1,3}</span>  only with probability  <span class="math">2^{-8}</span> . Our attack exploits these different probability in order to find  <span class="math">k_{0,0} \\oplus k_{1,1}</span> .</p>

    <p class="text-gray-300">The idea is to consider n different pairs of plaintexts (with one plaintext in common) for each possible value of  <span class="math">\\delta</span> , that is  <span class="math">n \\cdot 2^8</span>  pairs of plaintexts  <span class="math">p^1</span>  and  <span class="math">p^2</span>  such that  <span class="math">p^1_{i,j} = p^2_{i,j}</span>  for each  <span class="math">(i,j) \\neq \\{(0,0),(1,1)\\}</span>  and  <span class="math">p^1_{0,0} \\oplus p^1_{1,1} = p^2_{0,0} \\oplus p^2_{1,1} = \\delta</span> . Given a  <span class="math">\\delta</span> , the attacker checks if the corresponding n pairs of ciphertexts belong or not to the same coset of  <span class="math">\\mathcal{M}_{0,1,3}</span> . If not, then the key is wrong due to previous considerations.</p>

    <p class="text-gray-300">What is the probability that all the false key candidates are discarded (i.e. they don't pass the test) using n pairs for each  <span class="math">\\delta</span> ? This probability is given by  <span class="math">1-(1-2^{-8})^{2^8 \\cdot n} \\simeq 1-e^{-n}</span> . If n=3 (that is, 4 chosen plaintexts - one plaintext is in common), then this probability is higher than 95%. Thus, in order to find 1 byte of the key,  <span class="math">4\\cdot 2^8=2^{10}</span>  chosen plaintexts. The cost of the attack can be approximated to  <span class="math">3\\cdot 2^8=2^{9.6}</span>  XOR operations (for 4 chosen plaintexts, the attacker computes only 3 XOR operations, since she considers only 3 different pairs).</p>

    <p class="text-gray-300">In order to find the secret key, for each of the four diagonals, the attacker has to repeat the same attack for three consecutive-diagonal bytes differences of the same diagonal, as for example  <span class="math">k_{0,0} \\oplus k_{1,1}</span> ,  <span class="math">k_{1,1} \\oplus k_{2,2}</span>  and  <span class="math">k_{2,2} \\oplus k_{3,3}</span>  for the first diagonal (note that the difference  <span class="math">k_{0,0} \\oplus k_{3,3}</span>  and all the other differences of these four bytes of the first diagonal are given by the sum of the previous ones). As result, the attacker is able to find the</p>

    <p class="text-gray-300">&lt;span id=&quot;page-61-1&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;26&lt;/sup&gt;Given two random texts x and y in they same coset of  <span class="math">\\mathcal{D}_0</span> , they belong to the same coset of  <span class="math">\\mathcal{M}_{0,1,3}</span>  with probability  <span class="math">2^{-24}</span>  - see Theorem 1. However, in this case we are not considering random texts in  <span class="math">\\mathcal{D}_0</span> , but two texts that belong after one round to the same coset of  <span class="math">\\mathcal{D}_{0,1,3}</span>  with probability  <span class="math">2^{-8}</span> . Since two texts belong to the same coset of  <span class="math">\\mathcal{M}_{0,1,3}</span>  if and only if they belong to the same coset of  <span class="math">\\mathcal{D}_{0,1,3}</span>  two rounds before, we obtain that the probability for the studied case is  <span class="math">2^{-8}</span>  and not  <span class="math">2^{-24}</span> .</p>

    <pre><code class="language-text">Data: 2
         10 plaintexts as described in the texts (i.e. 4 for each possible value of
        p
         1
         0,0 ⊕ p
                1
                1,1 = p
                        2
                        0,0 ⊕ p
                               2
                               1,1 = δ)
Result: k0,0 ⊕ k1,1
for δ from 0 to 2
                   8 − 1 do
   flag ← 0;
   let (p
         i
          , ci
             ) for i = 0, ..., 3 the 4 (plaintexts, ciphertexts) such that p
                                                                              i
                                                                              l,k = p
                                                                                     j
                                                                                     l,k for
     each (l, k) 6= {(0, 0),(1, 1)} and p
                                         i
                                         0,0 ⊕ p
                                                i
                                                1,1 = δ for each i;
   for i from 1 to 3 do
       x ← MC−1
                    (c
                      0 ⊕ c
                            i
                             );
       if ((x0,1 6= 0) OR (x1,0 6= 0) OR (x2,3 6= 0) OR (x3,2 6= 0)) then
           flag ← 1;
             break;
       end
       if flag = 0 then
           identify δ as candidate of k0,0 ⊕ k1,1;
       end
   end
end
</code></pre>

    <p class="text-gray-300"><strong>return</strong> <em>Candidates for k</em>0<em>,</em>&lt;sup&gt;0&lt;/sup&gt; ⊕ <em>k</em>1<em>,</em>1<em>.</em> <strong>Algorithm 8:</strong> <em>Attack on 3-round of AES with secret S-Box - Pseudo Code</em>. The same attack can be use to find the remaining part of the key.</p>

    <p class="text-gray-300">whitening key up to (2&lt;sup&gt;8&lt;/sup&gt; ) &lt;sup&gt;4&lt;/sup&gt; = 2&lt;sup&gt;32&lt;/sup&gt; variants, if she doesn't use any information about the secret S-Box. Thus, the total cost of the attack is 12 · 2 &lt;sup&gt;10&lt;/sup&gt; = 2&lt;sup&gt;13&lt;/sup&gt;<em>.</em>&lt;sup&gt;6&lt;/sup&gt; chosen plaintexts and 12 · 2 &lt;sup&gt;9&lt;/sup&gt;<em>.</em>&lt;sup&gt;6&lt;/sup&gt; = 2&lt;sup&gt;13&lt;/sup&gt;<em>.</em>&lt;sup&gt;2&lt;/sup&gt; XOR operations.</p>

    <p class="text-gray-300">Without discovering any information about the secret S-Box, the attacker is able to find the secret key up to 2 &lt;sup&gt;32&lt;/sup&gt; variants. However, it is possible to reduce this number to 2 8 if one discovers and exploits an equivalent class of the secret S-Box. We refer to App. <a href="#page-63-1">G.2.1</a> for more details. Moreover, it is also possible to consider the case in which only one row of the MixColumns matrix has two identical elements. In this case, it is not possible to recover all the key bytes using the previous procedure, but at most four byte-differences (one per diagonal). However, it is still possible to find the secret key, working also on the secret S-Box. The details of this procedure are given in App. <a href="#page-63-2">G.2.2.</a></p>

    <p class="text-gray-300">Finally, note that the same strategy can be used to attack 1- and 2-round of AES, using the subspace C instead of M in this second case (a coset of D is mapped into a coset of C after one round).</p>

    <p class="text-gray-300"><strong>Practical Verification.</strong> The attack just presented has been practically verified: as final thing, we report here the practical results. Suppose that an attacker is looking for a byte difference, e.g. <em>δ</em> ≡ <em>k</em>0<em>,</em>&lt;sup&gt;0&lt;/sup&gt; ⊕<em>k</em>1<em>,</em>&lt;sup&gt;1&lt;/sup&gt; (similarly for the other cases). As we have seen, in order to have a probability of success higher than 95%, she has to use 3 pairs of texts (with one text in common), and the computational cost can be approximated by 3 · 2 &lt;sup&gt;8&lt;/sup&gt; = 768 XOR operations (in the worse case). However, consider the case of a wrong guessed value of <em>δ</em>. In this case, when the attacker finds the first pair of ciphertexts that doesn't belong to the same coset of M0, she can immediately deduce that the guessed value <em>δ</em> is certainly wrong, without considering the other remaining pairs. For this reason, we can expect that the practical computational cost is lower than the theoretical one (which is computed analyzing the worse case). In effect, our practical results show that the <em>average</em> computational cost of the attacker is of 261 XOR operations, that is 1<em>/</em>3 of the theoretical one.</p>

    <h2 id="sec-55" class="text-2xl font-bold">&lt;span id=&quot;page-63-0&quot;&gt;&lt;/span&gt;<strong>G.2 Possible Variants of the Truncated Differential Attack on 3 Rounds of AES with Secret S-Box</strong></h2>

    <p class="text-gray-300">In the previous section, we have presented a truncated differential attack on 3 rounds of AES with a secret S-Box. Here we discuss some variants of such an attack.</p>

    <h4 id="sec-56" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-63-1&quot;&gt;&lt;/span&gt;<strong>G.2.1 Use Information of the Secret S-Box to Reduce the 2 &lt;sup&gt;32&lt;/sup&gt; Variants of the Whitening Key to 2 &lt;sup&gt;8&lt;/sup&gt; Variants</strong></h4>

    <p class="text-gray-300">Without discovering any information about the secret S-Box, the attacker is able to find the secret key up to 2 &lt;sup&gt;32&lt;/sup&gt; variants. However, it is possible to reduce this number to 2 8 if one discovers and exploits an equivalent class of the secret S-Box.</p>

    <p class="text-gray-300">Using the previous strategy, the attacker is able to discover <em>k</em>0<em>,</em>&lt;sup&gt;0&lt;/sup&gt; ⊕ <em>k</em>1<em>,</em>1, <em>k</em>1<em>,</em>&lt;sup&gt;1&lt;/sup&gt; ⊕ <em>k</em>2<em>,</em>&lt;sup&gt;2&lt;/sup&gt; and <em>k</em>2<em>,</em>&lt;sup&gt;2&lt;/sup&gt; ⊕ <em>k</em>3<em>,</em>&lt;sup&gt;3&lt;/sup&gt; (analogous for the other diagonals). Consider a pair of ciphertexts that belong to the same coset of M<em>&lt;sup&gt;j&lt;/sup&gt;</em> for |<em>j</em>| = 1. W.l.o.g we assume <em>j</em> = {0} (the other cases are analogous). As we have seen, these two ciphertexts belong to the same coset of D<em>&lt;sup&gt;j&lt;/sup&gt;</em> two rounds before. This means that the whitening key and the plaintexts have to satisfy certain relationships in order to guarantee it, as for example:</p>

    <p class="text-gray-300"><span class="math">$0x09 \\cdot [S-Box(p_{0,0}^1 \\oplus k_{0,0}) \\oplus S-Box(p_{0,0}^2 \\oplus k_{0,0})] =</span>$</p>

    <p class="text-gray-300"><span class="math">$=0x0e \\cdot [S-Box(p_{1,1}^1 \\oplus k_{1,1}) \\oplus S-Box^{-1}(p_{1,1}^2 \\oplus k_{1,1})].</span>$
(23)</p>

    <p class="text-gray-300">&lt;span id=&quot;page-63-3&quot;&gt;&lt;/span&gt;Since the difference <em>k</em>0<em>,</em>&lt;sup&gt;0&lt;/sup&gt; ⊕ <em>k</em>1<em>,</em>&lt;sup&gt;1&lt;/sup&gt; is known, one can rewrite this equation in the unknown function S-Box(· ⊕ <em>k</em>0<em>,</em>0). The same can be done for the other two relationships of the first diagonal of <em>k</em>. Collecting enough equations and working exactly as in <a href="#page-36-2">[TKKL15]</a>, it is possible to recover (an equivalent representation of) this function.</p>

    <p class="text-gray-300">Assume that this function is found (we refer to <a href="#page-36-2">[TKKL15]</a> for more details), and note that similar relationships hold among the bytes of the other diagonals. The idea is to rewrite these relationships of the other diagonals using the found function S-Box(· ⊕ <em>k</em>0<em>,</em>0). For example, the relationship of the second diagonal can be rewritten in the unknown function S-Box(·⊕<em>k</em>0<em>,</em>1) = S-Box((·⊕<em>k</em>0<em>,</em>&lt;sup&gt;1&lt;/sup&gt; ⊕<em>k</em>0<em>,</em>0)⊕<em>k</em>0<em>,</em>0). Since an equivalent representation of S-Box(· ⊕ <em>k</em>0<em>,</em>0) is known, one can find <em>k</em>0<em>,</em>&lt;sup&gt;1&lt;/sup&gt; ⊕ <em>k</em>0<em>,</em>&lt;sup&gt;0&lt;/sup&gt; using the same strategy presented in <a href="#page-36-2">[TKKL15]</a>. Working in the same way for all the diagonals, this allows to reduce the possible variants of the whitening key to 2 8 .</p>

    <p class="text-gray-300">Finally, note that for this step we are forced to use chosen ciphertexts instead of chosen plaintexts. Indeed, working with plaintexts one finds relationships that involves S-Box&lt;sup&gt;−&lt;/sup&gt;&lt;sup&gt;1&lt;/sup&gt; (· ⊕ <em>k</em> 3 ) (e.g. Eq. <a href="#page-45-0">(10)</a>), where <em>k</em> 3 is the key of the final round. Since the key schedule involves some S-Box operations, it is not possible to use it to find <em>k</em> &lt;sup&gt;3&lt;/sup&gt; given variants of the whitening key. Thus, a possible way to overcome the problem is to consider chosen ciphertexts, in order to find relationships that involves S-Box(· ⊕ <em>k</em>).</p>

    <h4 id="sec-57" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-63-2&quot;&gt;&lt;/span&gt;<strong>G.2.2 Another Variant of the Attack</strong></h4>

    <p class="text-gray-300">As last thing, we consider the case in which only one row of the MixColumns matrix has two identical elements. In this case, it is not possible to recover all the key bytes using the previous procedure, but at most four byte-differences (one per diagonal). However, it is still possible to find the key if one works also on the secret S-Box. The procedure is similar to the previous one, used to reduce the number of possible variants of the secret key.</p>

    <p class="text-gray-300">Suppose for simplicity that only the third row of the MixColumns matrix has two identical element. Using the same strategy of the previous algorithm, one is able to find <em>k</em>0<em>,</em>&lt;sup&gt;0&lt;/sup&gt; ⊕ <em>k</em>1<em>,</em>1, for a cost of 2 &lt;sup&gt;10&lt;/sup&gt; chosen plaintexts.</p>

    <p class="text-gray-300">The idea now is to consider ciphertexts that belong to the same coset of M<em>&lt;sup&gt;j&lt;/sup&gt;</em> for |<em>j</em>| = 1 (or ID<em>&lt;sup&gt;j&lt;/sup&gt;</em> for |<em>j</em>| = 1 if the final MixColumns operation is omitted). W.l.o.g. we assume <em>j</em> = {0}. As we have seen, the corresponding plaintexts have to belong to the same coset of</p>

    <p class="text-gray-300"><span class="math">\\mathcal{D}_0</span>  after one round. Using the same strategy of the low-data truncated differential attack, we can find the relationships that the bytes the secret key and of the plaintexts have to satisfy. In particular, if  <span class="math">c^1 \\oplus c^2 \\in \\mathcal{M}_0</span> , then the key bytes  <span class="math">k_{0,0}</span>  and  <span class="math">k_{1,1}</span>  have to satisfy the relationship (23) in order to guarantee that  <span class="math">R(p^1) \\oplus R(p^2) \\in \\mathcal{D}_0</span> . Rewriting this equation in the unknown function S-Box <span class="math">(\\cdot \\oplus k_{0,0})</span>  (the difference  <span class="math">k_{0,0} \\oplus k_{1,1}</span>  is known) and collecting enough equations, it is possible to recover this function. When this function is discovered, the idea is to work exactly as in [TKKL15] to find the whitening key up to  <span class="math">2^8</span>  variants.</p>

    <h3 id="sec-58" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-64-0&quot;&gt;&lt;/span&gt;G.3 Square Attack on 3 Rounds of AES with Secret S-Box</h3>

    <p class="text-gray-300">In App. G.1, we have presented a truncated differential attack on 3 rounds of AES with secret S-Box. In this section, we show how to use a similar technique for the case of the square attack. We recall that with respect to other attacks present in literature (as for example [TKKL15]), for our attack it is not necessary to find any other information about the secret S-Box. However, the consequence is that our attack has a higher data complexity.</p>

    <p class="text-gray-300">As we have seen in details in Sect. G.1, given two plaintexts  <span class="math">p^1</span>  and  <span class="math">p^2</span>  such that  <span class="math">p^1_{i,j} = p^2_{i,j}</span>  for each  <span class="math">(i,j) \\neq \\{(0,0),(1,1)\\}</span>  and  <span class="math">p^1_{0,0} \\oplus p^1_{1,1} = p^2_{0,0} \\oplus p^2_{1,1} = \\delta</span> , then they belong to the same coset of  <span class="math">\\mathcal{C}_0 \\cap \\mathcal{M}_{0,1,3}</span>  after one round if  <span class="math">\\delta = k_{0,0} \\oplus k_{1,1}</span> .</p>

    <p class="text-gray-300">The idea of the attack is the following. Consider the set  <span class="math">V_{\\delta}</span>  defined as in (6):</p>

    <p class="text-gray-300"><span class="math">$V_{\\delta} = \\{ (p^i, c^i) \\text{ for } i = 0, ..., 2^8 - 1 \\mid p_{0,0}^i \\oplus p_{1,1}^i = \\delta \\quad \\forall i \\text{ and}</span>$
and
<span class="math">$p_{k,l}^i = p_{k,l}^j \\, \\forall (k,l) \\neq \\{ (0,0), (1,1) \\} \\text{ and } i \\neq j \\},</span>$</p>

    <p class="text-gray-300">If  <span class="math">\\delta = k_{0,0} \\oplus k_{1,1}</span> , one round encryption of  <span class="math">V_{\\delta}</span>  corresponds to</p>

    <p class="text-gray-300"><span class="math">$\\begin{bmatrix} x &amp; c_{0,1} &amp; c_{0,2} &amp; c_{0,3} \\\\ c_{1,0} &amp; x \\oplus \\delta &amp; c_{1,2} &amp; c_{1,3} \\\\ c_{2,0} &amp; c_{2,1} &amp; c_{2,2} &amp; c_{2,3} \\\\ c_{3,0} &amp; c_{3,1} &amp; c_{3,2} &amp; c_{3,3} \\end{bmatrix} \\rightarrow \\begin{bmatrix} y \\oplus \\tilde{c}_{0,0} &amp; \\tilde{c}_{0,1} &amp; \\tilde{c}_{0,2} &amp; \\tilde{c}_{0,3} \\\\ 0x03 \\cdot y \\oplus \\tilde{c}_{1,0} &amp; \\tilde{c}_{1,1} &amp; \\tilde{c}_{1,2} &amp; \\tilde{c}_{1,3} \\\\ \\tilde{c}_{2,0} &amp; \\tilde{c}_{2,1} &amp; \\tilde{c}_{2,2} &amp; \\tilde{c}_{2,3} \\\\ 0x02 \\cdot y \\oplus \\tilde{c}_{3,0} &amp; \\tilde{c}_{3,1} &amp; \\tilde{c}_{3,2} &amp; \\tilde{c}_{3,3} \\end{bmatrix}</span>$</p>

    <p class="text-gray-300">for each  <span class="math">x \\in \\mathbb{F}_{2^8}</span> , where  <span class="math">y = \\text{S-Box}(x \\oplus k_{0,0})</span> . That is, if  <span class="math">\\delta = k_{0,0} \\oplus k_{1,1}</span> , then the set  <span class="math">V_{\\delta}</span>  is mapped into  <span class="math">\\mathcal{D}_{0,1,3} \\cap \\mathcal{C}_0 \\cap \\mathcal{M}_3</span> , which implies that the bytes in positions (0,0), (1,0) and (3,0) can take each possible values in  <span class="math">\\mathbb{F}_{2^8}</span> . Instead, if  <span class="math">\\delta \\neq k_{0,0} \\oplus k_{1,1}</span> , no claims can be made about the bytes of the first column (the others are obviously constant). Equivalently, these two cases correspond to:</p>

    <p class="text-gray-300"><span class="math">$\\begin{bmatrix} A &amp; C &amp; C &amp; C \\\\ A &amp; C &amp; C &amp; C \\\\ C &amp; C &amp; C &amp; C \\\\ A &amp; C &amp; C &amp; C \\end{bmatrix}, \\qquad \\begin{bmatrix} ? &amp; C &amp; C &amp; C \\\\ ? &amp; C &amp; C &amp; C \\\\ ? &amp; C &amp; C &amp; C \\\\ ? &amp; C &amp; C &amp; C \\end{bmatrix},</span>$</p>

    <p class="text-gray-300">respectively for  <span class="math">\\delta = k_{0,0} \\oplus k_{1,1}</span>  and  <span class="math">\\delta \\neq k_{0,0} \\oplus k_{1,1}</span> , where A,B,C and ? denote byte with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Active (A): Every value in  <span class="math">\\mathbb{F}_{2^8}</span>  appears the same number of times in X;</li>
      <li>Balance (B): The XOR of all values in X is 0;</li>
      <li>Constant (C): The value is fixed to a constant for all texts in X;</li>
      <li>Unknown (?): ? is indistinguishable from random sets.</li>
    </ul>

    <p class="text-gray-300">Since</p>

    <p class="text-gray-300"><span class="math">$\\begin{bmatrix} A &amp; C &amp; C &amp; C \\\\ A &amp; C &amp; C &amp; C \\\\ C &amp; C &amp; C &amp; C \\\\ A &amp; C &amp; C &amp; C \\end{bmatrix} \\rightarrow \\begin{bmatrix} B &amp; B &amp; B &amp; B \\\\ B &amp; B &amp; B &amp; B \\\\ B &amp; B &amp;</span>$</p>

    <pre><code class="language-text">Data: 2^8 set V_{\\delta} as defined in (6) (i.e. one for each possible value of
          p_{0,0}^1 \\oplus p_{1,1}^1 = p_{0,0}^2 \\oplus p_{1,1}^2 = \\delta
Result: k_{0.0} \\oplus k_{1.1}
for \\delta from 0 to 2^8 - 1 do
    x \\leftarrow 0;
    let V_{\\delta} = \\{p^i, c^i\\} for each i = 0, ..., 2^8 - 1;
    for i from \\theta to 2^8 - 1 do
     x \\leftarrow x \\oplus c^i;
    end
    for i from \\theta to 16 do
         a \\leftarrow i \\mod 4;
           b \\leftarrow (i-r)/4;
         if (x_{a,b} \\neq 0) then
              flag \\leftarrow 1;
               break;
         if flag = 0 then
          identify \\delta as candidate of k_{0,0} \\oplus k_{1,1};
    end
end
return Candidates for k_{0,0} \\oplus k_{1,1}.
</code></pre>

    <p class="text-gray-300">Algorithm 9: Square Attack on 3-round of AES with secret S-Box. The same attack can be use to find the remaining part of the key.</p>

    <p class="text-gray-300">after 2 rounds, it follows that the 3-round encryption of  <span class="math">V_{\\delta}</span>  has the balance property if  <span class="math">\\delta = k_{0,0} \\oplus k_{1,1}</span> . Instead, if  <span class="math">\\delta \\neq k_{0,0} \\oplus k_{1,1}</span> , the probability that  <span class="math">V_{\\delta}</span>  satisfies the balance property after 3-round if  <span class="math">\\delta \\neq k_{0,0} \\oplus k_{1,1}</span>  is  <span class="math">(2^{-8})^{-16} = 2^{-128}</span> , since it is not in general possible to guarantee any property of the one round of encryption of  <span class="math">V_{\\delta}</span> .</p>

    <p class="text-gray-300">Thus, the idea is to consider  <span class="math">2^8</span>  different sets  <span class="math">V_{\\delta}</span> , one for each possible values of  <span class="math">\\delta</span> , and to check if the balance property on the ciphertexts is satisfied or not. If the balance property is not satisfied, then the value  <span class="math">\\delta</span>  as candidate for  <span class="math">k_{0,0} \\oplus k_{1,1}</span>  is certainly wrong. What is the probability that all the false candidates don't satisfy this test? By simply computation is  <span class="math">(1-2^{-128})^{2^8-1} \\simeq 1-2^{-120}</span> . As a result, in order to find one byte of the secret key, the data complexity is  <span class="math">2^8 \\cdot 2^8 = 2^{16}</span> , while the computational complexity can be approximated to  <span class="math">2^{16}</span>  XOR operations.</p>

    <p class="text-gray-300">As for the attack of App. G.1, the idea is to repeat the attack for three different consecutive-diagonal bytes, and for all the four diagonals. In this way, the attacker is able to find  <span class="math">2^{32}</span>  variants of the whitening key without working on the secret S-Box. The total data complexity for the attack can be approximated to  <span class="math">12 \\cdot 2^{16} = 2^{19.6}</span>  chosen plaintexts, and a cost of  <span class="math">2^{19.6}</span>  XOR operations.</p>

    <p class="text-gray-300">For completeness, using the same strategy of App. G.1, one can reduce this number of variants to  <span class="math">2^8</span>  working also on the secret S-Box.</p>

    <p class="text-gray-300"><strong>Practical Verification.</strong> As last thing, we report that for this attack the practical computational cost is approximately the same of the theoretical one, and that the given data complexity allows to have an high probability of success, as indicated above.</p>

    <p class="text-gray-300">As for the case of 3-round of AES, we present an attack on 4-round of AES with secret S-Box which exploits the truncated differential attack and the subspace trail. The previous truncated differential attack on 3-round of AES with secret S-Box exploits a subspace trail with probability 1. In this section, we present a truncated differential to attack 4-round of AES with secret S-Box - illustrated in Fig. 14 - that exploits the subspace trail described in Sect. 4.3, which has probability strictly less than 1 (but greater than 0).</p>

    <p class="text-gray-300">The idea of the attack is to exploit the fact that two elements that belong to the same coset of  <span class="math">\\mathcal{D}_I</span>  belong to the same coset of  <span class="math">\\mathcal{M}_J</span>  after three rounds with probability higher than two random elements, as we have showed in Sect. 4.3. To set up the attack, we exploit this fact together with the possibility to map a subset of a coset of  <span class="math">\\mathcal{D}_i</span>  (which depends on the secret key) into a subset of a coset of  <span class="math">\\mathcal{D}_I</span>  after one round.</p>

    <p class="text-gray-300">Consider two plaintexts  <span class="math">p^1</span>  and  <span class="math">p^2</span>  such that  <span class="math">p_{i,j}^1 = p_{i,j}^2</span>  for each  <span class="math">(i,j) \\neq \\{(0,0),(1,1)\\}</span>  and  <span class="math">p_{0,0}^1 \\oplus p_{1,1}^1 = p_{0,0}^2 \\oplus p_{1,1}^2 = \\delta</span> . As we have seen, if  <span class="math">\\delta = k_{0,0} \\oplus k_{1,1}</span> , then the two plaintexts belong to the same coset of  <span class="math">\\mathcal{D}_{0,1,3}</span>  after one round. First of all, the previous choice of plaintexts can be generalized.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-66-1&quot;&gt;&lt;/span&gt;<strong>Proposition 7.</strong> Let  <span class="math">p^1</span>  and  <span class="math">p^2</span>  be two texts such that</p>

    <p class="text-gray-300"><span class="math">$p_{i,j}^1 = p_{i,j}^2 \\qquad \\forall (i,j) \\neq \\{0,0), (0,3), (1,1), (1,2), (2,0), (2,3), (3,1), (3,2)\\}</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$p_{0,0}^1 \\oplus p_{1,1}^1 = p_{0,0}^2 \\oplus p_{1,1}^2 = \\delta_0, \\qquad p_{1,2}^1 \\oplus p_{2,3}^1 = p_{1,2}^2 \\oplus p_{2,3}^2 = \\delta_1, p_{0,3}^1 \\oplus p_{3,2}^1 = p_{0,3}^2 \\oplus p_{3,2}^2 = \\delta_2, \\qquad p_{2,0}^1 \\oplus p_{3,1}^1 = p_{2,0}^2 \\oplus p_{3,1}^2 = \\delta_3.</span>$</p>

    <p class="text-gray-300">Then, if  <span class="math">\\delta_0 = k_{0,0} \\oplus k_{1,1}</span> ,  <span class="math">\\delta_1 = k_{1,2} \\oplus k_{2,3}</span> ,  <span class="math">\\delta_2 = k_{0,3} \\oplus k_{3,2}</span>  and  <span class="math">\\delta_3 = k_{2,0} \\oplus k_{3,1}</span>  (where k is the secret key of the first round), then after one round they belong to the same coset of  <span class="math">\\mathcal{C}_0 \\cap \\mathcal{D}_{0,1,3} \\subseteq \\mathcal{D}_{0,1,3}</span> , that is  <span class="math">R(p^1) \\oplus R(p^2) \\in \\mathcal{C}_0 \\cap \\mathcal{D}_{0,1,3}</span> .</p>

    <p class="text-gray-300">The proof is similar to that of Prop. 7.</p>

    <p class="text-gray-300">For the following, we consider pairs of plaintexts such that  <span class="math">p_{i,j}^1 = p_{i,j}^2</span>  for each  <span class="math">(i,j) \\neq \\{(0,0),(1,1),(1,2),(2,3)\\}</span>  and  <span class="math">p_{0,0}^1 \\oplus p_{1,1}^1 = p_{0,0}^2 \\oplus p_{1,1}^2 = \\delta_0</span> ,  <span class="math">p_{1,2}^1 \\oplus p_{2,3}^1 = p_{1,2}^2 \\oplus p_{2,3}^2 = \\delta_1</span> . If  <span class="math">\\delta_0 = k_{0,0} \\oplus k_{1,1}</span>  and  <span class="math">\\delta_1 = k_{1,2} \\oplus k_{2,3}</span> , these two plaintexts belong to the same coset of  <span class="math">\\mathcal{D}_{0,1,3}</span>  with probability 1, that is they belong to the same coset of  <span class="math">\\mathcal{M}_{0,1,3}</span>  after three rounds with probability 1. Using Prop. 1, this means that if  <span class="math">\\delta_0 = k_{0,0} \\oplus k_{1,1}</span>  and  <span class="math">\\delta_1 = k_{1,2} \\oplus k_{2,3}</span> , the two plaintexts belong to the same coset of  <span class="math">\\mathcal{C}_J</span>  with probability  <span class="math">(2^8)^{-12+4\\cdot |J|}</span>  after three rounds. That is, if |J| = 3,  <span class="math">\\delta_0 = k_{0,0} \\oplus k_{1,1}</span>  and  <span class="math">\\delta_1 = k_{1,2} \\oplus k_{2,3}</span> , then after three rounds these two plaintexts belong to the same coset of  <span class="math">\\mathcal{C}_J</span>  with probability  <span class="math">2^{-24}</span>  for a fixed J with |J| = 3, or with probability  <span class="math">4 \\cdot 2^{-24} = 2^{-22}</span>  for a free J with |J| = 3. Since a coset of  <span class="math">\\mathcal{C}_J</span>  is mapped into a coset of  <span class="math">\\mathcal{M}_J</span>  with probability 1, we can conclude that if  <span class="math">\\delta_0 = k_{0,0} \\oplus k_{1,1}</span>  and  <span class="math">\\delta_1 = k_{1,2} \\oplus k_{2,3}</span> , the two plaintexts belong to the same coset of  <span class="math">\\mathcal{M}_J</span>  for a certain J with |J| = 3 with probability  <span class="math">2^{-24}</span> .</p>

    <p class="text-gray-300">Consider now the case  <span class="math">\\delta_0 \\neq k_{0,0} \\oplus k_{1,1}</span>  or/and  <span class="math">\\delta_1 \\neq k_{1,2} \\oplus k_{2,3}</span> . In this case, we can consider the corresponding ciphertexts as randomly distributed, that is they belong to the same coset of  <span class="math">\\mathcal{M}_J</span>  for a certain J with |J|=3 after four rounds only with probability  <span class="math">4 \\cdot 2^{-32}=2^{-30}</span> .</p>

    <p class="text-gray-300"><strong>Remark.</strong> Before to go on, we explain why it is not possible to work on a single  <span class="math">\\delta</span>  (that is, on separately  <span class="math">\\delta</span>  as on the previous attack on 3 rounds of App. G.1). Suppose to consider two plaintexts  <span class="math">p^1</span>  and  <span class="math">p^2</span>  such that  <span class="math">p_{i,j}^1 = p_{i,j}^2</span>  for each  <span class="math">(i,j) \\neq \\{(0,0),(1,1)\\}</span>  and  <span class="math">p_{0,0}^1 \\oplus p_{1,1}^1 = p_{0,0}^2 \\oplus p_{1,1}^2 = \\delta</span> . By definition, these two plaintexts belong to the same coset of</p>

    <p class="text-gray-300">&lt;span id=&quot;page-67-0&quot;&gt;&lt;/span&gt;    <img src="_page_67_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 14: 4-round Truncated Differential Attack on AES with secret S-Box. The choice of the plaintexts (i.e.  <span class="math">p_{0,0} \\oplus p_{1,1} = k_{0,0} \\oplus k_{1,1}</span>  and  <span class="math">p_{1,2} \\oplus p_{2,3} = k_{1,2} \\oplus k_{2,3}</span> ) guarantees that after one round they belong to the same coset of  <span class="math">C_{0,1} \\cap D_{0,1,3}</span> . As a consequence, after three rounds they belong to the same coset of  <span class="math">C_J</span>  for a certain  <span class="math">J \\subseteq \\{0,1,2,3\\}</span>  with |J| = 3 with probability  <span class="math">2^{-22}</span>  instead of  <span class="math">2^{-30}</span> . White box denotes denotes a byte with a zero-difference, while a black box denotes a byte with non-zero difference.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{D}_0 \\cap \\mathcal{C}_{0,1} \\subseteq \\mathcal{D}_0</span> , independently by  <span class="math">\\delta</span> . Thus, as shown in Sect. 4.4, the probability that they belong to the same coset of  <span class="math">\\mathcal{M}_J</span>  for |J| = 3 is  <span class="math">Pr(R^{(4)}(u) \\oplus R^{(4)}(v) \\in \\mathcal{M}_J \\mid u \\oplus v \\in \\mathcal{D}_I) = 0</span>  (see Prob. 5), independently of  <span class="math">\\delta</span> .</p>

    <h4 id="sec-59" class="text-lg font-semibold mt-6"><strong>Data and Computational Cost</strong></h4>

    <p class="text-gray-300"><strong>Data Complexity.</strong> The idea of the attack is to exploit these different probabilities in order to recover the key. In particular, consider  <span class="math">n \\leq 2^{16}</span>  plaintexts defined as before for each possible values of  <span class="math">\\delta_0</span>  and  <span class="math">\\delta_1</span> . If  <span class="math">\\delta_0 = k_{0,0} \\oplus k_{1,1}</span>  and  <span class="math">\\delta_1 = k_{1,2} \\oplus k_{2,3}</span> , then we expect approximately  <span class="math">n \\cdot (n-1) \\cdot 2^{-23}</span>  different pairs of ciphertexts that belong to the same coset of  <span class="math">\\mathcal{M}_J</span>  for a certain J with |J| = 3 (i.e. collisions), while  <span class="math">n \\cdot (n-1) \\cdot 2^{-31}</span>  collisions if  <span class="math">\\delta_0 \\neq k_{0,0} \\oplus k_{1,1}</span>  or/and  <span class="math">\\delta_1 \\neq k_{1,2} \\oplus k_{2,3}</span> . For example, if  <span class="math">n = 2^{16}</span> , we expect on average  <span class="math">2^8 = 256</span>  collisions for the first case and 2 in the other one. By our experiments, we check that  <span class="math">n = 2^{13}</span>  is (largely) sufficient to find the right value of  <span class="math">k_{0,0} \\oplus k_{1,1}</span>  and  <span class="math">k_{1,2} \\oplus k_{2,3}</span> .</p>

    <p class="text-gray-300">Assume that  <span class="math">k_{0,0} \\oplus k_{1,1}</span>  and  <span class="math">k_{1,2} \\oplus k_{2,3}</span>  have been found. The idea is to proceed in the same way to find the  <span class="math">2^{32}</span>  variants of the whitening secret key. To improve the total cost of the attack, suppose that for each diagonal the attacker one difference of two consecutive-diagonal bytes is known. A good strategy is to use it to find the others. As an example, a good strategy could be to use the knowledge of  <span class="math">\\delta_0 = k_{0,0} \\oplus k_{1,1}</span>  and to look for  <span class="math">\\delta_2 = k_{0,3} \\oplus k_{3,2}</span>  (similar for  <span class="math">\\delta_0</span>  and  <span class="math">\\delta_3 = k_{2,0} \\oplus k_{3,1}</span> ), instead to work on  <span class="math">\\delta_2</span>  and  <span class="math">\\delta_3</span> . Note that both the method allows to find the secret key, but in the first case the attacker does  <span class="math">2 \\cdot 2^8 = 2^9</span>  tests, while in the second one  <span class="math">2^{16}</span> . Thus, the data complexity cost can be</p>

    <p class="text-gray-300">approximated by  <span class="math">8 \\cdot 2^8 \\cdot 2^8 + 2 \\cdot (2^8)^2 \\cdot 2^{13} = 2^{30}</span>  chosen plaintexts.</p>

    <p class="text-gray-300">Computational Complexity. To give a good approximation of the computational cost, observe that the first step of the attack (i.e. to find  <span class="math">\\delta_0</span>  and  <span class="math">\\delta_1</span> ) is the most expensive one. Thus, the total cost can be approximated by this step (which is repeated two times on the first and on the second diagonals, and then on the third and on the fourth diagonal). Moreover, note that the attacker must construct all the possible pairs of ciphertexts and check if they belong or not to the same coset of  <span class="math">\\mathcal{M}_J</span>  for a certain J with |J|=3. Note that the cost to check if two texts belong to the same coset of  <span class="math">\\mathcal{M}_J</span>  for a certain J with |J|=3 requires only 1 XOR operations. Thus, the computational cost can be approximated by the cost to construct all the pairs. Since for each  <span class="math">\\delta_0</span>  and  <span class="math">\\delta_1</span>  the attack needs  <span class="math">2^{13}</span>  chosen plaintexts, the operation to construct all the pairs requires  <span class="math">2^{13} \\cdot (2^{13} - 1)/2 = 2^{25}</span>  table look-ups, for a total of  <span class="math">2 \\cdot (2^8)^2 \\cdot 2^{25} = 2^{42}</span>  table look-ups.</p>

    <p class="text-gray-300">A way to improve this step is to re-order all the texts using a merge-sort algorithm, as we described in details in App. F. Indeed, when the elements are ordered with respect to a particular relationship  <span class="math">\\leq</span> , one can work only on two consecutive texts  <span class="math">t^1</span>  and  <span class="math">t^2</span>  such that  <span class="math">t^1 \\leq t^2</span>  instead to consider all the possible pairs in order to count all the collisions (see App. F for details). For each  <span class="math">\\delta_0</span>  and  <span class="math">\\delta_1</span>  and for each J with |J|=3, the computational cost to re-order all the elements and to count the collision can be approximated to  <span class="math">2^{13} \\cdot (\\log 2^{13} + 1) \\simeq 2^{17}</span>  table look-ups, for a total of  <span class="math">4 \\cdot 2 \\cdot (2^8)^2 \\cdot 2^{17} = 2^{36}</span>  table look-ups, that is  <span class="math">2^{29.7}</span>  four-round encryption assuming the approximation that one round of AES corresponds to 20 table look-ups. The memory cost is  <span class="math">2^{30}</span>  to store all the texts. In this way, the attacker is able to find  <span class="math">2^{32}</span>  variants of the whitening key, without working (or finding) any information about the secret S-Box. However, as shown in App. G.1, it is possible to reduce this number to  <span class="math">2^8</span>  if one works also on the secret S-Box.</p>

    <p class="text-gray-300"><strong>Practical Verification.</strong> The attack just presented has been practically verified: as final thing, we report here the practical results. For simplicity, here we limit to report the results when the attacker tries to find two bytes of the secret key - as  <span class="math">k_{0,0} \\oplus k_{1,1}</span>  and  <span class="math">k_{1,2} \\oplus k_{2,3}</span>  - using  <span class="math">2^{13}</span>  different chosen plaintexts. These results can be easily extended for the complete attack, as described in the previous text. For completeness, we consider both the two cases in which the attacker (1) re-orders the texts before to count the number of collisions (working only on consecutive ordered elements), or (2) constructs all the possible pairs. This second setting allows to understand better the importance of the re-ordering algorithm in terms of performance/computational cost.</p>

    <p class="text-gray-300">In the second case (that is the one in which all the possible pairs are constructed - no use of the re-ordering algorithm), the expected theoretical computational cost in order to find 2 bytes of the secret key is of  <span class="math">(2^8)^2 \\cdot 2^{12} \\cdot (2^{13} - 1) = 2^{41} - 2^{28} \\simeq 2^{41}</span>  memory accesses, and it is approximately the same of the practical computational one. Instead, for the first setting (that is the one the re-order the text before to counts the number of collisions) the expected theoretical computational cost in order to find 2 bytes of the secret key is of  <span class="math">4 \\cdot (2^8)^2 \\cdot 2^{13} \\cdot (\\log 2^{13} + 1) \\simeq 2^{32.8}</span>  memory accesses. The average practical computational cost is approximately of  <span class="math">2^{32.65}</span>  memory accesses, which is very close to the theoretical one. Finally,  <span class="math">2^{13}</span>  chosen plaintexts are (largely) sufficient to find the right value of  <span class="math">k_{0,0} \\oplus k_{1,1}</span>  and  <span class="math">k_{1,2} \\oplus k_{2,3}</span> , as predicted by the theory.</p>

    <p class="text-gray-300">In Sect. 7 we presented an impossible differential attack on 5-round AES with a single secret S-Box. Here we provide all the details about the data complexity and the computational</p>

    <pre><code class="language-text">Data: 2^{21} plaintexts as described in the texts (i.e. 2^{13} for each possible value of
            p_{0,0}^i \\oplus p_{1,1}^i = \\delta_0 \\text{ and } p_{1,2}^i \\oplus p_{2,3}^i = \\delta_1
  Result: k_{0.0} \\oplus k_{1.1} and k_{1.2} \\oplus k_{2.3}
  for \\delta_0 from 0 to 2^8 - 1 do
      for \\delta_1 from 0 to 2^8 - 1 do
           maxCollision \\leftarrow -1;
           numberCollision \\leftarrow 0; let (p^i,c^i) for i=0,...,2^{13}-1 the 2^{13} (plaintexts, ciphertexts) such that
            p_{l,k}^i = p_{l,k}^j for each (l,k) \\neq \\{(0,0), (1,1), (1,2), (2,3)\\} and p_{0,0}^i \\oplus p_{1,1}^i = \\delta_0
            and p_{1,2}^i \\oplus p_{2,3}^i = \\delta_1 for each i;
           re-order this set of elements as described in App. F;
           while i &lt; 2^{13} do
                n \\leftarrow 0;
                  while c^j \\oplus c^{j+1} \\in \\mathcal{M}_J for a certain with |J| = 3 do
                     n \\leftarrow n + 1;
                end
                i \\leftarrow j + 1;
                 numberCollision \\leftarrow numberCollision + n \\cdot (n+1)/2;
           if numberCollision &gt; maxCollision then
                maxCollision \\leftarrow numberCollision;
                identify \\delta_0 as candidate of k_{0,0} \\oplus k_{1,1} and \\delta_1 as candidate of k_{1,2} \\oplus k_{2,3};
      end
  end
  return Candidates for k_{0,0} \\oplus k_{1,1} and of k_{1,2} \\oplus k_{2,3}.
Algorithm 10: Attack on 4-round of AES with secret S-Box - Pseudo-Code. The same
</code></pre>

    <p class="text-gray-300">cost of the attack, besides a possible variant of it.</p>

    <p class="text-gray-300">attack can be use to find the remaining part of the key.</p>

    <h3 id="sec-60" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-69-0&quot;&gt;&lt;/span&gt;I.1 Details of the Attack - Data Complexity and Computational Cost</h3>

    <p class="text-gray-300">In this section, we give the details of the data and computational complexity of the impossible differential attack on 5-round AES with a single secret S-Box. The attack presented in Sect. 7 is constructed in two steps. First we focus on a single difference among two bytes of the secret key, and then we show how to find the entire key.</p>

    <h4 id="sec-61" class="text-lg font-semibold mt-6">I.1.1 Data Complexity</h4>

    <p class="text-gray-300">Find a Single Byte of the Secret Key - Data Complexity. As we have seen, the probability that two texts belong to the same coset of  <span class="math">\\mathcal{M}_J</span>  for |J|=1 is  <span class="math">2^{-94}</span>  (analogous for  <span class="math">\\mathcal{ID}_J</span> ). Thus, given n pairs, the probability to have at least one collision in the same coset of  <span class="math">\\mathcal{M}_J</span>  for |J|=1 for a fixed  <span class="math">\\delta \\neq k_{0,0} \\oplus k_{1,1}</span>  is given by  <span class="math">p=1-e^{-n/2^{94}}</span> , due to the birthday paradox probability (4). If the number of pairs n is approximately  <span class="math">2^{95.6}</span> , then p is greater than 95%. Given a single set  <span class="math">V_\\delta</span> , it is possible to construct  <span class="math">2^7 \\cdot (2^8-1) \\simeq 2^{15}</span>  different pairs. Thus, for the distinguisher one needs approximately  <span class="math">2^{95.6} \\cdot 2^{-15} = 2^{80.6}</span></p>

    <p class="text-gray-300">different sets  <span class="math">V_{\\delta}</span> . Since each of these sets contains  <span class="math">2^8</span>  texts, the data complexity of the distinguisher is  <span class="math">2^{80.6} \\cdot 2^8 = 2^{88.6}</span>  texts.</p>

    <p class="text-gray-300">However, one needs at least one collision in the same coset of  <span class="math">\\mathcal{M}_J</span>  for |J|=1 for each one of the  <span class="math">2^8-1\\simeq 2^8</span>   <span class="math">\\delta\\neq k_{0,0}\\oplus k_{1,1}</span> . If we consider  <span class="math">2^{80.6}</span>  sets for each  <span class="math">\\delta</span>  as before, then the probability to have one collision is 95% for each single collection of sets corresponding to a given value  <span class="math">\\delta</span> . However, the probability that there is at least one collision for each one of the  <span class="math">2^8-1</span>  wrong  <span class="math">\\delta</span>  is only of  <span class="math">0.95^{255}\\simeq 2\\cdot 10^{-6}</span>  (note that the  <span class="math">2^8</span>  collections of sets are independent). In order to have a total probability of about 95%, the probability to have at least one collision for each wrong  <span class="math">\\delta</span>  must be increased to approximately  <span class="math">(0.95)^{1/2^8}=0.9998</span> . Indeed, in this way the total probability is equal by  <span class="math">0.9998^{256}=0.95</span> , as desired. Using similar calculation as before, for each one of the  <span class="math">2^8</span>  collections (i.e. for each  <span class="math">\\delta</span> ), one needs at least  <span class="math">2^{97.2}</span>  pairs to have at least one collision with probability 0.9998. Since each set  <span class="math">V_{\\delta}</span>  has about  <span class="math">2^{15}</span>  different pairs, then one needs about  <span class="math">2^{97.2}\\cdot 2^{-15}=2^{82.2}</span>  different sets for each  <span class="math">\\delta</span>  (instead of  <span class="math">2^{80.6}</span>  as before), that is  <span class="math">2^{90.2}</span>  texts for each  <span class="math">\\delta</span> . Since there are  <span class="math">2^8</span>  different values of  <span class="math">\\delta</span> , the total number of texts required for this distinguisher is  <span class="math">2^{90.2}=2^{98.2}</span>  texts. In this way, one is able to find one byte of the secret kev.</p>

    <p class="text-gray-300">Find the Secret Key - Data Complexity. In order to find the entire key, the idea is simply to repeat the previous attack 12 times (i.e. three times for each possible diagonal), in order to find  <span class="math">2^{32}</span>  variants of the whitening secret key. As shown in App. G.1 for the three round case, it is useless to repeat more times this attack, since it is not possible to reduce this number of variants without exploiting the details of the S-Box. However, due to similar argumentation of before, the total probability of success becomes of  <span class="math">(0.95)^{12} = 54\\%</span>  using only  <span class="math">12 \\cdot 2^{98.2} = 2^{101.8}</span>  chosen plaintexts. Thus, in order to have a total probability of success of at least 95%, we need to increase the number of chosen plaintexts. In particular, for each one of the 12 cases, the probability to have at least one collision must be increased to  <span class="math">0.95^{1/(256\\cdot12)} \\simeq 0.9999833</span> . Thus, for each one of the 12 possible two consecutive-diagonal bytes and for each one of the corresponding  <span class="math">2^8</span>   <span class="math">\\delta</span> , one needs at least  <span class="math">2^{97.4}</span>  pairs to have at least one collision with probability 0.999983 (using analogous computation as before). Since each set  <span class="math">V_{\\delta}</span>  has about  <span class="math">2^{15}</span>  different pairs, then one needs about  <span class="math">2^{97.4} \\cdot 2^{-15} = 2^{82.4}</span>  different sets for each  <span class="math">\\delta</span>  (instead of  <span class="math">2^{82.2}</span>  as before), that is  <span class="math">2^{90.4}</span>  texts for each  <span class="math">\\delta</span> . Since there are  <span class="math">2^8</span>  different values of  <span class="math">\\delta</span>  and since the attack is repeated 12 times, the total number of texts required for this attack is  <span class="math">12 \\cdot 2^8 \\cdot 2^{90.4} = 2^{102}</span> . which is lower than the entire input-output space.</p>

    <h4 id="sec-62" class="text-lg font-semibold mt-6">I.1.2 Computational Complexity</h4>

    <p class="text-gray-300">The attacker has to construct all the possible pairs and to count the number of collision in the same coset of  <span class="math">\\mathcal{M}_J</span>  for |J|=3. As shown in details for the 4 rounds truncated differential attack - App. H, the best strategy to minimize the computational cost is first to re-order the elements of each set using the algorithm described in App. F, and then to count the number of collisions working only on (ordered) consecutive texts. Since in this case each set contains  <span class="math">2^8</span>  elements, the cost to re-order each set and count the number of collision for each possible J with |J|=3 can be approximated to  <span class="math">4\\cdot 2^8\\cdot (\\log 2^8+1)=2^{13}</span>  table look-ups. Since this operation is the most expensive one, we can approximate the cost of this attack with  <span class="math">12\\cdot 2^{90.4}\\cdot 2^{13}\\approx 2^{107}</span>  table-look ups, or  <span class="math">2^{100.35}</span>  five rounds AES encryption.</p>

    <p class="text-gray-300">Finally, it is also possible to modify the attack considering the difference of two sub-key bytes for more than one column at the same time. However, as we show in details in App. I.2, this case is worse both for the data complexity and the computational cost than the one presented here.</p>

    <h4 id="sec-63" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-71-1&quot;&gt;&lt;/span&gt;I.1.3 Practical Verification on small-scale AES</h4>

    <p class="text-gray-300">Due to the huge data and computational complexities of the proposed distinguisher, it can not verified directly on AES. Here we show that - due to the same reasons - it can not also verified on small-scale AES, as presented in [CMR05]. While in &quot;real&quot; AES, each word is composed of 8 bits, in this variant each word is composed of 4 bits. We refer to [CMR05] for a complete description of this small-scale AES, and we limit ourselves to describe the results of our 5-round distinguisher in this case.</p>

    <p class="text-gray-300">First of all, note that the argumentations exploited by the proposed distinguisher hold exactly in the same way also for this small-scale variant of AES (they are independent by the fact that each word of AES is of 4 or 8 bits). Thus, our verification on the small-scale variant of AES is strong evidence for it to hold for the real AES.</p>

    <p class="text-gray-300">On the other hand, also a practical verification on small-scale AES can not be done due to the huge data and computational complexities of the proposed distinguisher also in this case. In particular, using the same calculation given before, it turn out that one has to use approximately  <span class="math">2^{42.2}</span>  different sets  <span class="math">V_{\\delta}</span>  in order to set up the distinguisher, for a total cost of  <span class="math">2^{42.2} \\cdot 2^4 = 2^{46.2}</span>  chosen plaintexts. In the same way, the time complexity is well approximated by  <span class="math">4 \\cdot 2^{42.2} \\cdot 2^4 \\cdot \\log 2^4 \\simeq 2^{50.2}</span>  table look-ups, or approximately  <span class="math">2^{43.6}</span>  five-round encryptions.</p>

    <h2 id="sec-64" class="text-2xl font-bold">&lt;span id=&quot;page-71-0&quot;&gt;&lt;/span&gt;I.2 A possible Variant of the Impossible Differential Attack on 5-round AES with Secret S-Box</h2>

    <p class="text-gray-300">In order to construct the impossible differential attack on 5-round of AES with secret S-Box of Sect. 8, we focused only on the difference of two sub-key bytes that belong to the same column after the first ShiftRows operation. As done for the truncated differential attack on 4 rounds - App. H, one possible variant consists of exploiting more than a single difference at the same time. As we show in the following, this variant of the attack has an higher data and computational complexity cost.</p>

    <p class="text-gray-300">In particular, let the set of plaintext-ciphertext  <span class="math">W_{\\Delta}</span>  defined as follows</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} W_{\\Delta} = &amp; \\{ (p^i, c^i) \\ \\text{ for } i = 0, ..., 2^{32} - 1 \\, | \\, p^i_{0,0} \\oplus p^i_{1,1} = \\delta_0, \\, p^i_{1,2} \\oplus p^i_{2,3} = \\delta_1, \\\\ &amp; p^i_{2,0} \\oplus p^i_{3,1} = \\delta_2, \\, p^i_{0,3} \\oplus p^i_{3,2} = \\delta_3 \\quad \\forall i \\quad \\text{and} \\quad p^i_{k,l} = p^j_{k,l} \\ \\text{ otherwise} \\}, \\end{split}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\Delta \\equiv (\\delta_0, \\delta_1, \\delta_2, \\delta_3)</span> ,  <span class="math">\\delta_0 = k_{0,0} \\oplus k_{1,1}</span> ,  <span class="math">\\delta_1 = k_{1,2} \\oplus k_{2,3}</span> ,  <span class="math">\\delta_2 = k_{2,0} \\oplus k_{3,1}</span>  and  <span class="math">\\delta_3 = k_{0,3} \\oplus k_{3,2}</span> . Note that  <span class="math">|W_{\\Delta}| = 2^{32}</span> , thus it is possible to construct  <span class="math">2^{31} \\cdot (2^{32} - 1) = 2^{63}</span>  different pairs.</p>

    <p class="text-gray-300"><strong>Proposition 8.</strong> Let  <span class="math">W_{\\Delta}</span>  defined as before and let  <span class="math">I = \\{0, 1, 3\\}</span> . There exists  <span class="math">a \\in \\mathcal{D}_{I}^{\\perp}</span>  such that  <span class="math">R(W_{\\Delta}) \\subseteq \\mathcal{D}_{0,1,3} \\oplus a</span> .</p>

    <p class="text-gray-300">As a consequence, given two elements p and q in  <span class="math">W_{\\Delta}</span> , then  <span class="math">R(p) \\oplus R(q) \\in \\mathcal{D}_{0,1,3}</span> , and so as before  <span class="math">R^{(5)}(p) \\oplus R^{(5)}(q) \\notin \\mathcal{M}_J</span>  with probability 1 for each J with |J| = 1.</p>

    <p class="text-gray-300">The strategy of the attack is the same as before. The idea is to construct  <span class="math">2^{32}</span>  collections (one for each possible combination of values of  <span class="math">\\Delta</span> ), each one with a certain number of sets  <span class="math">W_{\\Delta}</span> . To compute this number, our goal is to guarantee that in the random case, there is at least one collision for each possible combination of values of  <span class="math">\\delta_i</span>  for i=0,...,3 with probability 95%. Using the same computation as before, for each one of the  <span class="math">2^{32}</span>  collections (i.e. for each combination of values of  <span class="math">\\delta_i</span>  for i=0,...,3), we need at least one collision with probability higher than  <span class="math">0.95^{1/2^{32}} \\simeq 1-2^{-36.4}</span> . Moreover, the attacker has to repeat this step 4 times, which implies a probability of  <span class="math">(1-2^{-36.4})^{1/4} \\simeq 1-2^{-38.4}</span> . Thus, to have at least one collision with this probability for each one of the  <span class="math">2^{32}</span>  collections, each collection has to be composed of  <span class="math">2^{98.74}</span>  pairs (instead of  <span class="math">2^{95.6}</span>  pairs). Equivalently, this means that for each one of the  <span class="math">2^{32}</span>  collections one needs about  <span class="math">2^{98.74} \\cdot 2^{-63} = 2^{35.74}</span>  different sets  <span class="math">W_{\\Delta}</span> .</p>

    <p class="text-gray-300">Since each one of these sets contains  <span class="math">2^{32}</span>  texts (equivalently  <span class="math">2^{63}</span>  pairs), since there are  <span class="math">2^{32}</span>  possible  <span class="math">\\Delta</span>  and since we have to repeat this attack 4 times, the total number of texts for the attack is  <span class="math">4 \\cdot 2^{32} \\cdot 2^{35.74} \\cdot 2^{32} = 2^{101.75}</span> , which is higher than before.</p>

    <p class="text-gray-300">Finally, using the same argumentation of Sect. 8, we can approximate the computational cost to  <span class="math">4 \\cdot 2^{101.75} \\cdot (\\log 2^{101.75} + 1) = 2^{110.4}</span>  table look-ups, which is higher than before.</p>

`;
---

<BaseLayout title="4 Distinguishers for 1, 2, 3 and 4 Rounds of AES with Secret... (2016/592)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/592
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="4-distinguishers-for-1-2-3-and-4-rounds-of-aes-with-secret-2016" />
  </article>
</BaseLayout>
