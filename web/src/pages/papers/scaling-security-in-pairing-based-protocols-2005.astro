---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2005/139';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Scaling security in pairing-based protocols';
const AUTHORS_HTML = 'Michael Scott';

const CONTENT = `    <p class="text-gray-300">Michael Scott</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">In number theoretic cryptography there is always the problem of scaling-up security to a higher level. This usually means increasing the size of the modulus, from, say 1024 bits to 2048 bits. In pairing-based cryptography however another option is available, keeping the modulus constant and increasing instead the embedding degree. This has a big potential advantage in smart-card and embedded applications – security can be scaled up while continuing to use the same sized calculations. For example a cryptographic co-processor which does 512-bit modular multiplications can be directly re-used in the higher security setting. Here we investigate the scaling-up issue in the context of prime characteristic non-supersingular elliptic curves. We also confirm that under certain circumstances at higher levels of security a slightly modified Weil pairing may become more efficient than the Tate pairing.</p>

    <p class="text-gray-300">Keywords: Cryptographic key sizes, pairing-based cryptosystems.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">In the majority of number-theoretic cryptographic protocols, both over the finite field and on elliptic and higher genus curves, the problem of increased security implies only one obvious solution – increase the size of the modulus, traditionally by doubling its size. Interestingly in the case of the RSA scheme, based as it is not on the difficulty of a discrete logarithm problem, but rather on the problem of integer factorisation, there is an alternative solution. Multi-prime RSA has been frequently suggested by many people as an alternative to simply doubling the length of the prime factors of the public key. If <span class="math">n=pq</span>, and <span class="math">p</span> and <span class="math">q</span> are originally 512 bits, then an increased security implementation might make <span class="math">p</span> and <span class="math">q</span> both 1024-bits. The multi-prime alternative is to use <span class="math">n=pqr s</span> where <span class="math">p</span>, <span class="math">q</span>, <span class="math">r</span> and <span class="math">s</span> all remain 512-bit primes. This does not apparently introduce any serious new weaknesses <em>[16]</em>, and represents a completely viable solution, with some significant performance advantages. And yet multi-prime RSA is not widely used, and has only relatively recently appeared in standardisation documents <em>[19]</em>. The reason for this may be that the optimal way of scaling RSA security was never properly addressed early on by the research community. And it is very simple to just double the bit length of <span class="math">p</span> and <span class="math">q</span> – for one thing it requires no further security analysis.</p>

    <p class="text-gray-300">For a particular discrete logarithm based scheme, there is no such choice. For increased security, one must increase the size of the modulus. There is of course the possibility of switching to a different scheme for which the same-sized modulus provides more security – for example one can switch from a standard finite field setting to a scheme such as LUC <em>[32]</em>, or XTR <em>[20]</em>. But as a way of scaling security this seems very clumsy. And there is something else to be considered – when attacking a discrete logarithm based system an attacker can choose to exploit the small size of the group (using the Pollard Lambda algorithm), or the small size of the field (using index calculus methods, if they apply, otherwise the Pollard Rho algorithm) <em>[25]</em>. For balanced security in a finite field one might choose a modulus of 1024-bits (to resist index calculus attacks) and a group size of 160-bits (to resist Pollard Lambda attacks).</p>

    <p class="text-gray-300">The issue of how to scale up security in pairing-based cryptosystems has also been addressed by Koblitz and Menezes <em>[18]</em> and Granger, Page and Smart <em>[15]</em>. As will be seen our experimental evidence largely supports their conclusions.</p>

    <p class="text-gray-300">In pairing based cryptography there are, as for RSA, two distinct strategies to obtain increased levels of security; double the size of the prime modulus, or double the embedding degree. In both cases the group size must also be increased as appropriate.</p>

    <p class="text-gray-300">However field size is a particularly significant parameter for smart-card and embedded implementations that use co-processor support, as it is field size that determines the hardware requirement.</p>

    <p class="text-gray-300">Here we analyse the approach of simply doubling the embedding degree. This has some immediate implications. Firstly supersinglar elliptic curves have a maximum embedding degree of 6. While it is true that higher embedding degrees can be obtained on hyper-elliptic curves <em>[26]</em>, as a method of scaling security switching to a different characteristic or to a higher genus curve again seems very clumsy. Therefore we consider here only non-supersingular curves, while acknowledging that small characteristic supersingular elliptic and hyperelliptic curves can be a very efficient vehicle for pairing-based cryptography. See for example <em>[3]</em> for some recent results, in particular the discovery of the new <span class="math">\\eta_{T}</span> pairing.</p>

    <p class="text-gray-300">The aim is to provide a simple mechanism for scaling security which requires minimal changes to an existing implementation, in terms of algorithm, software and hardware.</p>

    <p class="text-gray-300">In most protocols it is the time taken to calculate the pairing that is most significant. However the time taken for field exponentiation and elliptic curve point multiplication must also be taken into account when evaluating in detail the performance of a particular protocol. In many cases precomputation can be exploited to eliminate much of the on-line computational cost, and this must also be taken into account. Such in-depth analysis must be done on a protocol by protocol basis, and is outside the scope of this paper, where we concentrate solely on the cost of the pairing.</p>

    <p class="text-gray-300">Generating suitable non-supersingular elliptic curves can be quite difficult. Many algorithms have been suggested, but the current state-of-the-art has its own constraints. To summarise:-</p>

    <p class="text-gray-300">Let <span class="math">F</span> be the number of bits in the field modulus <span class="math">p</span>, and <span class="math">G</span> the size of the group order <span class="math">r</span> in bits. The embedding degree is <span class="math">k</span>. Then it is relatively easy to generate suitable curves with <span class="math">G&lt;F/2</span> for any <span class="math">k</span>. In some specific cases it is possible to generate curves with <span class="math">F/2&lt;G&lt;F</span>. For <span class="math">k=\\{3,4,6\\}</span> it is possible to find curves with <span class="math">G=F</span>. Recently Barreto and Naehrig <em>[7]</em> have discovered a remarkable formula for easily generating curves with <span class="math">G=F</span> and <span class="math">k=12</span>, and Freeman <em>[13]</em> has also found a number of <span class="math">G=F</span> solutions for the case <span class="math">k=10</span>.</p>

    <p class="text-gray-300">In some applications, like a short signature scheme <em>[10]</em>, it is very important that <span class="math">G=F</span>, otherwise the signature will not be short. And at first glance this also appears to be most efficient. However in the majority of applications it is not so important, and so we will focus (mostly) to the condition <span class="math">G&lt;F/2</span> where curves are plentiful and easy to find. An added advantage of choosing <span class="math">G&lt;F/2</span> is that in this case the group order <span class="math">r</span> can be chosen to have the lowest possibly Hamming weight, with some performance benefits <em>[4]</em>.</p>

    <p class="text-gray-300">For our purposes we define 3 levels of security, which are roughly within the limits laid down by Lenstra and Verheul <em>[21]</em>. These are referred to here as (1024/160) security, (2048/192) security, and (4096/224) security, where the first figure refers to the effective field size <span class="math">kF</span>, and the second refers to the group size. Here we advocate fixing <span class="math">F=512</span> and using <span class="math">k=2</span>, <span class="math">k=4</span> and <span class="math">k=8</span> to achieve the higher levels of security. Much greater granularity could be achieved by using intermediate values of <span class="math">k</span>, and different values for <span class="math">F</span>. And we acknowledge that an embedding degree of <span class="math">k=2^{n}</span> may not in fact be optimal – in particular many nice tricks are known to exist for curves with <span class="math">k=2^{n}.3^{m}</span> <em>[7]</em>, <em>[15]</em>.</p>

    <p class="text-gray-300">However we justify our approach by pointing out that in practice the “algorithm” used by cryptographers is that if using an <span class="math">N</span> bit “RSA equivalent” level of security, and cryptanalysts threaten at the <span class="math">N/2</span> level, then switch to <span class="math">2N</span> bit security, and we maintain that the convenience and scalability of <span class="math">k=2^{n}</span> implementations will make them likely to be adopted in practise.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2 The Tate pairing</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this section we will review the Tate pairing algorithm on non-supersingular curves over fields of large prime characteristic <span class="math">p</span>. We choose a prime <span class="math">r</span> of size <span class="math">G</span> which has a low Hamming weight. Next we find an elliptic curve over <span class="math">\\mathbb{F}_{p}</span> where <span class="math">p</span> is of size <span class="math">F</span> and whose order is divisible by <span class="math">r</span>, and where $r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p^{k}-1<span class="math">. Assuming that </span>r<span class="math"> does not divide </span>p^{i}-1<span class="math"> for any value of </span>i<k<span class="math">, then this is a curve suitable for use in pairing-based cryptography, and has an embedding degree of </span>k$. Observe the well-known fact that the cyclotomic polynomial</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Phi_{2^{n}}(x)=x^{2^{n-1}}+1</span></p>

    <p class="text-gray-300">is irreducible, and</p>

    <p class="text-gray-300"><span class="math">p^{2^{n}}-1=(p^{2^{n-1}}-1).\\Phi_{2^{n}}(p)</span></p>

    <p class="text-gray-300">Since we know that <span class="math">r</span> does not divide <span class="math">(p^{2^{n-1}}-1)</span>, then it must divide <span class="math">\\Phi_{2^{n}}(p)</span>.</p>

    <p class="text-gray-300">The general Tate pairing is written as <span class="math">e_{r}(P,Q)</span>, where <span class="math">P</span> is a point on <span class="math">E(\\mathbb{F}_{p^{k}})</span> in a subgroup of order <span class="math">r</span> and <span class="math">Q</span> is also on <span class="math">E(\\mathbb{F}_{p^{k}})</span>, a representative of the coset of points which includes a member of a distinct subgroup, also of order <span class="math">r</span>. The Tate pairing evaluates as a non-trivial element of the extension field <span class="math">F_{p^{k}}</span> of order <span class="math">r</span>.</p>

    <p class="text-gray-300">The Tate pairing has the following relevant properties.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">e_{r}(aP,bQ)=e_{r}(P,Q)^{ab}</span> for all <span class="math">a,b\\in\\mathbb{F}_{r}</span> (Bilinearity)</li>

      <li><span class="math">e_{r}(P,P)=1</span></li>

    </ol>

    <p class="text-gray-300">The bilinearity property is the one that enables the implementation of many novel protocols.</p>

    <p class="text-gray-300">In practise it is common for efficiency reasons to choose <span class="math">P\\in E(\\mathbb{F}_{p})</span>. It is also possible to manipulate <span class="math">Q</span> as a point on the twisted curve defined over <span class="math">\\mathbb{F}_{p^{k/2}}</span>, before mapping it to a point on <span class="math">E(\\mathbb{F}_{p^{k}})</span> prior to calculation of the pairing <em>[6]</em>. The coordinates of this point will exhibit some redundancy which can be exploited to speed up the calculation.</p>

    <p class="text-gray-300">The Tate pairing algorithm consists of an application of Miller’s algorithm followed by a final exponentiation. In Miller’s algorithm the point <span class="math">P</span> is implicitly multiplied by <span class="math">r</span> using the standard double and add method, and at each iteration a distance relationship between the current point and the fixed point <span class="math">Q</span> is calculated and accumulated in a <span class="math">\\mathbb{F}_{p^{k}}</span> variable.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The purpose of the final exponentiation is to yield a unique result of order <span class="math">r</span>. Now the field <span class="math">\\mathbb{F}_{p^{k}}</span> has <span class="math">p^{k}-1</span> elements in it, and by definition $r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p^{k}-1<span class="math">. Assuming that </span>k=2^{n}<span class="math"> the final exponentiation is to the power of </span>(p^{2^{n}}-1)/r<span class="math">. This can be written as </span>(p^{2^{n-1}}-1)(\\Phi_{2^{n}}(p)/r<span class="math">. The exponentiation by </span>(p^{2^{n-1}}-1)<span class="math"> is cheap, using the Frobenius action and a single extension field inversion. The hard work here is the exponentiation to the power of </span>\\Phi_{2^{n}}(p)/r$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As demonstrated in <em>[30]</em> the output of the Tate pairing can easily be compressed to half its size for even <span class="math">k</span>. The compressed pairing returns an element of <span class="math">\\mathbb{F}_{k/2}</span>.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.1 Non-supersingular Vs Supersingular</h3>

    <p class="text-gray-300">There is a view (unsupported by any hard evidence) that non-supersingular curves are intrinsically “more secure” than supersingular curves. We will not comment on this. There is also a view that it is faster to use a supersingular curve, perhaps as a form of compensation for its perceived weakness. For prime field characteristic one is restricted to the case <span class="math">k=2</span>. Counterintuitively it has been demonstrated in <em>[29]</em> that the optimal pairing algorithm for certain non-supersingular curves is in fact faster than that for the equivalent supersingular curve. It has also been suggested <em>[18]</em> that the ease of domain generation for</p>

    <p class="text-gray-300">persingular curves makes it easier to generate a modulus <span class="math">p</span> with a low Hamming weight, which in turn leads to faster implementation. But as they also point out a low Hamming weight <span class="math">p</span> raises genuine security concerns. See section 5 below for more details on curve generation.</p>

    <p class="text-gray-300">Nevertheless the vast majority of pairing based protocols have been described in the context of super-singular curves. Most can be transferred directly onto a non-supersingular curve and will work fine under the so-called co-Bilinear Diffie-Hellman assumption, co-BDH, rather than under the original (and arguably more intuitive) BDH assumption <em>[9]</em>. However there are subtle differences. Recall that when using supersingular curves a distortion map exists, and so <span class="math">\\hat{e}(P,Q)=e_{r}(P,\\phi(Q))</span>, where <span class="math">P,Q\\in E(\\mathbb{F}_{p})</span>. Then this distorted Tate pairing has the properties</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\hat{e}_{r}(aP,bQ)=\\hat{e}_{r}(P,Q)^{ab}</span> for all <span class="math">a,b\\in\\mathbb{F}_{r}</span> (Bilinearity)</li>

      <li><span class="math">\\hat{e}_{r}(P,P)\\neq 1</span></li>

      <li><span class="math">\\hat{e}_{r}(P,Q)=\\hat{e}_{r}(Q,P)</span></li>

    </ol>

    <p class="text-gray-300">Note that property 2 is different and property 3 is new. However the two pairings do share the important property of bilinearity which is the property required for the new pairing-based protocols. Sometimes these different properties can affect the behaviour of a protocol in interesting ways. However the main implication is that when working on non-supersingular curves we need to remember to treat the two parameters <span class="math">P\\in E(\\mathbb{F}_{p})</span> and <span class="math">Q\\in E(\\mathbb{F}_{p^{k}})</span> quite differently. They cannot be interchanged or moved from side to side of the pairing calculation. Another potentially significant difference is that manipulation of the <span class="math">Q</span> parameter prior to the pairing calculation is much simpler using super-singular curves, as <span class="math">Q</span> will be a point on the base curve rather than on the curve taken over a larger extension field when <span class="math">k&gt;2</span>, even using the “twist” idea (see below). Finally as pointed out in <em>[28]</em> it is possible to do useful precomputation on the first parameter if it should be a constant, but not on the second. Since the parameters can be switched from side to side with supersingular curves (using property 2 above) then this feature is easier to exploit in this setting than in the non-supersingular case.</p>

    <h2 id="sec-6" class="text-2xl font-bold">3 A Tower of extensions</h2>

    <p class="text-gray-300">We will require a scalable implementation of finite field arithmetic over the field <span class="math">\\mathbb{F}_{p^{2^{n}}}</span>. The simplest way to do this will be to use a tower of extensions <em>[24]</em>. That is an element of <span class="math">\\mathbb{F}_{p^{2^{n}}}</span> will be represented as a pair of elements from <span class="math">\\mathbb{F}_{p^{2^{n-1}}}</span>, and so on recursively, starting with an efficient implementation of <span class="math">\\mathbb{F}_{p}</span>.</p>

    <p class="text-gray-300">For a suitable extension field arithmetic representation we first need an irreducible polynomial. For example if <span class="math">p=3\\mod 4</span>, then <span class="math">x^{2}+1</span> is a suitable irreducible polynomial for representation of the extension field <span class="math">\\mathbb{F}_{p^{2}}</span>. Elements of the field can be represented as a polynomial <span class="math">ax+b</span> where <span class="math">a,b\\in\\mathbb{F}_{p}</span>. Alternatively “solve” the irreducible polynomial and set <span class="math">x=\\sqrt{-1}</span>, and use as a representation <span class="math">a+b.\\sqrt{-1}</span>. Numbers in this form can be manipulated directly without explicit</p>

    <p class="text-gray-300">reference to an irreducible polynomial. Note that <span class="math">-1</span> is a quadratic non-residue with respect to <span class="math">p</span>, iff <span class="math">p=3\\mod 4</span>. Unfortunately this representation does not permit a simple tower of extensions to be built on top of it.</p>

    <p class="text-gray-300">An alternative is to choose <span class="math">p=1\\mod 4</span>. In this case the irreducible polynomial <span class="math">x^{2}+2</span> can be chosen, and it does support an infinite tower of similar extensions. In practise we choose <span class="math">p=5\\mod 8</span>, as it is important to have a simple formula for modular square roots, which does exist for this case, but not in general for <span class="math">p=1\\mod 8</span> (the calculation of square roots is required to generate points on the elliptic curve). So –</p>

    <p class="text-gray-300">An element of <span class="math">\\mathbb{F}_{p^{2}}</span> is <span class="math">a+b.(-2)^{1/2}</span>, or <span class="math">[a,b]</span> a pair of elements from <span class="math">\\mathbb{F}_{p}</span>.</p>

    <p class="text-gray-300">An element of <span class="math">\\mathbb{F}_{p^{4}}</span> is <span class="math">c+d.(-2)^{1/4}</span>, or <span class="math">[c,d]</span> a pair of elements from <span class="math">\\mathbb{F}_{p^{2}}</span>.</p>

    <p class="text-gray-300">An element of <span class="math">\\mathbb{F}_{p^{8}}</span> is <span class="math">e+f.(-2)^{1/8}</span>, or <span class="math">[e,f]</span> a pair of elements from <span class="math">\\mathbb{F}_{p^{4}}</span>.</p>

    <p class="text-gray-300">Now the implementation of each new layer of the tower can be built in an identical fashion on top of the previous layer. In the terminology of the programming language C++, a templated class which supports the operations of field addition, subtraction, multiplication and division (plus square rooting and Lucas powering/multi-exponentiation) can be written just once which will support all these instantiations. We omit implementation details as they are quite straightforward.</p>

    <p class="text-gray-300">There is now an extra constraint on the curve generation process, that <span class="math">p=5\\mod 8</span>. However we found that in most cases it was still easy to find suitable curves.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">3.1 The Twist Idea</h3>

    <p class="text-gray-300">Let <span class="math">i</span> be the <span class="math">k</span>-th root of <span class="math">-2</span>. Then if the point <span class="math">([x,0],[0,y])</span> is a point on the curve <span class="math">E:y^{2}=x^{3}+Ax+B</span> over the field <span class="math">\\mathbb{F}_{p^{k}}</span>, then it is easy to verify by simple substitution that the point <span class="math">(i^{2}x,i^{4}y)</span> is a point on the twisted curve <span class="math">E^{\\prime}:y^{2}=x^{3}+i^{4}Ax+i^{6}B</span> over the smaller field <span class="math">\\mathbb{F}_{p^{k/2}}</span>. It is also a simple matter to map points back from the twisted representation to the original curve <em>[6]</em>.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">3.2 Frobenius action</h3>

    <p class="text-gray-300">In the field <span class="math">\\mathbb{F}_{p^{k}}</span> the Frobenius action is defined as the well-known identity</p>

    <p class="text-gray-300"><span class="math">(x+iy)^{p}=x^{p}+i^{p}y^{p}</span></p>

    <p class="text-gray-300">This means that exponentiation by <span class="math">p</span> is almost for free. Using the Tower of extensions this formula can be applied recursively to <span class="math">x^{p}</span> and <span class="math">y^{p}</span> (and finally <span class="math">x^{p}=x</span> over <span class="math">\\mathbb{F}_{p}</span> by Fermat’s little theorem). However the term <span class="math">i^{p}</span> needs to be handled carefully. For example if <span class="math">i=(-2)^{1/8}</span>, and <span class="math">p=5\\mod 8</span>, then <span class="math">i^{p}=(-2)^{(p-5)/8}i^{5}</span>, where the term <span class="math">(-2)^{(p-5)/8}</span> can be precalculated.</p>

    <p class="text-gray-300">3.3 The final exponentiation of the Tate pairing</p>

    <p class="text-gray-300">The hard part of the final exponentiation can be computed by precalculating <span class="math">\\Phi_{2^{n}}(p)/r</span> and performing the exponentiation using compression of the pairing value, followed by Lucas exponentiation <em>[30]</em>. The exponent in this case will be approximately <span class="math">(k/2).lg(p)-lg(r)</span> bits in length. This is quite efficient for small values of <span class="math">k</span>, as we are dealing with elements over the compressed half-sized field <span class="math">\\mathbb{F}_{p^{k/2}}</span>. However for larger values of <span class="math">k</span>, as pointed out by Granger, Page and Smart <em>[15]</em>, it is more efficient to exploit multi-exponentiation <em>[1]</em>. Briefly <span class="math">\\Phi_{2^{n}}(p)/r</span> is precalculated and stored as a number to the base <span class="math">p</span>, and the Frobenius again exploited to allow a multi-exponentiation, with all exponents of length less than or equal to <span class="math">lg(p)</span>. Alternatively the whole of the final exponentiation to the power of <span class="math">(p^{2^{n}}-1)/r</span> could be included in the multi-exponentiation for a reasonably efficient and totally inverse-free pairing algorithm. Following the multi-exponentiation the output of the pairing can again be compressed if desired.</p>

    <p class="text-gray-300">In our experience for the cases considered here the Lucas method is superior for <span class="math">k\\leq 4</span>, while the multi-exponentiation method is superior for <span class="math">k\\geq 8</span>.</p>

    <h2 id="sec-9" class="text-2xl font-bold">4 The Algorithm</h2>

    <p class="text-gray-300">In this section we describe the BKLS version of the Tate Pairing algorithm (which in turn is based on the original Miller algorithm), closely following the treatment in <em>[28]</em>, which is based on earlier work by Barreto et al <em>[4]</em> and Galraith et al. <em>[14]</em>. For efficiency we use a standard projective coordinate system, as described in <em>[17]</em>, for the implicit point multiplication on <span class="math">E(\\mathbb{F}_{p})</span>. First we need a function to execute a point addition, obtaining the line slope and finally calculating the contribution of the current iteration of the algorithm. Capital letters denote curve points, lower case letters and symbols represent elements of <span class="math">\\mathbb{F}_{p}</span> or simple integers, and boldface letters represent elements of <span class="math">\\mathbb{F}_{p^{k/2}}</span>.</p>

    <p class="text-gray-300"><span class="math">\\boldsymbol{g}(R,P,\\mathbf{x_{q}},\\mathbf{y_{q}})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">x,y,z\\leftarrow R</span></li>

      <li><span class="math">\\lambda_{n},\\lambda_{d}=R.add(P)</span></li>

      <li><span class="math">\\mathbf{return}\\ y\\lambda_{d}-\\lambda_{n}(xz-\\mathbf{x_{q}}z^{3})-\\mathbf{y_{q}}z^{3}\\lambda_{d}\\cdot i</span></li>

    </ol>

    <p class="text-gray-300">The function <span class="math">A.add(B)</span> performs the standard projective point addition, but also returns the line slope as the rational <span class="math">\\lambda_{n}/\\lambda_{d}</span>. Note that the line slope is needed anyway to perform the point addition, so no extra work is involved. Assume that the point <span class="math">P</span> is of prime order <span class="math">r</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Tate}(r,p,P,Q)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\boldsymbol{m}=1</span></li>

      <li><span class="math">R=P</span></li>

      <li><span class="math">n=r-1</span></li>

      <li><span class="math">\\mathbf{x_{q}},\\mathbf{y_{q}}\\leftarrow untwist(Q)</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for <span class="math">i\\leftarrow\\lfloor\\lg(r)\\rfloor-2</span> downto <span class="math">0</span> do</li>

      <li><span class="math">\\bm{m}=\\bm{m}^{2}\\cdot\\bm{g}(R,R,\\mathbf{x_{q}},\\mathbf{y_{q}})</span></li>

      <li>if <span class="math">n_{i}=1</span> then <span class="math">\\bm{m}=\\bm{m}\\cdot\\bm{g}(R,P,\\mathbf{x_{q}},\\mathbf{y_{q}})</span></li>

      <li>end for</li>

      <li><span class="math">\\bm{m}=\\bm{m}^{(p^{k/2}-1)}</span></li>

      <li>return <span class="math">E_{(p^{k/2}+1)/r}(\\mathbf{m})</span></li>

    </ol>

    <p class="text-gray-300">The variable <span class="math">\\bm{m}</span> is the <em>Miller variable</em>, and is the only variable that is an element of the full extension field <span class="math">\\mathbb{F}_{p^{k}}</span>. The notation <span class="math">n_{i}</span> refers to the i-th bit of <span class="math">n</span>. Note that the choice of a low Hamming weight <span class="math">r</span> means that this bit may be 1 only once in the entire calculation. The function <em>untwist</em> converts the point <span class="math">Q</span> on the twisted curve to the point <span class="math">([\\mathbf{x_{q}},0],[0,\\mathbf{y_{q}}])</span> on the original curve over the full extension field <span class="math">\\mathbb{F}_{p^{k}}</span>, as described in section 3.1. The function <span class="math">E</span> represents the “difficult” part of the final exponentiation, as described above.</p>

    <p class="text-gray-300">In certain circumstances the first parameter to the pairing algorithm, the point <span class="math">P</span>, may be a constant. If it is, then we can benefit significantly from a precomputation. All the points and slopes in the implicit multiplication of <span class="math">P</span> by <span class="math">r</span> can be precomputed and stored, and a much simpler affine version of the function <span class="math">g(.)</span> can be used <em>[28]</em>.</p>

    <p class="text-gray-300">Using a tower of extensions this same algorithm can be used for any positive value of <span class="math">n</span>, where the extension degree is <span class="math">k=2^{n}</span>. Although implementation details might vary slightly (in particular in the <em>untwist</em> function and in the Frobenius action), by and large it is fair to say that the same basic algorithm works for any <span class="math">n</span>. But how do we find suitable non-supersingular curves for <span class="math">k=2</span>, <span class="math">k=4</span>, <span class="math">k=8</span> etc?</p>

    <h2 id="sec-10" class="text-2xl font-bold">5 Curve Generation</h2>

    <p class="text-gray-300">It was long known that non-supersingular curves might exhibit a low embeddeding degree – hence the famous MOV condition <em>[22]</em> that was recommended to avoid the use of such curves in classic elliptic curve cryptography. Since they were generally regarded as a “bad thing”, there was not much interest in deliberately generating them. Fortunately at around the time that pairings became cryptographically interesting Miyaji et al. published their paper on the construction of so-called MNT curves <em>[23]</em>. The original paper described constructions for non-supersingular elliptic curves over fields of prime characteristic with embedding degrees of 3, 4 and 6 with <span class="math">G=F</span> (Recall that <span class="math">F</span> is the number of bits in the prime modulus <span class="math">p</span>, and that <span class="math">G</span> is the number of bits in the prime group order <span class="math">r</span>). The condition <span class="math">G=F</span> implies that the curve <span class="math">E(\\mathbb{F}_{p})</span> is of prime order, and such pairing-friendly curves are very rare, although subsequent developments extended the idea to produce many more curves where the curve order was <span class="math">hr</span>, for small values of <span class="math">h</span> <em>[31]</em>. The term MNT curve is now commonly (and sometimes confusingly) used to refer to any non-singular curve with a useful embedding degree.</p>

    <p class="text-gray-300">A major development was an algorithm of Cocks and Pinch (unfortunately unpublished, but essentially the same algorithm is described in <em>[8]</em>). This method</p>

    <p class="text-gray-300">makes it quite easy to find a curve with any desired embedding degree, but with the restriction <span class="math">G&lt;F/2</span>.</p>

    <p class="text-gray-300">Subsequently a series of papers <em>[5]</em>, <em>[11]</em>, <em>[12]</em>, <em>[31]</em> discovered alternative strategies which in special cases could find curves with <span class="math">F/2&lt;G&lt;F</span>. Although at first glance it appears preferable to choose curves with <span class="math">G=F</span>, unfortunately until very recently there was no known method for doing so with <span class="math">k&gt;6</span>. This situation changed with the surprising discovery by Barreto and Naehrig <em>[7]</em> that solutions with <span class="math">G=F</span> for the particular case of <span class="math">k=12</span> were indeed possible, followed by the discovery by Freeman <em>[13]</em> of <span class="math">G=F</span> solutions for <span class="math">k=10</span>. However it seems to be generally true that for <span class="math">G&gt;F/2</span> the number of possible curves starts to become constrained, and in particular one no longer has control of the choice of <span class="math">r</span>. This is a pity because it is clearly more efficient if <span class="math">r</span> is chosen to have a low Hamming weight.</p>

    <p class="text-gray-300">Since it is our ideal to develop a method which can be scaled without limit, the Cocks and Pinch algorithm seems ideal, although we will also consider candidate curves generated using alternative methods, such as that described by Brezing and Weng <em>[11]</em>.</p>

    <p class="text-gray-300">These algorithms give us enough information to know that a suitable curve exists, with the desired embedding degree and with a curve order divisible by the chosen <span class="math">r</span>. However to find the actual curve parameters we must use the method of Complex Multiplication as described in <em>[17]</em>, and implemented in, for example, <em>[27]</em>.</p>

    <p class="text-gray-300">The actual elliptic curves <span class="math">E_{n}(\\mathbb{F}_{p})</span> that we used are described using the standard Weierstrass representation <em>[17]</em> for curves of prime characteristic, <span class="math">y^{2}=x^{3}+Ax+B</span>.</p>

    <p class="text-gray-300">E_{160} <span class="math">F</span> = <span class="math">512,G=160,k=2</span> <span class="math">p</span> = <span class="math">8d19a10497f9cc35bc026c6a7651da9ce4d794d4d67a4ab6e77d3b322e462b899</span> <span class="math">1a31e8fbfcb60b411f0e5afd85977d7eee3dd09cd197dafe4f377c3e23af2af</span> <span class="math">A</span> = <span class="math">-3</span> <span class="math">B</span> = <span class="math">4d438977ff9360a5df4294efe4bd7465351b7d19e99c17463f3c7f72ab95ca3c95</span> <span class="math">c82339f2c8b9f8801bc29328ae2d73969493d719fbbe3d34f689778ebd85ae</span> <span class="math">r</span> = <span class="math">80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span> E_{160e} <span class="math">F</span> = <span class="math">512,G=160,k=2</span> <span class="math">p</span> = <span class="math">dac2f97cdd22ac93ccc12106f6541b748c9d8f71c806b1023b95d69281eb5f739</span> <span class="math">f9a3efc931882113ca321a0ae348d825249b44e45c180726ec6e896e6de568b</span> <span class="math">A</span> = <span class="math">0</span> <span class="math">B</span> = <span class="math">5</span> <span class="math">r</span> = <span class="math">1000000000000000020001000000000000100010001</span></p>

    <p class="text-gray-300">E_{160s} <span class="math">F=256,G\\geq 160,k=4</span> <span class="math">p=555555d61555a64609707b5f09cb9d19c8c8fe1d68029a58dcc79a17ddd9acab</span> <span class="math">A=0</span> <span class="math">B=2</span> <span class="math">r=40000040601018484216141e16c9452503153868301</span> E_{192} <span class="math">F=512,G=192,k=4</span> <span class="math">p=b7fd9899de545d9d6b3644da15e9b662fd08ca211da537978b5556299c6b02f77</span> <span class="math">d5e776d48c14b14c65e905646de2318391b0ac3820ab2be9eb54b70927ee9b5</span> <span class="math">A=-3</span> <span class="math">B=865b15c872c80609aC5a6b397438a020d9c1cfbccd2d7e57480b1c80f6325461f</span> <span class="math">b1bf32b28d689412c6875e267676d926dd0232dbcc049efa670cfe2cb971a65</span> <span class="math">r=80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span> E_{192bw} <span class="math">F=256,G=192,k=8</span> <span class="math">p=cc485d26177a1a5fcc9d53ba93da298fd7f2f23d8fc02a8123bf24f9548a5f15</span> <span class="math">A=0</span> <span class="math">B=2</span> <span class="math">r=9d0261dd89cf83d5d20198162c22c942ef68622a6df25621</span> E_{224} <span class="math">F=512,G=224,k=8</span> <span class="math">p=bc1e1bf222c03dfd1bd55f2f220cf3b3f7f185834d6db68cdcc11d413e77ea4ee</span> <span class="math">cf8ffa5038e46c303a407da24b15aa57cc8bd6df69c5d9806742fca59f8604d</span> <span class="math">A=-3</span> <span class="math">B=62dc6331021838f1b0557dd1b016b4898fc16c084b8f2a4b9368d0ce1c4e744c6</span> <span class="math">e4319e1bbdd27ad060439ba50f0eb6cbc79e74404cd371263f024aecabfa9c7</span> <span class="math">r=80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</span></p>

    <p class="text-gray-300">The curves <span class="math">E_{160}</span>, <span class="math">E_{192}</span> and <span class="math">E_{224}</span> have a field size of 512 bits, and embedding degrees of 2, 4 and 8 respectively. Observe the low Hamming weight group orders <span class="math">r</span>, which are of sizes 160, 192 and 224 bits respectively. These were all generated using variations of the Cocks and Pinch algorithm. For the <span class="math">E_{160}</span> curves, <span class="math">p=3</span> mod 4 and we can use the irreducible polynomial <span class="math">x^{2}+1</span>. This will be a little faster. For all the other curves <span class="math">p=5\\mod 8</span> to facilitate the building of the tower of extensions using the irreducible polynomial <span class="math">x^{2}+2</span> as described above. It was particularly easy to find curves using the Cocks and Pinch algorithm, and we would expect that it would be as easy to find curves with higher embedding degrees <span class="math">k&gt;8</span>. The curve <span class="math">E_{192bw}</span> was generated using the Brezing-Weng algorithm <em>[11]</em>, and has a field size of 256 bits, a group size of 192 bits (of hamming weight 86), and an embedding degree of 8. Therefore in terms of security it should be similar to <span class="math">E_{192}</span>. The Brezing and Weng curve was much harder to find, given the constraints imposed. The curve <span class="math">E_{160s}</span> was found using an unpublished method of our own, and has a field size of 256 bits and a group size a little greater than 160 bits, with an embedding degree of 4. This curve was selected to have a lower than average hamming weight of just 47. The curve <span class="math">E_{160e}</span> is similar to <span class="math">E_{160}</span> but uses an elliptic curve with an efficient endomorphism, as described in <em>[29]</em>.</p>

    <p class="text-gray-300">Timings were carried out on a 3GHz Pentium IV processor, and are shown in Table 1. In particular we compare the scaling approach advocated here, with fixed size prime modulus and doubling  <span class="math">k</span> , with the alternative scaling method of simply doubling the size of the prime modulus, and keeping  <span class="math">k = 2</span>  fixed, using curves  <span class="math">E_{192a}</span>  and  <span class="math">E_{224a}</span> . We also compare curves generated using the Cocks and Pinch algorithm with curves generated using alternative approaches such as [11] for which  <span class="math">G &amp;gt; F / 2</span> .</p>

    <p class="text-gray-300">Table 1. Timings - Pentium IV 3GHz - Tate Pairing</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Curve</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(kF/G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F (bits)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G (bits)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time (ms)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">with precomp.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">E160</td>

            <td class="px-3 py-2 border-b border-gray-700">(1024/160)</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">8.9</td>

            <td class="px-3 py-2 border-b border-gray-700">4.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">E160e</td>

            <td class="px-3 py-2 border-b border-gray-700">(1024/160)</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">7.2</td>

            <td class="px-3 py-2 border-b border-gray-700">4.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">E160s</td>

            <td class="px-3 py-2 border-b border-gray-700">(1024/160)</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">165</td>

            <td class="px-3 py-2 border-b border-gray-700">7.5</td>

            <td class="px-3 py-2 border-b border-gray-700">6.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">E192</td>

            <td class="px-3 py-2 border-b border-gray-700">(2048/192)</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">20.5</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">E192bw</td>

            <td class="px-3 py-2 border-b border-gray-700">(2048/192)</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">E192a</td>

            <td class="px-3 py-2 border-b border-gray-700">(2048/192)</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">E224</td>

            <td class="px-3 py-2 border-b border-gray-700">(4096/224)</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">224</td>

            <td class="px-3 py-2 border-b border-gray-700">85</td>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">E224a</td>

            <td class="px-3 py-2 border-b border-gray-700">(4096/224)</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2048</td>

            <td class="px-3 py-2 border-b border-gray-700">224</td>

            <td class="px-3 py-2 border-b border-gray-700">209</td>

            <td class="px-3 py-2 border-b border-gray-700">137</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Observe that the curve generated using the simple Cocks and Pinch algorithm  <span class="math">E_{192}</span>  is in practice a little faster than the Brezing and Weng curve  <span class="math">E_{192bw}</span>  for the same security level. (Note that for the Brezing and Weng curve we do not use the algorithm as described above, but rather a standard windowing algorithm, which is more suitable in this case where the Hamming weight of  <span class="math">r</span>  is not insignificant.) The method of doubling the prime modulus as a method of scaling suffers, as point multiplication on an elliptic curve over a large prime field is very expensive. Precomputation (if it applies) solves this problem to an extent, but only at the cost of large precomputed tables.</p>

    <p class="text-gray-300">For comparison purposes, it is interesting to observe that an optimized implementation of the Tate pairing on a  <span class="math">k = 4</span>  supersingular curve over  <span class="math">\\mathbb{F}_{2^379}</span>  using the  <span class="math">\\eta_T</span>  approach [3] takes just 3.8 milliseconds on the same platform. The  <span class="math">eta_T</span>  algorithm does not benefit from precomputation.</p>

    <p class="text-gray-300">Originally it was thought that the Tate pairing would always be a better choice than the Weil pairing, a view articulated for example in [8].</p>

    <p class="text-gray-300">It has been suggested recently that at higher levels of security the Weil pairing may in fact be more efficient than the Tate pairing [2], [18]. This is supported by the observation that the final exponentiation of the Tate pairing makes a</p>

    <p class="text-gray-300">significant contribution to the overall timing. On the other hand the Weil pairing requires two invocations of Miller’s algorithm, but no final exponentiation.</p>

    <p class="text-gray-300">Here we will try to determine experimentally if there is a cross-over point at which the Weil pairing becomes superior. We observe that rather than using the standard Weil pairing directly it will be advantageous to consider the Weil pairing raised to the power of <span class="math">p^{k/2}-1</span> (using the fast Frobenius action) as this permits various optimizations similar to the denominator elimination optimization described by Barreto et al <em>[4]</em>. This observation was also made independently by Koblitz and Menezes <em>[18]</em>.</p>

    <p class="text-gray-300">The parameters <span class="math">P</span> and <span class="math">Q</span> are as above, although this time it is a requirement that <span class="math">Q</span> should also be of order <span class="math">r</span>.</p>

    <p class="text-gray-300">The function <span class="math">g(.)</span> is more complex for the Weil pairing, as a pair of point additions are required as we implement two invocations of the Miller algorithm. As before we use projective coordinates for the implicit point multiplication of the point <span class="math">P</span> on <span class="math">E(\\mathbb{F}_{p})</span>, but affine coordinates for the much more expensive point multiplication of <span class="math">Q</span> on the twisted curve <span class="math">E^{\\prime}(\\mathbb{F}_{p^{k/2}})</span>. The <em>untwisting</em> required of the points is merged into the formulae, whose derivation is left as an exercise for the reader. Note that the function <span class="math">g(.)</span> formally computes a numerator and a denominator. However the denominator can be replaced by its conjugate, and the implied division replaced by a multiplication, exploiting the exponentiation of the final result to the power of <span class="math">p^{k/2}-1</span>.</p>

    <p class="text-gray-300"><span class="math">\\boldsymbol{g}(R,P,S,Q,x_{p},y_{p},\\mathbf{x_{q}},\\mathbf{y_{q}})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">x,y,z\\leftarrow R</span></li>

      <li><span class="math">\\lambda_{n},\\lambda_{d}=R.add(P)</span></li>

      <li><span class="math">\\boldsymbol{n}=y\\lambda_{d}-\\lambda_{n}(xz-\\mathbf{x_{q}}z^{3})-\\mathbf{y_{q}}z^{3}\\lambda_{d}\\cdot i</span></li>

      <li><span class="math">\\mathbf{x,y}\\leftarrow S</span></li>

      <li><span class="math">\\lambda=S.add(Q)</span></li>

      <li><span class="math">\\boldsymbol{d}=i^{4}y_{p}+(\\mathbf{y}-\\lambda(\\mathbf{x}-i^{2}x_{p}))\\cdot i</span></li>

      <li>return <span class="math">(\\boldsymbol{n}\\cdot\\boldsymbol{d})</span></li>

    </ol>

    <p class="text-gray-300">The full Weil pairing algorithm can now be given. Note the absence of the final exponentiation. Otherwise the structure is very similar to that of the Tate pairing.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Weil}(r,p,P,Q)</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\boldsymbol{m}=1</span></li>

      <li><span class="math">R=P</span></li>

      <li><span class="math">S=Q</span></li>

      <li><span class="math">n=r-1</span></li>

      <li><span class="math">x_{p},y_{p}\\leftarrow P</span></li>

      <li><span class="math">\\mathbf{x_{q},y_{q}}\\leftarrow untwist(Q)</span></li>

      <li>for <span class="math">i\\leftarrow\\lfloor\\lg(r)\\rfloor-2</span> downto <span class="math">0</span> do</li>

      <li><span class="math">\\boldsymbol{m}=\\boldsymbol{m}^{2}\\cdot\\boldsymbol{g}(R,R,S,S,x_{p},y_{p},\\mathbf{x_{q}},\\mathbf{y_{q}})</span></li>

      <li>if <span class="math">n_{i}=1</span> then <span class="math">\\boldsymbol{m}=\\boldsymbol{m}\\cdot\\boldsymbol{g}(R,P,S,Q,x_{p},y_{p},\\mathbf{x_{q}},\\mathbf{y_{q}})</span></li>

      <li>end for</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pmb{m} = \\pmb{m}^{(p^{k / 2} - 1)}</span></li>

      <li>return  <span class="math">m</span></li>

    </ol>

    <p class="text-gray-300">Using the same curves as above, we proceeded to obtain timings for the Weil pairing, for the curves using  <span class="math">F = 512</span>  and  <span class="math">k = 2,4,8</span> . For the Weil pairing precomputation for a constant second parameter  <span class="math">Q</span>  is particularly rewarding, as the point multiplication on the twisted curve (for  <span class="math">k = 4,8</span> ) is very expensive - so we include timings for this case as well.</p>

    <p class="text-gray-300">Table 2. Timings - Pentium IV 3GHz - Weil Pairing</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Curve</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(kF/G)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F (bits)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G (bits)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time (ms)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">with precomp.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">E160</td>

            <td class="px-3 py-2 border-b border-gray-700">(1024/160)</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">E192</td>

            <td class="px-3 py-2 border-b border-gray-700">(2048/192)</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">E192bw</td>

            <td class="px-3 py-2 border-b border-gray-700">(2048/192)</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">E224</td>

            <td class="px-3 py-2 border-b border-gray-700">(4096/224)</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">224</td>

            <td class="px-3 py-2 border-b border-gray-700">90</td>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Observe that the Weil pairing is significantly more efficient at the security level (4096/224), but only if precomputation is possible.</p>

    <p class="text-gray-300">We have demonstrated that using non-supersingular MNT curves we can easily scale the security of pairing based cryptosystems, effectively without limit. The basic algorithm remains the same at all levels of security. The proposed method of doubling the embedding degree to reach the next level of security seems to compare well with the alternative approach of simple doubling the size of the modulus.</p>

    <p class="text-gray-300">Finally we provide experimental evidence to support the view that at higher levels of security the Weil pairing can become more efficient than the Tate pairing, but only if precomputation is possible, that is if one of the pairing parameters is a constant.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>R. M. Avanzi. On multi-exponentiation in cryptography. Cryptology ePrint Archive, Report 2002/154, 2002. http://eprint.iacr.org/2002/154.</li>

      <li>Paulo Barreto. Private communication.</li>

      <li>Paulo S. L. M. Barreto, Steven Galbraith, Colm O hEigeartaigh, and Michael Scott. Efficient pairing computation on supersingular abelian varieties. Cryptology ePrint Archive, Report 2004/375, 2004. http://eprint.iacr.org/2004/375.</li>

      <li>P.S.L.M. Barreto, H.Y. Kim, B. Lynn, and M. Scott. Efficient algorithms for pairing-based cryptosystems. In Advances in Cryptology - Crypto'2002, volume 2442 of Lecture Notes in Computer Science, pages 354-68. Springer-Verlag, 2002.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>P.S.L.M. Barreto, B. Lynn, and M. Scott. Constructing elliptic curves with prescribed embedding degrees. In Security in Communication Networks – SCN’2002, volume 2576 of Lecture Notes in Computer Science, pages 263–273. Springer-Verlag, 2002.</li>

      <li>P.S.L.M. Barreto, B. Lynn, and M. Scott. On the selection of pairing-friendly groups. In Selected Areas in Cryptography – SAC 2003, volume 3006 of Lecture Notes in Computer Science, pages 17–25. Springer-Verlag, 2003.</li>

      <li>P.S.L.M. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order. Cryptology ePrint Archive, Report 2005/133, 2005. http://eprint.iacr.org/2005/133.</li>

      <li>I. F. Blake, G. Seroussi, and N. P. Smart, editors. Advances in Elliptic Curve Cryptography, Volume 2. Cambridge University Press, 2005.</li>

      <li>D. Boneh and M. Franklin. Identity-based encryption from the Weil pairing. SIAM Journal of Computing, 32(3):586–615, 2003.</li>

      <li>D. Boneh, B. Lynn, and H. Shacham. Short signatures from the Weil pairing. In Advances in Cryptology – Asiacrypt’2001, volume 2248 of Lecture Notes in Computer Science, pages 514–532. Springer-Verlag, 2002.</li>

      <li>F. Brezing and A. Weng. Elliptic curves suitable for pairing based cryptography. Cryptology ePrint Archive, Report 2003/143, 2003. Available from http://eprint.iacr.org/2003/143.</li>

      <li>R. Dupont, A. Enge, and F. Morain. Building curves with arbitrary small MOV degree over finite prime fields. Cryptology ePrint Archive, Report 2002/094, 2002. http://eprint.iacr.org/2002/094.</li>

      <li>R. Dutta, R. Barua, and P. Sarkar. Constructing pairing-friendly elliptic curves with embedding degree 10. Cryptology ePrint Archive, Report 2006/026, 2006. http://eprint.iacr.org/2006/026.</li>

      <li>S. Galbraith, K. Harrison, and D. Soldera. Implementing the Tate pairing. In Algorithm Number Theory Symposium – ANTS V, volume 2369 of Lecture Notes in Computer Science, pages 324–337. Springer-Verlag, 2002.</li>

      <li>R. Granger, D. Page, and N. P. Smart. Cryptology ePrint Archive, Report 2006/059, 2006. http://eprint.iacr.org/2006/059.</li>

      <li>M. J. Hinek, M. K. Low, and E. Teske. On some attacks on multi-prime RSA. In Selected Areas in Cryptography, volume 2595 of Lecture Notes in Computer Science, pages 385–404. Springer-Verlag, 2002.</li>

      <li>IEEE Std 1363-2000. Standard specifications for public-key cryptography. IEEE P1363 Working Group, 2000.</li>

      <li>Neal Koblitz and Alfred Menezes. Pairing-based cryptography at high security levels. Cryptology ePrint Archive, Report 2005/076, 2005. http://eprint.iacr.org/2005/076.</li>

      <li>RSA Laboratories. PKCS # 1 v2.0 Amendment 1 – Multi-prime RSA, 2000.</li>

      <li>A. K. Lenstra and E. R. Verheul. The XTR public key system. In Advances in Cryptology – Crypto’2000, volume 1880 of Lecture Notes in Computer Science, pages 1–19, Santa Barbara, USA, 2000. Springer-Verlag.</li>

      <li>Arjen K. Lenstra and Eric R. Verheul. Selecting cryptographic key sizes. Journal of Cryptology, 14(4):255–293, 2001.</li>

      <li>A. Menezes, T. Okamoto, and S. Vanstone. Reducing elliptic curve logarithms to logarithms in a finite field. IEEE Transactions on Information Theory, 39:1639–1646, 1993.</li>

      <li>A. Miyaji, M. Nakabayashi, and S. Takano. New explicit conditions of elliptic curve traces for FR-reduction. IEICE Transactions on Fundamentals, E84-A(5):1234–1243, 2001.</li>

    </ol>

    <p class="text-gray-300">24] Y. Nogami and Y. Morikawa. A fast implementation of elliptic curve cryptosystem with prime order defined over <span class="math">f_{p^{8}}</span>, 1998. http://www.trans.cne.okayama-u.ac.jp/nogami-group/papers/kiyou(2).pdf.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[25] J. M. Pollard. Monte carlo methods for index computation (mod p). Mathematics of Computation, 32:918–924, 1978.</li>

      <li>[26] K. Rubin and A. Silverberg. Supersingular abelian varieties in cryptology. In Advances in Cryptology – Crypto 2002, volume 2442 of Lecture Notes in Computer Science, pages 336–353. Springer-Verlag, 2002.</li>

      <li>[27] M. Scott, 2002. ftp://ftp.computing.dcu.ie/pub/crypto/cm.exe.</li>

      <li>[28] M. Scott. Computing the Tate pairing. In CT-RSA, volume 3376 of Lecture Notes in Computer Science, pages 293–304. Springer-Verlag, 2005.</li>

      <li>[29] M. Scott. Faster pairings using an elliptic curve with an efficient endomorphism. In Progress in Cryptology – Indocrypt 2005, volume 3797 of Lecture Notes in Computer Science, pages 258–269. Springer-Verlag, 2005. Also available from http://eprint.iacr.org/2005/252.</li>

      <li>[30] M. Scott and P. Barreto. Compressed pairings. In Advances in Cryptology – Crypto’ 2004, volume 3152 of Lecture Notes in Computer Science, pages 140–156. Springer-Verlag, 2004. Also available from http://eprint.iacr.org/2004/032/.</li>

      <li>[31] M. Scott and P. Barreto. Generating more MNT elliptic curves. Cryptology ePrint Archive, Report 2004/058, 2004. Available from http://eprint.iacr.org/2004/058/.</li>

      <li>[32] P. J. Smith and M. J. Lennon. LUC : A new public key system. In Proceedings of the Ninth IFIP International Symposium on Computer Security ’93, pages 97–111. Elsevier Science Publications, 1994.</li>

    </ul>`;
---

<BaseLayout title="Scaling security in pairing-based protocols (2005/139)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2005 &middot; eprint 2005/139
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
