---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2015/1165';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-19';
const TITLE_HTML = 'Meet-in-the-Middle Attacks on Reduced-Round  Midori-64';
const AUTHORS_HTML = 'Li Lin, Wenling Wu';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Midori is a lightweight block cipher designed by Banik et al. at ASIACRYPT 2015. One version of Midori uses a 64-bit state, another uses a 128-bit state and we denote these versions Midori-64 and Midori-128. Each of these versions uses a 128-bit key. In this paper, we focus on the key-recovery attacks on reduced-round Midori-64 with meet-in-the-middle method. We use the differential enumeration technique and key-dependent sieve technique which are popular to analyze AES to attack Midori-64. We propose a 6-round distinguisher, and achieve a 10-round attack with time complexity of 2^{99.5} 10-round Midori-64 encryptions, data complexity of 2^{61.5} chosen-plaintexts and memory complexity of 2^{92.7} 64-bit blocks. After that, by adding one round at the end, we get an 11-round attack  with time complexity of 2^{122} 11-round Midori-64 encryptions, data complexity of 2^{53} chosen-plaintexts and memory complexity of 2^{89.2} 64-bit blocks. Finally, with a 7-round distinguisher, we get an attack on 12-round Midori-64 with time complexity of 2^{125.5} 12-round Midori-64 encryptions, data complexity of 2^{55.5} chosen-plaintexts and memory complexity of 2^{106} 64-bit blocks. To the best of our knowledge, this  is recently the best attack on Midori-64.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Block Cipher &middot; Meet-in-the-Middle Attack &middot; Midori-64</p>
    </section>

    <p class="text-gray-300">In the past few years, lightweight cryptography has become a popular research discipline with a number of ciphers and hash functions proposed. The goals of these ciphers range from minimizing the hardware area <a href="#page-15-0">[2,</a><a href="#page-16-0">17,</a><a href="#page-16-1">16]</a> to low latency<a href="#page-15-1">[3]</a>. However, the optimization goal of low energy for block cipher design has not attached much attention. At ASIACRYPT 2015, Banik et al. present a new lightweight block cipher Midori that is optimized with respect to the energy consumed by the circuit per bit in encryption or decryption operation <a href="#page-15-2">[1]</a>. Midori is based on the Substitution-Permutation Network (SPN). One version of Midori uses a 64-bit state, another uses a 128-bit state and we denote these versions Midori-64 and Midori-128. Each of these versions uses a 128-bit key.</p>

    <p class="text-gray-300">Meet-in-the-middle attack is first proposed by Diffie and Hellman to attack DES <a href="#page-15-3">[9]</a>. In recent years, it is widely researched due to its effectiveness against block cipher AES <a href="#page-15-4">[4]</a>. For AES, Gilbert and Minier show in <a href="#page-15-5">[11]</a> some collision attacks on 7-round AES. At FSE 2008, Demirci and Sel&cedil;cuk improve the Gilbert and Minier attacks using meet-in-the-middle technique instead of collision idea. More specifically, they show that the value of each byte of 4-round AES ciphertext can be described by a function of the &delta;-set, i.e. a set of 256 plaintexts where a byte (called active byte) can take all values and the other 15 bytes are constant, parameterized by 25 <a href="#page-15-6">[6]</a> and 24 <a href="#page-15-7">[7]</a> 8-bit parameters. The last improvement is due to storing differences instead of values. This function is used to build a distinguisher in the offline phase, i.e. they build a lookup table containing all the possible sequences constructed from a &delta;-set. In the online phase, they identify a &delta;-set, and then partially decrypt the &delta;-set through some rounds and check whether it belongs to the table. At ASIACRYPT 2010, Dunkelman, Keller and Shamir develop many new ideas to solve the memory problems of the Demirci and Sel&cedil;cuk attacks <a href="#page-15-8">[10]</a>. First of all, they only store multiset, i.e. an unordered sequence with multiplicity, rather than the ordered sequence. The second and main idea is the differential enumeration technique which uses a special property on a truncated differential trail to reduce the number of parameters that describes the set of functions from 24 to 16. Furthermore, Derbez, Fouque and Jean present a significant improvement to the Dunkelman et al.'s differential enumeration technique at EUROCRYPT 2013 <a href="#page-15-9">[8]</a>, called efficient tabulation. Using this rebound-like idea, they show that many values in the precomputation table are not reached at all under the constraint of a special truncated differential trail. Actually, the size of the precomputation table is determined by 10 byte-parameters only. At FSE 2014, Li et al. introduce the key-dependent sieve technique, which filters the wrong states based on the key relations, to further reduce the complexity in the precomputaion phase <a href="#page-15-10">[13]</a>. Then they give an attack on 9-round AES-192. In <a href="#page-16-2">[14]</a>, Li et al. give an attack on 10-round AES-256 with differential enumeration technique and key-dependent sieve technique.</p>

    <p class="text-gray-300">Our contributions. In this paper, we carefully study and apply the variants of Derbez et al. attack on Midori-64. With the differential enumeration technique and key-dependent sieve technique, we present a 6-round distinguisher on Midori-64. Based on this distinguisher, we add 1 round at the beginning and 3 rounds at the end to present a 10-round meet-in-the-middle attack on Midori-64. The time complexity of this attack is 299.<sup>5</sup> 10-round Midori-64 encryptions, the data complexity is 261.<sup>5</sup> chosen-plaintexts and the memory complexity is 292.<sup>7</sup> 64-bit blocks. After that, by adding one round at the end, we get an 11-round attack with time complexity of 2<sup>122</sup> 11-round Midori-64 encryptions, data complexity of 2<sup>53</sup> chosen-plaintexts and memory complexity of 2<sup>89</sup>.<sup>2</sup> 64-bit blocks. To the best of our knowledge, this is recently the best attack on Midori-64. Finally, with a 7-round distinguisher, we get an attack on 12-round Midori-64 with time complexity of 2<sup>125</sup>.<sup>5</sup> 12-round Midori-64 encryptions, data complexity of 2<sup>55</sup>.<sup>5</sup> chosen-plaintexts and memory complexity of 2<sup>106</sup> 64-bit blocks.</p>

    <p class="text-gray-300">Organizations of this paper. The rest of this paper is organized as follows. In section <a href="#page-2-0">2,</a> we provide a brief description of Midori-64, some definitions and properties, a brief recall of the previous meet-in-the-middle distinguisher and the attack scheme. In section <a href="#page-6-0">3,</a> we give our attack on 10-round Midori-64. In section 4, we give our attack on 11-round Midori-64. In section 5, we give our attack on 12-round Midori-64. In section 6, we conclude this paper.</p>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">In this section we give a short description of Midori-64 and gives some definitions and propositions used throughout this paper. Then we briefly recall the previous meet-in-the-middle distinguisher. Finally, the attack scheme is given.</p>

    <p class="text-gray-300">Midori is a lightweight block cipher designed by Banik et al. at ASIACRYPT 2015 [1] and is based on the Substitution-Permutation Network (SPN). One version of Midori uses a 64-bit state, another uses a 128-bit state and we denote these versions Midori-64 and Midori-128. Each of these versions uses a 128-bit key. In this paper, we focus on the 64-bit version of Midori, so we describe it here. The Midori-64 block cipher operates on 64-bit state, and uses the following  <span class="math">4\\times 4</span>  array called state as a data expression:</p>

    <p class="text-gray-300"><span class="math">$S = \\begin{pmatrix} s_0 \\ s_4 \\ s_8 \\ s_{12} \\\\ s_1 \\ s_5 \\ s_9 \\ s_{13} \\\\ s_2 \\ s_6 \\ s_{10} \\ s_{14} \\\\ s_3 \\ s_7 \\ s_{11} \\ s_{15} \\end{pmatrix}</span>$</p>

    <p class="text-gray-300">where the size of each cell is 4 bits.</p>

    <p class="text-gray-300">A Midori-64 round applies the following four operations to the state matrix:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>SubCell:</strong> Apply the non-linear  <span class="math">4 \\times 4</span>  S-box in parallel on each nibble of the state.</li>
      <li><strong>ShuffleCell:</strong> Each nibble of the state is preformed as follows:  <span class="math">(s_0, s_1, \\dots, s_{15}) \\leftarrow (s_0, s_{10}, s_5, s_{15}, s_4, s_{11}, s_1, s_9, s_3, s_{12}, s_6, s_7, s_{13}, s_2, s_8).</span></li>
      <li>MixColumn: Midori-64 utilizes an involutive binary matrix M defined as follows:</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mathbf{M} = \\begin{pmatrix} 0 &amp; 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 0 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 0 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 &amp; 0 \\end{pmatrix}</span>$</p>

    <p class="text-gray-300"><strong>M</strong> is applied to every 4-nibble column of the state S, i.e.  <span class="math">{}^{t}(s_{i}, s_{i+1}, s_{i+2}, s_{i+3}) \\leftarrow \\mathbf{M} \\cdot {}^{t}(s_{i}, s_{i+1}, s_{i+2}, s_{i+3})</span>  and i = 0, 4, 8, 12.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>KeyAdd:</strong> The  <span class="math">i^{th}</span>  64-bit round key  <span class="math">rk_i</span>  is xored to a state S.</li>
    </ul>

    <p class="text-gray-300">Before the first round, an additional KeyAdd operation is applied, and in the last round the ShuffleCell and MixColumn operations are omitted. The total round number of Midori-64 is 16.</p>

    <p class="text-gray-300">The key-schedule of Midori-64 is quite simple. A 128-bit secret key K is denoted as two 64-bit keys  <span class="math">k_0</span>  and  <span class="math">k_1</span>  as  <span class="math">K = k_0 || k_1</span> . Suppose we focus on</p>

    <p class="text-gray-300">Midori-64 reduced to R-round, the whiten key and the last sub-key are  <span class="math">rk_{-1} = rk_{R-1} = k_0 \\oplus k_1</span> , and the sub-key for round i is  <span class="math">rk_i = k_{(i \\mod 2)} \\oplus \\alpha_i</span> , where  <span class="math">0 \\le i \\le R - 2</span>  and  <span class="math">\\alpha_i</span>  is a constant.</p>

    <p class="text-gray-300">In this paper, the plaintext is denoted by P, the ciphertext is denoted by C. Let  <span class="math">x_i, y_i, z_i</span>  and  <span class="math">w_i</span>  denote the intermediate states before SubCell, ShuffleCell, MixColumn and KeyAdd operations of round i.  <span class="math">x_i[j]</span>  denotes the  <span class="math">j^{th}</span>  nibble of round i.  <span class="math">x_i^k[j]</span>  denotes the  <span class="math">k^{th}</span>  element of a set of some  <span class="math">x_i[j]</span> .  <span class="math">\\Delta x_i^k[j]</span>  denotes the difference of the  <span class="math">k^{th}</span>  element and  <span class="math">0^{th}</span>  element of a set, i.e.  <span class="math">\\Delta x_i^k[j] = x_i^k[j] \\oplus x_i^0[j]</span> .</p>

    <p class="text-gray-300">In some cases, we are interested in interchanging the order of the MixColumn and KeyAdd operations. As these operations are linear, they can be interchanged by first xoring the data with an equivalent key  <span class="math">ru_i = MixColumn^{-1}(rk_i)</span>  and then applying the MixColumn operation. And we denote the intermediate state after xoring with  <span class="math">u_i</span>  by  <span class="math">\\overline{w_i}</span> . We also denote  <span class="math">u_i = MixColumn^{-1}(k_i)</span> , where i = 0, 1.</p>

    <p class="text-gray-300">In [4], Daemen et al. first proposed the definition of  <span class="math">\\delta</span> -set of byte. After that,  <span class="math">\\delta</span> -set was used in the meet-in-the-middle attacks on AES and other ciphers. In [12], Li et al. extended the definition of  <span class="math">\\delta</span> -set to T active cells, and got T- <span class="math">\\delta</span> -set. In this paper, we use 2- <span class="math">\\delta</span> -set which defines as follows.</p>

    <p class="text-gray-300"><strong>Definition 1 (2-\\delta-set).</strong> Let a 2- <span class="math">\\delta</span> -set be a set of  <span class="math">2^{2\\times 4}</span>  states that are all different in two state nibbles (active nibbles) and all equal in the other state nibbles (inactive nibbles).</p>

    <p class="text-gray-300">In [5], Daemen et al. gave the definition of super S-box for AES. For Midori, we can give a similar definition as follows.</p>

    <p class="text-gray-300"><strong>Definition 2 (Super S-box).</strong> For each value of one column of  <span class="math">rk_3</span> , a Midori Super S-box maps one column of  <span class="math">z_3</span>  to one column of  <span class="math">y_4</span>  as shown in Fig. 1. It consists of one SubCell operation, one MixColumn operation, one KeyAdd operation and one SubCell operation.</p>

    <p class="text-gray-300">    <img src="_page_3_Picture_9.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 1. Super S-box for Midori-64.</p>

    <p class="text-gray-300">For one S-box, we have the following proposition.</p>

    <p class="text-gray-300">Proposition 1 (Differential Property of S-box, <a href="#page-15-9">[8]</a>). Given &#8710;<sup>i</sup> and &#8710;<sup>0</sup> two non-zero differences, the equation of S-box</p>

    <p class="text-gray-300">
<span class="math">$S(x) \\oplus S(x \\oplus \\Delta_i) = \\Delta_0, \\tag{1}</span>$</p>

    <p class="text-gray-300">has one solution in average.</p>

    <p class="text-gray-300">This proposition also applies to super S-box.</p>

    <p class="text-gray-300">Proposition 2 (Differential Property of Super S-box). Given &#8710;<sup>i</sup> and &#8710;<sup>0</sup> two non-zero differences in F<sup>2</sup> <sup>16</sup> , the equation of super S-box</p>

    <p class="text-gray-300">
<span class="math">$Super - S(x) \\oplus Super - S(x \\oplus \\Delta_i) = \\Delta_0, \\tag{2}</span>$</p>

    <p class="text-gray-300">has one solution in average for each key value.</p>

    <p class="text-gray-300">For ru<sup>i</sup> , we have the following proposition.</p>

    <p class="text-gray-300">Proposition 3. As shown in Fig. <a href="#page-3-0">1,</a> if the first column of z<sup>3</sup> is active only in the last 3 nibbles, Proposition <a href="#page-4-0">2</a> holds for each equivalent sub-key ru3[1, 2, 3].</p>

    <p class="text-gray-300">Proof. We use the equivalent sub-key in this proof. For each y4[0, 1, 2, 3] and ru3[1, 2, 3], since &#8710;y4[0, 1, 2, 3] is known, one can get w3[0, 1, 2, 3] and &#8710;w3[0, 1, 2, 3]. With the probability of 2<sup>&minus;</sup><sup>4</sup> , y3[0, 1, 2, 3] is active only in the last 3 nibbles. By adding ru3[1, 2, 3], one can get &#8710;z3[1, 2, 3].</p>

    <p class="text-gray-300">Therefore, for each &#8710;<sup>i</sup> and &#8710;0, the average number of input values of Super S-box is 216&minus;12&minus;<sup>4</sup> = 1 for each equivalent sub-key.</p>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 Reviews of Former Works</h3>

    <p class="text-gray-300">In this section, we review the previously meet-in-the-middle distinguishers on AES in <a href="#page-15-6">[6</a><a href="#page-15-8">,10,</a><a href="#page-15-9">8]</a>.</p>

    <p class="text-gray-300">Demirci and Sel&cedil;cuk distinguisher. Consider the set of functions</p>

    <p class="text-gray-300"><span class="math">$f: \\{0,1\\}^8 \\longrightarrow \\{0,1\\}^8</span>$</p>

    <p class="text-gray-300">that maps a byte of a &delta;-set to another byte of the state after four AES rounds. A convenient way is to view f as an ordered byte sequence (f(0), . . . , f(255)) so that it can be represented by 256 bytes. The crucial observation made by the generalizing Gilbert and Minier attacks <a href="#page-15-5">[11]</a> is that this set is tiny since it can be described by 25 byte-parameters (2<sup>25</sup>&middot;<sup>8</sup> = 2<sup>200</sup>) compared with the set of all functions of this type which counts as may as 2<sup>8</sup>&middot;<sup>2</sup> 8 = 2<sup>2048</sup> elements <a href="#page-15-6">[6]</a>. Considering the differences (f(0) &minus; f(0), f(1) &minus; f(0), . . . , f(255) &minus; f(0)) rather than values, the set of functions can be described by 24 parameters <a href="#page-15-7">[7]</a>. The 24 byte-parameters which map x1[0] to &#8710;x5[0] are presented as gray cells in Fig. <a href="#page-5-0">2.</a></p>

    <p class="text-gray-300">Dunkelman et al. distinguisher and Derbez et al. distinguisher. In <a href="#page-15-8">[10]</a>, Dunkelman et al. introduced two new improvements to further reduce the memory complexity of <a href="#page-15-7">[7]</a>. The first uses multiset which is an unordered sequence with multiplicity to replace ordered sequence in the offline phase, since there is enough information so that the attack succeeds. The second improvement uses</p>

    <p class="text-gray-300">    <img src="_page_5_Picture_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 2. The 4-round AES distinguisher used in <a href="#page-15-7">[7]</a>. The gray cells represent 24 byteparameters, &delta; represents the &delta;-set and m represents the differential sequence to be stored.</p>

    <p class="text-gray-300">a novel idea named differential enumeration technique. The main idea of this technique is to use a special 4-round property on a truncated differential trail to reduce the number of parameters which describes the set of functions from 24 to 16.</p>

    <p class="text-gray-300">In <a href="#page-15-9">[8]</a>, Derbez et al. used the efficient tabulation to improve Dunkelman et al.'s differential enumeration technique. Combining with the rebound-like idea, many values in the precomputation table are not reached at all under the constraint of a truncated differential trail.</p>

    <p class="text-gray-300">Proposition 4 (Efficient Tabulation , <a href="#page-15-9">[8]</a>). If a message of &delta;-set belongs to a pair conforming to the 4-round truncated differential trail outlined in Fig. <a href="#page-5-1">3,</a> the values of multiset are only determined by 10 byte-parameters of intermediate state &#8710;z1[0]||x2[0, 1,</p>

    <p class="text-gray-300">2, 3]||&#8710;x5[0]||z4[0, 1, 2, 3] presented as gray cells in this figure.</p>

    <p class="text-gray-300">    <img src="_page_5_Figure_7.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 3. The truncated differential trail of 4-round AES used in <a href="#page-15-6">[6]</a>, the gray cells represent 10 byte-parameters, &#8710; represents difference.</p>

    <p class="text-gray-300">The main idea of their works is that suppose one get a pair of messages conforming to this truncated differential trail, the differences &#8710;x<sup>3</sup> and &#8710;y<sup>3</sup> can be determined by these 10 byte-parameters. By Proposition <a href="#page-3-1">1,</a> part of the 24 byteparameters in the Demirci and Sel&cedil;cuk distinguisher, i.e. x3, can be determined.</p>

      <h3 id="sec-2.4" class="text-xl font-semibold mt-8">2.4 Attack Scheme</h3>

    <p class="text-gray-300">In this section, we present a unified view of the meet-in-the-middle attack, where R rounds of block cipher can be split into three consecutive parts: r1, r, and r2, such that a particular set of messages may verify a certain property that we denote ? in the sequel in the middle r rounds as shown in Fig. <a href="#page-6-1">4.</a></p>

    <p class="text-gray-300">The general attack scheme uses two successive phases:</p>

    <h3 id="sec-misc-1" class="text-xl font-semibold mt-8">Precomputation phase</h3>

    <p class="text-gray-300">    <img src="_page_6_Picture_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Fig. 4.</strong> General scheme of meet-in-the-middle attack, where some messages in the middle rounds may verify a certain  <span class="math">\\star</span>  property used to perform the meet-in-the-middle method.</p>

    <p class="text-gray-300">1. In the precomputation phase, we build a lookup table T containing all the possible sequences constructed from a 2- <span class="math">\\delta</span> -set such that one message verifies a truncated differential trail.</p>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6">Online phase</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In the online phase, we need to identify a  <span class="math">2-\\delta</span> -set containing a message m verifying the desired property. This is done by using a large number of plaintexts and ciphertexts, and expecting that for each key candidate, there is one pair of plaintexts satisfying the truncated differential trail.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Finally, we partially decrypt the associated 2- <span class="math">\\delta</span> -set through the last  <span class="math">r_2</span>  rounds and check whether it belongs to T.</li>
    </ol></li>
    </ul>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Meet-in-the-Middle Attack on 10-Round Midori-64</h2>

    <p class="text-gray-300">In this section, we first propose a 6-round meet-in-the-middle distinguisher with differential enumeration technique and key-dependent sieve technique on Midori-64. Then, we apply this distinguisher to 10-round Midori-64 by adding 1 round at the beginning and 3 rounds at the end.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 6-Round Distinguisher on Midori-64</h3>

    <p class="text-gray-300">Since  <span class="math">w_6[9] = z_6[8] \\oplus z_6[10] \\oplus z_6[11]</span>  and  <span class="math">w_6[10] = z_6[8] \\oplus z_6[9] \\oplus z_6[11]</span> , we have  <span class="math">w_6[9] \\oplus w_6[10] = z_6[9] \\oplus z_6[10]</span> . Let  <span class="math">e_{in} = z_6[9] \\oplus z_6[10]</span>  and  <span class="math">e_{out} = x_7[9] \\oplus x_7[10]</span> , then  <span class="math">e_{out} = e_{in} \\oplus rk_6[9] \\oplus rk_6[10]</span> , the 6-round distinguisher on Midori-64 is based on the proposition below.</p>

    <p class="text-gray-300"><strong>Proposition 5.</strong> Let  <span class="math">\\{w_0^0, w_0^1, \\dots, w_0^{255}\\}</span>  be a 2- <span class="math">\\delta</span> -set where  <span class="math">w_0[5]</span>  and  <span class="math">w_0[10]</span>  are the active nibbles. Consider the encryption of the first 33 values  <span class="math">(w_0^0, w_0^1, \\dots, w_0^{33})</span>  of the 2- <span class="math">\\delta</span> -set through  <span class="math">\\delta</span> -round Midori- <span class="math">\\delta 4</span> , in the case of that a message of the 2- <span class="math">\\delta</span> -set belongs to a pair which conforms to the truncated differential trail outlined in Fig. 5, then the corresponding 128-bit ordered sequence  <span class="math">(e_{out}^1 \\oplus e_{out}^0, e_{out}^2 \\oplus e_{out}^0, \\dots, e_{out}^{32} \\oplus e_{out}^0)</span>  only takes about  <span class="math">2^{104}</span>  values (out of the  <span class="math">2^{128}</span>  theoretically values).</p>

    <p class="text-gray-300"><em>Proof.</em> As shown in Fig. 5, for the encryption of the first 33 values of the 2- <span class="math">\\delta</span> -set, the output sequence  <span class="math">(e^1_{out} \\oplus e^0_{out}, e^2_{out} \\oplus e^0_{out}, \\cdots, e^{32}_{out} \\oplus e^0_{out})</span>  is determined by</p>

    <p class="text-gray-300">the 42 nibble-parameters:</p>

    <p class="text-gray-300">
<span class="math">$w_0[5,10]||x_1[5,10]||x_2[0,1,2,3]||x_3[1,2,3,4,5,6,8,10,11,12,13,15]|| (3)</span>$</p>

    <p class="text-gray-300"><span class="math">$x_4[0,1,2,3,5,6,7,8,9,10,11,12,14,15]||rk_4[0,2,5,8,10,13]||rk_5[3,12]</span>$</p>

    <p class="text-gray-300">At round 1, since  <span class="math">\\Delta x_1^m[5,10] = \\Delta w_0^m[5,10]</span>  (0 &lt;  <span class="math">m \\le 33</span> ), we can get  <span class="math">z_1[1,2]</span>  by the knowledge of  <span class="math">x_1[5,10]</span> . Since the ShuffleCell, MixColumn and KeyAdd operations are linear,  <span class="math">\\Delta x_2^m[0,1,2,3]</span>  can be got. Similarly,  <span class="math">\\Delta y_2^m[0,1,2,3]</span>  can be got by the knowledge of  <span class="math">x_2[0,1,2,3]</span> ,  <span class="math">\\Delta y_3^m[1,2,3,4,5,6,8,10,11,12,13,15]</span>  can be got by the knowledge of  <span class="math">x_3[1,2,3,4,5,6,8,10,11,12,13,15]</span> ,  <span class="math">\\Delta y_4^m[0,1,2,3,5,6,7,8,9,10,11,12,14,15]</span>  can be got by the knowledge of  <span class="math">x_4[0,1,2,3,5,6,7,8,9,10,11,12,14,15]</span> ,  <span class="math">\\Delta y_5^m[0,2,5,8,10,13]</span>  can be got by the knowledge of  <span class="math">x_4[0,1,2,3,5,6,7,8,9,10,11,12,14,15]</span> ,  <span class="math">\\Delta y_5^m[0,2,5,8,10,13]</span>  can be got by the knowledge of  <span class="math">x_4[0,2,5,8,10,13]</span> , and  <span class="math">\\Delta z_6^m[9,10]</span>  can be got by the knowledge of  <span class="math">x_5[3,12]</span> . Then we get the value of  <span class="math">e_{out}^m \\oplus e_{out}^0</span> . Since  <span class="math">e_{out}^m \\oplus e_{out}^0 \\oplus e_{out}^0</span> , we can get  <span class="math">(e_{out}^1 \\oplus e_{out}^1, e_{out}^2 \\oplus e_{out}^1)</span> .</p>

    <p class="text-gray-300">However, if a pair of messages conforms to the truncated differential trail outlined in Fig. 5, the above 42 nibble-parameters are determined by the 27 nibble-parameters:</p>

    <p class="text-gray-300">
<span class="math">$\\Delta z_1[1,2]||x_2[0,1,2,3]||x_3[1,2,3,4,5,6,8,10,11,12,13,15]|| y_5[0,2,5,8,10,13]||y_6[3,12]||\\Delta z_6[9]</span>$
(4)</p>

    <p class="text-gray-300">Since  <span class="math">\\Delta z_1[1,2]</span>  is known, we can get  <span class="math">\\Delta x_2[0,1,2,3]</span> . Since  <span class="math">\\Delta y_2[0,1,2,3]</span>  can be got by the knowledge of  <span class="math">x_2[0, 1, 2, 3]</span> , we can get  <span class="math">\\Delta x_3[1, 2, 3, 4, 5, 6, 8, 10, 11, 12, 13, 13]</span> 15], and  <span class="math">\\Delta x_4</span> [0, 1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15] can be got by the knowledge of  <span class="math">x_3[1,2,3,4,5,6,8,10,11,12,13,15]</span> . For the backward direction, since  <span class="math">\\Delta w_6[8] =</span>  <span class="math">\\Delta z_6[9] \\oplus \\Delta z_6[10] \\oplus \\Delta z_6[11]</span> ,  <span class="math">\\Delta z_6[11] = 0</span>  and  <span class="math">\\Delta w_6[8] = 0</span> , we can get that  <span class="math">\\Delta z_6[9] = 0</span>  <span class="math">\\Delta z_6[10]</span> . For the same reason as the forward direction,  <span class="math">\\Delta y_4[0,1,2,3,5,6,7,8,9,10,</span> 11, 12, 14, 15] can be got by the knowledge of  <span class="math">y_5[0, 2, 5, 8, 10, 13] ||y_6[3, 12]|| \\Delta z_6[9]</span> . According to Property 1, we get one value of intermediate state  <span class="math">x_4[0, 1, 2, 3, 5, 6, 7,</span> 8, 9, 10, 11, 12, 14, 15] on average for the fixed difference  <span class="math">\\Delta x_4[0, 1, 2, 3, 5, 6, 7, 8, 9,</span> 10, 11, 12, 14, 15  <span class="math">||\\Delta y_4[0, 1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15]</span> . Apparently,  <span class="math">ru_2[0, 7, 9, 10, 11, 12, 14, 15]</span>  <span class="math">9, 14|||rk_4|0, 2, 5, 8, 10, 13|||rk_5|3, 12|</span>  is also deduced for every 27 nibble-parameters. Since  <span class="math">z_3[13, 14, 15]</span>  is known,  <span class="math">w_3[12]</span>  can be got. Then  <span class="math">rk_3[12]</span>  can be deduced for the reason that  <span class="math">rk_3[12] = x_4[12] \\oplus w_3[12]</span> . According to the key-schedule of Midori-64,  <span class="math">rk_3[12]</span>  and  <span class="math">rk_5[12]</span>  are affected by the same nibble of  <span class="math">k_1</span> . By the key-dependent sieve technique, there are  <span class="math">2^{104}</span>  possible values for the 27 nibbleparameters.</p>

    <p class="text-gray-300">Since  <span class="math">z_3[1,2,3]</span>  and  <span class="math">x_4[0,1,2,3]</span>  are known,  <span class="math">ru_3[1,2,3]</span>  can be got. According to the key-schedule,  <span class="math">rk_3[3]</span>  can be got by the knowledge of  <span class="math">rk_5[3]</span> . Since  <span class="math">rk_3[3] = ru_3[0] \\oplus ru_3[1] \\oplus ru_3[2]</span> ,  <span class="math">ru_3[0]</span>  can be got. Then  <span class="math">rk_3[0,1,2,3]</span>  can be got. After that, we can deduce  <span class="math">rk_1[0,1,2,3]</span> . We can also deduce  <span class="math">rk_0[5,10]</span>  from  <span class="math">rk_4[5,10]</span> . Therefore, we can get  <span class="math">w_0[5,10]</span>  and  <span class="math">x_1[5,10]</span>  from  <span class="math">x_2[0,1,2,3]</span> .</p>

    <p class="text-gray-300">So the 42 nibble-parameters (3) are determined by 27 nibble-parameters (4), i.e. the sequence  <span class="math">(e^1_{out} \\oplus e^0_{out}, e^2_{out} \\oplus e^0_{out}, \\cdots, e^{32}_{out} \\oplus e^0_{out})</span>  can take about  <span class="math">2^{104}</span>  values.</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Attack on 10-Round Midori-64</h3>

    <p class="text-gray-300">The attack is made up of two phase: precomputation phase and online phase. <strong>Precomputation phase:</strong> In the precomputation phase, we need to build a table that contains all the sequence  <span class="math">(e^1_{out} \\oplus e^0_{out}, e^2_{out} \\oplus e^0_{out}, \\cdots, e^{32}_{out} \\oplus e^0_{out})</span>  described in Propostion 6.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">1. Guess  <span class="math">y_6[12]||y_5[2,8,13]</span> , and compute  <span class="math">x_6[12]</span>  and  <span class="math">w_5[12]</span> . Deduce  <span class="math">rk_5[12]</span>  from  <span class="math">x_6[12]||w_5[12]</span> . Store  <span class="math">y_5[2,8,13]</span>  in a table  <span class="math">T_1</span>  with the index of  <span class="math">rk_5[12]||y_6[12]</span> . There are about  <span class="math">2^8</span>  values of  <span class="math">y_5[2,8,13]</span>  for each index.</p></li>
      <li><p class="text-gray-300">2. For each 48-bit  <span class="math">ru_3[1, 2, 3, 5, 6, 7, 9, 10, 11, 13, 14, 15]</span> , do the following steps.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Guess  <span class="math">\\Delta z_6[9]</span> . Since  <span class="math">\\Delta w_6[8] = \\Delta z_6[11] = 0</span> , we can deduce  <span class="math">\\Delta z_6[10]</span> . Deduce  <span class="math">rk_5[12]</span>  from  <span class="math">ru_3[13,14,15]</span> . Guess  <span class="math">y_6[3,12]||y_5[0,5,10]</span> , look up the table  <span class="math">T_1</span>  to get about  <span class="math">2^8</span>  values of  <span class="math">y_5[2,8,13]</span>  by the index of  <span class="math">rk_5[12]||y_6[12]</span> . Then compute  <span class="math">x_5[0,2,5,8,10,13]||\\Delta x_5[0,2,5,8,10,13]</span> . Deduce  <span class="math">rk_5[3]</span>  from  <span class="math">y_6[3]</span>  and  <span class="math">y_5[0,5,10]</span> , then deduce  <span class="math">rk_1[0,1,2,3]</span>  from  <span class="math">rk_5[3]</span>  and  <span class="math">ru_3[1,2,3]</span> . Store  <span class="math">rk_1[0,1,2,3]||x_5[0,2,5,8,10,13]</span>  in a table  <span class="math">T_2</span>  with the index of  <span class="math">\\Delta x_5[0,2,5,8,10,13]</span> . There are about  <span class="math">2^8</span>  values for each index.</li>
      <li>(b) For all  <span class="math">2^{40}</span>  values of  <span class="math">\\Delta y_2[0,1,2,3]</span>  and  <span class="math">\\Delta x_5[0,2,5,8,10,13]</span> , deduce  <span class="math">\\Delta x_3</span>  and  <span class="math">\\Delta y_4</span> . According to Proposition 3, we can get  <span class="math">x_3[1,2,3,4,5,6,8,10,11,12,13,15]</span>  and  <span class="math">y_4[0,1,2,3,5,6,7,8,9,10,11,12,14,15]</span> . Then compute  <span class="math">w_4[0,2,5,8,10,13]</span> , and store  <span class="math">x_3[1,2,3,4,5,6,8,10,11,12,13,15]||x_4[0,1,2,3,5,6,7,8,9,10,11,12,14,15]||w_4[0,2,5,8,10,13]||\\Delta x_5[0,2,5,8,10,13]</span>  in a table  <span class="math">T_3</span>  with the index of  <span class="math">\\Delta y_2[0,1,2,3]</span> . There are about  <span class="math">2^{24}</span>  values for each index.</li>
      <li>(c) For each  <span class="math">\\Delta z_1[1,2]||x_2[0,1,2,3]|</span> , do the following sub-steps:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>i. Compute  <span class="math">\\Delta y_2[0,1,2,3]</span>  from  <span class="math">\\Delta z_1[1,2]</span>  and  <span class="math">x_2[0,1,2,3]</span> . Then look up the table  <span class="math">T_3</span>  to get about  <span class="math">2^{24}</span>  values  <span class="math">x_3[1,2,3,4,5,6,8,10,11,12,13,15]||</span>   <span class="math">x_4[0,1,2,3,5,6,7,8,9,10,11,12,14,15]||w_4[0,2,5,8,10,13]||\\Delta x_5[0,2,5,8,10,13].</span>  For each of these values, look up the table  <span class="math">T_2</span>  to get about  <span class="math">2^8</span>  values  <span class="math">rk_1[0,1,2,3]||x_5[0,2,5,8,10,13].</span>  Deduce  <span class="math">rk_4[0,2,5,8,10,13]</span>  from  <span class="math">x_5[0,2,5,8,10,13]</span>  and  <span class="math">w_4[0,2,5,8,10,13]</span> , then deduce  <span class="math">rk_0[5,10]</span>  from  <span class="math">rk_4[5,10]</span> . Compute  <span class="math">x_1[5,10]</span>  from  <span class="math">rk_1[0,1,2,3]</span>  and  <span class="math">x_2[0,1,2,3]</span> , then compute  <span class="math">w_0[5,10]</span>  from  <span class="math">x_1[5,10]</span>  and  <span class="math">rk_0[5,10]</span> . Therefore, we get the 42 nibble-parameters (3).</li>
      <li>ii. Compute the sequence  <span class="math">(e_{out}^1 \\oplus e_{out}^0, e_{out}^2 \\oplus e_{out}^0, \\cdots, e_{out}^{32} \\oplus e_{out}^0)</span> , and store them along with a 16-bit value  <span class="math">ru_2[0, 9, 14] || ru_3[1]</span>  in a table  <span class="math">T_4</span> .</li>
    </ul></li>
    </ul></li>
      <li><p class="text-gray-300">3. We build two tables  <span class="math">T_5^0</span>  and  <span class="math">T_5^2</span>  for online phase. As shown in Fig. 6, for column 0, guess  <span class="math">\\Delta C[0,1,2,3]||\\Delta z_8[0,1]</span> , and deduce  <span class="math">\\Delta x_9[0,1,2,3]</span>  and  <span class="math">\\Delta y_9[0,1,2,3]</span> . By Proposition 1, we can deduce  <span class="math">y_9[0,1,2,3]</span> . Guess C[1,3],  <span class="math">rk_9[1,3]</span>  can be got. One can deduce  <span class="math">rk_{-1}[1,3]</span>  from  <span class="math">rk_9[1,3]</span> , and store  <span class="math">x_9[0,1,2,3]||\\Delta z_8[0,1]</span>  in a table  <span class="math">T_5^0</span>  with the index of  <span class="math">rk_{-1}[1,3]||\\Delta C[0,1,2,3]||C[1,3]</span> . There is one value for each index in average. Similarly, we can get a table  <span class="math">T_5^2</span>  for column 2.</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We build a table  <span class="math">T_6</span>  for online phase. Guess  <span class="math">x_7[9, 10]||\\Delta x_7[9]</span> , one can deduce  <span class="math">\\Delta y_7[9, 10]</span>  and  <span class="math">y_7[9, 10]</span>  since  <span class="math">\\Delta x_7[9] = \\Delta x_7[10]</span> . Then  <span class="math">\\Delta x_8[0, 2, 3, 9, 10, 11]</span>  can be deduced. Guess  <span class="math">\\Delta y_8[0, 2, 3, 9, 10, 11]</span> , then  <span class="math">x_8[0, 2, 3, 9, 10, 11]</span>  and  <span class="math">y_8[0, 2, 3, 9, 10, 11]</span>  can be deduced by Proposition 1. Deduce  <span class="math">ru_7[1, 8]</span>  from  <span class="math">x_7[9, 10]</span>  and  <span class="math">x_8[0, 2, 3, 9, 10, 11]</span> , and deduce  <span class="math">ru_8[1, 8] \\oplus ru_9[1, 8]</span>  from  <span class="math">ru_7[1, 8]</span> . Let  <span class="math">\\chi</span>  denote  <span class="math">z_8[1, 8] \\oplus ru_8[1, 8] \\oplus ru_9[1, 8]</span> . Store  <span class="math">y_8[0, 2, 3, 9, 10, 11]||ru_7[1, 8]</span>  in a table  <span class="math">T_6</span>  with the index of  <span class="math">\\chi||\\Delta z_8[0, 1, 6, 8, 9, 14]</span> . There are  <span class="math">2^4</span>  values for each index</li>
    </ol></li>
      <li><p class="text-gray-300">5. We build another table  <span class="math">T_7</span>  for online phase. For all 36-bit sub-keys  <span class="math">ru_7[1,8]||</span>   <span class="math">ru_8[0,1,6,8,9,14]</span> , decrypt all 24-bit values  <span class="math">\\overline{w_8}[0,1,6,8,9,14]</span>  and obtain the value  <span class="math">e_{out}</span> . Store  <span class="math">e_{out}</span>  with the index of  <span class="math">ru_7[1,8]||ru_8[0,1,6,8,9,14]||\\overline{w_8}[0,1,6,8,9,14]</span>  in a table  <span class="math">T_7</span> .</p></li>
    </ul>

    <p class="text-gray-300">Online phase: In the online phase of the attack, we first find at least one pair which satisfies the truncated differential trail in Fig. 5. To find the right pair, instead of guessing the sub-keys and checking whether this pair satisfy the truncated differential trail, we deduce the sub-keys which make it satisfy the truncated differential trail for each pair. Then we identify the  <span class="math">2-\\delta</span> -set, caculate the sequence  <span class="math">(e_{out}^1 \\oplus e_{out}^0, e_{out}^2 \\oplus e_{out}^0, \\cdots, e_{out}^{32} \\oplus e_{out}^0)</span>  and check whether it belongs to the table  <span class="math">T_4</span> . Finally, we use  <span class="math">ru_2[0, 9, 14]||ru_3[1]</span>  to filter the reminding keys and retrieve the correct key.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Define a structure of  <span class="math">2^{24}</span>  plaintexts where P[1,3,6,9,11,14] take all the possible values, and the remaining 10 nibbles are fixed to some constants. Hence, we can generate  <span class="math">2^{24} \\times (2^{24} 1)/2 \\approx 2^{47}</span>  pairs satisfying the plaintext difference. Choose  <span class="math">2^{29}</span>  structures to get about  <span class="math">2^{29+47} = 2^{76}</span>  pairs. As shown in Fig. 6, the probability to get the truncated differential trail in the forward and backward direction is  <span class="math">2^{(2-6+1-16)\\times 4} = 2^{-76}</span> , then about 1 pair follows the truncated differential trail for each guess of the key. Among the  <span class="math">2^{76}</span>  pairs, we expect about  <span class="math">2^{76-8} = 2^{68}</span>  pairs to verify that  <span class="math">\\Delta C[6,14] = 0</span> .</li>
    </ol></li>
      <li><p class="text-gray-300">2. For each of the  <span class="math">2^{68}</span>  remaining pairs, we do the following sub-steps.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Guess  <span class="math">\\Delta w_0[5, 10]</span> , and deduce  <span class="math">\\Delta y_0[1, 3, 6, 9, 11, 14]</span> . According to Proposition 1,  <span class="math">x_0[1, 3, 6, 9, 11, 14]</span>  can be got from  <span class="math">\\Delta y_0[1, 3, 6, 9, 11, 14]</span>  and  <span class="math">\\Delta P[1, 3, 6, 9, 11, 14]</span> . Then  <span class="math">rk_{-1}[1, 3, 6, 9, 11, 14]</span>  can be got.</li>
      <li>(b) For each of the  <span class="math">2^8</span>  deduced sub-key in (a), encrypt the plaintext pair and get the value  <span class="math">w_0[4, 6, 7, 8, 9, 11]</span> . Change the value of  <span class="math">w_0[5, 10]</span>  to be  <span class="math">(0, 1, \\dots, 32)</span>  and compute their corresponding plaintexts  <span class="math">(P^0, P^1, \\dots, P^{32})</span> , then get the corresponding ciphertexts.</li>
      <li>(c) For each of the deduced  <span class="math">rk_{-1}[1,3,6,9,11,14]</span> , compute  <span class="math">rk_{9}[1,3]</span>  (resp.  <span class="math">rk_{9}[9,11]</span> ). Look up the table  <span class="math">T_{5}^{0}</span>  (resp.  <span class="math">T_{5}^{2}</span> ) to get about one value  <span class="math">x_{9}[0,1,2,3]||\\Delta z_{8}[0,1]</span>  (resp.  <span class="math">x_{9}[8,9,10,11]||\\Delta z_{8}[8,9]</span> ) with the index of  <span class="math">rk_{-1}[1,3]||\\Delta C[0,1,2,3]||C[1,3]</span>  (resp.  <span class="math">rk_{-1}[9,11]||\\Delta C[8,9,10,11]||C[9,11]</span> ). Deduce  <span class="math">rk_{9}[0,2]</span>  (resp.  <span class="math">rk_{9}[8,10]</span> ) from the ciphertext.</li>
      <li>(d) Guess  <span class="math">\\Delta z_8[6, 14]</span> , and deduce  <span class="math">\\Delta x_9[4, 5, 7, 12, 13, 15]</span> . Then  <span class="math">rk_9[4, 5, 7, 12, 13, 15]</span>  and  <span class="math">x_9[4, 5, 7, 12, 13, 15]</span>  can be got. Deduce  <span class="math">ru_9[1, 8]</span>  from  <span class="math">rk_9[0, 2, 3, 9, 10, 11]</span> , and deduce  <span class="math">\\overline{w_8}[1, 8]</span>  from  <span class="math">x_9[0, 2, 3, 9, 10, 11]</span> . Then we can get  <span class="math">\\chi&#x27; = ru_9[1, 8] \\oplus \\overline{w_8}[1, 8]</span> , i.e.  <span class="math">\\chi&#x27; = z_8[1, 8] \\oplus ru_8[1, 8] \\oplus ru_9[1, 8]</span> . Look up the</li>
    </ul></li>
      <li><p class="text-gray-300">table  <span class="math">T_6</span>  to get about  <span class="math">2^4</span>  values  <span class="math">y_8[0,2,3,9,10,11]||ru_7[1,8]</span>  with the index of  <span class="math">\\chi&#x27;||\\Delta z_8[0,1,6,8,9,14]</span> . Deduce  <span class="math">ru_8[0,1,6,8,9,14]</span>  from  <span class="math">y_8[0,2,3,9,10,11]</span>  and  <span class="math">x_9[0,1,2,3,4,5,7,8,9,10,11,12,13,15]</span> .</p></li>
      <li><p class="text-gray-300">(e) For about  <span class="math">2^{20}</span>  values  <span class="math">rk_{-1}[1, 3, 6, 9, 11, 14]||rk_9[0, 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 15]||ru_8[0, 1, 6, 8, 9, 14]||ru_7[1, 8]</span>  we have got, decrypt the corresponding ciphertexts we made in (b) and get  <span class="math">(e^1_{out} \\oplus e^0_{out}, e^2_{out} \\oplus e^0_{out}, \\cdots, e^{32}_{out} \\oplus e^0_{out})</span>  using  <span class="math">T_7</span> . Check whether it lies in the precomputation table  <span class="math">T_4</span> . If not, try another one. If so, we check whether  <span class="math">ru_2[0, 9, 14]||ru_3[1]</span>  matches  <span class="math">ru_8[0, 9, 14]||ru_7[1]</span> . So the probability for a wrong sub-key to pass this test is  <span class="math">2^{-24-16} = 2^{-40}</span> .</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In the end, there are about  <span class="math">2^{22\\times 4-40}=2^{44}</span>  sub-keys remaining. Then exhaustively search for the  <span class="math">2^{44}</span>  sub-keys and 10 unknown key-nibbles to recover the master key.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Complexity analysis. In the precomputation phase, in order to construct  <span class="math">T_4</span> , we need to perform  <span class="math">2^{104}</span>  partial encryptions on 33 messages. The time complexity of this phase is about  <span class="math">2^{104+5-2}=2^{107}</span>  10-round Midori-64 encryptions, the memory complexity is about  <span class="math">2^{104+7.2-6}=2^{105.2}</span>  64-bit blocks. In the online phase, we need to perform  <span class="math">2^{20+68}</span>  partial encryptions on 33 messages. The time complexity of this phase is about  <span class="math">2^{88+5-3} = 2^{90}</span>  10-round Midori-64 encryptions, the data complexity is  <span class="math">2^{24+29} = 2^{53}</span>  chosen-plaintexts and the memory complexity is 2<sup>53</sup> 64-bit blocks. With data/time/memory tradeoff, the adversary only need to precompute a fraction of  <span class="math">2^{-8.5}</span>  of possible sequences, then the time complexity becomes  <span class="math">2^{107-8.5} = 2^{98.5}</span> , the memory complexity becomes  <span class="math">2^{96.7}</span>  64-bit blocks. But in the online phase, the adversary will repeat the attack  <span class="math">2^{8.5}</span>  times to offset the probability of the failure. So the data complexity increases to  <span class="math">2^{61.5}</span> chosen-plaintexts, and the time complexity increases to  <span class="math">2^{90+8.5} = 2^{98.5}</span> . Otherwise, we can divide the whole attack into series of weak-key attacks according to the relations between the subkeys in the online phase and the precomputation phase as Li et al. presented in [13]. Using the relation of  <span class="math">ru_3[1]</span>  (step 2) in the precomputation phase) and  <span class="math">ru_7[1]</span>  (step 4 in the precomputation phase and step 2(d) in the online phase), the attack can be divided into 2<sup>4</sup> weak-key attacks. The memory complexity can be reduced by a fraction of  <span class="math">2^{-4}</span> . In total, the time complexity of this attack is 299.5 10-round Midori-64 encryptions, the data complexity is  <span class="math">2^{61.5}</span>  chosen-plaintexts and the memory complexity is  <span class="math">2^{92.7}</span> 64-bit blocks.</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Attack on 11-Round Midori-64</h2>

    <p class="text-gray-300">Based on the 10-round attack, we can add one round at the end to mount an 11-round attack on Midori-64.</p>

    <p class="text-gray-300">The precomputation is almost the same as the 10-round attack except the following steps.</p>

    <p class="text-gray-300">1. At step 3, we need to build four tables  <span class="math">T_5^i</span>   <span class="math">(i = 0, \\dots, 3)</span> . As shown in Fig. 7, for column 0, guess  <span class="math">\\Delta C[0, 1, 2, 3] ||\\Delta z_9[0, 1, 2, 3]</span> , and deduce  <span class="math">\\Delta x_{10}[0, 1, 2, 3]</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>and  <span class="math">\\Delta y_{10}[0,1,2,3]</span> . By Proposition 1, we can deduce  <span class="math">y_{10}[0,1,2,3]</span> . Guess C[1,3],  <span class="math">rk_{10}[1,3]</span>  can be got. One can deduce  <span class="math">rk_{-1}[1,3]</span>  from  <span class="math">rk_{10}[1,3]</span> , and store  <span class="math">x_{10}[0,1,2,3]||\\Delta z_{9}[0,1,2,3]</span>  in a table  <span class="math">T_{5}^{0}</span>  with the index of  <span class="math">rk_{-1}[1,3]||\\Delta C[0,1,2,3]||C[1,3]</span> . There are  <span class="math">2^{8}</span>  values for each index in average. Similarly, we can get one table  <span class="math">T_{5}^{i}</span>  for column i ( <span class="math">i=1,\\cdots,3</span> ), and there are  <span class="math">2^{8}</span>  values for each index in each table.</li>
      <li>2. At step 4, Guess  <span class="math">x_7[9,10]||\\Delta x_7[9]</span> , one can deduce  <span class="math">\\Delta y_7[9,10]</span>  and  <span class="math">y_7[9,10]</span>  since  <span class="math">\\Delta x_7[9] = \\Delta x_7[10]</span> . Then  <span class="math">\\Delta x_8[0,2,3,9,10,11]</span>  can be deduced. Guess  <span class="math">\\Delta y_8[0,2,3,9,10,11]||\\Delta y_9[0,1,2,3,4,5,7,8,9,10,11,12,13,15]</span> , then  <span class="math">x_8[0,2,3,9,10,11]</span>  and  <span class="math">y_8[0,2,3,9,10,11]</span>  can be deduced by Proposition 1, and  <span class="math">x_9[0,1,2,3,4,5,7,8,9,10,11,12,13,15]</span>  can be also deduced by Proposition 1. Deduce  <span class="math">ru_7[1,8]</span>  from  <span class="math">x_7[9,10]</span>  and  <span class="math">x_8[0,2,3,9,10,11]</span> , and deduce  <span class="math">ru_8[0,1,6,8,9,14]</span>  from  <span class="math">y_8[0,2,3,9,10,11]</span>  and  <span class="math">x_9[0,1,2,3,4,5,7,8,9,10,11,12,13,15]</span> . Deduce  <span class="math">ru_{10}[1,8]</span>  from  <span class="math">ru_{7}[1,8]</span>  and  <span class="math">ru_{8}[1,8]</span> , and deduce  <span class="math">ru_{10}[0,1,6,8,9,14] \\oplus ru_{10}[0,1,6,8,9,14] \\oplus ru_{10}[0,1,6,8,9,14] \\oplus ru_{10}[0,1,6,8,9,14] \\oplus ru_{10}[0,1,6,8,9,14]</span>  in a table  <span class="math">T_6</span>  with the index of  <span class="math">ru_{10}[1,8]||x||\\Delta z_{9}[0,1,2,3,5,6,7,8,9,10,12,13,14,15]</span> . There are  <span class="math">2^4</span>  values for each index. We can also reduce the size of  <span class="math">T_6</span>  by dividing it into small tables.</li>
      <li>3. Besides, we need to build two more tables for online phase. For all 28-bit sub-keys  <span class="math">ru_9[0,2,5,7,9,12,14]</span> , decrypt all 28-bit values  <span class="math">\\overline{w_9}[0,2,5,7,9,12,14]</span>  and obtain  <span class="math">\\overline{w_8}[0,1,6]</span> . Store  <span class="math">\\overline{w_8}[0,1,6]</span>  with the index of  <span class="math">ru_9[0,2,5,7,9,12,14]||</span>   <span class="math">\\overline{w_9}[0,2,5,7,9,12,14]</span>  in a table  <span class="math">T_8^0</span> . For all 28-bit sub-keys  <span class="math">ru_9[1,3,6,8,10,13,15]</span> , decrypt all 28-bit values  <span class="math">\\overline{w_9}[1,3,6,8,10,13,15]</span>  and obtain  <span class="math">\\overline{w_8}[8,9,14]</span> . Store  <span class="math">\\overline{w_8}[8,9,14]</span>  with the index of  <span class="math">ru_9[1,3,6,8,10,13,15]||\\overline{w_9}[1,3,6,8,10,13,15]</span>  in a table  <span class="math">T_8^1</span> .</li>
    </ul>

    <p class="text-gray-300">The online phase is different from the 10-round attack at step 2(c), 2(d) and 2(e). And since all nibbles of ciphertext are active, we should try all the  <span class="math">2^{76}</span>  pairs.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>At step 2(c), for each of the deduced  <span class="math">rk_{-1}[1,3]</span> , compute  <span class="math">rk_{10}[1,3]</span> . Look up the table  <span class="math">T_5^0</span>  to get about  <span class="math">2^8</span>  values  <span class="math">x_{10}[0,1,2,3]||\\Delta z_9[0,1,2,3]</span>  with the index of  <span class="math">rk_{-1}[1,3]||\\Delta C[0,1,2,3]||C[1,3]</span> . Deduce  <span class="math">rk_{10}[0,2]</span>  from the ciphertext. Do the same things to column i and  <span class="math">T_5^i</span>  (i=1,2,3), and deduce about  <span class="math">2^{32}</span>  values  <span class="math">rk_{10}||x_{10}||\\Delta z_9[0,1,2,3,5,6,7,8,9,10,12,13,14,15]</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>At step 2(d), deduce  <span class="math">ru_{10}[0, 1, 6, 8, 9, 14]</span>  from  <span class="math">rk_{10}</span> , and deduce  <span class="math">\\overline{w_9}[0, 1, 6, 8, 9, 14]</span>  from  <span class="math">x_{10}</span> . Then we can get  <span class="math">\\chi&#x27; = ru_{10}[0, 1, 6, 8, 9, 14] \\oplus \\overline{w_9}[0, 1, 6, 8, 9, 14]</span> , i.e.  <span class="math">\\chi&#x27; = z_9[0, 1, 6, 8, 9, 14] \\oplus ru_9[0, 1, 6, 8, 9, 14] \\oplus ru_{10}[0, 1, 6, 8, 9, 14]</span> . Look up the table  <span class="math">T_6</span>  to get about  <span class="math">2^4</span>  values  <span class="math">y_9[0, 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 15]||</span>   <span class="math">ru_7[1, 8]||ru_8[0, 1, 6, 8, 9, 14]</span>  with the index of  <span class="math">ru_{10}[1, 8]||\\chi&#x27;||\\Delta z_9[0, 1, 2, 3, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15]</span> . Deduce  <span class="math">ru_9[0, 1, 2, 3, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15]</span>  from  <span class="math">y_9[0, 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 15]</span>  and  <span class="math">x_{10}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>At step 2(e), for about  <span class="math">2^{44}</span>  values  <span class="math">rk_{-1}[1,3,6,9,11,14]||rk_{10}||ru_9[0,1,2,3,5,6,7,8,9,10,12,13,14,15]||ru_8[0,1,6,8,9,14]||ru_7[1,8]|</span>  we have got, decrypt</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">the corresponding ciphertexts we made in (b) and get  <span class="math">(e_{out}^1 \\oplus e_{out}^0, e_{out}^2 \\oplus e_{out}^0, \\cdots, e_{out}^{32} \\oplus e_{out}^0)</span>  using  <span class="math">T_7</span> ,  <span class="math">T_8^0</span>  and  <span class="math">T_8^1</span> . Check whether it lies in the precomputation table  <span class="math">T_4</span> . If not, try another one. If so, we check whether  <span class="math">ru_2[0,9,14]||ru_3[1]</span>  matches  <span class="math">ru_8[0,9,14]||ru_7[1]</span> . So the probability for a wrong sub-key to pass this test is  <span class="math">2^{-24-16} = 2^{-40}</span> .</p>

    <p class="text-gray-300">Complexity analysis. The time complexity of the precomputation phase is the same as the 10-round attack. In the online phase, we need to perform  <span class="math">2^{44+76}</span>  partial encryptions on 33 messages. The time complexity of this phase is about  <span class="math">2^{120+5-3} = 2^{122}</span>  11-round Midori-64 encryptions, the data complexity is  <span class="math">2^{24+29} = 2^{53}</span>  chosen-plaintexts and the memory complexity is  <span class="math">2^{53}</span>  64-bit blocks. Otherwise, we can divide the whole attack into series of weak-key attacks according to the relations between the subkeys in the online phase and the precomputation phase as Li et al. presented in [13]. Using the relation of  <span class="math">ru_2[0,9,14]||ru_3[1]</span>  (precomputation phase) and  <span class="math">ru_8[0,9,14]||ru_7[1]</span>  (online phase), the attack can be divided into  <span class="math">2^{16}</span>  weak-key attacks. The memory complexity can be reduced by a fraction of  <span class="math">2^{-16}</span> . In total, the time complexity of this attack is  <span class="math">2^{122}</span>  11-round Midori-64 encryptions, the data complexity is  <span class="math">2^{53}</span>  chosen-plaintexts and the memory complexity is  <span class="math">2^{89.2}</span>  64-bit blocks.</p>

    <p class="text-gray-300">In this section, we first propose a 7-round meet-in-the-middle distinguisher with differential enumeration technique and key-dependent sieve technique on Midori-64. Then, we apply this distinguisher to 12-round Midori-64 by adding 1 round at the beginning and 4 rounds at the end.</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 7-Round Distinguisher on Midori-64</h3>

    <p class="text-gray-300">Since  <span class="math">w_7[5] = z_7[4] \\oplus z_7[6] \\oplus z_7[7]</span>  and  <span class="math">w_7[6] = z_7[4] \\oplus z_7[5] \\oplus z_7[7]</span> , we have  <span class="math">w_7[5] \\oplus w_7[6] = z_7[5] \\oplus z_7[6]</span> . Let  <span class="math">e_{in} = z_7[5] \\oplus z_7[6]</span>  and  <span class="math">e_{out} = x_8[5] \\oplus x_8[6]</span> , then  <span class="math">e_{out} = e_{in} \\oplus rk_7[5] \\oplus rk_7[6]</span> , the 7-round distinguisher on Midori-64 is based on the proposition below.</p>

    <p class="text-gray-300"><strong>Proposition 6.</strong> Let  <span class="math">\\{w_0^0, w_0^1, \\cdots, w_0^{255}\\}</span>  be a 2- <span class="math">\\delta</span> -set where  <span class="math">w_0[5]</span>  and  <span class="math">w_0[10]</span>  are the active nibbles. Consider the encryption of the first 33 values  <span class="math">(w_0^0, w_0^1, \\cdots, w_0^{33})</span>  of the 2- <span class="math">\\delta</span> -set through 7-round Midori-64, in the case of that a message of the 2- <span class="math">\\delta</span> -set belongs to a pair which conforms to the truncated differential trail outlined in Fig. 8(a), then the corresponding 128-bit ordered sequence  <span class="math">(e_{out}^1 \\oplus e_{out}^0, e_{out}^2 \\oplus e_{out}^1)</span>  only takes about  <span class="math">2^{124}</span>  values (out of the  <span class="math">2^{128}</span>  theoretically values).</p>

    <p class="text-gray-300"><em>Proof.</em> As shown in Fig. 8(a), for the encryption of the first 33 values of the 2- <span class="math">\\delta</span> -set, the output sequence  <span class="math">(e_{out}^1 \\oplus e_{out}^0, e_{out}^2 \\oplus e_{out}^0, \\cdots, e_{out}^{32} \\oplus e_{out}^0)</span>  is determined</p>

    <p class="text-gray-300">by the 58 nibble-parameters:</p>

    <p class="text-gray-300"><span class="math">$w_0[5,10]||x_1[5,10]||x_2[0,1,2,3]||x_3[1,2,3,4,5,6,8,10,11,12,13,15]||x_4| (5)</span>$</p>

    <p class="text-gray-300"><span class="math">$rk_4[0,1,2,3,4,5,6,8,9,10,11,12,13,15]||rk_5[1,3,4,9,11,12]||rk_6[4,11]|</span>$</p>

    <p class="text-gray-300">However, if a pair of messages conforms to the truncated differential trail outlined in Fig. 8(a), the above 58 nibble-parameters are determined by the 41 nibble-parameters:</p>

    <p class="text-gray-300"><span class="math">$\\Delta z_1[1,2]||x_2[0,1,2,3]||x_3[1,2,3,4,5,6,8,10,11,12,13,15]||</span>$</p>

    <p class="text-gray-300"><span class="math">$y_5[0,1,2,3,4,5,6,8,9,10,11,12,13,15]||y_6[1,3,4,9,11,12]||y_7[4,11]||\\Delta z_7[5]</span>$
(6)</p>

    <p class="text-gray-300">Meanwhile,  <span class="math">ru_2[0,7,9,14]||ru_3[1,2,3,5,6,7,9,10,11,13,14,15]||rk_4[0,1,2,3,4,5,6,8,9,10,11,12,13,15]||rk_5[1,3,4,9,11,12]||rk_6[4,11]</span>  can be determined by the above 41 nibble-parameters. Since  <span class="math">ru_4[0,7,9,14]</span>  can be deduced from  <span class="math">rk_4[0,1,2,3,4,5,6,8,9,10,11,12,13,15]</span> ,  <span class="math">rk_3[4,12]</span>  can de deduced from  <span class="math">ru_3[5,6,7,13,14,15]</span>  and  <span class="math">rk_3[3,11]</span>  can be deduced from  <span class="math">ru_3[1,2,3,9,10,11]||ru_5[1,9]</span> , according to the key-schedule of Midori-64,  <span class="math">ru_2[0,7,9,14]||rk_3[3,4,11,12]||rk_6[4,11]</span>  and  <span class="math">ru_4[0,7,9,14]||rk_5[3,4,11,12]||rk_4[4,11]</span>  are affected by the same nibbles of the master key. By the key-dependent sieve technique, there are  <span class="math">2^{124}</span>  possible values for the 41 nibble-parameters.</p>

    <p class="text-gray-300">So the 58 nibble-parameters (5) are determined by 41 nibble-parameters (6), i.e. the sequence  <span class="math">(e^1_{out} \\oplus e^0_{out}, e^2_{out} \\oplus e^0_{out}, \\cdots, e^{32}_{out} \\oplus e^0_{out})</span>  can take about  <span class="math">2^{124}</span>  values.</p>

    <p class="text-gray-300"></p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 12-Round Attack on Midori-64</h3>

    <p class="text-gray-300">The attack is made up of two phase: precomputation phase and online phase. <strong>Precomputation phase:</strong> In the precomputation phase, we need to build a table that contains all the sequence  <span class="math">(e^1_{out} \\oplus e^0_{out}, e^2_{out} \\oplus e^0_{out}, \\cdots, e^{32}_{out} \\oplus e^0_{out})</span>  described in Propostion 6.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">1. For each 120-bit value  <span class="math">\\Delta z_2[0,7,9,14]||\\Delta w_4[0,1,2,3,4,5,6,8,9,10,11,12,13,15]||ru_3[1,2,3,5,6,7,9,10,11,13,14,15],</span>  deduce  <span class="math">x_3[1,2,3,4,5,6,8,10,11,12,13,15]||y_4</span>  by Proposition 3. Compute  <span class="math">\\overline{w_2}[0,7,9,14]</span>  and  <span class="math">z_4[0,7,9,14]</span> , and let  <span class="math">\\varsigma_1=\\overline{w_2}[0,7,9,14]\\oplus z_4[0,7,9,14]</span> . Deduce  <span class="math">rk_3[4,12]</span>  from  <span class="math">ru_3[5,6,7,13,14,15]</span> , and let  <span class="math">\\varsigma_2=rk_3[4,12]||ru_3[1,9]\\oplus ru_3[3,11]</span> . Store  <span class="math">x_3[1,2,3,4,5,6,8,10,11,12,13,15]||x_4||w_4[0,1,2,3,4,5,6,8,9,10,11,12,13,15]</span>  in a table  <span class="math">T_1</span>  with the index of  <span class="math">w_4[4,11]||\\varsigma_1||\\varsigma_2||\\Delta z_2[0,7,9,14]||\\Delta w_4[0,1,2,3,4,5,6,8,9,10,11,12,13,15]</span> . There are  <span class="math">2^8</span>  values for each index.</p></li>
      <li><p class="text-gray-300">2. For each 92-bit value  <span class="math">\\Delta z_7[5]||\\Delta x_7[4,11]||\\Delta x_6[1,3,4,9,11,12]||\\Delta w_4[0,1,2,3,4,5,6,8,9,10,11,12,13,15],</span>  deduce  <span class="math">\\Delta z_7[6]</span>  since  <span class="math">\\Delta z_7[6] = \\Delta z_7[5],</span>  then deduce  <span class="math">x_7[4,11], x_6[1,3,4,9,11,12]</span>  and  <span class="math">x_5[0,1,2,3,4,5,6,8,9,10,11,12,13,15]</span>  by Proposition 1. Deduce  <span class="math">rk_6[4,11]</span>  and  <span class="math">rk_5[1,3,4,9,11,12].</span>  Store  <span class="math">x_5[0,1,2,3,4,5,6,8,9,10,11,12,13,15]||rk_6[4,11]||rk_5[1,3,4,9,11,12]||\\Delta w_4[0,1,2,3,4,5,6,8,9,10,11,12,13,15]</span>  in a table  <span class="math">T_2</span> .</p></li>
      <li><p class="text-gray-300">3. For each 24-bit value  <span class="math">\\Delta z_1[1,2]||\\Delta y_2[0,1,2,3]|</span> , deduce  <span class="math">y_2[0,1,2,3]</span> . Store  <span class="math">y_2[0,1,2,3]||\\Delta z_2[0,7,9,14]|</span>  in a table  <span class="math">T_3</span> .</p></li>
      <li><p class="text-gray-300">4. For each value of table  <span class="math">T_2</span>  and  <span class="math">T_3</span> , do the following steps.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Compute  <span class="math">w_4[4,11]</span>  from  <span class="math">rk_5[4,11]</span>  and  <span class="math">x_5[4,11]</span> , and compute  <span class="math">\\varsigma_1&#x27;=z_2[0,7,9,14]\\oplus\\overline{w_4}[0,7,9,14]</span>  from  <span class="math">y_2[0,1,2,3]</span>  and  <span class="math">x_5[0,1,2,3,4,5,6,8,9,10,11,12,13,15]</span> . Deduce  <span class="math">\\varsigma_2&#x27;=rk_3[4,12]||ru_3[1,9]\\oplus ru_3[3,11]</span>  from  <span class="math">rk_5[1,3,4,9,11,12]</span> . Look up the table  <span class="math">T_1</span>  to get about  <span class="math">2^8</span>  values of  <span class="math">x_3[1,2,3,4,5,6,8,10,11,12,13,15]||x_4||w_4[0,1,2,3,4,5,6,8,9,10,11,12,13,15]</span>  with the index of  <span class="math">w_4[4,11]||\\varsigma_1&#x27;||\\varsigma_2&#x27;||\\Delta z_2[0,7,9,14]||\\Delta w_4[0,1,2,3,4,5,6,8,9,10,11,12,13,15]</span> ,  <span class="math">rk_1[0,1,2,3]</span>  and  <span class="math">rk_0[5,10]</span> , then deduce  <span class="math">x_1[5,10]</span>  and  <span class="math">w_0[5,10]</span> . Therefore, we get the 58 nibble-parameters (5).</li>
      <li>(b) Compute the sequence  <span class="math">(e_{out}^1 \\oplus e_{out}^0, e_{out}^2 \\oplus e_{out}^0, \\cdots, e_{out}^{32} \\oplus e_{out}^0)</span> , and store them along with a 60-bit value  <span class="math">ru_4[0, 1, 2, 7, 8, 9, 10, 11, 14] || ru_3[0, 1, 7, 8, 9, 15]</span>  in a table  <span class="math">T_4</span> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">The online phase and the construction of tables  <span class="math">T_5^i</span>  ( <span class="math">i = 0, \\dots, 3</span> ),  <span class="math">T_6</span> ,  <span class="math">T_7</span> ,  <span class="math">T_8^0</span>  and  <span class="math">T_8^1</span>  are almost the same as the 11-round attack except the position of nibbles. The procedure of this phase is shown in Fig. 8(b).</p>

    <p class="text-gray-300">Therefore, the time complexity of the precomputation phase is  <span class="math">2^{124+5-2} = 2^{127}</span>  12-round Midori-64 encryptions, the memory complexity is  <span class="math">2^{124+7\\cdot 2-6} = 2^{125\\cdot 2}</span>  64-bit blocks. The time complexity of the online phase is about  <span class="math">2^{120+5-3} = 2^{122}</span>  12-round Midori-64 encryptions, the data complexity is  <span class="math">2^{24+29} = 2^{53}</span>  chosenplaintexts and the memory complexity is  <span class="math">2^{53}</span>  64-bit blocks. By data/time/memory tradeoff and weak-key attacks, the time complexity of this attack is about  <span class="math">2^{125.5}</span>  12-round Midori-64 encryptions, the data complexity is  <span class="math">2^{55.5}</span>  chosen-plaintexts and the memory complexity is  <span class="math">2^{106}</span>  64-bit blocks<sup>1</sup>.</p>

    <p class="text-gray-300">In this paper, we discussed the security of Midori-64 against meet-in-the-middle attacks. Using the differential enumeration technique and key-dependent sieve technique, we proposed a 6-round meet-in-the-middle distinguisher on Midori-64. Based on this distinguisher, we added 1 round at the beginning and 3 rounds at the end to present a 10-round attack with time complexity of  <span class="math">2^{99.5}</span>  10-round Midori-64 encryptions, data complexity of  <span class="math">2^{61.5}</span>  chosen-plaintexts and memory complexity of  <span class="math">2^{92.7}</span>  64-bit blocks. After that, by adding one round at the end, we got an 11-round attack with time complexity of  <span class="math">2^{122}</span>  11-round Midori-64 encryptions, data complexity of  <span class="math">2^{53}</span>  chosen-plaintexts and memory complexity of  <span class="math">2^{89.2}</span>  64-bit blocks. Finally, with a 7-round distinguisher, we got an attack on 12-round Midori-64 with time complexity of  <span class="math">2^{125.5}</span>  12-round Midori-64 encryptions, data complexity of  <span class="math">2^{55.5}</span>  chosen-plaintexts and memory complexity of  <span class="math">2^{106}</span>  64-bit blocks.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;1</sup> The memory comes from the construction of  <span class="math">T_1</span></p>

    <p class="text-gray-300">There are many further works possible: the way to apply this kind of attacks to Midori-128, the way to get better attack complexity with meet-in-the-middle method and the security level against other cryptanalytic methods (e.g. impossible differential and zero-correlation linear) for Midori.</p>

    <p class="text-gray-300">The research presented in this paper is supported by the National Basic Research Program of China (No. 2013CB338002) and National Natural Science Foundation of China (No. 61272476, No.61232009 and No. 61202420).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">1. Subhadeep Banik, Andrey Bogdanov, Takanori Isobe, Kyoji Shibutani, Harunaga Hiwatari, Toru Akishita, and Francesco Regazzoni. Midori: A Block Cipher for Low Energy (Extended Version). Cryptology ePrint Archive, Report 2015/1142, 2015. <a href="http://eprint.iacr.org/" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/</a>.</p></li>
      <li><p class="text-gray-300">2. Andrey Bogdanov, Lars R Knudsen, Gregor Leander, Christof Paar, Axel Poschmann, Matthew JB Robshaw, Yannick Seurin, and Charlotte Vikkelsoe. PRESENT: An Ultra-Lightweight Block Cipher. Springer, 2007.</p></li>
      <li><p class="text-gray-300">3. Julia Borghoff, Anne Canteaut, Tim Gneysu, Elif Bilge Kavun, Miroslav Knezevic, Lars R. Knudsen, Gregor Leander, Ventzislav Nikov, Christof Paar, and Christian Rechberger. PRINCE C A Low-Latency Block Cipher for Pervasive Computing Applications. Springer Berlin Heidelberg, 2012.</p></li>
      <li><p class="text-gray-300">4. Joan Daemen and Vincent Rijmen. The Design of Rijndael: AES-the Advanced Encryption Standard. Springer, 2002.</p></li>
      <li><p class="text-gray-300">5. Joan Daemen and Vincent Rijmen. Understanding two-round differentials in aes. In Security and Cryptography for Networks, pages 78&ndash;94. Springer, 2006.</p></li>
      <li><p class="text-gray-300">6. H&uml;useyin Demirci and Ali Ayd&#305;n Sel&cedil;cuk. A Meet-In-the-Middle Attack on 8-Round AES. In Fast Software Encryption, pages 116&ndash;126. Springer, 2008.</p></li>
      <li><p class="text-gray-300">7. H&uml;useyin Demirci, &#729;Ihsan Ta&cedil;sk&#305;n, Mustafa C&cedil; oban, and Adnan Baysal. Improved Meet-in-the-Middle Attacks on AES. In Progress in Cryptology-INDOCRYPT 2009, pages 144&ndash;156. Springer, 2009.</p></li>
      <li><p class="text-gray-300">8. Patrick Derbez, Pierre-Alain Fouque, and J&acute;er&acute;emy Jean. Improved Key Recovery Attacks on Reduced-Round AES in the Single-Key Setting. In Advances in Cryptology&ndash;EUROCRYPT 2013, pages 371&ndash;387. Springer, 2013.</p></li>
      <li><p class="text-gray-300">9. Whitfield Diffie and Martin E Hellman. Special Feature Exhaustive Cryptanalysis of the NBS Data Encryption Standard. Computer, 10(6):74&ndash;84, 1977.</p></li>
      <li><p class="text-gray-300">10. Orr Dunkelman, Nathan Keller, and Adi Shamir. Improved Single-Key Attacks on 8-Round AES-192 and AES-256. In Advances in Cryptology-ASIACRYPT 2010, pages 158&ndash;176. Springer, 2010.</p></li>
      <li><p class="text-gray-300">11. Henri Gilbert and Marine Minier. A Collisions Attack on the 7-Rounds Rijndael. In In AES Candidate Conference. Citeseer, 2000.</p></li>
      <li><p class="text-gray-300">12. Leibo Li, Keting Jia, and Xiaoyun Wang. Improved Meet-in-the-Middle Attacks on AES-192 and PRINCE. IACR Cryptology ePrint Archive, 2013:573, 2013.</p></li>
      <li><p class="text-gray-300">13. Leibo Li, Keting Jia, Xiaoyun Wang, et al. Improved Single-Key Attacks on 9- Round AES-192/256. In FSE 2014 (21st International Workshop on Fast Software Encryption), 2014.</p></li>
      <li><p class="text-gray-300">14. Rongjia Li and Chenhui Jin. Meet-in-the-Middle Attacks on 10-Round AES-256. Designs, Codes and Cryptography, pages 1&ndash;13, 2015.</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Li Lin, Wenling Wu, Yanfeng Wang, and Lei Zhang. General Model of the Single-Key Meet-in-the-Middle Distinguisher on the Word-oriented Block Cipher. In Information Security and Cryptology&ndash;ICISC 2013, pages 203&ndash;223. Springer, 2014.</li>
    </ol></li>
      <li><p class="text-gray-300">16. Tomoyasu Suzaki, Kazuhiko Minematsu, Sumio Morioka, and Eita Kobayashi. TWINE: A Lightweight Block Cipher for Multiple Platforms. In Selected Areas in Cryptography, pages 339&ndash;354. Springer, 2013.</p></li>
      <li><p class="text-gray-300">17. Wenling Wu and Lei Zhang. Lblock: A Lightweight Block Cipher. In Applied Cryptography and Network Security, pages 327&ndash;344. Springer, 2011.</p></li>
    </ul>

    <p class="text-gray-300">    <img src="_page_17_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 5. The truncated differential trail of 6-round Midori-64.</p>

    <p class="text-gray-300">    <img src="_page_18_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 6. Online phase of the attack on 10-round Midori-64.</p>

    <p class="text-gray-300">    <img src="_page_19_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 7. Online phase of the attack on 11-round Midori-64.</p>

    <p class="text-gray-300">    <img src="_page_20_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 8. The attack on 12-round Midori-64. The 7-round distinguisher is shown in (a), the online phase is shown in (b).</p>

    </section>
`;
---

<BaseLayout title="Meet-in-the-Middle Attacks on Reduced-Round  Midori-64 (2015/1165)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2015 &middot; eprint 2015/1165
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li>
          <a href="#sec-2" class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Description of Midori-64</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Definitions and Propositions</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">Reviews of Former Works</a></li>
            <li><a href="#sec-2.4" class="hover:text-white">Attack Scheme</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">Meet-in-the-Middle Attack on 10-Round Midori-64</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">6-Round Distinguisher on Midori-64</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">Attack on 10-Round Midori-64</a></li>
          </ol>
        </li>
        <li><a href="#sec-4" class="hover:text-white">Attack on 11-Round Midori-64</a></li>
        <li>
          <a href="#sec-5" class="hover:text-white">Attack on 12-round Midori-64</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">7-Round Distinguisher on Midori-64</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">12-Round Attack on Midori-64</a></li>
          </ol>
        </li>
        <li><a href="#sec-6" class="hover:text-white">Conclusions and Further Work</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#acknowledgements" class="hover:text-white">Acknowledgements</a></li>
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="meet-in-the-middle-attacks-on-reduced-round-midori-64-2015" />
  </article>
</BaseLayout>
