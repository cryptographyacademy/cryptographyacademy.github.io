---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2015/1165';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Meet-in-the-Middle Attacks on Reduced-Round  Midori-64';
const AUTHORS_HTML = 'Li Lin, Wenling Wu';

const CONTENT = `    <p class="text-gray-300">Li Lin and Wenling Wu</p>

    <p class="text-gray-300">Trusted Computing and Information Assurance Laboratory, Institute of Software, Chinese Academy of Sciences, Beijing 100190, China {linli, wwl}@tca.iscas.ac.cn</p>

    <p class="text-gray-300">Abstract. Midori is a lightweight block cipher designed by Banik et al. at ASIACRYPT 2015. One version of Midori uses a 64-bit state, another uses a 128-bit state and we denote these versions Midori-64 and Midori-128. Each of these versions uses a 128-bit key. In this paper, we focus on the key-recovery attacks on reduced-round Midori-64 with meet-in-the-middle method. We use the differential enumeration technique and key-dependent sieve technique which are popular to analyze AES to attack Midori-64. We propose a 6-round distinguisher, and achieve a 10-round attack with time complexity of <span class="math">2^{99.5}</span> 10-round Midori-64 encryptions, data complexity of <span class="math">2^{61.5}</span> chosen-plaintexts and memory complexity of <span class="math">2^{92.7}</span> 64-bit blocks. After that, by adding one round at the end, we get an 11-round attack with time complexity of <span class="math">2^{122}</span> 11-round Midori-64 encryptions, data complexity of <span class="math">2^{53}</span> chosen-plaintexts and memory complexity of <span class="math">2^{89.2}</span> 64-bit blocks. Finally, with a 7-round distinguisher, we get an attack on 12-round Midori-64 with time complexity of <span class="math">2^{125.5}</span> 12-round Midori-64 encryptions, data complexity of <span class="math">2^{55.5}</span> chosen-plaintexts and memory complexity of <span class="math">2^{106}</span> 64-bit blocks. To the best of our knowledge, this is recently the best attack on Midori-64.</p>

    <p class="text-gray-300">Keywords: Block Cipher, Meet-in-the-Middle Attack, Midori-64.</p>

    <p class="text-gray-300">In the past few years, lightweight cryptography has become a popular research discipline with a number of ciphers and hash functions proposed. The goals of these ciphers range from minimizing the hardware area [2,17,16] to low latency[3]. However, the optimization goal of low energy for block cipher design has not attached much attention. At ASIACRYPT 2015, Banik et al. present a new lightweight block cipher Midori that is optimized with respect to the energy consumed by the circuit per bit in encryption or decryption operation [1]. Midori is based on the Substitution-Permutation Network (SPN). One version of Midori uses a 64-bit state, another uses a 128-bit state and we denote these versions Midori-64 and Midori-128. Each of these versions uses a 128-bit key.</p>

    <p class="text-gray-300">Meet-in-the-middle attack is first proposed by Diffie and Hellman to attack DES [9]. In recent years, it is widely researched due to its effectiveness against</p>

    <p class="text-gray-300">block cipher AES <em>[4]</em>. For AES, Gilbert and Minier show in <em>[11]</em> some collision attacks on 7-round AES. At FSE 2008, Demirci and Selçuk improve the Gilbert and Minier attacks using meet-in-the-middle technique instead of collision idea. More specifically, they show that the value of each byte of 4-round AES ciphertext can be described by a function of the <span class="math">\\delta</span>-<span class="math">set</span>, i.e. a set of 256 plaintexts where a byte (called active byte) can take all values and the other 15 bytes are constant, parameterized by 25 <em>[6]</em> and 24 <em>[7]</em> 8-bit parameters. The last improvement is due to storing differences instead of values. This function is used to build a distinguisher in the offline phase, i.e. they build a lookup table containing all the possible sequences constructed from a <span class="math">\\delta</span>-set. In the online phase, they identify a <span class="math">\\delta</span>-set, and then partially decrypt the <span class="math">\\delta</span>-set through some rounds and check whether it belongs to the table. At ASIACRYPT 2010, Dunkelman, Keller and Shamir develop many new ideas to solve the memory problems of the Demirci and Selçuk attacks <em>[10]</em>. First of all, they only store <span class="math">multiset</span>, i.e. an unordered sequence with multiplicity, rather than the ordered sequence. The second and main idea is the differential enumeration technique which uses a special property on a truncated differential trail to reduce the number of parameters that describes the set of functions from 24 to 16. Furthermore, Derbez, Fouque and Jean present a significant improvement to the Dunkelman et al.’s differential enumeration technique at EUROCRYPT 2013 <em>[8]</em>, called efficient tabulation. Using this rebound-like idea, they show that many values in the precomputation table are not reached at all under the constraint of a special truncated differential trail. Actually, the size of the precomputation table is determined by 10 byte-parameters only. At FSE 2014, Li et al. introduce the key-dependent sieve technique, which filters the wrong states based on the key relations, to further reduce the complexity in the precomputaion phase <em>[13]</em>. Then they give an attack on 9-round AES-192. In <em>[14]</em>, Li et al. give an attack on 10-round AES-256 with differential enumeration technique and key-dependent sieve technique.</p>

    <p class="text-gray-300">Our contributions. In this paper, we carefully study and apply the variants of Derbez et al. attack on Midori-64. With the differential enumeration technique and key-dependent sieve technique, we present a 6-round distinguisher on Midori-64. Based on this distinguisher, we add 1 round at the beginning and 3 rounds at the end to present a 10-round meet-in-the-middle attack on Midori-64. The time complexity of this attack is <span class="math">2^{99.5}</span> 10-round Midori-64 encryptions, the data complexity is <span class="math">2^{61.5}</span> chosen-plaintexts and the memory complexity is <span class="math">2^{92.7}</span> 64-bit blocks. After that, by adding one round at the end, we get an 11-round attack with time complexity of <span class="math">2^{122}</span> 11-round Midori-64 encryptions, data complexity of <span class="math">2^{53}</span> chosen-plaintexts and memory complexity of <span class="math">2^{89.2}</span> 64-bit blocks. To the best of our knowledge, this is recently the best attack on Midori-64. Finally, with a 7-round distinguisher, we get an attack on 12-round Midori-64 with time complexity of <span class="math">2^{125.5}</span> 12-round Midori-64 encryptions, data complexity of <span class="math">2^{55.5}</span> chosen-plaintexts and memory complexity of <span class="math">2^{106}</span> 64-bit blocks.</p>

    <p class="text-gray-300">Organizations of this paper. The rest of this paper is organized as follows. In section 2, we provide a brief description of Midori-64, some definitions and properties, a brief recall of the previous meet-in-the-middle distinguisher and the attack scheme. In section 3, we give our attack on 10-round Midori-64. In</p>

    <p class="text-gray-300">section 4, we give our attack on 11-round Midori-64. In section 5, we give our attack on 12-round Midori-64. In section 6, we conclude this paper.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">In this section we give a short description of Midori-64 and gives some definitions and propositions used throughout this paper. Then we briefly recall the previous meet-in-the-middle distinguisher. Finally, the attack scheme is given.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">2.1 Description of Midori-64</h3>

    <p class="text-gray-300">Midori is a lightweight block cipher designed by Banik et al. at ASIACRYPT 2015 <em>[1]</em> and is based on the Substitution-Permutation Network (SPN). One version of Midori uses a 64-bit state, another uses a 128-bit state and we denote these versions Midori-64 and Midori-128. Each of these versions uses a 128-bit key. In this paper, we focus on the 64-bit version of Midori, so we describe it here. The Midori-64 block cipher operates on 64-bit state, and uses the following <span class="math">4\\times 4</span> array called state as a data expression:</p>

    <p class="text-gray-300">\\[ S=\\begin{pmatrix}s_{0}&s_{4}&s_{8}&s_{12}\\\\ s_{1}&s_{5}&s_{9}&s_{13}\\\\ s_{2}&s_{6}&s_{10}&s_{14}\\\\ s_{3}&s_{7}&s_{11}&s_{15}\\end{pmatrix} \\]</p>

    <p class="text-gray-300">where the size of each cell is 4 bits.</p>

    <p class="text-gray-300">A Midori-64 round applies the following four operations to the state matrix:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>SubCell: Apply the non-linear <span class="math">4\\times 4</span> S-box in parallel on each nibble of the state.</li>

      <li>ShuffleCell: Each nibble of the state is preformed as follows:</li>

    </ul>

    <p class="text-gray-300"><span class="math">(s_{0},s_{1},\\cdots,s_{15})\\leftarrow(s_{0},s_{10},s_{5},s_{15},s_{4},s_{11},s_{1},s_{9},s_{3},s_{12},s_{6},s_{7},s_{13},s_{2},s_{8}).</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>MixColumn: Midori-64 utilizes an involutive binary matrix <span class="math">\\mathbf{M}</span> defined as follows:</li>

    </ul>

    <p class="text-gray-300">\\[ \\mathbf{M}=\\begin{pmatrix}0&1&1&1\\\\ 1&0&1&1\\\\ 1&1&0&1\\\\ 1&1&1&0\\end{pmatrix} \\]</p>

    <p class="text-gray-300"><span class="math">\\mathbf{M}</span> is applied to every 4-nibble column of the state <span class="math">S</span>, i.e.</p>

    <p class="text-gray-300"><span class="math">{}^{t}(s_{i},s_{i+1},s_{i+2},s_{i+3})\\leftarrow\\mathbf{M}\\,.^{t}\\,(s_{i},s_{i+1},s_{i+2},s_{i+3})\\ and\\ i=0,4,8,12.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>KeyAdd: The <span class="math">i^{th}</span> 64-bit round key <span class="math">rk_{i}</span> is xored to a state <span class="math">S</span>.</li>

    </ul>

    <p class="text-gray-300">Before the first round, an additional KeyAdd operation is applied, and in the last round the ShuffleCell and MixColumn operations are omitted. The total round number of Midori-64 is 16.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The key-schedule of Midori-64 is quite simple. A 128-bit secret key <span class="math">K</span> is denoted as two 64-bit keys <span class="math">k_{0}</span> and <span class="math">k_{1}</span> as $K=k_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{1}$. Suppose we focus on</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Midori-64 reduced to  <span class="math">R</span> -round, the whiten key and the last sub-key are  <span class="math">rk_{-1} = rk_{R - 1} = k_0 \\oplus k_1</span> , and the sub-key for round  <span class="math">i</span>  is  <span class="math">rk_i = k_{(i \\mod 2)} \\oplus \\alpha_i</span> , where  <span class="math">0 \\leq i \\leq R - 2</span>  and  <span class="math">\\alpha_i</span>  is a constant.</p>

    <p class="text-gray-300">In this paper, the plaintext is denoted by  <span class="math">P</span> , the ciphertext is denoted by  <span class="math">C</span> . Let  <span class="math">x_{i}, y_{i}, z_{i}</span>  and  <span class="math">w_{i}</span>  denote the intermediate states before SubCell, ShuffleCell, MixColumn and KeyAdd operations of round  <span class="math">i</span> .  <span class="math">x_{i}[j]</span>  denotes the  <span class="math">j^{th}</span>  nibble of round  <span class="math">i</span> .  <span class="math">x_{i}^{k}[j]</span>  denotes the  <span class="math">k^{th}</span>  element of a set of some  <span class="math">x_{i}[j]</span> .  <span class="math">\\Delta x_{i}^{k}[j]</span>  denotes the difference of the  <span class="math">k^{th}</span>  element and  <span class="math">0^{th}</span>  element of a set, i.e.  <span class="math">\\Delta x_{i}^{k}[j] = x_{i}^{k}[j] \\oplus x_{i}^{0}[j]</span> .</p>

    <p class="text-gray-300">In some cases, we are interested in interchanging the order of the MixColumn and KeyAdd operations. As these operations are linear, they can be interchanged by first xoring the data with an equivalent key  <span class="math">ru_{i} = MixColumn^{-1}(rk_{i})</span>  and then applying the MixColumn operation. And we denote the intermediate state after xoring with  <span class="math">u_{i}</span>  by  <span class="math">\\overline{w_i}</span> . We also denote  <span class="math">u_{i} = MixColumn^{-1}(k_{i})</span> , where  <span class="math">i = 0,1</span> .</p>

    <p class="text-gray-300">In [4], Daemen et al. first proposed the definition of  <span class="math">\\delta</span> -set of byte. After that,  <span class="math">\\delta</span> -set was used in the meet-in-the-middle attacks on AES and other ciphers. In [12], Li et al. extended the definition of  <span class="math">\\delta</span> -set to  <span class="math">T</span>  active cells, and got  <span class="math">T</span> - <span class="math">\\delta</span> -set. In this paper, we use 2- <span class="math">\\delta</span> -set which defines as follows.</p>

    <p class="text-gray-300">Definition 1 (2-δ-set). Let a 2-δ-set be a set of  <span class="math">2^{2 \\times 4}</span>  states that are all different in two state nibbles (active nibbles) and all equal in the other state nibbles (inactive nibbles).</p>

    <p class="text-gray-300">In [5], Daemen et al. gave the definition of super S-box for AES. For Midori, we can give a similar definition as follows.</p>

    <p class="text-gray-300">Definition 2 (Super S-box). For each value of one column of  <span class="math">rk_3</span> , a Midori Super S-box maps one column of  <span class="math">z_3</span>  to one column of  <span class="math">y_4</span>  as shown in Fig. 1. It consists of one SubCell operation, one MixColumn operation, one KeyAdd operation and one SubCell operation.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig.1. Super S-box for Midori-64.</p>

    <p class="text-gray-300">For one S-box, we have the following proposition.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Proposition 1 (Differential Property of S-box, <em>[8]</em>).</h6>

    <p class="text-gray-300">Given <span class="math">\\Delta_{i}</span> and <span class="math">\\Delta_{0}</span> two non-zero differences, the equation of S-box</p>

    <p class="text-gray-300"><span class="math">S(x)\\oplus S(x\\oplus\\Delta_{i})=\\Delta_{0},</span> (1)</p>

    <p class="text-gray-300">has one solution in average.</p>

    <p class="text-gray-300">This proposition also applies to super S-box.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Proposition 2 (Differential Property of Super S-box).</h6>

    <p class="text-gray-300">Given <span class="math">\\Delta_{i}</span> and <span class="math">\\Delta_{0}</span> two non-zero differences in <span class="math">F_{2^{16}}</span>, the equation of super S-box</p>

    <p class="text-gray-300"><span class="math">Super-S(x)\\oplus Super-S(x\\oplus\\Delta_{i})=\\Delta_{0},</span> (2)</p>

    <p class="text-gray-300">has one solution in average for each key value.</p>

    <p class="text-gray-300">For <span class="math">ru_{i}</span>, we have the following proposition.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Proposition 3.</h6>

    <p class="text-gray-300">As shown in Fig. 1, if the first column of <span class="math">z_{3}</span> is active only in the last 3 nibbles, Proposition 2 holds for each equivalent sub-key <span class="math">ru_{3}[1,2,3]</span>.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We use the equivalent sub-key in this proof. For each <span class="math">y_{4}[0,1,2,3]</span> and <span class="math">ru_{3}[1,2,3]</span>, since <span class="math">\\Delta y_{4}[0,1,2,3]</span> is known, one can get <span class="math">\\overline{w_{3}}[0,1,2,3]</span> and <span class="math">\\Delta\\overline{w_{3}}[0,1,2,</span> 3]. With the probability of <span class="math">2^{-4}</span>, <span class="math">y_{3}[0,1,2,3]</span> is active only in the last 3 nibbles. By adding <span class="math">ru_{3}[1,2,3]</span>, one can get <span class="math">\\Delta z_{3}[1,2,3]</span>.</p>

    <p class="text-gray-300">Therefore, for each <span class="math">\\Delta_{i}</span> and <span class="math">\\Delta_{0}</span>, the average number of input values of Super S-box is <span class="math">2^{16-12-4}=1</span> for each equivalent sub-key.</p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.3 Reviews of Former Works</h3>

    <p class="text-gray-300">In this section, we review the previously meet-in-the-middle distinguishers on AES in <em>[6, 10, 8]</em>.</p>

    <p class="text-gray-300">Demirci and Selçuk distinguisher. Consider the set of functions</p>

    <p class="text-gray-300"><span class="math">f:\\{0,1\\}^{8}\\longrightarrow\\{0,1\\}^{8}</span></p>

    <p class="text-gray-300">that maps a byte of a <span class="math">\\delta</span>-set to another byte of the state after four AES rounds. A convenient way is to view <span class="math">f</span> as an ordered byte sequence <span class="math">(f(0),\\ldots,f(255))</span> so that it can be represented by 256 bytes. The crucial observation made by the generalizing Gilbert and Minier attacks <em>[11]</em> is that this set is tiny since it can be described by 25 byte-parameters (<span class="math">2^{25\\cdot 8}=2^{200}</span>) compared with the set of all functions of this type which counts as may as <span class="math">2^{8\\cdot 2^{8}}=2^{2048}</span> elements <em>[6]</em>. Considering the differences <span class="math">(f(0)-f(0),f(1)-f(0),\\ldots,f(255)-f(0))</span> rather than values, the set of functions can be described by 24 parameters <em>[7]</em>. The 24 byte-parameters which map <span class="math">x_{1}[0]</span> to <span class="math">\\Delta x_{5}[0]</span> are presented as gray cells in Fig. 2.</p>

    <p class="text-gray-300">Dunkelman et al. distinguisher and Derbez et al. distinguisher. In <em>[10]</em>, Dunkelman et al. introduced two new improvements to further reduce the memory complexity of <em>[7]</em>. The first uses <span class="math">multiset</span> which is an unordered sequence with multiplicity to replace ordered sequence in the offline phase, since there is enough information so that the attack succeeds. The second improvement uses</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2. The 4-round AES distinguisher used in [7]. The gray cells represent 24 byteparameters,  <span class="math">\\delta</span>  represents the  <span class="math">\\delta</span> -set and  <span class="math">m</span>  represents the differential sequence to be stored.</p>

    <p class="text-gray-300">a novel idea named differential enumeration technique. The main idea of this technique is to use a special 4-round property on a truncated differential trail to reduce the number of parameters which describes the set of functions from 24 to 16.</p>

    <p class="text-gray-300">In [8], Derbez et al. used the efficient tabulation to improve Dunkelman et al.'s differential enumeration technique. Combining with the rebound-like idea, many values in the precomputation table are not reached at all under the constraint of a truncated differential trail.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proposition 4 (Efficient Tabulation, [8]). If a message of  <span class="math">\\delta</span> -set belongs to a pair conforming to the 4-round truncated differential trail outlined in Fig. 3, the values of multiset are only determined by 10 byte-parameters of intermediate state  $\\Delta z_{1}[0]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{2}[0,1,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2,3]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Δx5[0]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z4[0,1,2,3] presented as gray cells in this figure.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 3. The truncated differential trail of 4-round AES used in [6], the gray cells represent 10 byte-parameters,  <span class="math">\\Delta</span>  represents difference.</p>

    <p class="text-gray-300">The main idea of their works is that suppose one gets a pair of messages conforming to this truncated differential trail, the differences  <span class="math">\\Delta x_{3}</span>  and  <span class="math">\\Delta y_{3}</span>  can be determined by these 10 byte-parameters. By Proposition 1, part of the 24 byte-parameters in the Demirci and Selçuk distinguisher, i.e.  <span class="math">x_{3}</span> , can be determined.</p>

    <p class="text-gray-300">In this section, we present a unified view of the meet-in-the-middle attack, where  <span class="math">R</span>  rounds of block cipher can be split into three consecutive parts:  <span class="math">r_1</span> ,  <span class="math">r</span> , and  <span class="math">r_2</span> , such that a particular set of messages may verify a certain property that we denote  <span class="math">\\star</span>  in the sequel in the middle  <span class="math">r</span>  rounds as shown in Fig. 4.</p>

    <p class="text-gray-300">The general attack scheme uses two successive phases:</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 4. General scheme of meet-in-the-middle attack, where some messages in the middle rounds may verify a certain  <span class="math">\\star</span>  property used to perform the meet-in-the-middle method.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the precomputation phase, we build a lookup table  <span class="math">T</span>  containing all the possible sequences constructed from a 2-δ-set such that one message verifies a truncated differential trail.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the online phase, we need to identify a 2-δ-set containing a message  <span class="math">m</span>  verifying the desired property. This is done by using a large number of plaintexts and ciphertexts, and expecting that for each key candidate, there is one pair of plaintexts satisfying the truncated differential trail.</li>

      <li>Finally, we partially decrypt the associated 2-δ-set through the last  <span class="math">r_2</span>  rounds and check whether it belongs to  <span class="math">T</span> .</li>

    </ol>

    <p class="text-gray-300">In this section, we first propose a 6-round meet-in-the-middle distinguisher with differential enumeration technique and key-dependent sieve technique on Midori-64. Then, we apply this distinguisher to 10-round Midori-64 by adding 1 round at the beginning and 3 rounds at the end.</p>

    <p class="text-gray-300">Since  <span class="math">w_{6}[9] = z_{6}[8] \\oplus z_{6}[10] \\oplus z_{6}[11]</span>  and  <span class="math">w_{6}[10] = z_{6}[8] \\oplus z_{6}[9] \\oplus z_{6}[11]</span> , we have  <span class="math">w_{6}[9] \\oplus w_{6}[10] = z_{6}[9] \\oplus z_{6}[10]</span> . Let  <span class="math">e_{in} = z_{6}[9] \\oplus z_{6}[10]</span>  and  <span class="math">e_{out} = x_{7}[9] \\oplus x_{7}[10]</span> , then  <span class="math">e_{out} = e_{in} \\oplus rk_{6}[9] \\oplus rk_{6}[10]</span> , the 6-round distinguisher on Midori-64 is based on the proposition below.</p>

    <p class="text-gray-300">Proposition 5. Let  <span class="math">\\{w_0^0, w_0^1, \\dots, w_0^{255}\\}</span>  be a 2-δ-set where  <span class="math">w_0[5]</span>  and  <span class="math">w_0[10]</span>  are the active nibbles. Consider the encryption of the first 33 values  <span class="math">(w_0^0, w_0^1, \\dots, w_0^{33})</span>  of the 2-δ-set through 6-round Midori-64, in the case of that a message of the 2-δ-set belongs to a pair which conforms to the truncated differential trail outlined in Fig. 5, then the corresponding 128-bit ordered sequence  <span class="math">(e_{out}^1 \\oplus e_{out}^0, e_{out}^2 \\oplus e_{out}^0, \\dots, e_{out}^{32} \\oplus e_{out}^0)</span>  only takes about  <span class="math">2^{104}</span>  values (out of the  <span class="math">2^{128}</span>  theoretically values).</p>

    <p class="text-gray-300">Proof. As shown in Fig. 5, for the encryption of the first 33 values of the 2-δ-set, the output sequence  <span class="math">(e_{out}^{1} \\oplus e_{out}^{0}, e_{out}^{2} \\oplus e_{out}^{0}, \\dots, e_{out}^{32} \\oplus e_{out}^{0})</span>  is determined by</p>

    <p class="text-gray-300">the 42 nibble-parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$w_{0}[5,10]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{1}[5,10]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{2}[0,1,2,3]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{3}[1,2,3,4,5,6,8,10,11,12,13,15]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ (3)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">At round 1, since <span class="math">\\Delta x_{1}^{m}[5,10]=\\Delta w_{0}^{m}[5,10]</span> (<span class="math">0&lt;m\\leq 33</span>), we can get <span class="math">z_{1}[1,2]</span> by the knowledge of <span class="math">x_{1}[5,10]</span>. Since the ShuffleCell, MixColumn and KeyAdd operations are linear, <span class="math">\\Delta x_{2}^{m}[0,1,2,3]</span> can be got. Similarly, <span class="math">\\Delta y_{2}^{m}[0,1,2,3]</span> can be got by the knowledge of <span class="math">x_{2}[0,1,2,3]</span>, <span class="math">\\Delta y_{3}^{m}[1,2,3,4,5,6,8,10,11,12,13,15]</span> can be got by the knowledge of <span class="math">x_{3}[1,2,3,4,5,6,8,10,11,12,13,15]</span>, <span class="math">\\Delta y_{4}^{m}[0,1,2,3,5,6,7,8,9,</span> <span class="math">10,11,12,14,15]</span> can be got by the knowledge of <span class="math">x_{4}[0,1,2,3,5,6,7,8,9,10,11,12,</span> <span class="math">14,15]</span>, <span class="math">\\Delta y_{5}^{m}[0,2,5,8,10,13]</span> can be got by the knowledge of <span class="math">rk_{4}[0,2,5,8,10,13]</span>, and <span class="math">\\Delta z_{6}^{m}[9,10]</span> can be got by the knowledge of <span class="math">rk_{5}[3,12]</span>. Then we get the value of <span class="math">e_{in}^{m}\\oplus e_{in}^{0}</span>. Since <span class="math">e_{out}^{m}\\oplus e_{out}^{0}=e_{in}^{m}\\oplus e_{in}^{0}</span>, we can get (<span class="math">e_{out}^{1}\\oplus e_{out}^{0},e_{out}^{2}\\oplus</span> <span class="math">e_{out}^{0},\\cdots,e_{out}^{32}\\oplus e_{out}^{0}</span>).</p>

    <p class="text-gray-300">However, if a pair of messages conforms to the truncated differential trail outlined in Fig. 5, the above 42 nibble-parameters are determined by the 27 nibble-parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Delta z_{1}[1,2]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{2}[0,1,2,3]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{3}[1,2,3,4,5,6,8,10,11,12,13,15]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ (4)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since <span class="math">\\Delta z_{1}[1,2]</span> is known, we can get <span class="math">\\Delta x_{2}[0,1,2,3]</span>. Since <span class="math">\\Delta y_{2}[0,1,2,3]</span> can be got by the knowledge of <span class="math">x_{2}[0,1,2,3]</span>, we can get <span class="math">\\Delta x_{3}[1,2,3,4,5,6,8,10,11,12,13,</span> <span class="math">15]</span>, and <span class="math">\\Delta x_{4}[0,1,2,3,5,6,7,8,9,10,11,12,14,15]</span> can be got by the knowledge of <span class="math">x_{3}[1,2,3,4,5,6,8,10,11,12,13,15]</span>. For the backward direction, since <span class="math">\\Delta w_{6}[8]=\\Delta z_{6}[9]\\oplus\\Delta z_{6}[10]\\oplus\\Delta z_{6}[11]</span>, <span class="math">\\Delta z_{6}[11]=0</span> and <span class="math">\\Delta w_{6}[8]=0</span>, we can get that <span class="math">\\Delta z_{6}[9]=\\Delta z_{6}[10]</span>. For the same reason as the forward direction, <span class="math">\\Delta y_{4}[0,1,2,3,5,6,7,8,9,10,</span> <span class="math">11,12,14,15]</span> can be got by the knowledge of $y_{5}[0,2,5,8,10,13]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{6}[3,12]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta z_{6}[9]<span class="math">. According to Property 1, we get one value of intermediate state </span>x_{4}[0,1,2,3,5,6,7,<span class="math"> </span>8,9,10,11,12,14,15]<span class="math"> on average for the fixed difference </span>\\Delta x_{4}[0,1,2,3,5,6,7,8,9,<span class="math"> </span>10,11,12,14,15]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\Delta y_{4}[0,1,2,3,5,6,7,8,9,10,11,12,14,15]}<span class="math">. Apparently, </span>ru_{2}[0,7,<span class="math"> </span>9,14]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rk_{4}[0,2,5,8,10,13]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rk_{5}[3,12]<span class="math"> is also deduced for every 27 nibble-parameters. Since </span>z_{3}[13,14,15]<span class="math"> is known, </span>w_{3}[12]<span class="math"> can be got. Then </span>rk_{3}[12]<span class="math"> can be deduced for the reason that </span>rk_{3}[12]=x_{4}[12]\\oplus w_{3}[12]<span class="math">. According to the key-schedule of Midori-64, </span>rk_{3}[12]<span class="math"> and </span>rk_{5}[12]<span class="math"> are affected by the same nibble of </span>k_{1}<span class="math">. By the key-dependent sieve technique, there are </span>2^{104}$ possible values for the 27 nibble-parameters.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Since <span class="math">z_{3}[1,2,3]</span> and <span class="math">x_{4}[0,1,2,3]</span> are known, <span class="math">ru_{3}[1,2,3]</span> can be got. According to the key-schedule, <span class="math">rk_{3}[3]</span> can be got by the knowledge of <span class="math">rk_{5}[3]</span>. Since <span class="math">rk_{3}[3]=ru_{3}[0]\\oplus ru_{3}[1]\\oplus ru_{3}[2]</span>, <span class="math">ru_{3}[0]</span> can be got. Then <span class="math">rk_{3}[0,1,2,3]</span> can be got. After that, we can deduce <span class="math">rk_{1}[0,1,2,3]</span>. We can also deduce <span class="math">rk_{0}[5,10]</span> from <span class="math">rk_{4}[5,10]</span>. Therefore, we can get <span class="math">w_{0}[5,10]</span> and <span class="math">x_{1}[5,10]</span> from <span class="math">x_{2}[0,1,2,3]</span>.</p>

    <p class="text-gray-300">So the 42 nibble-parameters (3) are determined by 27 nibble-parameters (4), i.e. the sequence <span class="math">(e_{out}^{1}\\oplus e_{out}^{0},e_{out}^{2}\\oplus e_{out}^{0},\\cdots,e_{out}^{32}\\oplus e_{out}^{0})</span> can take about <span class="math">2^{104}</span> values.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">3.2 Attack on 10-Round Midori-64</p>

    <p class="text-gray-300">The attack is made up of two phase: precomputation phase and online phase.</p>

    <p class="text-gray-300">Precomputation phase: In the precomputation phase, we need to build a table that contains all the sequence <span class="math">(e^{1}_{out}\\oplus e^{0}_{out},e^{2}_{out}\\oplus e^{0}_{out},\\cdots,e^{32}_{out}\\oplus e^{0}_{out})</span> described in Proposition 6.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Guess $y_{6}[12]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{5}[2,8,13]<span class="math">, and compute </span>x_{6}[12]<span class="math"> and </span>w_{5}[12]<span class="math">. Deduce </span>rk_{5}[12]<span class="math"> from </span>x_{6}[12]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w_{5}[12]<span class="math">. Store </span>y_{5}[2,8,13]<span class="math"> in a table </span>T_{1}<span class="math"> with the index of </span>rk_{5}[12]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{6}[12]<span class="math">. There are about </span>2^{8}<span class="math"> values of </span>y_{5}[2,8,13]$ for each index.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each 48-bit <span class="math">ru_{3}[1,2,3,5,6,7,9,10,11,13,14,15]</span>, do the following steps.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Guess <span class="math">\\Delta z_{6}[9]</span>. Since <span class="math">\\Delta w_{6}[8]=\\Delta z_{6}[11]=0</span>, we can deduce <span class="math">\\Delta z_{6}[10]</span>. Deduce <span class="math">rk_{5}[12]</span> from <span class="math">ru_{3}[13,14,15]</span>. Guess $y_{6}[3,12]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{5}[0,5,10]<span class="math">, look up the table </span>T_{1}<span class="math"> to get about </span>2^{8}<span class="math"> values of </span>y_{5}[2,8,13]<span class="math"> by the index of </span>rk_{5}[12]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{6}[12]<span class="math">. Then compute </span>x_{5}[0,2,5,8,10,13]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta x_{5}[0,2,5,8,10,13]<span class="math">. Deduce </span>rk_{5}[3]<span class="math"> from </span>y_{6}[3]<span class="math"> and </span>y_{5}[0,5,10]<span class="math">, then deduce </span>rk_{1}[0,1,2,3]<span class="math"> from </span>rk_{5}[3]<span class="math"> and </span>ru_{3}[1,2,3]<span class="math">. Store </span>rk_{1}[0,1,2,3]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{5}[0,2,5,8,10,13]<span class="math"> in a table </span>T_{2}<span class="math"> with the index of </span>\\Delta x_{5}[0,2,5,8,10,13]<span class="math">. There are about </span>2^{8}$ values for each index.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. For each $\\Delta z_{1}[1,2]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">x_{2}[0,1,2,3]$, do the following sub-steps:</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Compute <span class="math">\\Delta y_{2}[0,1,2,3]</span> from <span class="math">\\Delta z_{1}[1,2]</span> and <span class="math">x_{2}[0,1,2,3]</span>. Then look up the table <span class="math">T_{3}</span> to get about <span class="math">2^{24}</span> values $x_{3}[1,2,3,4,5,6,8,10,11,12,13,15]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{4}[0,1,2,3,5,6,7,8,9,10,11,12,14,15]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w_{4}[0,2,5,8,10,13]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta x_{5}[0,2,<span class="math"> </span>5,8,10,13]<span class="math">. For each of these values, look up the table </span>T_{2}<span class="math"> to get about </span>2^{8}<span class="math"> values </span>rk_{1}[0,1,2,3]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{5}[0,2,5,8,10,13]<span class="math">. Deduce </span>rk_{4}[0,2,5,8,10,13]<span class="math"> from </span>x_{5}[0,2,5,8,10,13]<span class="math"> and </span>w_{4}[0,2,5,8,10,13]<span class="math">, then deduce </span>rk_{0}[5,10]<span class="math"> from </span>rk_{4}[5,10]<span class="math">. Compute </span>x_{1}[5,10]<span class="math"> from </span>rk_{1}[0,1,2,3]<span class="math"> and </span>x_{2}[0,1,2,3]<span class="math">, then compute </span>w_{0}[5,10]<span class="math"> from </span>x_{1}[5,10]<span class="math"> and </span>rk_{0}[5,10]$. Therefore, we get the 42 nibble-parameters (3).</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. We build two tables <span class="math">T_{5}^{0}</span> and <span class="math">T_{5}^{2}</span> for online phase. As shown in Fig. 6, for column 0, guess $\\Delta C[0,1,2,3]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">\\Delta z_{8}[0,1]<span class="math">, and deduce </span>\\Delta x_{9}[0,1,2,3]<span class="math"> and </span>\\Delta y_{9}[0,1,<span class="math"> </span>2,3]<span class="math">. By Proposition 1, we can deduce </span>y_{9}[0,1,2,3]<span class="math">. Guess </span>C[1,3]<span class="math">, </span>rk_{9}[1,3]<span class="math"> can be got. One can deduce </span>rk_{-1}[1,3]<span class="math"> from </span>rk_{9}[1,3]<span class="math">, and store </span>x_{9}[0,1,2,3]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">\\Delta z_{8}[0,<span class="math"> </span>1]<span class="math"> in a table </span>T_{5}^{0}<span class="math"> with the index of </span>rk_{-1}[1,3]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">\\Delta C[0,1,2,3]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">C[1,3]<span class="math">. There is one value for each index in average. Similarly, we can get a table </span>T_{5}^{2}$ for column 2.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. We build a table <span class="math">T_{6}</span> for online phase. Guess $x_{7}[9,10]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\Delta x_{7}[9]}<span class="math">, one can deduce </span>{\\Delta y_{7}[9,10]}<span class="math"> and </span>y_{7}[9,10]<span class="math"> since </span>{\\Delta x_{7}[9]}={\\Delta x_{7}[10]}<span class="math">. Then </span>{\\Delta x_{8}[0,2,3,9,10,11]}<span class="math"> can be deduced. Guess </span>{\\Delta y_{8}[0,2,3,9,10,11]}<span class="math">, then </span>x_{8}[0,2,3,9,10,11]<span class="math"> and </span>y_{8}[0,<span class="math"> </span>2,3,9,10,11]<span class="math"> can be deduced by Proposition 1. Deduce </span>ru_{7}[1,8]<span class="math"> from </span>x_{7}[9,10]<span class="math"> and </span>x_{8}[0,2,3,9,10,11]<span class="math">, and deduce </span>ru_{8}[1,8]\\oplus ru_{9}[1,8]<span class="math"> from </span>ru_{7}[1,8]<span class="math">. Let </span>\\chi<span class="math"> denote </span>z_{8}[1,8]\\oplus ru_{8}[1,8]\\oplus ru_{9}[1,8]<span class="math">. Store </span>y_{8}[0,2,3,9,10,11]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ru_{7}[1,8]<span class="math"> in a table </span>T_{6}<span class="math"> with the index of </span>\\chi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\Delta z_{8}[0,1,6,8,9,14]}<span class="math">. There are </span>2^{4}$ values for each index.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Online phase: In the online phase of the attack, we first find at least one pair which satisfies the truncated differential trail in Fig. 5. To find the right pair, instead of guessing the sub-keys and checking whether this pair satisfy the truncated differential trail, we deduce the sub-keys which make it satisfy the truncated differential trail for each pair. Then we identify the 2-<span class="math">\\delta</span>-set, caculate the sequence <span class="math">(e_{out}^{1}\\oplus e_{out}^{0},e_{out}^{2}\\oplus e_{out}^{0},\\cdots,e_{out}^{32}\\oplus e_{out}^{0})</span> and check whether it belongs to the table <span class="math">T_{4}</span>. Finally, we use $ru_{2}[0,9,14]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ru_{3}[1]$ to filter the reminding keys and retrieve the correct key.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define a structure of <span class="math">2^{24}</span> plaintexts where <span class="math">P[1,3,6,9,11,14]</span> take all the possible values, and the remaining 10 nibbles are fixed to some constants. Hence, we can generate <span class="math">2^{24}\\times(2^{24}-1)/2\\approx 2^{47}</span> pairs satisfying the plaintext difference. Choose <span class="math">2^{29}</span> structures to get about <span class="math">2^{29+47}=2^{76}</span> pairs. As shown in Fig. 6, the probability to get the truncated differential trail in the forward and backward direction is <span class="math">2^{(2-6+1-16)\\times 4}=2^{-76}</span>, then about 1 pair follows the truncated differential trail for each guess of the key. Among the <span class="math">2^{76}</span> pairs, we expect about <span class="math">2^{76-8}=2^{68}</span> pairs to verify that <span class="math">{\\Delta C}[6,14]=0</span>.</li>

      <li>For each of the <span class="math">2^{68}</span> remaining pairs, we do the following sub-steps.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Guess <span class="math">{\\Delta w_{0}[5,10]}</span>, and deduce <span class="math">{\\Delta y_{0}[1,3,6,9,11,14]}</span>. According to Proposition 1, <span class="math">x_{0}[1,3,6,9,11,14]</span> can be got from <span class="math">{\\Delta y_{0}[1,3,6,9,11,14]}</span> and <span class="math">{\\Delta P}[1,3,6,9,11,14]</span>. Then <span class="math">rk_{-1}[1,3,6,9,11,14]</span> can be got.</li>

      <li>For each of the <span class="math">2^{8}</span> deduced sub-key in 1, encrypt the plaintext pair and get the value <span class="math">w_{0}[4,6,7,8,9,11]</span>. Change the value of <span class="math">w_{0}[5,10]</span> to be <span class="math">(0,1,\\cdots,32)</span> and compute their corresponding plaintexts <span class="math">(P^{0},P^{1},\\cdots,</span> <span class="math">P^{32})</span>, then get the corresponding ciphertexts.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. For each of the deduced <span class="math">rk_{-1}[1,3,6,9,11,14]</span>, compute <span class="math">rk_{9}[1,3]</span> (resp. <span class="math">rk_{9}[9,11]</span>). Look up the table <span class="math">T_{5}^{0}</span> (resp. <span class="math">T_{5}^{2}</span>) to get about one value $x_{9}[0,1,2,3]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\Delta z_{8}[0,1]}<span class="math"> (resp. </span>x_{9}[8,9,10,11]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\Delta z_{8}[8,9]}<span class="math">) with the index of </span>rk_{-1}[1,3]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\Delta C}[0,1,2,3]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C[1,3]<span class="math"> (resp. </span>rk_{-1}[9,11]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\Delta C}[8,9,10,11]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C[9,<span class="math"> </span>11]<span class="math">). Deduce </span>rk_{9}[0,2]<span class="math"> (resp. </span>rk_{9}[8,10]$) from the ciphertext.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Guess <span class="math">{\\Delta z_{8}[6,14]}</span>, and deduce <span class="math">{\\Delta x_{9}[4,5,7,12,13,15]}</span>. Then <span class="math">rk_{9}[4,5,7,12,</span> <span class="math">13,15]</span> and <span class="math">x_{9}[4,5,7,12,13,15]</span> can be got. Deduce <span class="math">ru_{9}[1,8]</span> from <span class="math">rk_{9}[0,2,</span> <span class="math">3,9,10,11]</span>, and deduce <span class="math">\\overline{w_{8}}[1,8]</span> from <span class="math">x_{9}[0,2,3,9,10,11]</span>. Then we can get <span class="math">\\chi^{\\prime}=ru_{9}[1,8]\\oplus\\overline{w_{8}}[1,8]</span>, i.e. <span class="math">\\chi^{\\prime}=z_{8}[1,8]\\oplus ru_{8}[1,8]\\oplus ru_{9}[1,8]</span>. Look up the</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">table <span class="math">T_{6}</span> to get about <span class="math">2^{4}</span> values $y_{8}[0,2,3,9,10,11]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ru_{7}[1,8]<span class="math"> with the index of </span>\\chi^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta z_{8}[0,1,6,8,9,14]<span class="math">. Deduce </span>ru_{8}[0,1,6,8,9,14]<span class="math"> from </span>y_{8}[0,2,3,9,10,<span class="math"> </span>11]<span class="math"> and </span>x_{9}[0,1,2,3,4,5,7,8,9,10,11,12,13,15]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the end, there are about <span class="math">2^{22\\times 4-40}=2^{44}</span> sub-keys remaining. Then exhaustively search for the <span class="math">2^{44}</span> sub-keys and <span class="math">10</span> unknown key-nibbles to recover the master key.</li>

    </ol>

    <p class="text-gray-300">Complexity analysis. In the precomputation phase, in order to construct <span class="math">T_{4}</span>, we need to perform <span class="math">2^{104}</span> partial encryptions on <span class="math">33</span> messages. The time complexity of this phase is about <span class="math">2^{104+5-2}=2^{107}</span> 10-round Midori-64 encryptions, the memory complexity is about <span class="math">2^{104+7.2-6}=2^{105.2}</span> 64-bit blocks. In the online phase, we need to perform <span class="math">2^{20+68}</span> partial encryptions on <span class="math">33</span> messages. The time complexity of this phase is about <span class="math">2^{88+5-3}=2^{90}</span> 10-round Midori-64 encryptions, the data complexity is <span class="math">2^{24+29}=2^{53}</span> chosen-plaintexts and the memory complexity is <span class="math">2^{53}</span> 64-bit blocks. With data/time/memory tradeoff, the adversary only need to precompute a fraction of <span class="math">2^{-8.5}</span> of possible sequences, then the time complexity becomes <span class="math">2^{107-8.5}=2^{98.5}</span>, the memory complexity becomes <span class="math">2^{96.7}</span> 64-bit blocks. But in the online phase , the adversary will repeat the attack <span class="math">2^{8.5}</span> times to offset the probability of the failure. So the data complexity increases to <span class="math">2^{61.5}</span> chosen-plaintexts, and the time complexity increases to <span class="math">2^{90+8.5}=2^{98.5}</span>. Otherwise, we can divide the whole attack into series of weak-key attacks according to the relations between the subkeys in the online phase and the precomputation phase as Li et al. presented in <em>[13]</em>. Using the relation of <span class="math">ru_{3}[1]</span> (step 2 in the precomputation phase) and <span class="math">ru_{7}[1]</span> (step 4 in the precomputation phase and step 2(d) in the online phase), the attack can be divided into <span class="math">2^{4}</span> weak-key attacks. The memory complexity can be reduced by a fraction of <span class="math">2^{-4}</span>. In total, the time complexity of this attack is <span class="math">2^{99.5}</span> 10-round Midori-64 encryptions, the data complexity is <span class="math">2^{61.5}</span> chosen-plaintexts and the memory complexity is <span class="math">2^{92.7}</span> 64-bit blocks.</p>

    <h2 id="sec-16" class="text-2xl font-bold">4 Attack on 11-Round Midori-64</h2>

    <p class="text-gray-300">Based on the 10-round attack, we can add one round at the end to mount an 11-round attack on Midori-64.</p>

    <p class="text-gray-300">The precomputation is almost the same as the 10-round attack except the following steps.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. At step 3, we need to build four tables <span class="math">T_{5}^{i}</span> (<span class="math">i=0,\\cdots,3</span>). As shown in Fig. 7, for column 0, guess $\\Delta C[0,1,2,3]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta z_{9}[0,1,2,3]<span class="math">, and deduce </span>\\Delta x_{10}[0,1,2,3]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and <span class="math">\\Delta y_{10}[0,1,2,3]</span>. By Proposition 1, we can deduce <span class="math">y_{10}[0,1,2,3]</span>. Guess <span class="math">C[1,3]</span>, <span class="math">rk_{10}[1,3]</span> can be got. One can deduce <span class="math">rk_{-1}[1,3]</span> from <span class="math">rk_{10}[1,3]</span>, and store $x_{10}[0,1,2,3]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\Delta z_{9}[0,1,2,3]}<span class="math"> in a table </span>T_{5}^{0}<span class="math"> with the index of </span>rk_{-1}[1,3]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\Delta C[0,1,2,3]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C[1,3]}<span class="math">. There are </span>2^{8}<span class="math"> values for each index in average. Similarly, we can get one table </span>T_{5}^{i}<span class="math"> for column </span>i<span class="math"> (</span>i=1,\\cdots,3<span class="math">), and there are </span>2^{8}$ values for each index in each table.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. Besides, we need to build two more tables for online phase. For all 28-bit sub-keys <span class="math">ru_{9}[0,2,5,7,9,12,14]</span>, decrypt all 28-bit values <span class="math">\\overline{w_{9}}[0,2,5,7,9,12,14]</span> and obtain <span class="math">\\overline{w_{8}}[0,1,6]</span>. Store <span class="math">\\overline{w_{8}}[0,1,6]</span> with the index of $ru_{9}[0,2,5,7,9,12,14]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math"> </span>\\overline{w_{9}}[0,2,5,7,9,12,14]<span class="math"> in a table </span>T_{8}^{0}<span class="math">. For all 28-bit sub-keys </span>ru_{9}[1,3,6,8,10,13,<span class="math"> </span>15]<span class="math">, decrypt all 28-bit values </span>\\overline{w_{9}}[1,3,6,8,10,13,15]<span class="math"> and obtain </span>\\overline{w_{8}}[8,9,14]<span class="math">. Store </span>\\overline{w_{8}}[8,9,14]<span class="math"> with the index of </span>ru_{9}[1,3,6,8,10,13,15]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">{\\overline{w_{9}}[1,3,6,8,10,13,}<span class="math"> </span>15]<span class="math"> in a table </span>T_{8}^{1}$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The online phase is different from the 10-round attack at step 2(c), 2(d) and 2(e). And since all nibbles of ciphertext are active, we should try all the <span class="math">2^{76}</span> pairs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. At step 2(c), for each of the deduced <span class="math">rk_{-1}[1,3]</span>, compute <span class="math">rk_{10}[1,3]</span>. Look up the table <span class="math">T_{5}^{0}</span> to get about <span class="math">2^{8}</span> values $x_{10}[0,1,2,3]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\Delta z_{9}[0,1,2,3]}<span class="math"> with the index of </span>rk_{-1}[1,3]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\Delta C[0,1,2,3]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C[1,3]}<span class="math">. Deduce </span>rk_{10}[0,2]<span class="math"> from the ciphertext. Do the same things to column </span>i<span class="math"> and </span>T_{5}^{i}<span class="math"> (</span>i=1,2,3<span class="math">), and deduce about </span>2^{32}<span class="math"> values </span>rk_{10}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{10}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\Delta z_{9}[0,}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">1,2,3,5,6,7,8,9,10,12,13,14,15]</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. At step 2(d), deduce <span class="math">ru_{10}[0,1,6,8,9,14]</span> from <span class="math">rk_{10}</span>, and deduce <span class="math">\\overline{w_{9}}[0,1,6,8,9,</span> <span class="math">14]</span> from <span class="math">x_{10}</span>. Then we can get <span class="math">\\chi^{\\prime}=ru_{10}[0,1,6,8,9,14]\\oplus\\overline{w_{9}}[0,1,6,8,9,14]</span>, i.e. <span class="math">\\chi^{\\prime}=z_{9}[0,1,6,8,9,14]\\oplus ru_{9}[0,1,6,8,9,14]\\oplus ru_{10}[0,1,6,8,9,14]</span>. Look up the table <span class="math">T_{6}</span> to get about <span class="math">2^{4}</span> values $y_{9}[0,1,2,3,4,5,7,8,9,10,11,12,13,15]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> </span>ru_{7}[1,8]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ru_{8}[0,1,6,8,9,14]<span class="math"> with the index of </span>ru_{10}[1,8]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\chi^{\\prime}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\Delta z_{9}[0,1,2,3,5,6,}<span class="math"> </span>7,8,9,10,12,13,14,15]<span class="math">. Deduce </span>ru_{9}[0,1,2,3,5,6,7,8,9,10,12,13,14,15]<span class="math"> from </span>y_{9}[0,1,2,3,4,5,7,8,9,10,11,12,13,15]<span class="math"> and </span>x_{10}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the corresponding ciphertexts we made in (b) and get <span class="math">(e^{1}_{out}\\oplus e^{0}_{out},e^{2}_{out}\\oplus e^{0}_{out},\\cdots,e^{32}_{out}\\oplus e^{0}_{out})</span> using <span class="math">T_{7}</span>, <span class="math">T^{0}_{8}</span> and <span class="math">T^{1}_{8}</span>. Check whether it lies in the precomputation table <span class="math">T_{4}</span>. If not, try another one. If so, we check whether $ru_{2}[0,9,14]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ru_{3}[1]<span class="math"> matches </span>ru_{8}[0,9,14]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ru_{7}[1]<span class="math">. So the probability for a wrong sub-key to pass this test is </span>2^{-24-16}=2^{-40}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Complexity analysis. The time complexity of the precomputation phase is the same as the 10-round attack. In the online phase, we need to perform <span class="math">2^{44+76}</span> partial encryptions on 33 messages. The time complexity of this phase is about <span class="math">2^{120+5-3}=2^{122}</span> 11-round Midori-64 encryptions, the data complexity is <span class="math">2^{24+29}=2^{53}</span> chosen-plaintexts and the memory complexity is <span class="math">2^{53}</span> 64-bit blocks. Otherwise, we can divide the whole attack into series of weak-key attacks according to the relations between the subkeys in the online phase and the precomputation phase as Li et al. presented in <em>[13]</em>. Using the relation of $ru_{2}[0,9,14]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ru_{3}[1]<span class="math"> (precomputation phase) and </span>ru_{8}[0,9,14]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ru_{7}[1]<span class="math"> (online phase), the attack can be divided into </span>2^{16}<span class="math"> weak-key attacks. The memory complexity can be reduced by a fraction of </span>2^{-16}<span class="math">. In total, the time complexity of this attack is </span>2^{122}<span class="math"> 11-round Midori-64 encryptions, the data complexity is </span>2^{53}<span class="math"> chosen-plaintexts and the memory complexity is </span>2^{89.2}$ 64-bit blocks.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-17" class="text-2xl font-bold">5 Attack on 12-round Midori-64</h2>

    <p class="text-gray-300">In this section, we first propose a 7-round meet-in-the-middle distinguisher with differential enumeration technique and key-dependent sieve technique on Midori-64. Then, we apply this distinguisher to 12-round Midori-64 by adding 1 round at the beginning and 4 rounds at the end.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">5.1 7-Round Distinguisher on Midori-64</h3>

    <p class="text-gray-300">Since <span class="math">w_{7}[5]=z_{7}[4]\\oplus z_{7}[6]\\oplus z_{7}[7]</span> and <span class="math">w_{7}[6]=z_{7}[4]\\oplus z_{7}[5]\\oplus z_{7}[7]</span>, we have <span class="math">w_{7}[5]\\oplus w_{7}[6]=z_{7}[5]\\oplus z_{7}[6]</span>. Let <span class="math">e_{in}=z_{7}[5]\\oplus z_{7}[6]</span> and <span class="math">e_{out}=x_{8}[5]\\oplus x_{8}[6]</span>, then <span class="math">e_{out}=e_{in}\\oplus rk_{7}[5]\\oplus rk_{7}[6]</span>, the 7-round distinguisher on Midori-64 is based on the proposition below.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Proposition 6.</h6>

    <p class="text-gray-300">Let <span class="math">\\{w^{0}_{0},w^{1}_{0},\\cdots,w^{255}_{0}\\}</span> be a 2-<span class="math">\\delta</span>-set where <span class="math">w_{0}[5]</span> and <span class="math">w_{0}[10]</span> are the active nibbles. Consider the encryption of the first 33 values <span class="math">(w^{0}_{0},w^{1}_{0},\\cdots,w^{33}_{0})</span> of the 2-<span class="math">\\delta</span>-set through 7-round Midori-64, in the case of that a message of the <span class="math">2</span>-<span class="math">\\delta</span>-set belongs to a pair which conforms to the truncated differential trail outlined in Fig. 8(a), then the corresponding 128-bit ordered sequence <span class="math">(e^{1}_{out}\\oplus e^{0}_{out},e^{2}_{out}\\oplus e^{0}_{out},\\cdots,e^{32}_{out}\\oplus e^{0}_{out})</span> only takes about <span class="math">2^{124}</span> values (out of the <span class="math">2^{128}</span> theoretically values).</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">As shown in Fig. 8(a), for the encryption of the first 33 values of the <span class="math">2</span>-<span class="math">\\delta</span>-<span class="math">set</span>, the output sequence <span class="math">(e^{1}_{out}\\oplus e^{0}_{out},e^{2}_{out}\\oplus e^{0}_{out},\\cdots,e^{32}_{out}\\oplus e^{0}_{out})</span> is determined</p>

    <p class="text-gray-300">by the 58 nibble-parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$w_{0}[5,10]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{1}[5,10]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{2}[0,1,2,3]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{3}[1,2,3,4,5,6,8,10,11,12,13,15]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{4}$ (5)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">However, if a pair of messages conforms to the truncated differential trail outlined in Fig. 8(a), the above 58 nibble-parameters are determined by the 41 nibble-parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Delta z_{1}[1,2]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{2}[0,1,2,3]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{3}[1,2,3,4,5,6,8,10,11,12,13,15]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ (6)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Meanwhile, $ru_{2}[0,7,9,14]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ru_{3}[1,2,3,5,6,7,9,10,11,13,14,15]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rk_{4}[0,1,2,3,<span class="math"> </span>4,5,6,8,9,10,11,12,13,15]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rk_{5}[1,3,4,9,11,12]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rk_{6}[4,11]<span class="math"> can be determined by the above 41 nibble-parameters. Since </span>ru_{4}[0,7,9,14]<span class="math"> can be deduced from </span>rk_{4}[0,<span class="math"> </span>1,2,3,4,5,6,8,9,10,11,12,13,15]<span class="math">, </span>rk_{3}[4,12]<span class="math"> can de deduced from </span>ru_{3}[5,6,7,13,<span class="math"> </span>14,15]<span class="math"> and </span>rk_{3}[3,11]<span class="math"> can be deduced from </span>ru_{3}[1,2,3,9,10,11]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ru_{5}[1,9]<span class="math">, according to the key-schedule of Midori-64, </span>ru_{2}[0,7,9,14]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rk_{3}[3,4,11,12]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rk_{6}[4,11]<span class="math"> and </span>ru_{4}[0,7,9,14]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rk_{5}[3,4,11,12]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rk_{4}[4,11]<span class="math"> are affected by the same nibbles of the master key. By the key-dependent sieve technique, there are </span>2^{124}$ possible values for the 41 nibble-parameters.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">So the 58 nibble-parameters (5) are determined by 41 nibble-parameters (6), i.e. the sequence <span class="math">(e_{out}^{1}\\oplus e_{out}^{0},e_{out}^{2}\\oplus e_{out}^{0},\\cdots,e_{out}^{32}\\oplus e_{out}^{0})</span> can take about <span class="math">2^{124}</span> values.</p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">5.2 12-Round Attack on Midori-64</h3>

    <p class="text-gray-300">The attack is made up of two phase: precomputation phase and online phase.</p>

    <p class="text-gray-300">Precomputation phase: In the precomputation phase, we need to build a table that contains all the sequence <span class="math">(e_{out}^{1}\\oplus e_{out}^{0},e_{out}^{2}\\oplus e_{out}^{0},\\cdots,e_{out}^{32}\\oplus e_{out}^{0})</span> described in Proposition 6.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. For each 120-bit value $\\Delta z_{2}[0,7,9,14]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta w_{4}[0,1,2,3,4,5,6,8,9,10,11,12,13,<span class="math"> </span>15]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ru_{3}[1,2,3,5,6,7,9,10,11,13,14,15]<span class="math">, deduce </span>x_{3}[1,2,3,4,5,6,8,10,11,12,<span class="math"> </span>13,15]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y_{4}<span class="math"> by Proposition 3. Compute </span>\\overline{w_{2}}[0,7,9,14]<span class="math"> and </span>z_{4}[0,7,9,14]<span class="math">, and let </span>\\varsigma_{1}=\\overline{w_{2}}[0,7,9,14]\\oplus z_{4}[0,7,9,14]<span class="math">. Deduce </span>rk_{3}[4,12]<span class="math"> from </span>ru_{3}[5,6,7,13,<span class="math"> </span>14,15]<span class="math">, and let </span>\\varsigma_{2}=rk_{3}[4,12]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ru_{3}[1,9]\\oplus ru_{3}[3,11]<span class="math">. Store </span>x_{3}[1,2,3,4,5,6,<span class="math"> </span>8,10,11,12,13,15]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{4}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w_{4}[0,1,2,3,4,5,6,8,9,10,11,12,13,15]<span class="math"> in a table </span>T_{1}<span class="math"> with the index of </span>w_{4}[4,11]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varsigma_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varsigma_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta z_{2}[0,7,9,14]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta w_{4}[0,1,2,3,4,5,6,8,9,10,<span class="math"> </span>11,12,13,15]<span class="math">. There are </span>2^{8}$ values for each index.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. For each 24-bit value $\\Delta z_{1}[1,2]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\Delta y_{2}[0,1,2,3]}<span class="math">, deduce </span>y_{2}[0,1,2,3]<span class="math">. Store </span>y_{2}[0,1,<span class="math"> </span>2,3]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\Delta z_{2}[0,7,9,14]}<span class="math"> in a table </span>T_{3}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each value of table <span class="math">T_{2}</span> and <span class="math">T_{3}</span>, do the following steps.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Compute <span class="math">w_{4}[4,11]</span> from <span class="math">rk_{5}[4,11]</span> and <span class="math">x_{5}[4,11]</span>, and compute <span class="math">\\varsigma_{1}^{\\prime}=z_{2}[0,7,</span> <span class="math">9,14]\\oplus\\overline{w_{4}}[0,7,9,14]</span> from <span class="math">y_{2}[0,1,2,3]</span> and <span class="math">x_{5}[0,1,2,3,4,5,6,8,9,10,11,</span> <span class="math">12,13,15]</span>. Deduce $\\varsigma_{2}^{\\prime}=rk_{3}[4,12]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ru_{3}[1,9]\\oplus ru_{3}[3,11]<span class="math"> from </span>rk_{5}[1,3,4,9,<span class="math"> </span>11,12]<span class="math">. Look up the table </span>T_{1}<span class="math"> to get about </span>2^{8}<span class="math"> values of </span>x_{3}[1,2,3,4,5,6,8,<span class="math"> </span>10,11,12,13,15]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{4}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w_{4}[0,1,2,3,4,5,6,8,9,10,11,12,13,15]<span class="math"> with the index of </span>w_{4}[4,11]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\varsigma_{1}^{\\prime}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\varsigma_{2}^{\\prime}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\Delta z_{2}[0,7,9,14]}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\Delta w_{4}[0,1,2,3,4,5,6,8,9,10,11,12,13,15]}<span class="math">. Deduce </span>rk_{4}[0,1,2,3,4,5,6,8,9,10,11,12,13,15]<span class="math">, </span>rk_{1}[0,1,2,3]<span class="math"> and </span>rk_{0}[5,10]<span class="math">, then deduce </span>x_{1}[5,10]<span class="math"> and </span>w_{0}[5,10]$. Therefore, we get the 58 nibble-parameters (5).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The online phase and the construction of tables <span class="math">T_{5}^{i}</span> (<span class="math">i=0,\\cdots,3</span>), <span class="math">T_{6}</span>, <span class="math">T_{7}</span>, <span class="math">T_{8}^{0}</span> and <span class="math">T_{8}^{1}</span> are almost the same as the 11-round attack except the position of nibbles. The procedure of this phase is shown in Fig. 8(b).</p>

    <p class="text-gray-300">Therefore, the time complexity of the precomputation phase is <span class="math">2^{124+5-2}=2^{127}</span> 12-round Midori-64 encryptions, the memory complexity is <span class="math">2^{124+7.2-6}=2^{125.2}</span> 64-bit blocks. The time complexity of the online phase is about <span class="math">2^{120+5-3}=2^{122}</span> 12-round Midori-64 encryptions, the data complexity is <span class="math">2^{24+29}=2^{53}</span> chosen-plaintexts and the memory complexity is <span class="math">2^{53}</span> 64-bit blocks. By data/time/memory tradeoff and weak-key attacks, the time complexity of this attack is about <span class="math">2^{125.5}</span> 12-round Midori-64 encryptions, the data complexity is <span class="math">2^{55.5}</span> chosen-plaintexts and the memory complexity is <span class="math">2^{106}</span> 64-bit blocks.</p>

    <h2 id="sec-22" class="text-2xl font-bold">6 Conclusions and Further Work</h2>

    <p class="text-gray-300">In this paper, we discussed the security of Midori-64 against meet-in-the-middle attacks. Using the differential enumeration technique and key-dependent sieve technique, we proposed a 6-round meet-in-the-middle distinguisher on Midori-64. Based on this distinguisher, we added 1 round at the beginning and 3 rounds at the end to present a 10-round attack with time complexity of <span class="math">2^{99.5}</span> 10-round Midori-64 encryptions, data complexity of <span class="math">2^{61.5}</span> chosen-plaintexts and memory complexity of <span class="math">2^{92.7}</span> 64-bit blocks. After that, by adding one round at the end, we got an 11-round attack with time complexity of <span class="math">2^{122}</span> 11-round Midori-64 encryptions, data complexity of <span class="math">2^{53}</span> chosen-plaintexts and memory complexity of <span class="math">2^{89.2}</span> 64-bit blocks. Finally, with a 7-round distinguisher, we got an attack on 12-round Midori-64 with time complexity of <span class="math">2^{125.5}</span> 12-round Midori-64 encryptions, data complexity of <span class="math">2^{55.5}</span> chosen-plaintexts and memory complexity of <span class="math">2^{106}</span> 64-bit blocks.</p>

    <p class="text-gray-300">There are many further works possible: the way to apply this kind of attacks to Midori-128, the way to get better attack complexity with meet-in-the-middle method and the security level against other cryptanalytic methods (e.g. impossible differential and zero-correlation linear) for Midori.</p>

    <h2 id="sec-23" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">The research presented in this paper is supported by the National Basic Research Program of China (No. 2013CB338002) and National Natural Science Foundation of China (No. 61272476, No.61232009 and No. 61202420).</p>

    <h2 id="sec-24" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Subhadeep Banik, Andrey Bogdanov, Takanori Isobe, Kyoji Shibutani, Harunaga Hiwatari, Toru Akishita, and Francesco Regazzoni. Midori: A Block Cipher for Low Energy (Extended Version). Cryptology ePrint Archive, Report 2015/1142, 2015. http://eprint.iacr.org/.</li>

      <li>[2] Andrey Bogdanov, Lars R Knudsen, Gregor Leander, Christof Paar, Axel Poschmann, Matthew JB Robshaw, Yannick Seurin, and Charlotte Vikkelsoe. PRESENT: An Ultra-Lightweight Block Cipher. Springer, 2007.</li>

      <li>[3] Julia Borghoff, Anne Canteaut, Tim Gneysu, Elif Bilge Kavun, Miroslav Knezevic, Lars R. Knudsen, Gregor Leander, Ventzislav Nikov, Christof Paar, and Christian Rechberger. PRINCE C A Low-Latency Block Cipher for Pervasive Computing Applications. Springer Berlin Heidelberg, 2012.</li>

      <li>[4] Joan Daemen and Vincent Rijmen. The Design of Rijndael: AES-the Advanced Encryption Standard. Springer, 2002.</li>

      <li>[5] Joan Daemen and Vincent Rijmen. Understanding two-round differentials in aes. In Security and Cryptography for Networks, pages 78–94. Springer, 2006.</li>

      <li>[6] Hüseyin Demirci and Ali Aydın Selçuk. A Meet-In-the-Middle Attack on 8-Round AES. In Fast Software Encryption, pages 116–126. Springer, 2008.</li>

      <li>[7] Hüseyin Demirci, İhsan Taşkın, Mustafa Çoban, and Adnan Baysal. Improved Meet-in-the-Middle Attacks on AES. In Progress in Cryptology-INDOCRYPT 2009, pages 144–156. Springer, 2009.</li>

      <li>[8] Patrick Derbez, Pierre-Alain Fouque, and Jérémy Jean. Improved Key Recovery Attacks on Reduced-Round AES in the Single-Key Setting. In Advances in Cryptology–EUROCRYPT 2013, pages 371–387. Springer, 2013.</li>

      <li>[9] Whitfield Diffie and Martin E Hellman. Special Feature Exhaustive Cryptanalysis of the NBS Data Encryption Standard. Computer, 10(6):74–84, 1977.</li>

      <li>[10] Orr Dunkelman, Nathan Keller, and Adi Shamir. Improved Single-Key Attacks on 8-Round AES-192 and AES-256. In Advances in Cryptology-ASIACRYPT 2010, pages 158–176. Springer, 2010.</li>

      <li>[11] Henri Gilbert and Marine Minier. A Collisions Attack on the 7-Rounds Rijndael. In In AES Candidate Conference. Citeseer, 2000.</li>

      <li>[12] Leibo Li, Keting Jia, and Xiaoyun Wang. Improved Meet-in-the-Middle Attacks on AES-192 and PRINCE. IACR Cryptology ePrint Archive, 2013:573, 2013.</li>

      <li>[13] Leibo Li, Keting Jia, Xiaoyun Wang, et al. Improved Single-Key Attacks on 9-Round AES-192/256. In FSE 2014 (21st International Workshop on Fast Software Encryption), 2014.</li>

    </ul>

    <p class="text-gray-300">14] Rongjia Li and Chenhui Jin. Meet-in-the-Middle Attacks on 10-Round AES-256. Designs, Codes and Cryptography, pages 1–13, 2015.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[15] Li Lin, Wenling Wu, Yanfeng Wang, and Lei Zhang. General Model of the Single-Key Meet-in-the-Middle Distinguisher on the Word-oriented Block Cipher. In Information Security and Cryptology–ICISC 2013, pages 203–223. Springer, 2014.</li>

      <li>[16] Tomoyasu Suzaki, Kazuhiko Minematsu, Sumio Morioka, and Eita Kobayashi. TWINE: A Lightweight Block Cipher for Multiple Platforms. In Selected Areas in Cryptography, pages 339–354. Springer, 2013.</li>

      <li>[17] Wenling Wu and Lei Zhang. Lblock: A Lightweight Block Cipher. In Applied Cryptography and Network Security, pages 327–344. Springer, 2011.</li>

    </ul>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 5. The truncated differential trail of 6-round Midori-64.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 6. Online phase of the attack on 10-round Midori-64.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Fig. 7. Online phase of the attack on 11-round Midori-64.</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Fig. 8. The attack on 12-round Midori-64. The 7-round distinguisher is shown in (a), the online phase is shown in (b).</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a></p>`;
---

<BaseLayout title="Meet-in-the-Middle Attacks on Reduced-Round  Midori-64 (2015/1165)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2015 &middot; eprint 2015/1165
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
