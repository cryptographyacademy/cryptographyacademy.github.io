---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/187';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'FFT-Based Key Recovery for the Integral Attack';
const AUTHORS_HTML = 'Yosuke Todo';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">The integral attack is one of the most powerful attack against block ciphers. In this paper, we propose two new techniques for the integral attack, the FFT technique and the key concealment technique. The FFT technique is useful for the integral attack with enormous chosen plaintexts. As the previous result using FFT, Collard et al. showed a new technique which reduces the complexity for the linear attack. In this paper, we review the result of Collard et al. to estimate the complexity in detail, and we show the complexity can be estimated from the number of times using the addition of integers. Moreover, we show that attacks using FFT can be applied to the integral attack. As applications, we show integral attacks against AES and CLEFIA. For AES, we show that 6-round AES can be attacked with about $2^{51.7} additions. For CLEFIA, we show that 12-round CLEFIA can be attacked with about $2^{86.9}$ additions.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> cryptanalysis</p>
    </section>

    <p class="text-gray-300">Block ciphers have round functions which are key-dependent nonlinear bijective functions, and block ciphers are constructed by performing round functions iteratively. The integral attack is one of the most powerful attack against block ciphers, and it was firstly proposed by Daemen et al. to evaluate the security of Square [4]. Thereafter, Knudsen and Wagner formulated the attack of Daemen et al. as the integral attack [8]. The integral attack consists of the distinguisher and the key recovery. For the distinguisher, we prepare N chosen plaintexts, and get N corresponding R-round intermediate texts which are calculated from plaintexts by encrypting R rounds. When the block cipher has the R-round integral distinguisher, we can distinguish the XOR of N intermediate texts from that of N random texts. In order to create the distinguisher, we often use three integral properties, the All(A)-property, the Balance(B)-property and the Constant(C)-property. We attack R + r-round block ciphers by using the R-round integral distinguisher. We first prepare chosen plaintexts for the integral distinguisher, and get corresponding ciphertexts. Next we recover Rround intermediate texts by guessing round keys used in the last r rounds. If the guessing key is wrong, intermediate texts behave as random texts. On the other hand, if the guessing key is correct, intermediate texts have the integral property. Then we can recover the correct round key.</p>

    <p class="text-gray-300">Several improving techniques for the integral attack have been proposed. In particular, there exist improving techniques for the key recovery, e.g., the partial-sum technique [6] and the meetin-the-middle (MITM) technique [13]. The partial-sum technique was proposed by Ferguson et al. in 2000. Generally, the integral attack uses enormous chosen plaintexts. For instance, when the integral attack uses 2<sup>n</sup> chosen plaintexts and recovers the k-bit key, it needs 2k+<sup>n</sup> time complexity. We can reduces the complexity by using the partial-sum technique in which we partially compute the sum by guessing each key one after another. Ferguson et al. applied the technique to AES [11], and showed that 6-round AES is attacked with 6 &times; 2 <sup>50</sup> S-box lookups. The MITM technique was proposed by Sasaki et al. in 2012. By using this technique, we can reduce the complexity of the integral attack against several Feistel ciphers. Now we evaluate L(x &oplus; y) = 0, where x and y are</p>

    <p class="text-gray-300">Table 1. The comparison of attack results.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Target cipher # round Data</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Time</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Techniques</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Reference</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">AES</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32 CP<br>6 &times; 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50 S-box lookups<br>6 &times; 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Integral (Partial-sum)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[6]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">AES</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32CP<br>6 &times; 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">51.7<br>2<br>additions</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Integral (FFT)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sect. 3.4</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CLEFIA</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">112 CP<br>13 &times; 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">106 S-box lookups<br>13 &times; 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Integral (MITM, Partial-sum) [13]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CLEFIA</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">112 CP<br>5 &times; 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">86.9<br>2<br>additions</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Integral (MITM, FFT)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sect. 3.5</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">calculated from ciphertexts by guessing keys. In the MITM technique, we first calculate L L x and y independently, and search keys satisfying Lx = Ly by using the analysis such as the MITM attack [5]. As a result, Sasaki et al. improved integral attacks against LBlock [15], HIGHT [7] and CLEFIA [14].</p>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8">1.1 Our contributions</h3>

    <p class="text-gray-300">In this paper, we propose new improving techniques for the integral attack, the FFT technique. By using this techniques, we improve integral attacks against AES and CLEFIA. Table 1 shows the comparison of previous and our attacks.</p>

    <p class="text-gray-300">The FFT technique is useful for the integral attack with enormous chosen plaintexts, then the reason to introduce this technique is similar to the reason to introduce the partial-sum technique. However applications of two techniques are a little different, and we discuss the difference in Sect. 3.6. As previous attacks using FFT, there exist two results. First Collard et al. proposed the linear attack using FFT in 2007 [3]. Next Bogdanov et al. proposed the zero correlation attack using FFT in 2013 [2]. In this paper, we review the result of Collard et al. to estimate the complexity in detail. First we use the Fast Walsh-Hadamard Transform instead of FFT. As a result, we show that the complexity can be estimated from the number of times using the addition of integers. The bit length of the addition is at most a double key length, e.g., the bit length of the addition is 256-bit when the bit length of the guessing key is 128-bit. We assume that the complexity of one addition is almost the same as that of one S-box lookup. Moreover, we show that FFT can be applied to the integral attack.</p>

    <p class="text-gray-300">As the application, we first show the integral attack against AES. When we use the FFT technique, 6-round AES can be attacked with about 251.<sup>7</sup> additions<sup>1</sup> . We next show the integral attack against 12-round CLEFIA. When we use both the FFT technique and the MITM technique, 12-round CLEFIA can be attacked with about 286.<sup>9</sup> additions. Then we improve integral attacks against 6-round AES and 12-round CLEFIA.</p>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Integral Attack</h2>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Integral Distinguisher</h3>

    <p class="text-gray-300">We define three major integral properties as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A-property : all values appear exactly the same number in the set of texts.</li>
      <li>B-property : the XOR of all texts in the set is 0.</li>
    </ul>

    <p class="text-gray-300"><sup>1</sup> In [6], Ferguson et al. showed the integral attack against 7-round AES. The complexity of the attack is derived from the preparation of adaptive chosen plaintexts. Then there is no change in the complexity of the integral attack against 7-round AES even if we use the FFT technique.</p>

    <p class="text-gray-300">    <img src="_page_2_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 1. The 4-round integral distinguisher of AES.</p>

    <p class="text-gray-300"><span class="math">-\\mathcal{C}</span> -property: the value is fixed to a constant for all texts in the set.</p>

    <p class="text-gray-300">We construct the integral distinguisher by using integral properties. For instance, Fig. 1 shows the 4-round integral distinguisher of AES. In the 1-st round, four values have  <span class="math">\\mathcal{A}_1</span> -property, where the concatenation of their four values also have  <span class="math">\\mathcal{A}</span> -property. In the distinguisher, we use  <span class="math">2^{32}</span>  chosen plaintexts, and the each byte after encrypting 4 rounds has  <span class="math">\\mathcal{B}</span> -property.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 Key Recovery</h3>

    <p class="text-gray-300">We can recover the key by using the integral distinguisher. For instance, Fig. 2 shows the key recover of the integral attack against 6-round AES. Now we have  <span class="math">2^{32}</span>  ciphertexts of 6-round AES, and we know that the value y has  <span class="math">\\mathcal{B}</span> -property. Let c[j] be byte data in ciphertexts as Fig. 2, and  <span class="math">c_n</span>  denotes the n-th ciphertext. Then the XOR of y is calculated from  <span class="math">2^{32}</span>  ciphertexts as follows:</p>

    <p class="text-gray-300"><span class="math">$\\bigoplus_{n=1}^{2^{32}} S_5 \\left( S_1(c_n[1] \\oplus k_1) \\oplus S_2(c_n[2] \\oplus k_2) \\oplus S_3(c_n[3] \\oplus k_3) \\oplus S_4(c_n[4] \\oplus k_4) \\oplus k_5 \\right) = 0, \\tag{1}</span>$</p>

    <p class="text-gray-300">where  <span class="math">S_1, S_2, \\ldots, S_5</span>  are S-boxes, each of which consists of an inverse AES S-box and a multiplication by a field element from the inverse AES MDS matrix. Moreover  <span class="math">k_1, k_2, k_3</span>  and  <span class="math">k_4</span>  are calculated from  <span class="math">RK_6</span>  and  <span class="math">k_5</span>  is calculated from  <span class="math">RK_5</span> , then the bit length of guessing key is 40-bit. The analysis takes about  <span class="math">2^{32+40} = 2^{70}</span>  time complexity with the straightforward method. However we can reduce the complexity by using the partial-sum technique. In the partial-sum technique, we partially compute the sum by guessing each key one after another. Ferguson <em>et al.</em> showed that the analysis takes only  <span class="math">2^{50}</span>  S-box lookups.</p>

    <p class="text-gray-300">    <img src="_page_3_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 2. The integral attack against 6-round AES.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 FFT Technique</h2>

    <p class="text-gray-300">In this section, we show a new technique for the integral attack, the FFT technique. In Sect. 3.1, we show the previous attack using FFT which was proposed by Collard et al. in 2007. Their attack can reduce the complexity of the linear attack, but &quot;the complexity 1&quot; of their attack is difficult from that of classical attacks. In classical attacks, we estimate the complexity from the number of times using S-box lookups or encryptions. However, in the attack using FFT, we estimate the complexity from the computational complexity of FFT. Then we can not compare classical attacks and attacks using FFT simply. In Sect. 3.2, we review the result of Collard et al. to estimate the complexity in detail. As a result, we show how to compare two attacks. In Sect. 3.3, we show that attacks using FFT can be applied to the integral attack. As applications, we show integral attacks against AES and CLEFIA in Sect. 3.4 and Sect. 3.5, respectively. Finally we compare the FFT technique and the partial-sum technique in Sect. 3.6.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 Previous Works about FFT</h3>

    <p class="text-gray-300">As the previous attack using FFT, Collard <em>et al.</em> showed a linear attack using FFT in 2007. In the key recovery of the linear attack [10], for any k-bit key rk, we often evaluate the following equation:</p>

    <p class="text-gray-300"><span class="math">$\\sum_{n=1}^{N} f(c_n \\oplus rk), \\tag{2}</span>$</p>

    <p class="text-gray-300">where  <span class="math">f: \\mathbb{F}_2^k \\to \\mathbb{F}_2</span>  be a boolean function. We have N ciphertexts  <span class="math">c_1, c_2, \\ldots, c_N</span> , and the boolean function f is generated from the linear approximate equation. The evaluation of Eq. (2) takes  <span class="math">N2^k</span>  time complexity with the straightforward method, and the size of N is generally enormous (i.e.  <span class="math">N &gt; 2^k</span> ). Collard <em>et al.</em> showed that the evaluation of Eq. (2) takes about  <span class="math">3k2^k</span>  time complexity by using FFT.</p>

    <p class="text-gray-300">First we create two k-dimensional vectors v and w, where v is generated from the boolean function f and w is generated from the set of ciphertexts as follows:</p>

    <p class="text-gray-300"><span class="math">$v_i = f(i),</span>$</p>

    <p class="text-gray-300"><span class="math">w_i = \\#\\{1 \\le n \\le N | c_n = i\\}.</span></p>

    <p class="text-gray-300">Next we calculate a k-dimensional vector u from v and w as follows:</p>

    <p class="text-gray-300"><span class="math">$\\begin{bmatrix} u_0 \\\\ u_1 \\\\ u_2 \\\\ \\vdots \\\\ u_{2^{k}-1} \\end{bmatrix} = \\begin{bmatrix} v_0 &amp; v_1 &amp; v_2 &amp; \\cdots &amp; v_{2^{k}-1} \\\\ v_1 &amp; v_0 &amp; v_3 &amp; \\cdots &amp; v_{2^{k}-2} \\\\ v_2 &amp; v_3 &amp; v_0 &amp; \\cdots &amp; v_{2^{k}-3} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ v_{2^{k}-1} &amp; v_{2^{k}-2} &amp; v_{2^{k}-3} &amp; \\cdots &amp; v_0 \\end{bmatrix} \\begin{bmatrix} w_0 \\\\ w_1 \\\\ w_2 \\\\ \\vdots \\\\ w_{2^{k}-1} \\end{bmatrix}.</span>$
(3)</p>

    <p class="text-gray-300">Then  <span class="math">u_{rk}</span>  is the same as the result of Eq. (2). Now we want to calculate Eq. (3) fast, then Collard et al. paid attention to the structure of the matrix and showed that Eq. (3) can be calculated fast by using FFT. We first calculate k-dimensional vectors  <span class="math">\\hat{v}</span>  and  <span class="math">\\hat{w}</span>  from v and w by using FFT, respectively. Next we calculate a k-dimensional vector  <span class="math">\\hat{u}</span>  that  <span class="math">\\hat{u}_i</span>  is calculated from  <span class="math">\\hat{v}_i \\times \\hat{w}_i</span> . Finally we calculate a k-dimensional vector u from  <span class="math">\\hat{u}</span>  by using the inverse FFT (IFFT). Each complexity of FFT and IFFT is  <span class="math">k2^k</span> . We calculate two FFTs and one IFFT to calculate u. Then the total complexity is  <span class="math">3k2^k</span> .</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Evaluation of the Complexity</h3>

    <p class="text-gray-300">We review the result of Collard <em>et al.</em> to estimate the complexity in detail. As a result, we show that the complexity can be estimated from the number of times using the addition of integers when we use the Fast Walsh-Hadamard Transform (FWHT) instead of FFT. Now we express Eq. (3) as  <span class="math">u = \\mathbf{V} \\times w</span>  simply. First we create four  <span class="math">2^{k-1}</span> -dimensional block matrices  <span class="math">V_{1,1}</span> ,  <span class="math">V_{1,2}</span> ,  <span class="math">V_{2,1}</span>  and  <span class="math">V_{2,2}</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{V} = \\begin{bmatrix} \\boldsymbol{V}_{1,1} &amp; \\boldsymbol{V}_{1,2} \\ \\boldsymbol{V}_{2,1} &amp; \\boldsymbol{V}_{2,2} \\end{bmatrix},</span>$</p>

    <p class="text-gray-300">where  <span class="math">V_{1,1} = V_{2,2}</span>  and  <span class="math">V_{1,2} = V_{2,1}</span>  are satisfied. From the diagonalization of  <span class="math">\\mathbf{V}</span> , we have</p>

    <p class="text-gray-300"><span class="math">$\\boldsymbol{V} = \\begin{bmatrix} \\boldsymbol{V}_{1,1} &amp; \\boldsymbol{V}_{1,2} \\\\ \\boldsymbol{V}_{1,2} &amp; \\boldsymbol{V}_{1,1} \\end{bmatrix} = \\frac{1}{2} \\begin{bmatrix} \\boldsymbol{I} &amp; \\boldsymbol{I} \\\\ \\boldsymbol{I} - \\boldsymbol{I} \\end{bmatrix} \\begin{bmatrix} \\boldsymbol{V}_{1,1} + \\boldsymbol{V}_{1,2} &amp; \\boldsymbol{0} \\\\ \\boldsymbol{0} &amp; \\boldsymbol{V}_{1,1} - \\boldsymbol{V}_{1,2} \\end{bmatrix} \\begin{bmatrix} \\boldsymbol{I} &amp; \\boldsymbol{I} \\\\ \\boldsymbol{I} - \\boldsymbol{I} \\end{bmatrix}.</span>$</p>

    <p class="text-gray-300">Since structures of  <span class="math">V_{1,1} + V_{1,2}</span>  and  <span class="math">V_{1,1} - V_{1,2}</span>  are the same as that of V, we can get the following equation:</p>

    <p class="text-gray-300"><span class="math">$V = \\frac{1}{2^k} \\times H_{2^k} \\times \\operatorname{diag}(H_{2^k}v) \\times H_{2^k},</span>$</p>

    <p class="text-gray-300">where  <span class="math">H_{2^k}</span>  is the  <span class="math">2^k</span> -dimensional walsh matrix. Then we can express Eq. (3) as follows:</p>

    <p class="text-gray-300"><span class="math">$u = \\boldsymbol{V} \\times w = \\frac{1}{2^k} \\boldsymbol{H}_{2^k} \\times \\operatorname{diag}(\\boldsymbol{H}_{2^k} v) \\times \\boldsymbol{H}_{2^k} w.</span>$</p>

    <p class="text-gray-300">Then the procedure to calculate u is as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We calculate  <span class="math">\\hat{v} = \\mathbf{H}_{2k}v</span> . Then we can express Eq. (3) as  <span class="math">u = \\frac{1}{2^k}\\mathbf{H}_{2^k} \\times \\operatorname{diag}(\\hat{v}) \\times \\mathbf{H}_{2^k}w</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We calculate  <span class="math">\\hat{w} = \\mathbf{H}_{2k}w</span> . Then we can express Eq. (3) as  <span class="math">u = \\frac{1}{2^k}\\mathbf{H}_{2^k} \\times \\operatorname{diag}(\\hat{v})\\hat{w}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We calculate  <span class="math">\\hat{u}</span>  that  <span class="math">\\hat{u}_i</span>  is calculated from  <span class="math">\\hat{v}_i \\times \\hat{w}</span> . Then we can express Eq. (3) as  <span class="math">u = \\frac{1}{2^k} \\mathbf{H}_{2^k} \\hat{u}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We calculate  <span class="math">u = \\frac{1}{2^k} \\mathbf{H}_{2k} \\hat{u}</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">In the 1-st, 2-nd and 3-rd steps, we calculate the multiplication of the walsh matrix using FWHT. We can calculate FWHT with k2 <sup>k</sup> additions. Moreover we can calculate the division of a power of 2 fast. Then each complexity of the 1-st, 2-nd and 4-th step is k2 <sup>k</sup> additions. In the 3-rd step, we calculate 2<sup>k</sup> multiplications of k-bit integers, and we think that the complexity is equal to the complexity of k additions. Then the complexity of the 3-rd step is k2 <sup>k</sup> additions. Therefore the detailed complexity for attack using FFT is 4k2 <sup>k</sup> additions. It is difficult to compare the complexity of one addition and that of one S-box lookup simply. However, the bit length of the addition is at most a double key length, then we assume that the complexity of one addition is almost the same as that of one S-box lookup. Hereafter we do not distinguish FFT with FWHT, and FFT represents FWHT.</p>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">3.3 How to Apply FFT to the Integral Attack</h3>

    <p class="text-gray-300">We can apply FFT to other attack. Bogdanov et al. showed a zero correlation attack using FFT in 2013 [2]. In this paper, we show that FFT can be applied to the integral attack. We assume the key recovery using B-property, namely, the key recovery can be expressed in the following equation:</p>

    <p class="text-gray-300"><span class="math">$\\bigoplus_{n=1}^{N} F_{rk_2}(F(c_n \\oplus rk_1)) = 0,</span>$</p>

    <p class="text-gray-300">where F is a function from F k1 2 to F k1 2 , Frk<sup>2</sup> is a function from F k1 2 to F <code> &lt;sup&gt;2&lt;/sup&gt; depending on rk2. rk&lt;sup&gt;1&lt;/sup&gt; denotes the k1-bit key and rk&lt;sup&gt;2&lt;/sup&gt; denotes the k2-bit key. This equation is always satisfied when rk&lt;sup&gt;1&lt;/sup&gt; and rk&lt;sup&gt;2&lt;/sup&gt; are correct. However the probability satisfying this equation is 2&minus;</code> when rk<sup>1</sup> and rk<sup>2</sup> are wrong.</p>

    <p class="text-gray-300">To apply FFT, the summation must be calculated on integers. Then we have the following equation:</p>

    <p class="text-gray-300"><span class="math">$\\left(\\sum_{n=1}^{N} F_{rk_2}^{(j)}(F(c_n \\oplus rk_1))\\right) = 0 \\mod 2,\\tag{4}</span>$</p>

    <p class="text-gray-300">where F (j) rk<sup>2</sup> is a boolean function whose output is the j-th bit of Frk<sup>2</sup> . The probability satisfying this equation is 2&minus;<sup>1</sup> when rk<sup>1</sup> and rk<sup>2</sup> are wrong. We evaluate Eq.(4) by using FFT. Our analysis consists of 3 steps, the circuit evaluation step, the ciphertexts evaluation step and the key recovery step.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The circuit evaluation step. We evaluate the circuit, namely, we create v and calculate &circ;v using FFT. This step does not depend on sets of ciphertexts and the key, then we can execute this step in advance.</li>
      <li>The ciphertexts evaluation step. We evaluate sets of ciphertexts, namely, we create w and calculate &circ;w using FFT.</li>
      <li>The key recovery step. We calculate &circ;u from &circ;v and &circ;w, and calculate u using FFT. Finally we recover the key from u.</li>
    </ul>

    <p class="text-gray-300">Roughly, we can estimate that the complexity to execute the FFT technique is \` &times; k<sup>1</sup> &times; 2 k1+k<sup>2</sup> , but the estimation of the detailed complexity is complicated. For integral attacks against AES and CLEFIA, we estimate the detailed complexity in Sect. 3.4 and Sect. 3.5.</p>

      <h3 id="sec-3.4" class="text-xl font-semibold mt-8">3.4 Application to AES</h3>

    <p class="text-gray-300"><strong>Apply the FFT Technique</strong> We apply the FFT technique to the key recovery of 6-round AES. Since the summation must be calculated on integers, we transform Eq. 1 to the following equation:</p>

    <p class="text-gray-300"><span class="math">$\\sum_{n=1}^{2^{32}} S_5^{(i)} \\left( S_1(c_n[1] \\oplus k_1) \\oplus S_2(c_n[2] \\oplus k_2) \\oplus S_3(c_n[3] \\oplus k_3) \\oplus S_4(c_n[4] \\oplus k_4) \\oplus k_5 \\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\sum_{n=1}^{2^{32}} F_{k_5}^{(i)} \\left( F(c_n \\oplus k_1 || k_2 || k_3 || k_4) \\right),</span>$</p>

    <p class="text-gray-300">where F is a function from  <span class="math">\\mathbb{F}_2^{32}</span>  to  <span class="math">\\mathbb{F}_2^{32}</span> , and  <span class="math">F_{rk_5}</span>  is a function from  <span class="math">\\mathbb{F}_2^{32}</span>  to  <span class="math">\\mathbb{F}_2^{8}</span>  depending on  <span class="math">k_5</span> . Since the output of  <span class="math">F_{k_5}</span>  is an 8-bit, i is chosen from  <span class="math">1, 2, \\dots 8</span> .</p>

    <p class="text-gray-300">The circuit evaluation step We first create a  <span class="math">2^8 \\times 2^{32}</span> -dimensional vector T. For any  <span class="math">k_5</span> ,  <span class="math">T_{k_5}</span>  is created as follows:</p>

    <p class="text-gray-300"><span class="math">$T_{k_5} = [F_{k_5}(F(0)), F_{k_5}(F(1)), \\dots, F_{k_5}(F(2^{32} - 1))].</span>$</p>

    <p class="text-gray-300">Moreover, we create  <span class="math">2^{32}</span> -dimensional vectors  <span class="math">v^{(i)}</span>  from  <span class="math">T_{k_5}</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">$v_{k_5}^{(i)} = [T_{k_5,0}^{(i)}, T_{k_5,1}^{(i)}, \\dots, T_{k_5,2^{32}-1}^{(i)}],</span>$</p>

    <p class="text-gray-300">where  <span class="math">T_{k_5,j}^{(i)}</span>  denotes <em>i</em>-th bit of  <span class="math">T_{k_5,j}</span> . Finally we calculate  <span class="math">\\hat{v}_{k_5}^{(i)}</span>  for any  <span class="math">k_5</span>  and any <em>i</em> by using FFT. The dominant complexity of this step is a calculation of FFT. Since  <span class="math">k_5</span>  is an 8-bit and <em>i</em> is chosen from  <span class="math">1, 2, \\ldots, 8</span> , the complexity is  <span class="math">2^8 \\times 8 \\times 32 \\times 2^{32} = 2^{48}</span>  additions.</p>

    <p class="text-gray-300">The ciphertexts evaluation step We count how many times each value of 4-byte c appears, and create a  <span class="math">2^{32}</span> -dimensional vector w. When the number of c satisfying c = j is even,  <span class="math">w_j</span>  is 0. When the number of c satisfying c = j is odd,  <span class="math">w_j</span>  is 1. Next we calculate  <span class="math">\\hat{w}</span>  by using FFT. The complexity of this step is  <span class="math">32 \\times 2^{32} = 2^{37}</span>  additions, and it is negligible.</p>

    <p class="text-gray-300">The key recovery step We calculate  <span class="math">2^{32}</span> -dimensional vectors  <span class="math">\\hat{u}_{k_5}^{(i)}</span>  from  <span class="math">\\hat{v}_{k_5}^{(i)}</span>  and  <span class="math">\\hat{w}</span> . Next we calculate  <span class="math">u_{k_5}^{(i)}</span>  by using FFT. When  <span class="math">k_5</span>  is correct,  <span class="math">u_{k_5}^{(i)}[k_1||k_2||k_3||k_4]=0</span>  mod 2 holds for all i. Since  <span class="math">k_5</span>  is an 8-bit key and i is chosen from  <span class="math">1,2,\\ldots,8</span> , the complexity to calculate  <span class="math">\\hat{u}</span>  is  <span class="math">2^8\\times8\\times2^{32}</span>  32-bit multiplications (=  <span class="math">2^{48}</span>  additions). Moreover the complexity to calculate u is  <span class="math">2^8\\times8\\times32\\times2^{32}=2^{48}</span>  additions. Then the complexity of this step is  <span class="math">2^{49}</span>  additions.</p>

    <p class="text-gray-300">The total complexity Ferguson <em>et al.</em> used 6 sets to recover 5 keys. We also use 6 sets. Since the circuit evaluation step does not depend on sets of ciphertexts and the key, we repeat the ciphertexts evaluation step and the key recovery step 6 times. Then the total complexity is about  <span class="math">2^{48} + 6 \\times 2^{49} \\approx 2^{51.7}</span>  additions.</p>

    <p class="text-gray-300">    <img src="_page_7_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 3. The round function of CLEFIA.</p>

      <h3 id="sec-3.5" class="text-xl font-semibold mt-8">3.5 Application to CLEFIA</h3>

    <p class="text-gray-300"><strong>CLEFIA</strong> CLEFIA is a 128-bit block cipher which was proposed by Shirai <em>et al.</em> in 2007, and it has the 4-branch generalized Feistel network. CLEFIA is adopted as an ISO standard. The round function is defined as Fig. 3, and an <em>i</em>-round intermediate text is calculated from an i-1-round intermediate text,  <span class="math">RK_{2i-2}</span>  and  <span class="math">RK_{2i-1}</span> . For the 128-bit security version, the number of round is 18.</p>

    <p class="text-gray-300">In the proposal of CLEFIA, Shirai et al. showed that CLEFIA has an 8-round integral distinguisher [1]. Next, Li et al. showed that CLEFIA has a 9-round integral distinguisher [9] which needs  <span class="math">2^{112}</span>  chosen plaintexts. Moreover they showed that the integral attack can attack 12-round CLEFIA. Sasaki and Wang showed the MITM technique and improved the complexity for the attack against 12-round CLEFIA to  <span class="math">13 \\times 2^{106}</span>  S-box lookups.</p>

    <p class="text-gray-300"><strong>Apply the FFT Technique</strong> We show the integral attack using FFT against 12-round CLEFIA. First we define several values and functions. Let  <span class="math">C_1</span> ,  <span class="math">C_2</span> ,  <span class="math">C_3</span>  and  <span class="math">C_4</span>  be ciphertexts and each value is a 32-bit (see Fig. 4). For any 32-bit data X, X[i] denotes the i-th byte of X, namely, X = X[1]||X[2]||X[3]||X[4]. We define function  <span class="math">f_i: \\mathbb{F}_2^{32} \\to \\mathbb{F}_2^8</span>  and  <span class="math">m_i: \\mathbb{F}_2^{32} \\to \\mathbb{F}_2^8</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">$F_1(X) = f_1(X) \\| f_2(X) \\| f_3(X) \\| f_4(X),</span>$</p>

    <p class="text-gray-300"><span class="math">$M_0^{-1}(X) = m_1(X) \\| m_2(X) \\| m_3(X) \\| m_4(X).</span>$</p>

    <p class="text-gray-300">For any function f, we define a boolean function  <span class="math">f^{(i)}(X)</span>  whose output is calculated from i-th bit of f(X). For any data x,  <span class="math">x^{(i)}</span>  denotes the i-th bit of x.</p>

    <p class="text-gray-300">Our attack uses the 9-round integral distinguisher where the 2-nd branch of the 9-round intermediate text has  <span class="math">\\mathcal{B}</span> -property. First we apply the MITM technique. We move the position of  <span class="math">M_0</span>  in 10-round  <span class="math">F_0</span>  as Fig. 4. From the distinguisher, we have  <span class="math">\\bigoplus Y = \\bigoplus Z</span> , and each 1-st byte is calculated as follows:</p>

    <p class="text-gray-300"><span class="math">$\\bigoplus Y[1] = \\bigoplus S_0(f_1(F_0(C_0 \\oplus RK_{22}) \\oplus C_1 \\oplus RK_{21} \\oplus WK_2) \\oplus C_2[1] \\oplus RK_{18}[1]),</span>$</p>

    <p class="text-gray-300"><span class="math">$\\bigoplus Z[1] = \\bigoplus m_1(F_1(C_2 \\oplus RK_{23}) \\oplus C_3).</span>$</p>

    <p class="text-gray-300"><span class="math">\\bigoplus Y[1] = \\bigoplus Z[1]</span>  is satisfied for correct  <span class="math">RK_{18}</span> ,  <span class="math">RK_{21} \\oplus WK_2</span> ,  <span class="math">RK_{22}</span>  and  <span class="math">RK_{23}</span> . The probability satisfying  <span class="math">\\bigoplus Y[1] = \\bigoplus Z[1]</span>  is  <span class="math">2^{-8}</span>  for wrong keys, and we can discard wrong keys fast by using the MITM technique.</p>

    <p class="text-gray-300">In order to apply the FFT technique, we transform the above equation to the following equation:</p>

    <p class="text-gray-300"><span class="math">$\\sum Y[1]^{(i)} = \\sum S_0^{(i)}(f_1(F_0(C_0 \\oplus RK_{22}) \\oplus C_1 \\oplus RK_{21} \\oplus WK_2) \\oplus C_2[1] \\oplus RK_{18}[1]),</span>$</p>

    <p class="text-gray-300"><span class="math">$\\sum Z[1]^{(i)} = \\sum m_1^{(i)}(F_1(C_2 \\oplus RK_{23}) \\oplus C_3).</span>$</p>

    <p class="text-gray-300">    <img src="_page_8_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 4. The key recovery of 12-round CLEFIA.</p>

    <p class="text-gray-300">For correct  <span class="math">RK_{18}</span> ,  <span class="math">RK_{21} \\oplus WK_2</span> ,  <span class="math">RK_{22}</span>  and  <span class="math">RK_{23}</span> ,  <span class="math">\\sum Y[1]^{(i)} = \\sum Z[1]^{(i)}</span>  (mod 2) is satisfied for all i. The probability satisfying  <span class="math">\\sum Y[1]^{(i)} = \\sum Z[1]^{(i)}</span>  (mod 2) is  <span class="math">2^{-1}</span>  for wrong keys, and we can discard wrong keys fast by using the MITM technique. Similarly we can discard wrong keys by using equations which are created from (Y[2], Z[2]), (Y[3], Z[3]) and (Y[4], Z[4]).</p>

    <p class="text-gray-300">The circuit evaluation step We first create a  <span class="math">2^{72}</span> -dimensional vector T and a  <span class="math">2^{32}</span> -dimensional vector T' as follows:</p>

    <p class="text-gray-300"><span class="math">$T = [S_0(f_1(F_0(0) \\oplus 0) \\oplus 0), S_0(f_1(F_0(0) \\oplus 0) \\oplus 1), \\dots, S_0(f_1(F_0(2^{32} - 1) \\oplus 2^{32} - 1) \\oplus 2^8 - 1)],</span>$</p>

    <p class="text-gray-300"><span class="math">$T&#x27; = [F_1(0), F_1(1), \\dots, F_1(2^{32} - 1)].</span>$</p>

    <p class="text-gray-300">Next we create  <span class="math">2^{72}</span> -dimensional vectors  <span class="math">v_i</span>  and  <span class="math">2^{32}</span> -dimensional vectors  <span class="math">v&#x27;^{(i)}</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">$v^{(i)} = [T_0^{(i)}, T_1^{(i)}, \\dots, T_{2^{72}-1}^{(i)}], \\quad v&#x27;^{(i)} = [T_0&#x27;^{(i)}, T_1&#x27;^{(i)}, \\dots, T_{2^{32}-1}&#x27;^{(i)}].</span>$</p>

    <p class="text-gray-300">Finally we calculate  <span class="math">\\hat{v}^{(i)}</span>  and  <span class="math">\\hat{v}&#x27;^{(i)}</span>  by using FFT. The complexity to calculate  <span class="math">\\hat{v}^{(i)}</span>  is  <span class="math">8\\times72\\times2^{72}\\approx2^{81.2}</span>  additions because i is chosen from  <span class="math">1,2,\\ldots,8</span> . The complexity to calculate  <span class="math">\\hat{v}&#x27;^{(i)}</span>  is  <span class="math">8\\times32\\times2^{32}</span>  additions, and it is negligible. Similarly we calculate  <span class="math">\\hat{v}^{(i)}</span>  and  <span class="math">\\hat{v}&#x27;^{(i)}</span>  which are created from (Y[2],Z[2]), (Y[3],Z[3]) and (Y[4],Z[4]), then the total complexity is  <span class="math">4\\times2^{81.2}=2^{83.2}</span>  additions.</p>

    <p class="text-gray-300">The ciphertexts evaluation step We count how many times each value of 9-byte tuple  <span class="math">(C_0, C_1, C_2[1])</span>  appears, and create a  <span class="math">2^{72}</span> -dimensional vector w. Similarly we count how many times each value of 4-byte  <span class="math">C_2</span>  appears, and create a  <span class="math">2^{32}</span> -dimensional vector w'. Moreover we calculate  <span class="math">\\bigoplus m_1(C_3)</span> . Next we calculate  <span class="math">\\hat{w}</span>  and  <span class="math">\\hat{w}&#x27;</span>  by using FFT. The complexity to calculate  <span class="math">\\hat{w}</span>  is  <span class="math">72 \\times 2^{72} \\approx 2^{78.2}</span>  additions. The complexity to calculate  <span class="math">\\hat{w}&#x27;</span>  is  <span class="math">32 \\times 2^{32}</span>  additions, and it is negligible. Similarly we calculate  <span class="math">\\hat{w}</span>  and  <span class="math">\\hat{w}&#x27;</span>  which are created from (Y[2], Z[2]), (Y[3], Z[3]) and (Y[4], Z[4]), then the total complexity is  <span class="math">4 \\times 2^{78.2} = 2^{80.2}</span>  additions.</p>

    <p class="text-gray-300">The key recovery step We calculate  <span class="math">2^{72}</span> -dimensional vectors  <span class="math">\\hat{u}^{(i)}</span>  from  <span class="math">\\hat{v}^{(i)}</span>  and  <span class="math">\\hat{w}</span> , and calculate  <span class="math">u^{(i)}</span>  by using FFT. Next we calculate  <span class="math">2^{32}</span> -dimensional vectors  <span class="math">\\hat{u}&#x27;^{(i)}</span>  from  <span class="math">\\hat{v}&#x27;^{(i)}</span>  and  <span class="math">\\hat{w}&#x27;</span> , and calculate</p>

    <p class="text-gray-300"><span class="math">u^{\\prime(i)}</span>  by using FFT. For the correct RK18, RK21, RK22 and RK23,</p>

    <p class="text-gray-300"><span class="math">$u^{(i)}[RK22||RK21||RK18[1]] = u&#x27;^{(i)}[RK23] + \\bigoplus m_1^{(i)}(C_3) \\mod 2</span>$
(5)</p>

    <p class="text-gray-300">is satisfied for all i. However for wrong keys, the probability satisfying Eq.(5) is  <span class="math">2^{-1}</span> . Since i is chosen from 1, 2, ..., 8, the complexity to calculate  <span class="math">\\hat{u}^{(i)}</span>  is  <span class="math">8 \\times 2^{72}</span>  72-bit multiplications ( <span class="math">\\approx 2^{81.2}</span>  additions). The complexity to calculate  <span class="math">u^{(i)}</span>  is  <span class="math">8 \\times 72 \\times 2^{72} \\approx 2^{81.2}</span>  additions. Since the complexity for other operations is negligible, the complexity to evaluate Eq.(5) is about  <span class="math">2^{82.2}</span>  additions. Similarly we discard wrong keys by evaluating Eq.(5) which is created from (Y[2], Z[2]), (Y[3], Z[3]) and (Y[4], Z[4]). Then the total complexity is  <span class="math">4 \\times 2^{82.2} = 2^{84.4}</span>  additions.</p>

    <p class="text-gray-300">The total complexity By using one set, the probability that wrong keys remain is  <span class="math">2^{-32}</span>  because Y and Z are a 32-bit. In order to recover the 128-bit key RK18,  <span class="math">RK21 \\oplus WK_2</span> , RK22 and RK23, we use 5 sets. Since the circuit evaluation step does not depend on sets of ciphertexts and the key, we repeat the ciphertexts evaluation step and the key recovery step 5 times. Then the total complexity is about  <span class="math">2^{83.2} + 5(2^{80.2} + 2^{84.4}) \\approx 2^{86.9}</span>  additions.</p>

      <h3 id="sec-3.6" class="text-xl font-semibold mt-8">3.6 Comparison between FFT Technique and Partial-sum Technique</h3>

    <p class="text-gray-300">We compare the partial-sum technique and the FFT technique. In the partial-sum technique, we estimate the complexity from the number of times using S-box lookups, and we must access random access memories. On the other hand, in the FFT technique, we estimate the complexity from the number of additions, and we access mainly sequential access memories. Since the access to sequential access memories is more efficient than that to random access memories, we think that the FFT technique is more efficient than the partial-sum technique if the complexity is the same. However we have an open problem about the FFT technique. Since round keys of block ciphers are calculated from the secret key, we can know some bits of round keys when we guess some bits of the secret key. In the partial-sum technique, attackers can exploit the property and reduce the complexity efficiently. For instance, the integral attack against 22-round LBlock exploits this property [12]. On the other hand, in the FFT technique, we do not know how to exploit this property.</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Conclusion</h2>

    <p class="text-gray-300">In this paper, we show new techniques for the integral attack, the FFT technique. This technique is useful for the integral attack with enormous chosen texts. In order to estimate the complexity of the FFT technique, we review the Collard's paper. Then we show the complexity can be estimated from the number of times using the addition of integers. As applications, we show that 4-round AES can be attacked with  <span class="math">2^{51.7}</span>  additions, and 12-round CLEFIA can be attacked with  <span class="math">2^{86.9}</span>  additions.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>The 128-bit Blockcipher CLEFIA Security and Performance Evaluations. Sony Corporation (2007)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Bogdanov, A., Geng, H., Wang, M., Wen, L., Collard, B.: Zero-Correlation Linear Cryptanalysis with FFT and Improved Attacks on ISO Standards Camellia and CLEFIA. In: SAC (2013)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Collard, B., Standaert, F.X., Quisquater, J.J.: Improving the Time Complexity of Matsui's Linear Cryptanalysis. In: ICISC. LNCS, vol. 4817, pp. 77&ndash;88 (2007)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Daemen, J., Knudsen, L.R., Rijmen, V.: The Block Cipher Square. In: FSE. LNCS, vol. 1267, pp. 149&ndash;165 (1997)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Diffie, W., Hellman, M.E.: Exhaustive cryptanalysis of the NBS Data Encryption Standard. Computer 10, 74&ndash;84 (1977)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Ferguson, N., Kelsey, J., Lucks, S., Schneier, B., Stay, M., Wagner, D., Whiting, D.: Improved Cryptanalysis of Rijndael. In: FSE. LNCS, vol. 1978, pp. 213&ndash;230 (2000)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Hong, D., Sung, J., Hong, S., Lim, J., Lee, S., Koo, B., Lee, C., Chang, D., Lee, J., Jeong, K., Kim, H., Kim, J., Chee, S.: HIGHT: A New Block Cipher Suitable for Low-Resource Device. In: CHES. LNCS, vol. 4249, pp. 46&ndash;59 (2006)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Knudsen, L.R., Wagner, D.: Integral Cryptanalysis. In: FSE. LNCS, vol. 2365, pp. 112&ndash;127 (2002)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Li, Y., Wu, W., Zhang, L.: Improved Integral Attacks on Reduced-Round CLEFIA Block Cipher. In: WISA. LNCS, vol. 7115, pp. 28&ndash;39 (2011)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Matsui, M.: Linear Cryptoanalysis Method for DES Cipher. In: EUROCRYPT. LNCS, vol. 765, pp. 386&ndash;397 (1993)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>National Institute of Standards and Technology: Specification for the ADVANCED ENCRYPTION STANDARD (AES). Federal Information Processing Standards Publication 197 (2001)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Sasaki, Y., Wang, L.: Comprehensive Study of Integral Analysis on 22-Round LBlock. In: ICISC. LNCS, vol. 7839, pp. 156&ndash;169 (2012a)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Sasaki, Y., Wang, L.: Meet-in-the-Middle Technique for Integral Attacks against Feistel Ciphers. In: SAC. LNCS, vol. 7707, pp. 234&ndash;251 (2012b)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Shirai, T., Shibutani, K., Akishita, T., Moriai, S., Iwata, T.: The 128-Bit Blockcipher CLEFIA (Extended Abstract). In: FSE. LNCS, vol. 4593, pp. 181&ndash;195 (2007)</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Wu, W., Zhang, L.: LBlock: A Lightweight Block Cipher. In: ACNS. LNCS, vol. 6715, pp. 327&ndash;344 (2011)</li>
    </ul></li>
    </ul>

    </section>
`;
---

<BaseLayout title="FFT-Based Key Recovery for the Integral Attack (2014/187)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/187
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#sec-1" class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-1.1" class="hover:text-white">Our contributions</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-2" class="hover:text-white">Integral Attack</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Integral Distinguisher</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Key Recovery</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">FFT Technique</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">Previous Works about FFT</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">Evaluation of the Complexity</a></li>
            <li><a href="#sec-3.3" class="hover:text-white">How to Apply FFT to the Integral Attack</a></li>
            <li><a href="#sec-3.4" class="hover:text-white">Application to AES</a></li>
            <li><a href="#sec-3.5" class="hover:text-white">Application to CLEFIA</a></li>
            <li><a href="#sec-3.6" class="hover:text-white">Comparison between FFT Technique and Partial-sum Technique</a></li>
          </ol>
        </li>
        <li><a href="#sec-4" class="hover:text-white">Conclusion</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="fft-based-key-recovery-for-the-integral-attack-2014" />
  </article>
</BaseLayout>
