---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2003/107';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Fujisaki-Okamoto IND-CCA hybrid encryption revisited';
const AUTHORS_HTML = 'David Galindo, Sebastià Mart\\&#x27;ın, Paz Morillo, Jorge L.  Villar';

const CONTENT = `    <p class="text-gray-300">Fujisaki-Okamoto IND-CCA hybrid encryption revisited</p>

    <p class="text-gray-300">David Galindo, Sebastià Martín, Paz Morillo and Jorge L. Villar</p>

    <p class="text-gray-300">Dep. Matemàtica Aplicada IV. Universitat Politècnica de Catalunya</p>

    <p class="text-gray-300">Campus Nord, c/Jordi Girona, 1-3, 08034 Barcelona</p>

    <p class="text-gray-300">e-mail: {dgalindo,sebasm,paz,jvillar}@mat.upc.es</p>

    <h6 id="sec-1" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">At Crypto’99, Fujisaki and Okamoto <em>[10]</em> presented a nice generic transformation from weak asymmetric and symmetric schemes into an IND-CCA hybrid encryption scheme in the Random Oracle Model. From this transformation, two specific candidates to standardization were designed: EPOC-2 <em>[9]</em> and PSEC-2 <em>[16]</em>, based on Okamoto-Uchiyama and El Gamal primitives, respectively. Since then, several cryptanalysis of EPOC have been published, one in the Chosen Ciphertext Attack game and others making use of a poor implementation that is vulnerable to reject timing attacks.</p>

    <p class="text-gray-300">The aim of this work is to avoid these attacks from the generic transformation, identifying the properties that an asymmetric scheme must hold to obtain a secure hybrid scheme. To achieve this, some ambiguities in the proof of the generic transformation <em>[10]</em> are described, which can lead to false claims. As a result the original conversion is modified and the range of asymmetric primitives that can be used is shortened.</p>

    <p class="text-gray-300">In second place, the concept of Easy Verifiable Primitive is formalized, showing its connection with the Gap problems. Making use of these ideas, a new security proof for the modified transformation is given. The good news is that the reduction is tight, improving the concrete security claimed in the original work for the Easy Verifiable Primitives. For the rest of primitives the concrete security is improved at the cost of stronger assumptions.</p>

    <p class="text-gray-300">Finally, the resistance of the new conversion against reject timing attacks is addressed.</p>

    <p class="text-gray-300">Keywords: public-key cryptography, chosen-ciphertext security, tight reduction, Random Oracle Model, Okamoto-Uchiyama scheme, reject timing attacks.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">When developing a new public key encryption scheme there are two basic criteria that a designer wants to reach: security and efficiency. Security is obviously the main concern, and it is expressed in terms of an attacker’s goal against the scheme and the means it uses. The standard security notion for a general purpose cryptosystem is indistinguishability against adaptive chosen ciphertext attacks, IND-CCA for short. Although there are other security notions equivalent to the latter (cf. <em>[1, 19]</em>), it is preferred for technical reasons. Proofs of security are accepted only if they are in the provable security model, in which security is polynomially reduced to trusted</p>

    <p class="text-gray-300">mathematical assumptions. Regarding efficiency, there are two main aspects to consider. On one hand, the computational complexity of the algorithms involved in the scheme and, on the other hand, the concrete security of the scheme, that is, how the security of the scheme is related to the computational assumptions which it is based on. There are other features of relevance, as the design simplicity or the length of the messages that can be encrypted.</p>

    <p class="text-gray-300">However, to develop a practical provably secure cryptosystem in the sense of IND-CCA is a quite difficult task. In fact, few such schemes are known in the standard model, being the exceptions the schemes designed in the Cramer-Shoup paradigm <em>[7]</em>. In the idealized Random Oracle Model <em>[2]</em>, several powerful generic constructions have been designed <em>[10, 17, 14, 5]</em>, which provide practical IND-CCA schemes from weak asymmetric and symmetric schemes.</p>

    <p class="text-gray-300">Among these constructions, <em>[14, 5]</em> present a better security reduction than <em>[10, 17]</em>. This is mainly due to the use of the <em>Plaintext Checking Oracle</em> introduced in <em>[13]</em>. The cost of using this oracle is that the security of the encryption scheme is in general based on (stronger) gap assumptions, when the asymmetric primitive is probabilistic.</p>

    <p class="text-gray-300">In this paper we revisit the generic conversion by Fujisaki and Okamoto (FO) presented at Crypto’99. The particular instantiation of this conversion with the Okamoto-Uchiyama scheme <em>[15]</em>, known as EPOC-2 <em>[9]</em>, has found practical attacks that lead to a total break <em>[12, 8, 18]</em>. The most serious flaw was found in <em>[12]</em>, where the secret key was recovered in the IND-CCA game itself. The authors of <em>[12]</em> pointed out that such a surprising result was related to the vagueness of the IND-CCA model when dealing with invalid ciphertexts. In the case of the original especification of EPOC-2, an attacker could obtain vital information about the system from that ciphertexts. The other attacks mentioned above (<em>[8, 18]</em>), take profit of extra information available at the real world, as the running time of the decryption algorithm. This enables to distinguish among the reasons to reject certain ciphertexts and it is used to launch an attack recovering again the secret key.</p>

    <p class="text-gray-300">Our results. We incorporate the comments made by EPOC’s authors in <em>[12]</em> about FO conversion. Then we show that some ambiguities still remain in the proof of security, with the outcome that the security result claimed in <em>[10]</em> cannot be guaranteed in general. This forces to slightly modify the conversion and to shorten the range of asymmetric primitives that can be used.</p>

    <p class="text-gray-300">In second place, the concept of <em>Easy Verifiable Primitive</em> is formalized, and it is used to give a <em>new</em> security proof for the modified transformation. We show that the reduction is <em>tight</em>, improving the concrete security claimed in the original work for the Easy Verifiable Primitives. For the rest of primitives the concrete security is improved at the cost of a stronger assumption, that is, a gap assumption (see <em>[13]</em>).</p>

    <p class="text-gray-300">Finally, the resistance of the new conversion against reject timing attacks is addressed. Since the vulnerability of a scheme against these attacks is closely related to the design of the rejection rules in the decryption algorithm, we take care about this when drawing the modification.</p>

    <p class="text-gray-300">2 Preliminaries</p>

    <p class="text-gray-300">In this section we recall some technical details and notations that are used in the rest of the paper.</p>

    <p class="text-gray-300">Algorithmic notation. Assigning a value <span class="math">a</span> to a variable <span class="math">x</span> will be in general denoted by <span class="math">x\\leftarrow a</span>. Nevertheless, this notation can be extended to allow different meanings. If <span class="math">A</span> is a non-empty set, then <span class="math">x\\leftarrow A</span> denotes that <span class="math">x</span> is uniformly chosen in <span class="math">A</span>. If <span class="math">D</span> is a probability distribution over <span class="math">A</span>, then <span class="math">x\\leftarrow D</span> means that <span class="math">x</span> is chosen in <span class="math">A</span> by sampling the distribution <span class="math">D</span>. Finally, if <span class="math">\\mathcal{A}</span> is an (probabilistic) algorithm, <span class="math">x\\leftarrow\\mathcal{A}</span> means that <span class="math">\\mathcal{A}</span> is executed on some specified input and its (random) output is assigned to the variable <span class="math">x</span>.</p>

    <p class="text-gray-300">Negligible functions. The class of negligible functions on a parameter <span class="math">\\ell\\in\\mathbb{Z}^{+}</span>, denoted as <span class="math">\\mathsf{negl}(\\ell)</span>, is the set of the functions <span class="math">\\epsilon:\\mathbb{Z}^{+}\\rightarrow\\mathbb{R}^{+}</span> such that for any polynomial <span class="math">p\\in\\mathbb{R}[\\ell]</span>, there exist <span class="math">C\\in\\mathbb{R}^{+}</span> such that <span class="math">\\epsilon(\\ell)&lt;\\frac{C}{p(\\ell)}</span>, for all <span class="math">\\ell\\in\\mathbb{Z}^{+}</span>. Let <span class="math">\\mathsf{poly}(\\ell)</span> the class of functions <span class="math">p:\\mathbb{Z}^{+}\\rightarrow\\mathbb{R}^{+}</span> upper bounded in <span class="math">\\mathbb{Z}^{+}</span> by some polynomial in <span class="math">\\mathbb{R}[\\ell]</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Set sequences. As usual, <span class="math">\\{0,1\\}^{\\star}</span> and <span class="math">\\{0,1\\}^{\\ell}</span> will respectively denote the set of all finite binary strings and the set of binary strings with length <span class="math">\\ell</span>. A string set sequence, <span class="math">X=\\{X_{\\ell}\\}_{\\ell\\in\\mathcal{Z}^{+}}</span>, is a polynomial size set if there exist a integer valued function <span class="math">p_{X}(\\ell)\\in\\mathsf{poly}(\\ell)</span> such that <span class="math">X_{\\ell}\\subseteq\\{0,1\\}^{p_{X}(\\ell)}</span> for all <span class="math">\\ell\\in\\mathbb{Z}^{+}</span>. A polynomial size set, <span class="math">X</span>, is <em>samplable</em> if there exists a probabilistic polynomial time algorithm (PPT) that on input <span class="math">1^{\\ell}</span>, outputs an uniformly distributed random element in <span class="math">X_{\\ell}</span>. Moreover, <span class="math">X</span> is <em>recognizable</em> if there exist a polynomial time algorithm (PT) that on input <span class="math">1^{\\ell}</span> and a string <span class="math">s</span>, with size polynomial in <span class="math">\\ell</span>, outputs <span class="math">1</span> if and only if <span class="math">s\\in X_{\\ell}</span>. The cardinality of a set sequence <span class="math">A</span> (as a function of <span class="math">\\ell</span>) will be denoted by $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">These notions can be easily extended to non-strings sets by using polynomial size injective encoding maps. In the sequel, the use of natural encodings (e.g. binary representations of integers) is assumed when necessary.</p>

    <p class="text-gray-300">Hereafter, the word ‘sequence’ in ‘set sequence’, ‘map sequence’ and ‘probability distribution sequence’ will be omitted.</p>

    <p class="text-gray-300">Keypair generators. Let <span class="math">PK</span> and <span class="math">SK</span> polynomial size sets such that the sets <span class="math">PK_{\\ell}</span> are all disjoint and there exists a PT algorithm that on input <span class="math">sk\\in SK_{\\ell}</span> outputs an element <span class="math">pk\\in PK_{\\ell}</span>. Suppose that there also exists a PT algorithm that on input <span class="math">pk\\in PK_{\\ell}</span> outputs <span class="math">\\ell</span>. Let <span class="math">I</span> a polynomial time samplable probability distribution over <span class="math">PK\\times SK</span>. The triple <span class="math">(PK,SK,I)</span> will be called a keypair generator.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Set and map families. Given a keypair generator, the family <span class="math">\\{X_{pk}\\}_{pk\\in PK}</span> is referred as the set family <span class="math">X</span>. In the same way, a map family <span class="math">f</span> is defined as <span class="math">\\{f_{pk}:X_{pk}\\rightarrow Z_{pk}\\}_{pk\\in PK}</span>. Given a set family, <span class="math">X</span>, the cardinality $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> as a function of </span>\\ell<span class="math"> is defined to be the minimal value of </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X_{pk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span>pk\\in PK_{\\ell}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A set family <span class="math">X</span> is <em>recognizable</em> if there exist a PT algorithm that on input <span class="math">pk\\in PK</span> and a string <span class="math">s</span>, with size polynomial in <span class="math">\\ell</span>, outputs <span class="math">1</span> if and only if <span class="math">s\\in X_{pk}</span>. A conjectured counterexample is the set family <span class="math">X_{pk}=Q_{n}</span> of the quadratic residues modulo <span class="math">n=pq</span> (<span class="math">p</span>, <span class="math">q</span> different primes with length <span class="math">\\ell</span>). However, if <span class="math">sk=(p,q)</span> is also provided then there exist an efficient way to recognise the elements in <span class="math">Q_{n}</span>.</p>

    <h2 id="sec-3" class="text-2xl font-bold">3 Easy verifiable functions</h2>

    <p class="text-gray-300">Firstly, recall the definition of a trapdoor one-way function family.</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Definition 1</h6>

    <p class="text-gray-300">Let <span class="math">(PK,SK,I)</span> a keypair generator. Let <span class="math">X</span> and <span class="math">Z</span> be polynomial size set families. Let <span class="math">f:X\\to Z</span> be a family of injective maps and <span class="math">g=\\{g_{sk}:Z_{pk}\\to X_{pk}\\}_{sk\\in SK}</span> the family of their inverses, i.e. <span class="math">g_{sk}(f_{pk}(x))=x</span> for all possible pairs <span class="math">(pk,sk)</span> generated by <span class="math">I</span> and for all <span class="math">x\\in X_{pk}</span>. The map family, <span class="math">f</span>, is called a Trapdoor One-Way (TOW) function family (with respect to the probability distribution <span class="math">I</span>) if and only if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there exist a PT algorithm that on input <span class="math">(pk,x)</span> outputs <span class="math">f_{pk}(x)</span> for all <span class="math">pk\\in PK</span> and <span class="math">x\\in X_{pk}</span>.</li>

      <li>there exist a PT algorithm that on input <span class="math">(sk,z)</span> outputs <span class="math">g_{sk}(z)</span> for all <span class="math">sk\\in SK</span> and <span class="math">z\\in Z_{pk}</span>.</li>

      <li>for any PPT algorithm <span class="math">\\mathcal{A}_{\\mathsf{OW}(f)}</span>,</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{Pr}\\left[\\mathcal{A}_{\\mathsf{OW}(f)}(pk,f_{pk}(x))=x\\mid(pk,sk)\\leftarrow I_{\\ell};\\;x\\leftarrow X_{pk}\\right]\\in\\mathsf{negl}(\\ell)</span></p>

    <p class="text-gray-300">The following definition, based on <em>[17]</em>, is somewhat related to the notion of probabilistic one-way encryption.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Definition 2</h6>

    <p class="text-gray-300">Let <span class="math">(PK,SK,I)</span> a keypair generator. Let <span class="math">X</span>, <span class="math">Y</span> and <span class="math">Z</span> be polynomial size set families. Let <span class="math">f:X\\times Y\\to Z</span> be a family of injective maps and <span class="math">g=\\{g_{sk}:Z_{pk}\\to X_{pk}\\}_{sk\\in SK}</span> the family of their partial inverses, i.e. <span class="math">g_{sk}(f_{pk}(x,y))=x</span> for all possible pairs <span class="math">(pk,sk)</span> generated by <span class="math">I</span> and for all <span class="math">x\\in X_{pk}</span> and <span class="math">y\\in Y_{pk}</span>. The map family, <span class="math">f</span>, is called a Trapdoor Partial One-Way (TPOW) function family (with respect to the probability distribution <span class="math">I</span>) if and only if</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there exist a PT algorithm that on input <span class="math">(pk,x,y)</span> outputs <span class="math">f_{pk}(x,y)</span> for all <span class="math">pk\\in PK</span>, <span class="math">x\\in X_{pk}</span> and <span class="math">y\\in Y_{pk}</span>.</li>

      <li>there exist a PT algorithm that on input <span class="math">(sk,z)</span> outputs <span class="math">g_{sk}(z)</span> for all <span class="math">sk\\in SK</span> and <span class="math">z\\in Z_{pk}</span>.</li>

      <li>for any PPT algorithm <span class="math">\\mathcal{A}_{\\mathsf{POW}(f)}</span>,</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{Pr}\\left[\\mathcal{A}_{\\mathsf{POW}(f)}(pk,f_{pk}(x,y))=x\\mid(pk,sk)\\leftarrow I_{\\ell};\\;x\\leftarrow X_{pk};\\;y\\leftarrow Y_{pk}\\right]\\in\\mathsf{negl}(\\ell)</span></p>

    <p class="text-gray-300">The last condition can be reformulated in terms of the game</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>Game POW()
1 <span class="math">(pk,sk)\\leftarrow I_{\\ell}</span>
2 <span class="math">x\\leftarrow X_{pk};\\;y\\leftarrow Y_{pk}</span>
3 <span class="math">x^{\\prime}\\leftarrow\\mathcal{A}_{\\mathsf{POW}(f)}(pk,f_{pk}(x,y))</span></p>
    </blockquote>

    <p class="text-gray-300">and the probability <span class="math">\\mathsf{Succ}\\left[\\mathcal{A}_{\\mathsf{POW}(f)}\\right]=\\mathsf{Pr}\\left[x^{\\prime}=x\\right]\\in\\mathsf{negl}(\\ell)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notice that the concept of TOW function family can be seen as a particular case of TPOW, in which $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Starting from <span class="math">f</span>, a probabilistic one-way cryptosystem, <span class="math">(\\mathsf{KeyGen}^{f},\\mathsf{Enc}^{f},\\mathsf{Dec}^{f})</span>, is obtained in the following way: the keys <span class="math">(pk,sk)=\\mathsf{KeyGen}^{f}(1^{\\ell})=I_{\\ell}</span> are generated by using the sampling algorithm for <span class="math">I</span>, the ciphertext for a message <span class="math">x\\in X_{pk}</span></p>

    <p class="text-gray-300">randomness <span class="math">y\\leftarrow Y_{pk}</span> is <span class="math">c=\\mathsf{Enc}^{f}(pk,x)=f_{pk}(x,y)</span> and a valid ciphertext <span class="math">z\\in Z_{pk}</span> is decrypted by means of <span class="math">\\mathsf{Dec}^{f}(sk,c)=g_{sk}(c)</span>. Note that we are implicitly assuming that <span class="math">Y</span> is samplable. In this context, there is no need to specify what happens when an invalid ciphertext, i.e. a polynomial size string <span class="math">z\\not\\in Z_{pk}</span>, is submited to <span class="math">\\mathsf{Dec}^{f}</span>.</p>

    <p class="text-gray-300">A new kind of attacks and computational problems have been introduced and found various applications in the context of probabilistic cryptosystems (cf <em>[13, 14]</em>). In this new scenario, the attacker has access to a Plaintext-Checking Oracle that checks if a given ciphertext <span class="math">z</span> is an encryption of a given message <span class="math">x</span>. This attack is called Plaintext-Checking Attack (PCA), and it can be reformulated in terms of trapdoor partial one-way functions.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Definition 3</h6>

    <p class="text-gray-300">A TPOW function family <span class="math">f:X\\times Y\\rightarrow Z</span> is Partial One-Way against Plaintext-Checking Attacks (POW-PCA) if it is a TPOW function even when access to a plaintext checking oracle <span class="math">\\mathcal{C}_{pk}</span> is given. For a query <span class="math">(x,z)</span>, where <span class="math">x\\in X_{pk}</span> and <span class="math">z\\in Z_{pk}</span>, <span class="math">\\mathcal{C}_{pk}</span> answers 1 if there exists <span class="math">y\\in Y_{pk}</span> such that <span class="math">f_{pk}(x,y)=z</span>, and 0 otherwise. (It is assumed that if <span class="math">x</span> or <span class="math">z</span> are outside their domains, the oracle also answers 0.)</p>

    <p class="text-gray-300">This notion is stronger than partial one-wayness, since now the adversary is provided with extra computational resources. Now we formalize the concept of easy verifiability, informally described in <em>[17]</em>, that captures the situation in which there exists an efficient algorithm that verifies if a pair <span class="math">(x,z)</span> is correct, that is, the algorithm implements a plaintext checking oracle.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Definition 4</h6>

    <p class="text-gray-300">The TPOW map family <span class="math">f:X\\times Y\\rightarrow Z</span> is easy verifiable if and only if there exists a (deterministic) PT algorithm <span class="math">\\mathcal{V}</span>, called plaintext checking algorithm, such that given any <span class="math">pk\\in PK</span>, <span class="math">\\mathcal{V}(pk,x,z)=1</span> if <span class="math">x\\in X_{pk}</span>, <span class="math">z\\in Z_{pk}</span> and there exists <span class="math">y\\in Y_{pk}</span> such that <span class="math">f_{pk}(x,y)=z</span>, and 0 otherwise.</p>

    <p class="text-gray-300">Obviously, if <span class="math">f</span> is easy verifiable then the Plaintext-Checking Oracle for <span class="math">f</span> can be replaced by the algorithm <span class="math">\\mathcal{V}</span>, without introducing any modification in the adversary’s model of computation. These functions are very interesting, since</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Lemma 5</h6>

    <p class="text-gray-300">If the map family <span class="math">f:X\\times Y\\rightarrow Z</span> is easy verifiable then it is POW-PCA.</p>

    <p class="text-gray-300">Note that the existence of the plaintext checking algorithm would imply that the set <span class="math">X</span> is recognizable. This is due to the fact that the polynomial time algorithm that computes <span class="math">f_{pk}(x,y)</span> could work when <span class="math">x</span> lies in a set <span class="math">\\bar{X}_{pk}</span> broader than <span class="math">X_{pk}</span>. Then, by definition, the output of <span class="math">\\mathcal{V}(pk,x,f_{pk}(x,y))</span>, for any choice of <span class="math">y\\in Y_{pk}</span>, can be used to efficiently recognise if <span class="math">x\\in\\bar{X}_{pk}</span> is in <span class="math">X_{pk}</span>. For instance, no easy verifiable function exists if <span class="math">X_{pk}=Q_{n}</span> (i.e. the set of quadratic residues modulo <span class="math">n=pq</span>) unless the quadratic residuosity modulo <span class="math">n</span> problem is solvable in deterministic polynomial time. Nevertheless, such a function can achieve POW-PCA under a computational gap assumption (e.g. the gap between the quadratic residuosity modulo <span class="math">n</span> and the factoring <span class="math">n</span> assumptions).</p>

    <p class="text-gray-300">It is straightforward to modify a TOW function family <span class="math">f^{\\prime}:X\\rightarrow Z^{\\prime}</span> to obtain a easy verifiable function family <span class="math">f</span>. To do it, simply take <span class="math">Y=\\{0,1\\}^{p(\\ell)}</span>, where <span class="math">p(\\ell)\\in\\mathsf{poly}(\\ell)</span>, and define <span class="math">f_{pk}(x,y)=(f^{\\prime}_{pk}(x),y)</span>, that is, leaving <span class="math">y</span> “in the clear”.</p>

    <p class="text-gray-300">For an arbitrary TPOW function a plaintext checking algorithm could not exist. For instance, this is supposed to be the case for El Gamal and Okamoto-Uchiyama</p>

    <p class="text-gray-300">functions. In this situation, we are forced to base POW-PCA on a gap problem, which is a stronger assumption (cf <em>[13, 14]</em>).</p>

    <p class="text-gray-300">A non-trivial example of easy verifiable function is the RSA-Paillier trapdoor bijection defined in <em>[4]</em>. A generalization of that function is presented below.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">3.1 Non-trivial families of easy verifiable functions</h3>

    <p class="text-gray-300">Let <span class="math">n=pq</span>, where <span class="math">p</span> and <span class="math">q</span> are different primes with equal length <span class="math">\\ell</span>. Let <span class="math">e&lt;n</span> be an integer such that <span class="math">\\gcd(e,(p-1)(q-1))=1</span>. For any integer <span class="math">r&gt;1</span> with size polynomial in <span class="math">\\ell</span>, consider the subset <span class="math">\\Omega_{n,r}\\subset\\mathbb{Z}_{nr}</span> defined as <span class="math">\\Omega_{n,r}=\\mathbb{Z}_{n}^{\\star}+n\\mathbb{Z}_{r}</span>. Then, the function</p>

    <p class="text-gray-300"><span class="math">f_{n,r,e}:\\mathbb{Z}_{n}^{\\star}\\times\\mathbb{Z}_{r}</span> <span class="math">\\longrightarrow</span> <span class="math">\\Omega_{n,r}</span> <span class="math">(x,y)</span> <span class="math">\\longrightarrow</span> <span class="math">x^{e}+ny\\bmod nr</span></p>

    <p class="text-gray-300">is a trapdoor bijection family, for <span class="math">pk=(n,r,e)</span> and <span class="math">sk=(p,q,r,d)</span>, where <span class="math">d</span> is the inverse of <span class="math">e</span> modulo <span class="math">(p-1)(q-1)</span>.</p>

    <p class="text-gray-300">Notice that this function is well defined since <span class="math">z\\in\\Omega_{n,r}</span> iff <span class="math">z\\bmod n\\in\\mathbb{Z}_{n}^{\\star}.</span> Let see that <span class="math">f_{n,r,e}</span> is a bijection. Suppose that <span class="math">f_{n,r,e}(x_{0},y_{0})=f_{n,r,e}(x_{1},y_{1})</span> for some <span class="math">x_{0}</span>, <span class="math">y_{0}</span>, <span class="math">x_{1}</span> and <span class="math">y_{1}</span>. Reducing the equality modulo <span class="math">n</span> we get <span class="math">x_{0}^{e}=x_{1}^{e}\\bmod n</span>, and then <span class="math">x_{0}=x_{1}\\bmod n</span>. This implies <span class="math">ny_{0}=ny_{1}\\bmod nr</span>, so <span class="math">y_{0}=y_{1}\\bmod r</span> and the function <span class="math">f_{n,r,e}</span> is injective. Finally, given <span class="math">(p,q,r,d)</span>, to invert <span class="math">f_{n,r,e}</span> on input <span class="math">z=f_{n,r,e}(x,y)</span>, it suffices to compute <span class="math">x=z^{d}\\bmod n</span>. Then, <span class="math">y</span> is easily obtained from the equation <span class="math">ny=z-x^{e}\\bmod nr</span>. This shows <span class="math">f_{n,r,e}</span> is exhaustive, and therefore it is a bijection.</p>

    <p class="text-gray-300">The above implies there exist two PT algorithms that compute both <span class="math">f_{n,r,e}</span> and its partial inverse.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Proposition 6</h6>

    <p class="text-gray-300">The partial one-wayness of the bijection family <span class="math">f_{n,r,e}</span> is tightly equivalent to the one-wayness of <span class="math">RSA[n,e]</span>.</p>

    <p class="text-gray-300">Proof:</p>

    <p class="text-gray-300"><span class="math">\\Rightarrow)</span> Assume that for some <span class="math">\\ell</span> there exist a PPT algorithm, <span class="math">\\mathcal{A}</span>, breaking the partial one-wayness of <span class="math">f_{n,r,e}</span> in time <span class="math">T</span> and probability <span class="math">\\epsilon</span>, i.e.</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathcal{A}(n,r,e,x^{e}+ny\\bmod nr)=x\\mid x\\leftarrow\\mathbb{Z}_{n}^{\\star};y\\leftarrow\\mathbb{Z}_{r}\\right]=\\epsilon</span></p>

    <p class="text-gray-300">The following PPT algorithm, <span class="math">\\mathcal{B}</span>, can be used to invert the <span class="math">RSA[n,e]</span> function (i.e. <span class="math">RSA<a href="x">n,e</a>=x^{e}\\bmod n)</span> in time <span class="math">T+O(\\ell^{2})</span> with probability at least <span class="math">\\epsilon</span>:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}(n,e,z)</span> <span class="math">1</span> <span class="math">y\\leftarrow\\mathbb{Z}_{r},\\,z^{\\prime}=z+ny\\bmod nr</span> <span class="math">2</span> <span class="math">x\\leftarrow\\mathcal{A}(n,r,e,z^{\\prime})</span> <span class="math">3</span> return <span class="math">x</span></p>

    <p class="text-gray-300">Then, <span class="math">\\Pr\\left[\\mathcal{B}(n,x^{e}\\bmod n)=x\\mid x\\leftarrow\\mathbb{Z}_{n}^{\\star}\\right]\\geq\\epsilon</span>.</p>

    <p class="text-gray-300"><span class="math">\\Leftarrow)</span> Trivial.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Proposition 7</h6>

    <p class="text-gray-300">The bijection family <span class="math">f_{n,r,e}</span> is easy verifiable.</p>

    <p class="text-gray-300">Proof: Given <span class="math">(n,r,e)</span>, it is straightforward to design a plaintext checking algorithm. Firstly, verify if <span class="math">x\\in\\mathbb{Z}_{n}^{\\star}</span> and <span class="math">z\\in\\Omega_{n,r}</span>, that is, <span class="math">z&lt;nr</span> and <span class="math">z\\bmod n\\in\\mathbb{Z}_{n}^{\\star}</span>. Then, check if the equation <span class="math">x^{e}\\equiv z\\pmod{n}</span> holds.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">7</p>

    <p class="text-gray-300">Let us briefly recall some standard definitions about the security of both symmetric and asymmetric encryption.</p>

    <h2 id="sec-13" class="text-2xl font-bold">4.1 Symmetric encryption</h2>

    <p class="text-gray-300">Let <span class="math">K</span> and <span class="math">M</span> be two (samplable and recognisable) polynomial size sets that respectively denote the key and message spaces. Consider a symmetric encryption scheme <span class="math">\\mathcal{E}^{sym} = (\\mathsf{KeyGen}^{sym}, \\mathsf{Enc}^{sym}, \\mathsf{Dec}^{sym})</span> over these sets with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{KeyGen}^{sym}</span> is a PPT algorithm that on input <span class="math">1^{\\ell}</span> outputs an uniformly distributed element in <span class="math">K_{\\ell}</span>.</li>

      <li><span class="math">\\mathsf{Enc}^{sym}</span> and <span class="math">\\mathsf{Dec}^{sym}</span> are PT algorithms with inputs are in <span class="math">K_{\\ell} \\times M_{\\ell}</span> and outputs in <span class="math">M_{\\ell}</span>. Denote <span class="math">\\mathsf{Enc}_k^{sym}(m) = \\mathsf{Enc}^{sym}(k, m)</span> and <span class="math">\\mathsf{Dec}_k^{sym}(c) = \\mathsf{Dec}^{sym}(k, c)</span>. For each <span class="math">k \\in K_{\\ell}</span>, <span class="math">\\mathsf{Enc}_k^{sym}</span> is a bijection on <span class="math">M_{\\ell}</span> and <span class="math">\\mathsf{Dec}_k^{sym}</span> is its inverse.</li>

      <li>For each pair <span class="math">(m, c) \\in M_{\\ell} \\times M_{\\ell}</span> there are at most <span class="math">\\gamma</span> values of <span class="math">k \\in K_{\\ell}</span> such that <span class="math">c = \\mathsf{Enc}_k^{sym}(m)</span>. (Most of the known symmetric cryptosystems have <span class="math">\\gamma = 1</span>.)</li>

    </ul>

    <p class="text-gray-300">Such a cryptosystem has indistinguishability of encryptions (IND-SYM), also called Find-Guess security in [10], if any couple of PPT algorithms <span class="math">\\mathcal{A}_{\\mathrm{IND - SYM}}(\\mathcal{E}^{sym}) = (\\mathcal{A}_1, \\mathcal{A}_2)</span> (called "finding" and "guessing" stages of the adversary) have negligible advantage in the following game:</p>

    <pre><code class="language-text">Game IND-SYM()
1  b  ←  {0,1}
2  (m₀, m₁, s)  ←  \\mathcal{A}_1(1^{\\ell})
3  k  ←  K_{\\ell};  c^{\\star} = \\mathsf{Enc}_k^{sym}(m_b)
4  b&#x27;  ←  \\mathcal{A}_2(s, c^{\\star})</code></pre>

    <p class="text-gray-300">That is, <span class="math">\\mathcal{E}^{sym}</span> is IND-SYM if and only if for all <span class="math">(\\mathcal{A}_1,\\mathcal{A}_2)</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Adv} \\left[ \\mathcal{A}_{\\mathrm{IND - SYM}}(\\mathcal{E}^{sym}) \\right] = \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2 \\Pr \\left[ b' = b \\right] - 1 \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ b' = b \\right] - \\Pr \\left[ b' \\neq b \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in \\operatorname{negl}(\\ell)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The messages <span class="math">m_0</span> and <span class="math">m_1</span> generated by <span class="math">\\mathcal{A}_1</span> must be in <span class="math">M_{\\ell}</span>.</p>

    <h2 id="sec-14" class="text-2xl font-bold">4.2 Asymmetric encryption</h2>

    <p class="text-gray-300">Let <span class="math">(PK, SK, I)</span> a keypair generator, defined as in section 2. Let <span class="math">M</span>, <span class="math">R</span> and <span class="math">C</span> be polynomial size set families. Consider an asymmetric encryption scheme <span class="math">\\mathcal{E}^{sym} = (\\mathsf{KeyGen}, \\mathsf{Enc}, \\mathsf{Dec})</span> over these sets with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{KeyGen}</span> is a PPT sampling algorithm for <span class="math">I</span>, that is, <span class="math">(pk, sk) = \\mathsf{KeyGen}(1^{\\ell})</span> is distributed as <span class="math">I_{\\ell}</span> on <span class="math">PK_{\\ell} \\times SK_{\\ell}</span>.</li>

      <li><span class="math">\\mathsf{Enc}: PK \\times M \\times R \\to C</span> and <span class="math">\\mathsf{Dec}: SK \\times C \\to M</span> are PT algorithms such that for any pair <span class="math">(pk, sk)</span> generated by <span class="math">\\mathsf{KeyGen}(1^{\\ell})</span>, <span class="math">\\mathsf{Dec}(sk, \\mathsf{Enc}(pk, m, r)) = m</span> for any <span class="math">m \\in M_{pk}</span> and <span class="math">r \\in R_{pk}</span>. In fact, <span class="math">\\mathsf{Enc}</span> can be seen as a PPT algorithm with input in <span class="math">PK \\times M</span> and coins taken in <span class="math">R</span>.</li>

    </ul>

    <p class="text-gray-300">Such a cryptosystem has indistinguishability of encryptions under a chosen ciphertext attack (IND-CCA), if any couple of PPT algorithms <span class="math">\\mathcal{A}_{\\text{IND-CCA}(\\mathcal{E})}=(\\mathcal{A}_{1},\\mathcal{A}_{2})</span> have negligible advantage in trying to distinguish the encryptions of two (conveniently selected) messages, with access to two decryption oracles <span class="math">\\mathcal{D}_{sk}</span> and <span class="math">\\mathcal{D}_{sk,c^{\\star}}</span>. When queried with a ciphertext <span class="math">c</span> the first decription oracle answers <span class="math">\\mathsf{Dec}(sk,c)</span>. The only difference between <span class="math">\\mathcal{D}_{sk}</span> and <span class="math">\\mathcal{D}_{sk,c^{\\star}}</span> is that <span class="math">\\mathcal{D}_{sk,c^{\\star}}</span> rejects the query <span class="math">c^{\\star}</span>, answering the special reject symbol <span class="math">\\bot</span>.</p>

    <p class="text-gray-300">More formally, consider the following game:</p>

    <pre><code class="language-text">Game IND-CCA()
1 $(pk,sk)\\leftarrow\\textsf{KeyGen}(1^{\\ell})$
2 $b\\leftarrow\\{0,1\\}$
3 $(m_{0},m_{1},s)\\leftarrow\\mathcal{A}_{1}^{\\mathcal{D}_{sk}}(pk)$
4 $c^{\\star}\\leftarrow\\mathsf{Enc}(pk,m_{b})$
5 $b^{\\prime}\\leftarrow\\mathcal{A}_{2}^{G,H,\\mathcal{D}_{sk,c^{\\star}}}(s,c^{\\star})$</code></pre>

    <p class="text-gray-300">Then, <span class="math">\\mathcal{E}</span> is IND-CCA if and only if for all couples of PPT algorithms <span class="math">\\mathcal{A}_{\\text{IND-CCA}(\\mathcal{E})}=(\\mathcal{A}_{1},\\mathcal{A}_{2})</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{Adv}\\left[\\mathcal{A}_{\\text{IND-CCA}(\\mathcal{E})}\\right]=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2\\mathsf{Pr}\\left[b^{\\prime}=b\\right]-1\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Pr}\\left[b^{\\prime}=b\\right]-\\mathsf{Pr}\\left[b^{\\prime}\\neq b\\right]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in\\mathsf{negl}(\\ell)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The messages <span class="math">m_{0}</span> and <span class="math">m_{1}</span> generated by <span class="math">\\mathcal{A}_{1}</span> must be in <span class="math">M_{pk}</span>.</p>

    <p class="text-gray-300">Notice that the decryption oracle formalizes the access to a decryption machine. Thus, the adversary is free to submit any polynomially bounded string (except for the target ciphertext, <span class="math">c^{\\star}</span>, in the guessing stage) to this oracle. This means that IND-CCA security depends not only on the encryption algorithm but also on the concrete implementation of the decryption algorithm, including its behaviour for inputs outside the set of valid ciphertexts (i.e. ciphertexts of the form <span class="math">\\mathsf{Enc}(pk,m,r)</span> for <span class="math">m\\in M_{pk}</span> and <span class="math">r\\in R_{pk}</span>). This behaviour can give very useful information for an adversary.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">4.3 Random oracle model</h3>

    <p class="text-gray-300">There are some ways to define random functions or random oracles in the literature. In the seminal work <em>[2]</em>, random oracles act as random functions from <span class="math">\\{0,1\\}^{\\star}</span> to <span class="math">\\{0,1\\}^{\\infty}</span>, while in the influential paper <em>[3]</em> the random functions are collections of functions. Moreover, in the second definition for a given value of the complexity parameter, <span class="math">\\ell</span>, the corresponding function goes from <span class="math">\\{0,1\\}^{p_{I}(\\ell)}</span> to <span class="math">\\{0,1\\}^{p_{O}(\\ell)}</span>, where <span class="math">p_{I}(\\ell),p_{O}(\\ell)\\in\\mathsf{poly}(\\ell)</span>. Furthermore, the security of some schemes (e.g. <em>[11]</em>) depends on which definition of random function is used.</p>

    <p class="text-gray-300">In this paper, a random oracle is viewed as a special type of random process or random sequence. The random oracle is defined through its idealised functionality, that is closely related to the random oracle simulations often used in the proofs of security.</p>

    <p class="text-gray-300">Let <span class="math">A</span> be a samplable polynomial size set. A random function <span class="math">G</span> over <span class="math">A</span> is a sequence of uniformly distributed independent random variables over <span class="math">A</span>, indexed by the elements of <span class="math">\\{0,1\\}^{\\star}</span>. Notice that <span class="math">\\{0,1\\}^{\\star}</span> is an ordered set. A random oracle over <span class="math">A</span> is an oracle that answers queries exactly as if the random function <span class="math">G</span> was evaluated.</p>

    <p class="text-gray-300">The main property of a random function is that the joint distribution of <span class="math">q_{G}</span> variables <span class="math">G(s)</span> for distinct values of <span class="math">s</span> is the same regardless which values of <span class="math">s</span> are selected. Thus, an efficient probabilistic (interactive) algorithm can simulate this random function by means of a table <span class="math">\\mathcal{T}_{G}</span> storing all previous queries along with their answers. Any new (yet unanswered) query will be answered with a “fresh” random value, that will be annotated in <span class="math">\\mathcal{T}_{G}</span>.</p>

    <p class="text-gray-300"><span class="math">G(s)</span> 1 if <span class="math">s\\in\\mathcal{T}_{G}</span>; return <span class="math">\\mathcal{T}_{G}(s)</span>; endif 2 <span class="math">g\\leftarrow A</span> 3 insert <span class="math">(s,g)</span> in table <span class="math">\\mathcal{T}_{G}</span> 4 return <span class="math">g</span></p>

    <p class="text-gray-300">Here, <span class="math">s\\in\\mathcal{T}_{G}</span> will denote the fact that <span class="math">s</span> has been queried to <span class="math">G</span> by some party and <span class="math">\\mathcal{T}_{G}(s)</span> will denote the answer given by <span class="math">G</span> to that query.</p>

    <p class="text-gray-300">Notice that the above algorithm runs in polynomial time and space if,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">A</span> is a samplable polynomial size set</li>

      <li>during the game, in which the different parties have access to the random oracle, no more than a polynomial quantity, <span class="math">q_{G}(\\ell)\\in\\mathsf{poly}(\\ell)</span>, of queries are made</li>

      <li>the size of each query is limited by a polynomial function in <span class="math">\\ell</span></li>

    </ul>

    <p class="text-gray-300">This last condition will be obviously fulfil if all parties are modeled by polynomial time machines.</p>

    <p class="text-gray-300">Finally, IND-CCA security in the Random Oracle Model (ROM) of an asymmetric cryptosystem <span class="math">\\mathcal{E}</span> is defined in the same way as above, but providing the adversary with oracle access to one or more random functions. In order to formalize the random coins of the random functions, a step <span class="math">G\\leftarrow\\mathcal{R}(A)</span> will be added at the beginning of the IND-CCA game for each random function used.</p>

    <p class="text-gray-300">Obviously, in the real world random functions have to be adequately replaced by (hash) function families with a polynomial size description. This description will be included in the public data available to all parties in a protocol (e.g. the public key of an encryption scheme).</p>

    <h2 id="sec-16" class="text-2xl font-bold">5 Revisiting Fujisaki-Okamoto hybrid scheme</h2>

    <p class="text-gray-300">In this section, the transformation introduced in <em>[10]</em> of weak symmetric and asymmetric schemes into an IND-CCA hybrid encryption scheme is revisited.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">5.1 The original construction</h3>

    <p class="text-gray-300">Let <span class="math">\\mathcal{E}^{f}=(\\mathsf{KeyGen}^{f},\\mathsf{Enc}^{f},\\mathsf{Dec}^{f})</span> be a probabilistic asymmetric encryption scheme, defined from a TPOW function family <span class="math">f</span> over the sets <span class="math">X</span>, <span class="math">Y</span> and <span class="math">Z</span>, and <span class="math">\\mathcal{E}^{sym}=(\\mathsf{KeyGen}^{sym},\\mathsf{Enc}^{sym},\\mathsf{Dec}^{sym})</span> be a symmetric encryption scheme over the sets <span class="math">K</span> and <span class="math">M</span>. Let <span class="math">G</span> be a random function over <span class="math">K</span> and <span class="math">H</span> an independent random function over <span class="math">Y</span>. The hybrid scheme, <span class="math">\\mathcal{E}^{FO}=(\\mathsf{KeyGen}^{FO},\\mathsf{Enc}^{FO},\\mathsf{Dec}^{FO})</span>, proposed by Fujisaki and Okamoto works as follows.</p>

    <p class="text-gray-300">Key generation. The public and secret keys are generated as in <span class="math">\\mathsf{KeyGen}^{f}</span>.</p>

    <p class="text-gray-300">Encryption. The ciphertext for a message <span class="math">m\\in M_{\\ell}</span> is <span class="math">c=(f_{pk}(x,y),\\mathsf{Enc}_{{}_{G(x)}}^{sym}(m))</span>, where <span class="math">y=H(x,m)</span> and <span class="math">x</span> is uniformly chosen in <span class="math">X_{pk}</span>.</p>

    <p class="text-gray-300">Decryption. To decrypt a ciphertext <span class="math">c=(c_{1},c_{2})</span>, firstly compute <span class="math">x=g_{sk}(c_{1})</span>. Then, compute <span class="math">m=\\mathsf{Dec}_{{}_{G(x)}}^{sym}(c_{2})</span> and return <span class="math">m</span> if <span class="math">c_{1}=f_{pk}(x,H(x,m))</span>. Otherwise, return the reject symbol <span class="math">\\bot</span>. If it is not possible to compute <span class="math">g_{sk}(c_{1})</span> or <span class="math">\\mathsf{Dec}_{{}_{G(x)}}^{sym}(c_{2})</span>, return <span class="math">\\bot</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}[T,\\epsilon,q_{G},q_{H},q_{D}]</span> denote an adversary against the <span class="math">\\mathsf{IND-CCA}</span> security of the above cryptosystem that runs in time <span class="math">T</span> with advantage <span class="math">\\epsilon</span>, doing no more than <span class="math">q_{G}</span>, <span class="math">q_{H}</span> and <span class="math">q_{D}</span> queries respectively to the random oracles <span class="math">G</span>, <span class="math">H</span> and to the decryption oracle, <span class="math">\\mathcal{D}_{sk}</span>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Theorem 8</h6>

    <p class="text-gray-300">If there exists for some values of <span class="math">\\ell</span> an adversary <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}[T,\\epsilon,q_{G},q_{H},q_{D}]</span>, then there exist an adversary <span class="math">\\mathcal{A}_{\\mathsf{POW}(f)}</span> against the <span class="math">\\mathsf{POW}</span> of <span class="math">f</span> in time <span class="math">T_{1}</span> with success probability <span class="math">\\epsilon_{1}</span> and an adversary <span class="math">\\mathcal{A}_{\\mathsf{IND-SYM}(\\mathcal{E}^{sym})}</span> against the <span class="math">\\mathsf{IND-SYM}</span> security of <span class="math">\\mathcal{E}^{sym}</span> in time <span class="math">T_{2}</span> with advantage <span class="math">\\epsilon_{2}</span> such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon\\leq(2(q_{G}+q_{H})\\epsilon_{1}+\\epsilon_{2}+1)\\left(1-2\\epsilon_{1}-2\\epsilon_{2}-\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}-\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^{-q_{D}}-1$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$T=\\min(T_{1},T_{2})-O((q_{G}+q_{H})\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The main drawback of this scheme is that the security reduction obtained in the proof is not tight, due to the quantity <span class="math">q_{G}+q_{H}</span> multiplying <span class="math">\\epsilon_{1}</span>. However, the same authors improved in <em>[11]</em> this result for the particular case of the Okamoto-Uchiyama scheme <em>[15]</em> (known as EPOC-2) and claimed, without proof, that a tight reduction is obtained for trivial easy verifiable primitives, using our terminology.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">5.2 Identifying dangerous ambiguities</h3>

    <p class="text-gray-300">However, as pointed out in the introduction, several attacks against EPOC-2 have been found <em>[12, 8, 18]</em>. Despite the precisions introduced about FO conversion after <em>[12]</em>, there are still some ambiguities in the scheme, as well as in the security proof, that compromise the validity of the theorem above.</p>

    <p class="text-gray-300">For instance, let us consider a TPOW function family <span class="math">f</span>, and <span class="math">X_{pk}\\subset\\bar{X}_{pk}</span> such that <span class="math">f_{pk}(x,y)</span> is computable in polynomial time for any <span class="math">x\\in\\bar{X}_{pk}</span> and <span class="math">y\\in Y_{pk}</span>. Then, some badly generated ciphertexts <span class="math">c=(f_{pk}(x,H(x,m)),\\mathsf{Enc}_{{}_{G(x)}}^{sym}(m))</span> for <span class="math">x\\in\\bar{X}_{pk}\\setminus X_{pk}</span> may be accepted. This was the case for Okamoto-Uchiyama function in the original EPOC-2, where <span class="math">\\bar{X}_{pk}=\\mathbb{Z}_{2^{\\ell}+1}</span> and <span class="math">X_{pk}=\\mathbb{Z}_{2^{\\ell}}</span>, for <span class="math">2^{\\ell}&lt;p&lt;2^{\\ell}+1</span>. This information was used in <em>[12]</em> to obtain the secret value <span class="math">p</span>.</p>

    <p class="text-gray-300">As Fujisaki and Okamoto proposed later in <em>[11]</em>, this attack is avoided if all ciphertexts <span class="math">(c_{1},c_{2})</span> such that <span class="math">g_{sk}(c_{1})\\not\\in X_{pk}</span> are rejected. However, when this change is included in the general conversion a problem of different kind arises. If <span class="math">X</span> is not a recognizable set, the checking cannot be performed in polynomial time. In this case the simulation of the <span class="math">\\mathcal{D}_{sk}</span> in the proof is not correct.</p>

    <p class="text-gray-300">Yet one could manage to use an additional oracle to solve this problem. In this situation, an adversary can use the decryption oracle to solve a difficult decisional</p>

    <p class="text-gray-300">problem. As a result, we only could guarantee that breaking security of the cryptosystem is equivalent to solve a gap problem, that is, a stronger assumption than claimed.</p>

    <p class="text-gray-300">This is the case for the Blum-Williams one-way trapdoor bijection family (i.e. squaring quadratic residues modulo <span class="math">n=pq</span>), where <span class="math">X_{pk}=Q_{n}</span> and <span class="math">\\bar{X}_{pk}=\\mathbb{Z}_{n}</span>. Rejection of all ciphertexts <span class="math">(c_{1},c_{2})</span> such that <span class="math">g_{sk}(c_{1})\\not\\in X_{pk}</span> means that the adversary will know if an arbitary <span class="math">x\\in\\mathbb{Z}_{n}</span> is a quadratic residue. Thus, the IND-CCA security of the hybrid cryptosystem will be based on the gap between the quadratic residuosity modulo <span class="math">n</span> and factoring <span class="math">n</span> assumptions.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">5.3 The new proposal</h3>

    <p class="text-gray-300">From the above discussion we know that, although it is necessary to check if <span class="math">g_{sk}(c_{1})\\in X_{pk}</span>, to avoid leaking vital information, this cannot be done in all cases. In this section we restrict the asymmetric primitives to that which admit a correct and unambiguous proof of security for the general transformation.</p>

    <p class="text-gray-300">We also take into account the results in <em>[8, 18]</em> that use the ability to distinguish among rejection rules in the hybrid scheme to launch a total break. Thus, we slightly modify the specification of the decryption algorithm in the conversion.</p>

    <p class="text-gray-300">Finally, the recent developments in <em>[14, 5, 6]</em> can be applied to this transformation, and together with the concept of easy verifiable primitives, they are used to give a new proof of security improving the concrete security result presented in the original work.</p>

    <p class="text-gray-300">As in the original transformation, let <span class="math">\\mathcal{E}^{f}=(\\mathsf{KeyGen}^{f},\\mathsf{Enc}^{f},\\mathsf{Dec}^{f})</span> be a probabilistic asymmetric encryption scheme, defined from a TPOW function family <span class="math">f</span> over the sets <span class="math">X</span>, <span class="math">Y</span> and <span class="math">Z</span>, and <span class="math">\\mathcal{E}^{sym}=(\\mathsf{KeyGen}^{sym},\\mathsf{Enc}^{sym},\\mathsf{Dec}^{sym})</span> be a symmetric encryption scheme over the sets <span class="math">K</span> and <span class="math">M</span>. Let <span class="math">G</span> be a random function over <span class="math">K</span> and <span class="math">H</span> an independent random function over <span class="math">Y</span>.</p>

    <p class="text-gray-300">The first change we introduce is that the random functions <span class="math">G</span> and <span class="math">H</span> are defined with unrestricted inputs, as explained in subsection 4.3. We think it is not realistic to restrict the inputs of the random functions, as suggested in <em>[10]</em>, since in a practical implementation random functions are replaced by cryptographic hash functions. Then, if a proof of security can be driven for unrestricted domains, this choice is preferable.</p>

    <p class="text-gray-300">The following modification to the original proposal shorten the range of asymmetric primitives that can be used. Now, <span class="math">X</span> and <span class="math">M</span> must be recognizable sets. This not an actual restriction for <span class="math">M</span>, since almost always <span class="math">M_{\\ell}=\\{0,1\\}^{p(\\ell)}</span>, for some polynomial <span class="math">p</span>. It is not demmanded <span class="math">Z</span> to be a recognizable set. Instead of this, it is assumed that there exists a recognizable set <span class="math">\\bar{Z}</span> such that <span class="math">Z_{pk}\\subseteq\\bar{Z}_{pk}</span>, and that the partial inverse of <span class="math">f_{pk}</span> can also be computed (in polynomial time) on elements of the extended set <span class="math">\\bar{Z}_{pk}</span>.</p>

    <p class="text-gray-300">The proposed hybrid cryptosystem, <span class="math">\\mathcal{E}=(\\mathsf{KeyGen},\\mathsf{Enc},\\mathsf{Dec})</span>, is almost the same as the original. The only but important change is that now two different reject symbols are produced in the decryption algorithm <span class="math">\\mathsf{Dec}</span>. Thus, when a ciphertext is rejected, the adversary will know the reason, obtaining different reject symbols without mounting a timing attack. Then, if the computing time of each step in the algorithm is independent of the data, the scheme is closely to be robust against reject timing attacks.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Dec}(sk,c)</span> 1 if <span class="math">c\\not\\in\\bar{Z}_{pk}\\times M_{\\ell}</span>; return <span class="math">\\perp_{1}</span>; endif 2 <span class="math">(c_{1},c_{2})=c</span> 3 <span class="math">x\\leftarrow g_{sk}(c_{1})</span> 4 <span class="math">m\\leftarrow\\mathsf{Dec}_{G(x)}^{sym}(c_{2})</span> 5 <span class="math">y\\leftarrow H(x,m)</span> 6 if <span class="math">x\\not\\in X_{pk}\\text{\\,}\\mathrm{or}\\&gt;f_{pk}(x,y)\\neq c_{1}</span>; return <span class="math">\\perp_{2}</span>; endif 7 return <span class="math">m</span></p>

    <p class="text-gray-300">We point out that in the or operation in step 6 of the algorithm both predicates have <em>always</em> to be evaluated, in order to prevent the adversary to detect an extra rejection reason.</p>

    <p class="text-gray-300">Now, the security results are stated. The first theorem is for the special case when <span class="math">f</span> is an easy verifiable function family, while the second theorem works for general TPOW function families.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Theorem 9</h6>

    <p class="text-gray-300">If there exists for some values of <span class="math">\\ell</span> an adversary <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}[T,\\epsilon,q_{G},q_{H},q_{D}]</span> against the IND-CCA security of the proposed cryptosystem, then there exist an adversary <span class="math">\\mathcal{A}_{\\mathsf{POW}(f)}</span> that in time <span class="math">T_{1}</span> breaks the POW of <span class="math">f</span> with success probability <span class="math">\\epsilon_{1}</span> and an adversary <span class="math">\\mathcal{A}_{\\mathsf{IND-SYM}(\\mathcal{E}^{sym})}</span> that in time <span class="math">T</span> breaks IND-SYM security of <span class="math">\\mathcal{E}^{sym}</span> with advantage <span class="math">\\epsilon_{2}</span> such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon\\leq\\epsilon_{1}+3\\epsilon_{2}+\\frac{2q_{D}q_{H}\\gamma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-q_{D}q_{H}\\gamma}+\\frac{2q_{D}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-q_{D}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">T_{1}\\leq(q_{G}+q_{H}+q_{D}+q_{G}q_{D})T[\\mathcal{V}]+q_{D}\\Big{(}T[f]+T[\\mathsf{Dec}^{sym}]\\Big{)}+T</span></p>

    <p class="text-gray-300">where <span class="math">T[\\mathcal{V}]</span> is the time complexity of the plaintext checking algoritm for <span class="math">f</span> and <span class="math">T[f]</span> is the time complexity of <span class="math">f</span>.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof is delayed to the appendix. ∎</p>

    <p class="text-gray-300">Notice that now the probabilities are tightly related.</p>

    <p class="text-gray-300">In the general case, there could not exist the plaintext checking algorithm. Using the access to a plaintext checking oracle instead, the following result is straightforward.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Corollary 10</h6>

    <p class="text-gray-300">If there exists for some values of <span class="math">\\ell</span> an adversary <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}[T,\\epsilon,q_{G},q_{H},q_{D}]</span> against the IND-CCA security of the proposed cryptosystem, then there exist an adversary <span class="math">\\mathcal{A}_{\\mathsf{POW-PCA}(f)}</span> that in time <span class="math">T_{1}</span> breaks the POW-PCA of <span class="math">f</span> with success probability <span class="math">\\epsilon_{1}</span> and an adversary <span class="math">\\mathcal{A}_{\\mathsf{IND-SYM}(\\mathcal{E}^{sym})}</span> that in time <span class="math">T</span> breaks IND-SYM security of <span class="math">\\mathcal{E}^{sym}</span> with advantage <span class="math">\\epsilon_{2}</span> such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\epsilon\\leq\\epsilon_{1}+3\\epsilon_{2}+\\frac{2q_{D}q_{H}\\gamma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-q_{D}q_{H}\\gamma}+\\frac{2q_{D}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-q_{D}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">T_{1}\\leq(q_{G}+q_{H}+q_{D}+q_{G}q_{D})+q_{D}\\Big{(}T[f]+T[\\mathsf{Dec}^{sym}]\\Big{)}+T</span></p>

    <p class="text-gray-300">where <span class="math">T[f]</span> is the time complexity of <span class="math">f</span>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">It suffices to invoke the PCA oracle into the plaintext checking algorithm <span class="math">\\mathcal{V}</span> for <span class="math">f</span>. Thus, by definition of oracle access, <span class="math">T[\\mathcal{V}]=1</span>. ∎</p>

    <p class="text-gray-300">5.4 Particular cases</p>

    <p class="text-gray-300">Both in the case of the trivial construction of partial one-way bijection families and in the non-trivial family defined in subsection 3.1, the simulation in the security proof can be improved introducing only technical modifications.</p>

    <p class="text-gray-300">In both cases, there exist a polynomial size set family <span class="math">Z^{\\prime}</span> and two very efficiently computable function families <span class="math">f^{\\prime}:X\\to Z^{\\prime}</span> and <span class="math">\\pi^{\\prime}:\\bar{Z}\\to Z^{\\prime}</span> such that for all <span class="math">pk\\in PK</span>, <span class="math">x\\in X_{pk}</span> and <span class="math">z\\in\\bar{Z}_{pk}</span>, <span class="math">\\mathcal{V}(pk,x,z)=1</span> if and only if <span class="math">f^{\\prime}_{pk}(x)=\\pi^{\\prime}_{pk}(z)</span>. Notice that this property implies the injectivity of <span class="math">f^{\\prime}</span>. It is shown in the appendix that</p>

    <p class="text-gray-300"><span class="math">T[\\mathcal{A}_{\\mathsf{POW}(f)}]</span> <span class="math">\\leq</span> <span class="math">(q_{G}+q_{H}+q_{D})T[\\mathcal{V}]+q_{G}T[f^{\\prime}]+</span> <span class="math">+q_{D}\\Big{(}T[f]+T[\\pi^{\\prime}]+T[\\mathsf{Dec}^{sym}]\\Big{)}+T[\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}]</span></p>

    <p class="text-gray-300">then providing a very-tight security reduction.</p>

    <p class="text-gray-300">If the trivial constructions are considered, <span class="math">f_{pk}(x,y)=(f^{\\prime}_{pk}(x),y)</span> and <span class="math">\\pi^{\\prime}_{pk}(z^{\\prime},y)=z^{\\prime}</span>. Then, <span class="math">T[\\pi^{\\prime}]</span> can be neglected and <span class="math">T[f]\\approx T[f^{\\prime}]\\approx T[\\mathcal{V}]</span>. So</p>

    <p class="text-gray-300"><span class="math">T[\\mathcal{A}_{\\mathsf{POW}(f)}]\\leq(2q_{G}+q_{H}+2q_{D})T[f^{\\prime}]+q_{D}T[\\mathsf{Dec}^{sym}]+T[\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}]</span></p>

    <p class="text-gray-300">On the other hand, if the generalised RSA-Paillier function is used, <span class="math">f^{\\prime}_{n,r,e}(x)=x^{e}\\bmod n</span> and <span class="math">\\pi^{\\prime}_{n,r,e}(z)=z\\bmod n</span>. Then,</p>

    <p class="text-gray-300"><span class="math">T[\\mathcal{A}_{\\mathsf{POW}(f)}]\\leq(2q_{G}+q_{H}+2q_{D})O(\\ell^{2}\\log e)+q_{D}T[\\mathsf{Dec}^{sym}]+T[\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}]</span></p>

    <h2 id="sec-25" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] M. Bellare, A. Desai, D. Pointcheval and P. Rogaway. Relations Among Notions of Security for Public-Key Encryption Schemes. CRYPTO ’98, LNCS 1462 26–45 (1998).</li>

      <li>[2] M. Bellare and P. Rogaway. Random Oracles are Practical: a Paradigm for Designing Efficient Protocols. ACM CCS 93, ACM Press (1993)</li>

      <li>[3] R. Canetti, O. Goldreich and S. Halevi. The random oracle methodology, revisited. In Proceedings of the 32nd Annual ACM Symposium on Theory of Computing, 209–218 (1998).</li>

      <li>[4] D. Catalano, R. Gennaro, N. Howgrave-Graham and P. Q. Nguyen. Paillier’s Cryptosystem Revisited. ACM CCS ’2001 ACM Press (2001).</li>

      <li>[5] J. Coron, H. Handschuh, M. Joye, P. Paillier, D. and C. Tymen. GEM: a Generic Chosen-Ciphertext Secure Encryption Method. CT-RSA’ 02, LNCS 2271 263–276 (2002).</li>

      <li>[6] J. Coron, H. Handschuh, M. Joye, P. Paillier, D. Pointcheval and C. Tymen. Optimal Chosen-Ciphertext Secure Encryption of Arbitrary-Length Messages. PKC 2002, LNCS 2274 17–33 (2002).</li>

      <li>[7] R. Cramer and V. Shoup. Universal Hash Proofs and a Paradigm for Adaptive Chosen Ciphertext Secure Public-Key Encryption. EUROCRYPT ’2002, LNCS 2332 45–64 (2002).</li>

      <li>[8] A. W. Dent. An implementation attack against the EPOC-2 public-key cryptosystem. Electronics Letters VOL. 38 NO. 9 412–413 (2002).</li>

      <li>[9] EPOC, Efficient Probabilistic Public-Key Encryption. http://info.isl.ntt.co.jp/epoc/</li>

      <li>[10] E. Fujisaki and T. Okamoto. Secure Integration of Asymmetric and Symmetric Encryption Schemes. CRYPTO ’99, LNCS 1666 537–554 (1999)</li>

      <li>[11] E. Fujisaki and T. Okamoto. A Chosen-Cipher Secure Encryption Scheme Tightly as Secure as Factoring. IEICE Trans. Fundamentals E84-A(1) 179–187 (2001).</li>

      <li>[12] M. Joye, J. J. Quisquater and M. Yung. On the Power of Misbehaving Adversaries and Security Analysis of the Original EPOC. CT-RSA’ 01, LNCS 2020 208–222 (2001).</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[13] T. Okamoto and D. Pointcheval. The Gap-Problems: a New Class of Problems for the Security of Cryptographic Schemes. PKC’ 01, LNCS 1992 104–118 (2001).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[14] T. Okamoto and D. Pointcheval. REACT: Rapid Enhanced-security Asymmetric Cryptosystem Transform. CT-RSA’ 01, LNCS 2020 159–175 (2001).</li>

      <li>[15] T. Okamoto and S. Uchiyama. A New Public-Key Cryptosystem as Secure as Factoring. EUROCRYPT-98, LNCS 1403 308–318 (1998)</li>

      <li>[16] PSEC, Provably Secure Encryption Scheme. http://info.isl.ntt.co.jp/psec/</li>

      <li>[17] D. Pointcheval. Chosen-Ciphertext Security for any One-Way Cryptosystem. Proc. PKC ’2000 LNCS 1751 129–146 (2000).</li>

      <li>[18] K. Sakurai and T. Takagi. A Reject Timing Attack on an IND-CCA2 Public-Key Cryptosystem. ICISC ’02, LNCS 2587 359–373 (2002).</li>

      <li>[19] Y. Watanabe, J. Shikata and H.Imai. Equivalence between Semantic Security and Indistinguishability against Chosen Ciphertext Attacks. PKC 2003, LNCS 2567 71–84 (2002).</li>

    </ul>

    <h2 id="sec-26" class="text-2xl font-bold">Appendix A Proof of theorem 9</h2>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}[T,\\epsilon,q_{G},q_{H},q_{D}]=(\\mathcal{A}_{1},\\mathcal{A}_{2})</span> be the adversary aiming to attack the IND-CCA security of the hybrid encryption scheme, <span class="math">\\mathcal{E}=(\\mathsf{KeyGen},\\mathsf{Enc},\\mathsf{Dec})</span> described in subsection 5.3.</p>

    <p class="text-gray-300">In order to prove the theorem, some different games will be considered. In all games, the adversary <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}</span> uses the same coins, but the events defined as functions of the view of <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}</span> could occur with different probabilities in each game. Starting from the IND-CCA game we will design several intermediate games before designing the game for an adversary who tries to break the partial one-wayness (POW) of <span class="math">f</span>. Each game will be obtained by introducing slight modifications to the previous game in such a way that the adversary success probabilities are easily related. We denote by <span class="math">\\mathsf{Pr}_{i}[F]</span> the probability of event <span class="math">F</span> in game <span class="math">i</span>.</p>

    <p class="text-gray-300">Each game will be described as a main algorithm along with some auxiliar algorithms used as oracles by <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}</span>. The bulleted steps in the algorithms will indicate the main changes introduced in each game.</p>

    <p class="text-gray-300">The following trivial lemma will be very useful in this proof.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Lemma 11</h6>

    <p class="text-gray-300">Let <span class="math">E_{1}</span>, <span class="math">F_{1}</span> be two events defined in a probability space <span class="math">\\mathcal{X}_{1}</span>, and <span class="math">E_{2}</span>, <span class="math">F_{2}</span> another two events defined in a probability space <span class="math">\\mathcal{X}_{2}</span>, such that <span class="math">p=\\mathsf{Pr}_{\\mathcal{X}_{2}}\\left[F_{2}\\right]=\\mathsf{Pr}_{\\mathcal{X}_{1}}\\left[F_{1}\\right]</span> and <span class="math">\\mathsf{Pr}_{\\mathcal{X}_{2}}\\left[E_{2}\\wedge\\neg F_{2}\\right]=\\mathsf{Pr}_{\\mathcal{X}_{1}}\\left[E_{1}\\wedge\\neg F_{1}\\right]</span>. Then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Pr}_{\\mathcal{X}_{2}}\\left[E_{2}\\right]-\\mathsf{Pr}_{\\mathcal{X}_{1}}\\left[E_{1}\\right]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq p$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Game0. The IND-CCA attack. There are some minor differences between Game0 and the standard IND-CCA game, described in subsection 4.2, but they do not modify any probability.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Game0}()</span> 1 <span class="math">(pk,sk)\\leftarrow\\mathsf{KeyGen}(1^{\\ell});\\;G\\leftarrow\\mathcal{R}(K_{\\ell});\\;H\\leftarrow\\mathcal{R}(Y_{pk})</span> 2 <span class="math">b\\leftarrow\\{0,1\\};\\;x^{\\star}\\leftarrow X_{pk}</span> 3 <span class="math">(m_{0},m_{1},s)\\leftarrow\\mathcal{A}_{1}^{G,H,\\mathcal{D}_{sk}}(pk)</span> 4 <span class="math">y^{\\star}\\leftarrow H(x^{\\star},m_{b});\\;c^{\\star}\\leftarrow\\left(f_{pk}(x^{\\star},y^{\\star}),\\mathsf{Enc}_{G(x^{\\star})}^{sym}(m_{b})\\right)</span> 5 <span class="math">b^{\\prime}\\leftarrow\\mathcal{A}_{2}^{G,H,\\mathcal{D}_{sk,c^{\\star}}}(s,c^{\\star})</span></p>

    <p class="text-gray-300">15</p>

    <p class="text-gray-300">where the oracle answer <span class="math">\\mathcal{D}_{sk}(c)</span> is exactly the same as the value returned by <span class="math">\\mathsf{Dec}(sk,c)</span>, described in subsection 5.3.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{Askx}</span> be the event that, during the game, either <span class="math">x^{\\star} \\in X</span> is queried (by <span class="math">\\mathcal{A}_{\\mathrm{IND - CCA}(\\mathcal{E})}</span>) to <span class="math">G</span> or <span class="math">(x^{\\star}, m)</span> is queried to <span class="math">H</span>, for some <span class="math">m</span>. Then,</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Adv} \\left[ \\mathcal{A}_{\\text{IND-CCA}(\\mathcal{E})} \\right] =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr_0 [b' = b] - Pr_0 [b' \\neq b]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\quad +</td>

            <td class="px-3 py-2 border-b border-gray-700">Pr_0 [b' = b \\wedge \\neg \\text{Askx}] - Pr_0 [b' \\neq b \\wedge \\neg \\text{Askx}]</td>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\leq Pr_0 [\\text{Askx}] +</td>

            <td class="px-3 py-2 border-b border-gray-700">Pr_0 [b' = b \\wedge \\neg \\text{Askx}] - Pr_0 [b' \\neq b \\wedge \\neg \\text{Askx}]</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">In order to improve the readability of the rest of the proof, let define <span class="math">S_1 = \\text{Askx}</span>, <span class="math">S_{01} = \\neg \\text{Askx} \\wedge b&#x27; = b</span> and <span class="math">S_{00} = \\neg \\text{Askx} \\wedge b&#x27; \\neq b</span>. The above equation can be rewritten as</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Adv} \\left[ \\mathcal{A}_{\\text{IND-CCA}(\\mathcal{E})} \\right] \\leq Pr_0 [S_1] +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr_0 [S_{01}] - Pr_0 [S_{00}]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Let <span class="math">\\mathcal{T}_G</span> be a table in which all the queries made by <span class="math">\\mathcal{A}_{\\mathrm{IND - CCA}(\\mathcal{E})}</span> to the oracle <span class="math">G</span> are stored along with the corresponding answers. Notice that <span class="math">\\mathcal{T}_G</span> would not contain ALL the queries made to <span class="math">G</span>. In the sequel, <span class="math">x \\in \\mathcal{T}_G</span> will denote the fact that <span class="math">x</span> has been queried to <span class="math">G</span> by <span class="math">\\mathcal{A}_{\\mathrm{IND - CCA}(\\mathcal{E})}</span> and <span class="math">\\mathcal{T}_G(x)</span> will denote the answer given by <span class="math">G</span>. Define <span class="math">(x, m) \\in \\mathcal{T}_H</span>, <span class="math">\\mathcal{T}_H(x, m)</span> and <span class="math">c \\in \\mathcal{T}_{\\mathcal{D}}</span>, <span class="math">\\mathcal{T}_{\\mathcal{D}}(c)</span> in a similar way respectively for the oracle calls to <span class="math">H</span> and <span class="math">\\mathcal{D}_{sk}</span>. Notice that the contents of these tables will vary during the game.</p>

    <p class="text-gray-300"><strong>Game1.</strong> In this game, the queries made by <span class="math">\\mathcal{A}_{\\mathrm{IND - CCA}(\\mathcal{E})}</span> to the two random oracles are intercepted in order to immediately abort the execution of the game if <span class="math">\\mathsf{Askx}</span> (i.e. <span class="math">S_1</span>) occurs. The following functions will do this task:</p>

    <div class="my-4 text-center"><span class="math-block">G1(x)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">x = x^{\\star}</span>; exit Game; endif</li>

      <li>return <span class="math">G(x)</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">H1(x, m)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">x = x^{\\star}</span>; exit Game; endif</li>

      <li>return <span class="math">H(x, m)</span></li>

    </ol>

    <p class="text-gray-300">and the new game is,</p>

    <div class="my-4 text-center"><span class="math-block">\\text{Game1}()</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(pk, sk) \\leftarrow \\text{KeyGen}(1^{\\ell}); G \\leftarrow \\mathcal{R}(K_{\\ell}); H \\leftarrow \\mathcal{R}(Y_{pk})</span></li>

      <li><span class="math">b \\leftarrow \\{0, 1\\}</span>; <span class="math">b&#x27; \\leftarrow \\{0, 1\\}</span>; <span class="math">x^{\\star} \\leftarrow X_{pk}</span></li>

      <li><span class="math">(m_0, m_1, s) \\leftarrow \\mathcal{A}_1^{G1, H1, \\mathcal{D}_{sk}}(pk)</span></li>

      <li><span class="math">y^{\\star} \\leftarrow H(x^{\\star}, m_b); c^{\\star} \\leftarrow \\left(f_{pk}(x^{\\star}, y^{\\star}), \\mathsf{Enc}_{G(x^{\\star})}^{sym}(m_b)\\right)</span></li>

      <li><span class="math">b&#x27; \\leftarrow \\mathcal{A}_2^{G1, H1, \\mathcal{D}_{sk, c^{\\star}}} (s, c^{\\star})</span></li>

    </ol>

    <p class="text-gray-300">Since the games are identical while <span class="math">\\neg S_1</span>, the events <span class="math">S_1</span>, <span class="math">S_{01}</span> and <span class="math">S_{00}</span> remain unchanged in Game1. Then,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Adv} \\left[ \\mathcal{A}_{\\text{IND-CCA}(\\mathcal{E})} \\right] \\leq Pr_1 [S_1] +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr_1 [S_{01}] - Pr_1 [S_{00}]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">16</p>

    <p class="text-gray-300"><strong>Game2.</strong> In this game, the decryption oracle is modified in such a way that it is disallowed to do new queries to the random oracle <span class="math">G</span>. To do this, all ciphertexts <span class="math">(c_1, c_2)</span> submitted to the decryption oracle such that <span class="math">g_{sk}(c_1) \\notin \\mathcal{T}_G \\cap X_{pk}</span> are rejected by returning <span class="math">\\bot_2</span>, even when some of them may be valid ciphertexts.</p>

    <p class="text-gray-300"><strong>Game2()</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(pk, sk) \\leftarrow \\mathsf{KeyGen}(1^{\\ell}); G \\leftarrow \\mathcal{R}(K_{\\ell}); H \\leftarrow \\mathcal{R}(Y_{pk})</span></li>

      <li><span class="math">b \\leftarrow \\{0,1\\}; x^{\\star} \\leftarrow X_{pk}</span></li>

      <li><span class="math">(m_0, m_1, s) \\leftarrow \\mathcal{A}_1^{G1,H1,\\mathcal{D}2_{sk}}(pk)</span></li>

      <li><span class="math">y^{\\star} \\leftarrow H(x^{\\star}, m_b); c^{\\star} \\leftarrow \\left(f_{pk}(x^{\\star}, y^{\\star}), \\mathsf{Enc}_{G(x^{\\star})}^{sym}(m_b)\\right)</span></li>

      <li><span class="math">b&#x27; \\leftarrow \\mathcal{A}_2^{G1,H1,\\mathcal{D}2_{sk,c^*}}(s, c^{\\star})</span></li>

    </ol>

    <p class="text-gray-300"><strong>D2_{sk}(c)</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">c \\notin \\bar{Z}_{pk} \\times M_{\\ell}</span>; return <span class="math">\\bot_1</span>; endif</li>

      <li><span class="math">(c_1, c_2) = c</span></li>

      <li><span class="math">x \\leftarrow g_{sk}(c_1)</span></li>

      <li>if <span class="math">x \\notin X_{pk}</span> or <span class="math">x \\notin \\mathcal{T}_G</span>; return <span class="math">\\bot_2</span>; endif</li>

      <li><span class="math">m \\leftarrow \\mathsf{Dec}_{G(x)}^{sym}(c_2)</span></li>

      <li><span class="math">y \\leftarrow H(x, m)</span></li>

      <li>if <span class="math">f_{pk}(x,y) \\neq c_1</span>; return <span class="math">\\bot_2</span>; endif</li>

      <li>return <span class="math">m</span></li>

    </ol>

    <p class="text-gray-300">Let <span class="math">F_2</span> be the event that, in some query to the decryption oracle, the ciphertext is accepted in Game1, but is rejected at step 4 of <span class="math">\\mathcal{D}2_{sk}</span>. Before <span class="math">F_2</span>, both games are identical. Then, by lemma 11,</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_2 [S_1] - \\Pr_1 [S_1] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\Pr [F_2] \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\Pr_2 [S_{00}] - \\Pr_1 [S_{00}] \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\Pr [F_2]</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">From these inequalities, it can be easily shown that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Adv} \\left[ \\mathcal{A}_{\\text{IND-CCA}(\\mathcal{E})} \\right] \\leq \\Pr_2 [S_1] + \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_2 [S_{01}] - \\Pr_2 [S_{00}] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2 \\Pr [F_2]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The following lemma gives an upper bound for <span class="math">\\Pr [F_2]</span>.</p>

    <p class="text-gray-300"><strong>Lemma 12</strong></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr [F_2] \\leq \\frac{q_D q_H \\gamma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- q_D q_H \\gamma} + \\frac{q_D}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- q_D}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><em>Proof:</em> Let <span class="math">\\mathsf{Fail}_k</span> be the event that <span class="math">F_2</span> occurs exactly at the <span class="math">k</span>-th query to the decryption oracle. Let <span class="math">\\mathsf{NoFail}_k = \\bigwedge_{j=1}^k \\neg \\mathsf{Fail}_j</span> denote the event that <span class="math">F_2</span> does not occur during the first <span class="math">k</span> queries to the decryption oracle, for <span class="math">k = 1, \\ldots, q_D</span>. Let <span class="math">\\mathsf{NoFail}_0</span> be the certain event. Then,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr [F_2] = 1 - \\Pr [\\text{NoFail}_{q_D}] = 1 - \\Pr \\left[ \\bigwedge_{k=1}^{q_D} \\neg \\text{Fail}_k \\right] = 1 - \\prod_{k=1}^{q_D} \\Pr [\\neg \\text{Fail}_k \\mid \\text{NoFail}_{k-1}]</span></div>

    <p class="text-gray-300">and, if we denote by <span class="math">p_{k}=\\mathsf{Pr}\\left[\\mathsf{Fail}_{k}\\mid\\mathsf{NoFail}_{k-1}\\right]</span>, then</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Pr}\\left[F_{2}\\right]=1-\\prod_{k=1}^{q_{D}}(1-p_{k})\\leq\\sum_{k=1}^{q_{D}}p_{k}</span></p>

    <p class="text-gray-300">In order to compute <span class="math">p_{k}</span>, let us suppose that Game1 and Game2 run identically just until <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}</span> is going to submit the <span class="math">k</span>-th query, <span class="math">\\bar{c}</span>, to the decryption oracle. This implies <span class="math">\\mathsf{NoFail}_{k-1}\\wedge\\neg\\mathsf{Askx}</span>. Suppose for a while that <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}</span> is in the ‘finding’ stage. The only information available to the adversary, in order to generate the cyphertext <span class="math">\\bar{c}</span> is the view of the game at this execution point, that is <span class="math">\\mathsf{View}=(pk,\\mathcal{T}_{G},\\mathcal{T}_{H},\\mathcal{T}_{\\mathcal{D}})</span>. To find an upper bound for <span class="math">p_{k}</span>, we will consider the best choice for <span class="math">\\bar{c}</span>, for each possible <span class="math">\\mathsf{View}</span> compatible with <span class="math">\\mathsf{NoFail}_{k-1}</span>.</p>

    <p class="text-gray-300">The event <span class="math">\\mathsf{Fail}_{k}</span> occurs if and only if <span class="math">\\mathcal{D}2_{sk}(\\bar{c})\\neq\\mathcal{D}_{sk}(\\bar{c})</span>, that is, <span class="math">\\mathcal{D}2_{sk}</span> rejects <span class="math">\\bar{c}</span> (returning <span class="math">\\bot_{2}</span>) while <span class="math">\\mathcal{D}_{sk}</span> accepts it. This means that <span class="math">\\bar{c}=(f_{pk}(\\bar{x},\\bar{y})),\\bar{c}_{2})</span>, where <span class="math">\\bar{x}\\in X_{pk}\\setminus\\mathcal{T}_{G}</span>, <span class="math">\\bar{y}\\in Y_{pk}</span>, <span class="math">\\bar{c}_{2}\\in M_{\\ell}</span>, and the equation <span class="math">\\bar{y}=H(\\bar{x},\\mathsf{Dec}_{G(\\bar{x})}^{sym}(\\bar{c}_{2}))</span> holds.</p>

    <p class="text-gray-300">If <span class="math">\\mathsf{View}</span> and <span class="math">\\bar{c}</span> are fixed, then <span class="math">p_{k}</span> depends only on the joint probability distribution of <span class="math">G(\\bar{x})</span> and <span class="math">H(\\bar{x},\\mathsf{Dec}_{G(\\bar{x})}^{sym}(\\bar{c}_{2}))</span>. But this distribution is conditioned by the answers given by <span class="math">H</span> to the queries <span class="math">(\\bar{x},m)</span> for some <span class="math">m</span>, and the answers given by <span class="math">\\mathcal{D}_{sk}</span> to the queries <span class="math">(f_{pk}(\\bar{x},y),c_{2})</span> for some <span class="math">y\\in Y_{pk}</span> and <span class="math">c_{2}\\in M_{\\ell}</span>. Notice that any queried ciphertext <span class="math">c\\not\\in Z_{pk}\\times M_{\\ell}</span> is rejected by <span class="math">\\mathcal{D}_{sk}</span>, independently of the values taken by the random functions.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the worst case, all queries in <span class="math">\\mathcal{T}_{H}</span> and <span class="math">\\mathcal{T}_{\\mathcal{D}}</span> are related to <span class="math">\\bar{x}</span>, that is, <span class="math">h_{i}=H(\\bar{x},m_{i})</span> for <span class="math">i=1,\\ldots,q_{H}</span>, and <span class="math">c^{(j)}=(f_{pk}(\\bar{x},y_{j}),c_{2}^{(j)})</span> for <span class="math">j=1,\\ldots,k-1</span>. Since <span class="math">\\bar{x}\\not\\in\\mathcal{T}_{G}</span>, then <span class="math">\\mathcal{D}_{sk}(c^{(j)})=\\mathcal{D}2_{sk}(c^{(j)})=\\bot_{2}</span> and then <span class="math">y_{j}\\neq H(\\bar{x},\\mathsf{Dec}_{G(\\bar{x})}^{sym}(c_{2}^{(j)}))</span>. These equations could be incompatible for some values of <span class="math">G(\\bar{x})</span>, namely those <span class="math">g\\in K_{\\ell}</span> such that <span class="math">m_{i}=\\mathsf{Dec}_{g}^{sym}(c_{2}^{(j)})</span> and <span class="math">h_{i}=y_{j}</span> for some <span class="math">(i,j)</span>. In the (unfeasible) worst case, all <span class="math">h_{i}</span> and <span class="math">y_{j}</span> are equal and there can be up to <span class="math">q_{H}(k-1)\\gamma</span> forbidden values for <span class="math">G(\\bar{x})</span>. Then, the random variable <span class="math">G(\\bar{x})</span> is uniformly distributed over a set of at least $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K_{\\ell}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-(k-1)q_{H}\\gamma$ elements.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">There are at most <span class="math">q_{H}\\gamma</span> different values of <span class="math">g</span> such that <span class="math">(\\bar{x},\\mathsf{Dec}_{g}^{sym}(\\bar{c}_{2}))\\in\\mathcal{T}_{H}</span>. For these values, <span class="math">\\bar{y}=H(\\bar{x},\\mathsf{Dec}_{g}^{sym}(\\bar{c}_{2}))</span> can be ensured if all <span class="math">h_{i}</span> are equal to <span class="math">\\bar{y}</span>. Thus,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{Pr}\\left[\\mathsf{Fail}_{k}\\wedge(\\bar{x},\\mathsf{Dec}_{G(\\bar{x})}^{sym}(\\bar{c}_{2}))\\in\\mathcal{T}_{H}\\mid\\mathsf{View}\\right]\\leq\\frac{q_{H}\\gamma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K_{\\ell}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-(k-1)q_{H}\\gamma}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any <span class="math">g</span> such that <span class="math">(\\bar{x},\\mathsf{Dec}_{g}^{sym}(\\bar{c}_{2}))\\not\\in\\mathcal{T}_{H}</span>, the variable <span class="math">H(\\bar{x},\\mathsf{Dec}_{g}^{sym}(\\bar{c}_{2}))</span> is uniformly distributed over a set of at least $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_{pk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-(k-1)<span class="math"> elements, because if </span>\\bar{c}_{2}=c_{2}^{(j)}<span class="math">, then the value </span>y_{j}$ is forbidden. Consequently,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{Pr}\\left[\\mathsf{Fail}_{k}\\wedge(\\bar{x},\\mathsf{Dec}_{G(x)}^{sym}(c_{2}))\\not\\in\\mathcal{T}_{H}\\mid\\mathsf{View}\\right]\\leq\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_{pk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-(k-1)}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and summing up, we obtain</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$p_{k}^{\\mathrm{find}}\\leq\\frac{q_{H}\\gamma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K_{\\ell}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-(k-1)q_{H}\\gamma}+\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_{pk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-(k-1)}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If <span class="math">\\mathcal{A}_{\\mathsf{IND-CCA}(\\mathcal{E})}</span> is in the ‘guessing’ stage, then <span class="math">c^{\\star}</span> holds valuable information. In fact, <span class="math">\\mathsf{View}=(pk,\\mathcal{T}_{G},\\mathcal{T}_{H},\\mathcal{T}_{\\mathcal{D}},c^{\\star})</span>, but <span class="math">c^{\\star}</span> depends only on <span class="math">G(x^{\\star})</span> and <span class="math">H(x^{\\star},m_{b})</span>. Thus,</p>

    <p class="text-gray-300">18</p>

    <p class="text-gray-300">if <span class="math">\\bar{x} \\neq x^{\\star}</span>, <span class="math">c^{\\star}</span> does not give any additional information about <span class="math">\\mathsf{Fail}_k</span> and everything goes the same way as in the 'finding' stage.</p>

    <p class="text-gray-300">If <span class="math">\\bar{x} = x^{\\star}</span>, also the restriction <span class="math">\\bar{c} \\neq c^{\\star}</span> must be considered. Moreover, there are no queries in <span class="math">\\mathcal{T}_H</span> related to <span class="math">x^{\\star}</span>. Then, in the worst case, the joint distribution of <span class="math">G(\\bar{x})</span> and <span class="math">H(\\bar{x}, \\mathsf{Dec}_{G(\\bar{x})}^{sym}(\\bar{c}_2))</span> is conditioned by the equations <span class="math">y_j \\neq H(x^{\\star}, \\mathsf{Dec}_{G(x^{\\star})}^{sym}(c_2^{(j)}))</span>, for <span class="math">j = 1, \\ldots, k-1</span>, <span class="math">y^{\\star} = H(x^{\\star}, m_b)</span> and <span class="math">m_b = \\mathsf{Dec}_{G(x^{\\star})}^{sym}(c_2^{\\star})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The equality <span class="math">y^{\\star} = H(x^{\\star}, m_b)</span> is useless since the only valid ciphertext related to <span class="math">H(x^{\\star}, m_b)</span> is <span class="math">c^{\\star}</span>. Nevertheless, from <span class="math">m_b = \\mathsf{Dec}_{G(x^{\\star})}^{sym}(c_2^{\\star})</span>, only a reduced number of values of <span class="math">G(x^{\\star})</span> remain possible, but, as above, <span class="math">H(x^{\\star}, \\mathsf{Dec}_{G(x^{\\star})}^{sym}(\\bar{c}_2))</span> is uniformly distributed over a set of at least $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_{pk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (k-1)<span class="math"> elements, and </span>p_k^{\\mathrm{guess}} \\leq \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_{pk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (k-1)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ F _ {2} \\right] \\leq \\sum_ {k = 1} ^ {q _ {D}} \\left(\\frac {q _ {H} \\gamma}{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K _ {\\ell} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (k - 1) q _ {H} \\gamma} + \\frac {1}{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y _ {p k} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (k - 1)}\\right) \\leq \\frac {q _ {D} q _ {H} \\gamma}{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- q _ {D} q _ {H} \\gamma} + \\frac {q _ {D}}{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- q _ {D}}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">■</p>

    <p class="text-gray-300">Game2'. In this game, oracles <span class="math">G</span> and <span class="math">H</span> are simulated by using tables <span class="math">\\mathcal{T}_{G2&#x27;}</span> and <span class="math">\\mathcal{T}_{H2&#x27;}</span>, as described in subsection 4.3.</p>

    <p class="text-gray-300">Also, the generation of the ciphertext differs from the one in Game2. Here, in Game2', some values of the random functions are redefined, namely <span class="math">G(x^{\\star}) = g</span> and <span class="math">H(x^{\\star}, m_b) = y^{\\star}</span>. But these changes in the oracles do not affect the probability distribution of the view of <span class="math">\\mathcal{A}_{\\mathrm{IND - CCA}(\\mathcal{E})}</span>, since in Game2 neither <span class="math">x^{\\star}</span> is queried to <span class="math">G</span> nor <span class="math">(x^{\\star}, m)</span> is queried to <span class="math">H</span>, for any <span class="math">m</span>. (Note that, at step 6 of <span class="math">\\mathcal{D}2_{sk}</span>, <span class="math">x \\neq x^{\\star}</span> since <span class="math">x^{\\star} \\notin \\mathcal{T}_G</span>.)</p>

    <p class="text-gray-300">Game2'()</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1 <span class="math">\\mathcal{T}_{G2&#x27;} \\gets \\text{empty}; \\mathcal{T}_{H2&#x27;} \\gets \\text{empty}</span></li>

      <li>2 <span class="math">(pk, sk) \\gets \\text{KeyGen}(1^{\\ell})</span></li>

      <li>3 <span class="math">b \\gets \\{0, 1\\}</span>; <span class="math">x^{\\star} \\gets X_{pk}</span></li>

      <li>4 <span class="math">(m_0, m_1, s) \\gets \\mathcal{A}_1^{G2&#x27;, H2&#x27;, \\mathcal{D}2_{sk}&#x27;}(pk)</span></li>

      <li>5 <span class="math">g \\gets K_{\\ell}</span>; <span class="math">y^{\\star} \\gets Y_{pk}</span>; <span class="math">c^{\\star} \\gets \\left(f_{pk}(x^{\\star}, y^{\\star}), \\mathsf{Enc}_g^{sym}(m_b)\\right)</span></li>

      <li>6 <span class="math">b&#x27; \\gets \\mathcal{A}_2^{G2&#x27;, H2&#x27;, \\mathcal{D}2_{sk,c&#x27;}&#x27;}(s, c^{\\star})</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{D}2_{sk}&#x27;(c)</span></p>

    <p class="text-gray-300">1 if <span class="math">c \\notin \\bar{Z}_{pk} \\times M_{\\ell}</span>; return <span class="math">\\perp_1</span>;endif 2 <span class="math">(c_{1},c_{2}) = c</span> 3 <span class="math">x\\gets g_{sk}(c_1)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>4 if <span class="math">x \\notin X_{pk}</span> or <span class="math">x \\notin \\mathcal{T}_{G2&#x27;}</span>; return <span class="math">\\perp_2</span>;endif</li>

    </ul>

    <p class="text-gray-300">5 <span class="math">m\\gets \\mathsf{Dec}_{G2&#x27;(x)}^{sym}(c_2)</span> 6 <span class="math">y\\gets H2&#x27;(x,m)</span> 7 if <span class="math">f_{pk}(x,y)\\neq c_1</span>; return <span class="math">\\perp_{2}</span>;endif 8 return <span class="math">m</span></p>

    <p class="text-gray-300"><span class="math">G2^{\\prime}(x)</span></p>

    <p class="text-gray-300">19</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1 if <span class="math">x \\in \\mathcal{T}_{G2&#x27;}</span>; return <span class="math">\\mathcal{T}_{G2&#x27;}(x)</span>; endif</li>

      <li>2 if <span class="math">x = x^{\\star}</span>; exit Game; endif</li>

      <li>3 <span class="math">r \\leftarrow K_{\\ell}</span></li>

      <li>4 insert <span class="math">(x, r)</span> in table <span class="math">\\mathcal{T}_{G2&#x27;}</span></li>

      <li>5 return <span class="math">r</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">H2&#x27;(x, m)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1 if <span class="math">(x, m) \\in \\mathcal{T}_{H2&#x27;}</span>; return <span class="math">\\mathcal{T}_{H2&#x27;}(x, m)</span>; endif</li>

      <li>2 if <span class="math">x = x^{\\star}</span>; exit Game; endif</li>

      <li>3 <span class="math">r \\leftarrow Y_{pk}</span></li>

      <li>4 insert <span class="math">((x, m), r)</span> in table <span class="math">\\mathcal{T}_{H2&#x27;}</span></li>

      <li>5 return <span class="math">r</span></li>

    </ul>

    <p class="text-gray-300"><strong>Game3.</strong> In this game, we introduce some modifications to avoid the use of <span class="math">m_b</span> in the generation of the target ciphertext. In fact, the differences between using <span class="math">m_b</span> and using a random message can be tapped by a new adversary <span class="math">\\mathcal{A}_{\\text{IND-SYM}(\\mathcal{E}^{sym})} = (\\mathcal{A}_1^{sym}, \\mathcal{A}_2^{sym})</span> who tries to break the IND-SYM security of <span class="math">\\mathcal{E}^{sym}</span> (see 4.1).</p>

    <p class="text-gray-300"><strong>Game3()</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\beta \\leftarrow \\{0,1\\}</span></li>

      <li><span class="math">(\\mu_0, \\mu_1, \\sigma) \\leftarrow \\mathcal{A}_1^{sym}(1^\\ell)</span></li>

      <li><span class="math">g \\leftarrow K_\\ell</span>; <span class="math">\\kappa^{\\star} = \\mathsf{Enc}_g^{sym}(\\mu_\\beta)</span></li>

      <li><span class="math">\\beta&#x27; \\leftarrow \\mathcal{A}_2^{sym}(\\sigma, \\kappa^{\\star})</span></li>

    </ol>

    <p class="text-gray-300"><strong><span class="math">\\mathcal{A}_1^{sym}(1^\\ell)</span></strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{T}_{G3} \\leftarrow \\text{empty}; \\mathcal{T}_{H3} \\leftarrow \\text{empty}</span></li>

      <li><span class="math">(pk, sk) \\leftarrow \\text{KeyGen}(1^\\ell)</span></li>

      <li><span class="math">b \\leftarrow \\{0,1\\}</span>; <span class="math">x^{\\star} \\leftarrow X_{pk}</span></li>

      <li><span class="math">(m_0, m_1, s) \\leftarrow \\mathcal{A}_1^{G3,H3,\\mathcal{D}3_{sk}}(pk)</span></li>

      <li><span class="math">m \\leftarrow M_\\ell</span></li>

      <li><span class="math">\\sigma = (\\mathcal{T}_{G3}, \\mathcal{T}_{H3}, pk, sk, b, x^{\\star}, s)</span></li>

      <li><span class="math">\\text{return}(m_b, m, \\sigma)</span></li>

    </ol>

    <p class="text-gray-300"><strong><span class="math">\\mathcal{A}_2^{sym}(\\sigma, \\kappa^{\\star})</span></strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathcal{T}_{G3}, \\mathcal{T}_{H3}, pk, sk, b, x^{\\star}, s) = \\sigma</span></li>

      <li><span class="math">y^{\\star} \\leftarrow Y_{pk}</span>; <span class="math">c^{\\star} \\leftarrow (f_{pk}(x^{\\star}, y^{\\star}), \\kappa^{\\star})</span></li>

      <li><span class="math">b&#x27; \\leftarrow \\mathcal{A}_2^{G3,H3,\\mathcal{D}3_{sk},c^{\\star}}(s, c^{\\star})</span></li>

      <li><span class="math">\\beta&#x27;&#x27; \\leftarrow 0</span></li>

      <li>if <span class="math">b&#x27; = b</span></li>

      <li><span class="math">\\beta&#x27; \\leftarrow 0</span></li>

      <li>else</li>

      <li><span class="math">\\beta&#x27; \\leftarrow 1</span></li>

      <li>endif</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathcal{D}3_{sk}(c)</span></p>

    <p class="text-gray-300">20</p>

    <p class="text-gray-300">1 if <span class="math">c \\notin \\bar{Z}_{pk} \\times M_{\\ell}</span>; return <span class="math">\\bot_1</span>; endif 2 <span class="math">(c_{1}, c_{2}) = c</span> 3 <span class="math">x \\gets g_{sk}(c_{1})</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>4 if <span class="math">x \\notin X_{pk}</span> or <span class="math">x \\notin \\mathcal{T}_{G3}</span>; return <span class="math">\\bot_2</span>; endif</li>

    </ul>

    <p class="text-gray-300">5 <span class="math">m \\gets \\operatorname{Dec}_{G3(x)}^{sym}(c_2)</span> 6 <span class="math">y \\gets H3(x, m)</span> 7 if <span class="math">f_{pk}(x,y) \\neq c_1</span>; return <span class="math">\\bot_2</span>; endif 8 return <span class="math">m</span></p>

    <p class="text-gray-300">G3(x)</p>

    <p class="text-gray-300">1 if <span class="math">x\\in \\mathcal{T}_{G3}</span>; return <span class="math">\\mathcal{T}_{G3}(x)</span>; endif 2 if <span class="math">x = x^{\\star}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>3 <span class="math">\\beta&#x27; \\gets \\{0,1\\}</span></li>

      <li>4 <span class="math">\\beta&#x27;&#x27; \\gets 1</span></li>

    </ul>

    <p class="text-gray-300">5 exit Game 6 endif 7 <span class="math">r \\gets K_{\\ell}</span> 8 insert <span class="math">(x,r)</span> in table <span class="math">\\mathcal{T}_{G3}</span> 9 return <span class="math">r</span></p>

    <p class="text-gray-300">H3(x, m)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1 if <span class="math">(x, m) \\in \\mathcal{T}_{H3}</span>; return <span class="math">\\mathcal{T}_{H3}(x, m)</span>; endif</li>

    </ul>

    <p class="text-gray-300">2 if <span class="math">x = x^{\\star}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>3 <span class="math">\\beta&#x27; \\gets \\{0,1\\}</span></li>

      <li>4 <span class="math">\\beta&#x27;&#x27; \\gets 1</span></li>

    </ul>

    <p class="text-gray-300">5 exit Game 6 endif 7 <span class="math">r \\gets Y_{pk}</span> 8 insert <span class="math">((x, m), r)</span> in table <span class="math">\\mathcal{T}_{H3}</span> 9 return <span class="math">r</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Actually, <span class="math">\\mathcal{A}_{\\mathrm{IND - SYM}(\\mathcal{E}^{sym})}</span> uses two different ways to guess the value of <span class="math">\\beta</span>: <span class="math">\\beta&#x27;</span> indicates if <span class="math">\\mathcal{A}_{\\mathrm{IND - CCA}(\\mathcal{E})}</span> guesses the correct value of <span class="math">b</span> and <span class="math">\\beta&#x27;&#x27;</span> indicates if <span class="math">\\mathsf{S}_1</span> occurs. Then, two different advantages can be taken into account: $\\mathsf{Adv}\\left[\\mathcal{A}_{\\mathrm{IND - SYM}(\\mathcal{E}^{sym})}\\right] =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2\\mathsf{Pr}_3[\\beta' = \\beta] - 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>\\mathsf{Adv}\\left[\\mathcal{A}_{\\mathrm{IND - SYM}(\\mathcal{E}^{sym})}\\right]' =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2\\mathsf{Pr}_3[\\beta'' = \\beta] - 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If <span class="math">\\beta = 1</span>, the value of <span class="math">m_b</span> is used nowhere in the game. So, the view of <span class="math">\\mathcal{A}_{\\mathrm{IND - CCA}(\\mathcal{E})}</span> is independent of <span class="math">b</span> and <span class="math">\\mathsf{Pr}_3[\\beta&#x27; = 1 \\mid \\beta = 1 \\land \\neg \\mathsf{S}_1] = \\mathsf{Pr}_3[b&#x27; \\neq b \\mid \\beta = 1 \\land \\neg \\mathsf{S}_1] = \\frac{1}{2}</span>. Moreover, <span class="math">\\mathsf{Pr}_3[\\beta&#x27; = 1 \\mid \\beta = 1 \\land \\mathsf{S}_1] = \\frac{1}{2}</span> and then <span class="math">\\mathsf{Pr}_3[\\beta&#x27; = 1 \\mid \\beta = 1] = \\frac{1}{2}</span>.</p>

    <p class="text-gray-300">If <span class="math">\\beta = 0</span>, Game3 and Game2' are identical. Thus</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_3 \\left[ \\beta&#x27; = 0 \\land \\neg \\mathsf{S}_1 \\mid \\beta = 0 \\right] = \\Pr_3 \\left[ b&#x27; = b \\land \\neg \\mathsf{S}_1 \\mid \\beta = 0 \\right] = \\Pr_2 \\left[ \\mathsf{S}_{01} \\right]</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_3 \\left[ \\beta&#x27; = 0 \\land \\mathsf{S}_1 \\mid \\beta = 0 \\right] = \\frac{1}{2} \\Pr_3 \\left[ \\mathsf{S}_1 \\mid \\beta = 0 \\right] = \\frac{1}{2} \\Pr_2 \\left[ \\mathsf{S}_1 \\right]</span></div>

    <p class="text-gray-300">Putting altogether,</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Adv} \\left[ \\mathcal{A}_{\\text{IND-SYM}(\\mathcal{E}^{sym})} \\right] =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2 \\Pr_3 [\\beta' = 0 \\wedge \\beta = 0] + 2 \\Pr_3 [\\beta' = 1 \\wedge \\beta = 1] - 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">\\Pr_2 [S_{01}] + \\frac{1}{2} \\Pr_2 [S_1] - \\frac{1}{2}</td>

            <td class="px-3 py-2 border-b border-gray-700">= \\frac{1}{2}</td>

            <td class="px-3 py-2 border-b border-gray-700">\\Pr_2 [S_{01}] - \\Pr_2 [S_{00}]</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">If <span class="math">\\beta&#x27;&#x27;</span> is used instead of <span class="math">\\beta&#x27;</span>, then</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Adv} \\left[ \\mathcal{A}_{\\text{IND-SYM}(\\mathcal{E}^{sym})} \\right]' =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2 \\Pr_3 [S_1 \\wedge \\beta'' = \\beta] + 2 \\Pr_3 [\\neg S_1 \\wedge \\beta'' = \\beta] - 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">\\Pr_3 [S_1 \\mid \\beta = 1] + (\\Pr_3 [\\neg S_1 \\mid \\beta = 0] - 1)</td>

            <td class="px-3 py-2 border-b border-gray-700">= \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">=</td>

            <td class="px-3 py-2 border-b border-gray-700">\\Pr_3 [S_1 \\mid \\beta = 1] - \\Pr_2 [S_1]</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">Finally,</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Adv} \\left[ \\mathcal{A}_{\\text{IND-CCA}(\\mathcal{E})} \\right] \\leq \\Pr_2 [S_1] +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_2 [S_{01}] - \\Pr_2 [S_{00}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2 \\Pr [F_2] = \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">= \\Pr_2 [S_1] + 2 \\text{Adv} \\left[ \\mathcal{A}_{\\text{IND-SYM}(\\mathcal{E}^{sym})} \\right] + 2 \\Pr [F_2] \\leq \\\\ \\leq \\Pr_3 [S_1 \\mid \\beta = 1] + 2 \\text{Adv} \\left[ \\mathcal{A}_{\\text{IND-SYM}(\\mathcal{E}^{sym})} \\right] + \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\text{Adv} \\left[ \\mathcal{A}_{\\text{IND-SYM}(\\mathcal{E}^{sym})} \\right]' + 2 \\Pr [F_2]</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300"><strong>Game4.</strong> Game3 (with <span class="math">\\beta = 0</span>) can be modified to obtain an implementation of an adversary, <span class="math">\\mathcal{A}_{\\mathrm{POW}(f)}</span>, that try to break the partial one-wayness of <span class="math">f</span>. This adversary will know neither <span class="math">sk</span> nor <span class="math">x^{\\star}</span>. The use of <span class="math">sk</span> in the decryption oracle simulator and the use of <span class="math">x^{\\star}</span> in the random oracle simulators are avoided conveniently using the deterministic plaintext checking algorithm <span class="math">\\mathcal{V}</span>. The value of <span class="math">x^{\\star}</span> is guessed by <span class="math">\\mathcal{A}_{\\mathrm{POW}(f)}</span> when possible (i.e. if <span class="math">S_1</span> occurs).</p>

    <p class="text-gray-300">These changes do not modify any probability. Moreover, the views of <span class="math">\\mathcal{A}_{\\mathrm{IND - CCA}(\\mathcal{E})}</span> in games 3 (with <span class="math">\\beta = 0</span>) and 4 are identically distributed.</p>

    <p class="text-gray-300"><strong>Game4()</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(pk, sk) \\gets \\text{KeyGen}(1^{\\ell})</span></li>

      <li><span class="math">x^{\\star} \\gets X_{pk}; y^{\\star} \\gets Y_{pk}; z \\gets f_{pk}(x^{\\star}, y^{\\star})</span></li>

      <li><span class="math">\\mathcal{A}_{\\mathrm{POW}(f)}(pk, z^{\\star})</span></li>

    </ol>

    <p class="text-gray-300"><strong><span class="math">\\mathcal{A}_{\\mathrm{POW}(f)}(pk, z)</span></strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\gets \\{0, 1\\}</span></li>

      <li><span class="math">m \\gets M_{\\ell}; g \\gets K_{\\ell}; c^{\\star} \\gets (z, \\mathsf{Enc}_g^{sym}(m))</span></li>

      <li><span class="math">\\mathcal{T}_{G4} \\gets \\text{empty}; \\mathcal{T}_{H4} \\gets \\text{empty}</span></li>

      <li><span class="math">(m_0, m_1, s) \\gets \\mathcal{A}_1^{G4, H4, \\mathcal{D}4_{pk}}(pk)</span></li>

      <li><span class="math">b&#x27; \\gets \\mathcal{A}_2^{G4, H4, \\mathcal{D}4_{pk, c^{\\star}}} (s, c^{\\star})</span></li>

      <li><span class="math">x&#x27; \\gets X_{pk}</span></li>

    </ol>

    <p class="text-gray-300"><strong>G4(x)</strong></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">x \\in \\mathcal{T}_{G4}</span>; return <span class="math">\\mathcal{T}_{G4}(x)</span>; end if</li>

      <li>if <span class="math">x \\in X_{pk}</span> and <span class="math">\\mathcal{V}(pk, x, z) = 1</span></li>

      <li><span class="math">x&#x27; \\gets x</span></li>

      <li>exit Game</li>

      <li>end if</li>

      <li><span class="math">r \\gets K_{\\ell}</span></li>

    </ol>

    <p class="text-gray-300">22</p>

    <p class="text-gray-300">7 insert <span class="math">(x,r)</span> in table <span class="math">\\mathcal{T}_{G4}</span> 8 return <span class="math">r</span></p>

    <p class="text-gray-300"><span class="math">H4(x,m)</span></p>

    <p class="text-gray-300">1 if <span class="math">(x,m)\\in \\mathcal{T}_{H4}</span>; return <span class="math">\\mathcal{T}_{H4}(x,m)</span>; end if 2 if <span class="math">x\\in X_{pk}</span> and <span class="math">\\mathcal{V}(pk,x,z) = 1</span> 3 <span class="math">x^{\\prime}\\gets x</span> 4 exit Game 5 end if 6 <span class="math">r\\gets Y_{pk}</span> 7 insert <span class="math">((x,m),r)</span> in table <span class="math">\\mathcal{T}_{H4}</span> 8 return <span class="math">r</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{D}4_{pk}(c)</span></p>

    <p class="text-gray-300">1 if <span class="math">c\\notin \\bar{Z}_{pk}\\times M_{\\ell}</span>; return <span class="math">\\perp_{1}</span>; end if 2 <span class="math">(c_{1},c_{2}) = c</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>3 foreach <span class="math">x \\in \\mathcal{T}_{G4}</span></li>

      <li>4 if <span class="math">x \\in X_{pk}</span> and <span class="math">\\mathcal{V}(pk, x, c_1) = 1</span></li>

    </ul>

    <p class="text-gray-300">5 <span class="math">m\\gets \\mathrm{Dec}_{\\mathcal{T}_{G4}(x)}^{sym}(c_2)</span> 6 <span class="math">y\\gets H4(x,m)</span> 7 if <span class="math">f_{pk}(x,y)\\neq c_1</span>; return <span class="math">\\perp_{2}</span>; end if 8 return <span class="math">m</span> 9 end if</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>10 end foreach</li>

    </ul>

    <p class="text-gray-300">11 return <span class="math">\\perp_{2}</span></p>

    <p class="text-gray-300">Now,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {S u c c} \\left[ \\mathcal {A} _ {\\mathrm {P O W} (f)} \\right] = \\Pr_ {4} \\left[ x ^ {\\prime} = x ^ {*} \\right] \\geq \\Pr_ {4} \\left[ \\mathrm {S} _ {1} \\right] = \\Pr_ {3} \\left[ \\mathrm {S} _ {1} \\mid \\beta = 1 \\right]</span></div>

    <p class="text-gray-300">and, from the above results,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\operatorname {A d v} \\left[ \\mathcal {A} _ {\\text {I N D - C C A} (\\mathcal {E})} \\right] \\leq \\operatorname {S u c c} \\left[ \\mathcal {A} _ {\\text {P O W} (f)} \\right] + 2 \\operatorname {A d v} \\left[ \\mathcal {A} _ {\\text {I N D - S Y M} (\\mathcal {E} ^ {s y m})} \\right] + \\\\ + \\operatorname {A d v} \\left[ \\mathcal {A} _ {\\text {I N D - S Y M} \\left(\\mathcal {E} ^ {s y m}\\right)} \\right] ^ {\\prime} + \\frac {2 q _ {D} q _ {H} \\gamma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- q _ {D} q _ {H} \\gamma} + \\frac {2 q _ {D}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- q _ {D}} \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">In terms of time complexity of the algorithms, the overhead introduced by the simulation of the random oracles, <span class="math">G</span> and <span class="math">H</span>, in games 3 and 4 can be reduced by using standard hashing techniques for table insertion and searching. In fact, in almost all security proofs in the Random Oracle Model in the literature, this time overhead is neglected. It is also supposed that the times needed to check if <span class="math">c \\in \\bar{Z}_{pk} \\times M_{\\ell}</span> and <span class="math">x \\in X_{pk}</span> are negligible.</p>

    <p class="text-gray-300">Neglecting lower order terms, the running time of <span class="math">\\mathcal{A}_{\\mathrm{POW}(f)}</span> in Game4 is bounded by</p>

    <div class="my-4 text-center"><span class="math-block">T \\left[ \\mathcal {A} _ {\\text {P O W} (f)} \\right] \\leq \\left(q _ {G} + q _ {H} + q _ {D} + q _ {G} q _ {D}\\right) T [ \\mathcal {V} ] + q _ {D} \\left(T [ f ] + T \\left[ \\operatorname {D e c} ^ {s y m} \\right]\\right) + T \\left[ \\mathcal {A} _ {\\text {I N D - C C A} (\\mathcal {E})} \\right]</span></div>

    <p class="text-gray-300">where <span class="math">T[\\mathcal{V}]</span> is the time complexity of the plaintext checking algorithm and <span class="math">T[f]</span> is the time complexity of <span class="math">f</span>. Also, <span class="math">T[\\mathcal{A}_{\\mathrm{IND - SYM}(\\mathcal{E}^{sym})}] = T[\\mathcal{A}_{\\mathrm{IND - CCA}(\\mathcal{E})}]</span>.</p>

    <p class="text-gray-300">23</p>

    <h2 id="sec-28" class="text-2xl font-bold">A.1 Particular cases</h2>

    <p class="text-gray-300">Both in the case of the trivial construction of easy verifiable functions and in the non-trivial family in subsection 3.1, the algorithm <span class="math">\\mathcal{D}4_{pk}</span> can be improved, without modifying the behavior of the game, to avoid exhaustive search in <span class="math">\\mathcal{T}_{G4}</span>. To do it, <span class="math">(f&#x27;(x),(x,G(x)))</span> is stored in another table <span class="math">\\mathcal{T}_{G4}&#x27;</span> for each query <span class="math">x\\in X_{pk}</span> to <span class="math">G</span>.</p>

    <pre><code class="language-text">G4&#x27;(x)
1 if x ∈ T_{G4}; return T_{G4}(x); endif
2 if x ∈ X_{pk} and V(pk, x, z) = 1
3     x&#x27; ← x
4     exitGame
5 endif
6     r ← K_{\\ell}
7     insert (x, r) in table T_{G4}
8 if x ∈ X_{pk}
9     insert (f&#x27;(x), (x, r)) in table T_{G4}&#x27;
10 endif
11     return r

D4&#x27;_pk(c)
1 if c ∉ Z_{pk} × M_{\\ell}; return ⊥_1; endif
2     (c_1, c_2) = c
3     z&#x27; ← π&#x27;_pk(c_1)
4 if z&#x27; ∈ T&#x27;_G4
5     (x, g) ← T&#x27;_G4(z&#x27;)
6     m ← Dec_{z}^{sym}(c_2)
7     y ← H4(x, m)
8     if f_{pk}(x, y) ≠ c_1; return ⊥_2; endif
9     return m
10 endif
11     return ⊥_2</code></pre>

    <p class="text-gray-300">The same standard hashing techniques used in the simulation of <span class="math">G</span> and <span class="math">H</span> can be also used here to maintain <span class="math">\\mathcal{T}_{G4}&#x27;</span>, so the time overhead of step 4 in <span class="math">\\mathcal{D}4_{pk}&#x27;</span> and step 9 in <span class="math">G4&#x27;</span> can be neglected.</p>

    <p class="text-gray-300">Then,</p>

    <p class="text-gray-300">$$ \\begin{array}{l} T[\\mathcal{A}_{\\text{POW}(f)}] \\leq (q_G + q_H + q_D) T[\\mathcal{V}] + q_G T[f'] + \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>q_D \\left( T[f] + T[\\pi'] + T[\\text{Dec}^{sym}] \\right) + T[\\mathcal{A}_{\\text{IND-CCA}(\\mathcal{E})}]</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>`;
---

<BaseLayout title="Fujisaki-Okamoto IND-CCA hybrid encryption revisited (2003/107)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2003 &middot; eprint 2003/107
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
