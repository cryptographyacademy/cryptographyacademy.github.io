---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2019/1261';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'On Round-By-Round Soundness and State Restoration Attacks';
const AUTHORS_HTML = 'Justin Holmgren';

const CONTENT = `    <p class="text-gray-300">Justin Holmgren</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">We show that the recently introduced notion of round-by-round soundness for interactive proofs (Canetti et al.; STOC 2019) is equivalent to the notion of soundness against state restoration attacks (Ben-Sasson, Chiesa, and Spooner; TCC 2016). We also observe that neither notion is implied by the random-oracle security of the Fiat-Shamir transform.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">The Fiat-Shamir transform <em>[x10]</em> is a heuristic methodology for using a hash family <span class="math">\\mathcal{H}</span> to convert a public-coin interactive protocol <span class="math">\\Pi</span> (either a proof or argument) into a non-interactive protocol <span class="math">\\mathsf{FS}[\\Pi,\\mathcal{H}]</span>. In this protocol, a hash function <span class="math">H\\leftarrow\\mathcal{H}</span> is first chosen as a public parameter. A proof for a claim <span class="math">x</span> then consists of messages <span class="math">(\\alpha_{1},\\ldots,\\alpha_{r})</span> such that with <span class="math">\\beta_{i}=H(\\alpha_{1},\\beta_{1},\\ldots,\\alpha_{i})</span>, the transcript <span class="math">(\\alpha_{1},\\beta_{1},\\ldots,\\alpha_{r},\\beta_{r})</span> is accepted on input <span class="math">x</span> in <span class="math">\\Pi</span>. It is also often convenient to model <span class="math">\\mathcal{H}</span> as a random oracle, in which case we will denote the resulting random oracle protocol by <span class="math">\\mathsf{FS}^{\\mathsf{RO}}[\\Pi]</span>.</p>

    <p class="text-gray-300">It is known that <span class="math">\\mathsf{FS}^{\\mathsf{RO}}[\\Pi]</span> is sound for all constant-round protocols <span class="math">\\Pi</span> <em>[x16]</em> and, more generally, for all protocols <span class="math">\\Pi</span> that resist <em>state restoration attacks</em> <em>[x3]</em>. In a state restoration attack, a malicious prover <span class="math">P^{<em>}</span> interacting with a verifier <span class="math">V</span> may at any point reset <span class="math">V</span> to a state that <span class="math">V</span> was previously in. Then, <span class="math">P^{</em>}</span> may continue to interact with <span class="math">V</span>, with <span class="math">V</span> using fresh randomness.</p>

    <p class="text-gray-300">Returning our attention to the soundness of Fiat-Shamir in the plain model, the state of the art is that <span class="math">\\mathsf{FS}[\\Pi,\\mathcal{H}]</span> is (computationally) sound if <span class="math">\\Pi</span> is <em>round-by-round sound</em> <em>[CCH^{+}19]</em> and <span class="math">\\mathcal{H}</span> is correlation intractable <em>[x7]</em>. Round-by-round soundness stipulates that there is a way to label certain transcript prefixes as “doomed” relative to an input <span class="math">x</span> such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">x</span> is an input that represents a false claim, then the empty transcript <span class="math">\\emptyset</span> is doomed relative to <span class="math">x</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If <span class="math">\\tau</span> is any transcript prefix (ending in a verifier message) that is doomed relative to <span class="math">x</span>, then for all choices <span class="math">\\alpha</span> of the prover’s next messages, it holds with overwhelming probability over <span class="math">\\beta</span> that $\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta<span class="math"> is also doomed relative to </span>x$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\tau</span> is a complete transcript that is doomed relative to <span class="math">x</span>, then the verifier on input <span class="math">x</span> will reject the transcript <span class="math">\\tau</span>.</li>

    </ul>

    <p class="text-gray-300">These two results and two subclasses of public-coin interactive proofs naturally raise the question:</p>

    <p class="text-gray-300"><em>What is the relation between soundness against state-restoration attacks and round-by-round soundness?</em></p>

    <p class="text-gray-300">It was observed by <em>[CCH^{+}19]</em> that if a protocol <span class="math">\\Pi</span> is round-by-round sound, then <span class="math">\\Pi</span> is also sound against state restoration attacks. Proving the converse (or indeed instantiating Fiat-Shamir by any means for this potentially broader class of protocols) was left as an open question.</p>

    <p class="text-gray-300">In this work, we show that the converse holds.</p>

    <p class="text-gray-300">*Simons Institute. Email: holmgren@alum.mit.edu.</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Theorem 1.1.</h6>

    <p class="text-gray-300">For any public-coin protocol <span class="math">\\Pi</span>, if <span class="math">\\Pi</span> is sound against state restoration attacks, then <span class="math">\\Pi</span> is round-by-round sound.</p>

    <p class="text-gray-300">We also show that soundness against state restoration attacks is a strictly stronger notion for a protocol <span class="math">\\Pi</span> than the soundness of <span class="math">\\mathsf{FS}^{\\mathsf{RO}}[\\Pi]</span>.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Theorem 1.2.</h6>

    <p class="text-gray-300">There exists a public-coin interactive proof <span class="math">\\Pi</span> such that <span class="math">\\Pi</span> is <em>unsound</em> against state restoration attacks, but <span class="math">\\mathsf{FS}^{\\mathsf{RO}}[\\Pi]</span> is secure.</p>

    <p class="text-gray-300">Our separation leverages the fact that in a state restoration attack a prover may rewind to the same state multiple times, each time obtaining a freshly random verifier messages. On the other hand, in <span class="math">\\mathsf{FS}^{\\mathsf{RO}}[\\Pi]</span>, verifier messages are deterministically generated as a function of the random oracle and the preceding partial transcript.</p>

    <h2 id="sec-6" class="text-2xl font-bold">2 Preliminary Definitions</h2>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.1 Interactive Protocols</h3>

    <p class="text-gray-300">It will be convenient for us to consider separately from interactive proofs (which are associated with a language <span class="math">\\mathcal{L}</span>, involve an input <span class="math">x</span>, and have completeness / soundness properties depending on whether <span class="math">x\\in\\mathcal{L}</span>) a notion of an interactive game, which has no input.</p>

    <p class="text-gray-300">We think of an interactive game as something that is played by a single player in <span class="math">r</span> rounds. At the beginning of the <span class="math">i^{th}</span> round, the player must specify a message <span class="math">\\alpha_{i}\\in\\{0,1\\}^{*}</span>. Then, a message <span class="math">\\beta_{i}</span> is sampled uniformly from <span class="math">\\{0,1\\}^{\\ell_{i}}</span> for some <span class="math">\\ell_{i}</span> that is pre-specified independently of any of the player’s choices. At the end of the <span class="math">r^{th}</span> round, a predicate <span class="math">W</span> is applied to <span class="math">(\\alpha_{1},\\beta_{1},\\ldots,\\alpha_{r},\\beta_{r})</span> to determine whether the player wins.</p>

    <p class="text-gray-300">More formally:</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 2.1 (Interactive Game).</h6>

    <p class="text-gray-300">An (<span class="math">r</span>-round) public-coin interactive game is a tuple <span class="math">(\\ell_{1},\\ldots,\\ell_{r},W)</span>, where each <span class="math">\\ell_{i}\\in\\mathbb{Z}^{+}</span> and <span class="math">W\\subseteq\\{0,1\\}^{<em>}</span> is an “acceptance” set. A strategy is a function <span class="math">s:\\{0,1\\}^{</em>}\\rightarrow\\{0,1\\}^{*}</span>.</p>

    <p class="text-gray-300">If <span class="math">\\mathcal{G}=(\\ell_{1},\\ldots,\\ell_{r},W)</span> is a public-coin interactive game and <span class="math">s</span> is a strategy, then the value of <span class="math">\\mathcal{G}</span> with respect to <span class="math">s</span> (alternatively the probability with which <span class="math">s</span> wins <span class="math">\\mathcal{G}</span>) is</p>

    <p class="text-gray-300">\\<a href="\\mathcal{G}"> v[s</a>\\overset{\\text{def}}{=}\\Pr_{\\begin{subarray}{c}\\beta_{1}\\leftarrow\\{0,1\\}^{\\ell_{1}}\\\\ \\beta_{r}\\leftarrow\\{0,1\\}^{\\ell_{r}}\\end{subarray}}\\left[(\\alpha_{1},\\beta_{1},\\ldots,\\alpha_{r},\\beta_{r})\\in W\\right], \\]</p>

    <p class="text-gray-300">where each <span class="math">\\alpha_{i}</span> is defined to be <span class="math">s(\\beta_{1},\\ldots,\\beta_{i-1})</span>. The value of <span class="math">\\mathcal{G}</span>, denoted <span class="math">v(\\mathcal{G})</span>, is <span class="math">\\sup_{s}v<a href="\\mathcal{G}">s</a></span>.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 2.2 (Interactive Proof).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An (<span class="math">r(\\cdot)</span>-round) public-coin interactive proof for a language <span class="math">\\mathcal{L}</span> with soundness error <span class="math">\\epsilon(\\cdot)</span> is a pair <span class="math">(P,V)</span>, where <span class="math">V</span> is a polynomial-time algorithm mapping any string <span class="math">x\\in\\{0,1\\}^{*}</span> to an $r(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$-round single-player game with the following properties:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(Completeness) If <span class="math">x\\in\\mathcal{L}</span>, then <span class="math">P(x)</span> is a strategy that wins <span class="math">V(x)</span> with probability 1.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (Soundness) If <span class="math">x\\notin\\mathcal{L}</span>, then <em>all</em> strategies <span class="math">P^{*}</span> win <span class="math">V(x)</span> with probability at most $\\epsilon(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The interactive proof is said to be public-coin if each <span class="math">V(x)</span> is public-coin.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 2.3 (Game Transcript).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">\\mathcal{G}=(\\ell_{1},\\ldots,\\ell_{r},W)</span> is a public-coin interactive game, then a (complete) transcript for <span class="math">\\mathcal{G}</span> is $\\alpha_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{r}<span class="math"> with each </span>\\beta_{i}\\in\\{0,1\\}^{\\ell_{i}}<span class="math"> and </span>\\alpha_{i}\\in\\{0,1\\}^{*}<span class="math">. An accepting transcript is one that is contained in </span>W<span class="math">. A transcript prefix is any </span>\\alpha_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{i}<span class="math"> for </span>i\\in\\{0,\\ldots,r\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 2.4 (Game Suffix).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">\\mathcal{G}=(\\ell_{1},\\ldots,\\ell_{r},W)</span> is an <span class="math">r</span>-round public-coin interactive game and $\\alpha_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{i}<span class="math"> is a transcript prefix for </span>\\mathcal{G}<span class="math">, we denote by </span>\\mathcal{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tau}<span class="math"> the game </span>(\\ell_{i+1},\\ldots,\\ell_{r},W</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tau})<span class="math">, where </span>W</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tau}<span class="math"> is the set of strings of the form </span>\\alpha_{i+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{i+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{r}<span class="math"> for which </span>\\alpha_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{r}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{r}\\in W$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We refer to $\\mathcal{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tau}<span class="math"> as the suffix of </span>\\mathcal{G}<span class="math"> following </span>\\tau$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">2.2 Notions of Soundness</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{L}</span> be a language and let <span class="math">\\Pi=(P,V)</span> be a public-coin interactive proof for <span class="math">\\mathcal{L}</span>. Recall the following definition from <em>[CCH^{+}19]</em>. Suppose without loss of generality that all verifier messages are of length <span class="math">\\ell</span>.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 2.5 (Round-by-Round Soundness Error <em>[CCH^{+}19]</em>).</h6>

    <p class="text-gray-300"><span class="math">\\Pi</span> has round-by-round soundness error <span class="math">\\epsilon(\\cdot)</span> if there exists a “doomed set” <span class="math">\\mathcal{D}\\subseteq\\{0,1\\}^{*}</span> such that the following properties hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">x\\not\\in L</span>, then <span class="math">(x,\\emptyset)\\in\\mathcal{D}</span>, where <span class="math">\\emptyset</span> denotes the empty transcript.</li>

      <li>If <span class="math">(x,\\tau)\\in\\mathcal{D}</span> for a transcript prefix <span class="math">\\tau</span>, then for every potential prover next message <span class="math">\\alpha</span>, it holds that</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\beta\\leftarrow\\{0,1\\}^{\\ell}}\\Big{[}\\big{(}x,\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta\\big{)}\\notin\\mathcal{D}\\Big{]}\\leq\\epsilon(n)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any complete transcript <span class="math">\\tau</span>, if <span class="math">(x,\\tau)\\in\\mathcal{D}</span> then <span class="math">V(x,\\tau)=0</span>.</li>

    </ol>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 2.6 (Asymptotic Round-by-Round Soundness <em>[CCH^{+}19]</em>).</h6>

    <p class="text-gray-300"><span class="math">\\Pi</span> is said to be round-by-round sound if there is a negligible function <span class="math">\\epsilon</span> such that <span class="math">\\Pi</span> has round-by-round soundness error <span class="math">\\epsilon</span>.</p>

    <p class="text-gray-300">To define soundness of public-coin interactive proofs against state restoration attacks, we first define corresponding notions for public-coin interactive <em>games</em>.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 2.7.</h6>

    <p class="text-gray-300">For any public-coin interactive game <span class="math">\\mathcal{G}=(\\ell_{1},\\ldots,\\ell_{r},W)</span> and any query-bound <span class="math">q</span>, we define a corresponding <em>q</em>-query state restoration game <span class="math">\\mathsf{SR}^{q}(\\mathcal{G})</span>. We only informally describe how this game is played:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A referee initializes a set <span class="math">S:=\\{\\emptyset\\}</span>, where <span class="math">\\emptyset</span> denotes the empty transcript.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Up to <span class="math">q</span> times, <span class="math">P^{*}</span> may specify a pair <span class="math">(\\tau,\\alpha)</span> where $\\tau=\\alpha_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{i}\\in S<span class="math"> and </span>\\alpha\\in\\{0,1\\}^{*}<span class="math">. The referee samples </span>\\beta\\leftarrow\\{0,1\\}^{\\ell_{i+1}}<span class="math">, and adds </span>\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta<span class="math"> to </span>S$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P^{*}</span> wins if <span class="math">S</span> contains any <span class="math">\\tau\\in W</span>.</li>

    </ol>

    <p class="text-gray-300">In our notation, the notion of state restoration soundness from <em>[BCS16]</em> can be formulated as follows.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 2.8 (State Restoration Soundness <em>[BCS16]</em>).</h6>

    <p class="text-gray-300">For functions <span class="math">q:\\mathbb{Z}^{+}\\to\\mathbb{Z}^{+}</span> and <span class="math">\\epsilon:\\mathbb{Z}^{+}\\to\\mathbb{R}</span>, a public-coin interactive proof <span class="math">(P,V)</span> for <span class="math">\\mathcal{L}</span> is said to be <span class="math">(q,\\epsilon)</span>-sound against state restoration attacks if for all <span class="math">n</span> and all <span class="math">x\\in\\{0,1\\}^{n}\\setminus\\mathcal{L}</span>, the value of <span class="math">\\mathsf{SR}^{q(n)}\\big{(}V(x)\\big{)}\\leq\\epsilon(n)</span>.</p>

    <p class="text-gray-300"><span class="math">\\Pi</span> is said simply to be sound against state restoration attacks if for all polynomially bounded <span class="math">q:\\mathbb{Z}^{+}\\to\\mathbb{Z}^{+}</span>, there is a negligible function <span class="math">\\epsilon</span> such that <span class="math">\\Pi</span> is <span class="math">(q,\\epsilon)</span>-sound against state restoration attacks.</p>

    <h2 id="sec-16" class="text-2xl font-bold">3 Proof of Theorem 1.1</h2>

    <p class="text-gray-300">Let <span class="math">\\mathcal{L}</span> be a language, and let <span class="math">\\Pi=(P,V)</span> be an <span class="math">r(\\cdot)</span>-round public-coin interactive proof for <span class="math">\\mathcal{L}</span>. For simplicity suppose that all verifier messages are of length <span class="math">\\ell=\\ell(n)</span>.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Proposition 3.1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{G}</span> be a public-coin interactive game, and let $\\tau=\\alpha_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{i}<span class="math"> be a transcript prefix for </span>\\mathcal{G}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If $v\\big{(}\\mathsf{SR}^{q}(\\mathcal{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tau})\\big{)}\\leq\\epsilon<span class="math">, then for all </span>q^{\\prime}<q<span class="math">, all </span>\\epsilon^{\\prime}>\\epsilon<span class="math">, and all </span>\\alpha\\in\\{0,1\\}^{*}$, it holds that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\beta\\leftarrow\\{0,1\\}^{\\ell(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}}\\Big{[}v\\big{(}\\mathsf{SR}^{q^{\\prime}}(\\mathcal{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta})\\big{)}>\\epsilon^{\\prime}\\Big{]}\\leq-\\frac{\\ln(\\epsilon^{\\prime}-\\epsilon)}{q-q^{\\prime}}.$ (1)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-18" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any <span class="math">\\alpha</span>, let <span class="math">p_{\\alpha}</span> denote the left-hand side of Eq. (1). Consider the following (informally specified) strategy for $\\mathsf{SR}^{q}(\\mathcal{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tau})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Specify <span class="math">(\\tau,\\alpha)</span> repeatedly. Specifically, do so <span class="math">q-q^{\\prime}</span> times. Let <span class="math">S</span> be the set as in the definition of $\\mathsf{SR}^{q}(\\mathcal{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tau})$ (Definition 2.7).</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. From this point on, <span class="math">P^{*}</span> plays according to an optimal strategy for $\\mathsf{SR}^{q^{\\prime}}(\\mathcal{G}</td>

            <td class="px-3 py-2 border-b border-gray-700">_{\\tau</td>

            <td class="px-3 py-2 border-b border-gray-700">\\alpha</td>

            <td class="px-3 py-2 border-b border-gray-700">\\beta})$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In order for this strategy to not contradict the assumption that $v\\big{(}\\mathsf{SR}^{q}(\\mathcal{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tau})\\big{)}\\leq\\epsilon<span class="math">, it must hold with probability at least </span>\\epsilon^{\\prime}-\\epsilon<span class="math"> that at the beginning of Step 2, for all </span>\\beta<span class="math"> with </span>\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta\\in S<span class="math">, </span>v\\big{(}\\mathsf{SR}^{q^{\\prime}}(\\mathcal{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta})\\big{)}\\leq\\epsilon^{\\prime}<span class="math">. Because each </span>\\beta<span class="math"> is chosen independently, this is equivalent to saying that </span>(1-p_{\\alpha})^{q-q^{\\prime}}\\geq\\epsilon^{\\prime}-\\epsilon$. Thus</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">p_{\\alpha}\\leq 1-(\\epsilon^{\\prime}-\\epsilon)^{\\frac{1}{q-q^{\\prime}}}=1-e^{\\frac{\\ln(\\epsilon^{\\prime}-\\epsilon)}{q-q^{\\prime}}}\\leq-\\frac{\\ln(\\epsilon^{\\prime}-\\epsilon)}{q-q^{\\prime}}.\\qed</span></p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Theorem 3.2.</h6>

    <p class="text-gray-300">If <span class="math">\\Pi</span> is <span class="math">(q,\\epsilon)</span>-sound against state-restoration attacks for <span class="math">\\epsilon&lt;1</span>, then it has round-by-round soundness error <span class="math">\\frac{r}{q}\\cdot\\ln\\left(\\frac{2r}{1-\\epsilon}\\right)</span>.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Define <span class="math">\\Delta\\epsilon=\\frac{1-\\epsilon}{2r}</span> and <span class="math">\\Delta q=\\frac{q}{\\epsilon}</span>. Define the set <span class="math">\\mathcal{D}\\subseteq\\{0,1\\}^{*}</span> such that if <span class="math">\\tau</span> is an <span class="math">i</span>-round transcript prefix for <span class="math">V(x)</span>, then <span class="math">(x,\\tau)\\in\\mathcal{D}</span> if and only if $v\\big{(}\\mathsf{SR}^{q-i\\cdot\\Delta q}(V(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tau})\\big{)}\\leq\\epsilon+i\\cdot\\Delta\\epsilon$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now show that <span class="math">\\mathcal{D}</span> satisfies the requirements of Definition 2.5.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Claim 3.3.</h6>

    <p class="text-gray-300">For <span class="math">x\\notin\\mathcal{L}</span>, <span class="math">(x,\\emptyset)\\in\\mathcal{D}</span> where <span class="math">\\emptyset</span> denotes the empty transcript.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$v\\big{(}\\mathsf{SR}^{q-0\\cdot\\Delta q}(V(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\emptyset})\\big{)}=v\\big{(}\\mathsf{SR}^{q}(V(x))\\big{)},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">which by assumption that <span class="math">\\Pi</span> is <span class="math">(q,\\epsilon)</span>-sound, must be bounded by <span class="math">\\epsilon</span>. Thus <span class="math">(x,\\emptyset)\\in\\mathcal{D}</span>. ∎</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Claim 3.4.</h6>

    <p class="text-gray-300">For all <span class="math">x</span>, <span class="math">\\tau</span>, if <span class="math">(x,\\tau)\\in\\mathcal{D}</span> then for all <span class="math">\\alpha</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\beta\\leftarrow\\{0,1\\}^{\\ell(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}}\\left[(x,\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta)\\notin\\mathcal{D}\\right]\\leq\\frac{r}{q}\\cdot\\ln\\left(\\frac{2r}{1-\\epsilon}\\right).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-24" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that <span class="math">\\tau</span> is an <span class="math">i</span>-round transcript prefix. Then by definition of <span class="math">\\mathcal{D}</span> we have $v\\big{(}\\mathsf{SR}^{q-i\\cdot\\Delta q}(V(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tau})\\big{)}\\leq\\epsilon+i\\cdot\\Delta\\epsilon<span class="math">. Then for any </span>\\alpha$, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\beta\\leftarrow\\{0,1\\}^{\\ell(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}}\\left[(x,\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta)\\notin\\mathcal{D}\\right]=\\Pr_{\\beta\\leftarrow\\{0,1\\}^{\\ell(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}}\\left[v\\big{(}\\mathsf{SR}^{q-(i+1)\\cdot\\Delta q}(V(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta})\\big{)}>\\epsilon+(i+1)\\cdot\\Delta\\epsilon\\right].$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By Proposition 3.1, this is bounded by <span class="math">-\\frac{\\ln(\\Delta\\epsilon)}{\\Delta q}=\\frac{r}{q}\\cdot\\ln\\left(\\frac{2r}{1-\\epsilon}\\right)</span>. ∎</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Claim 3.5.</h6>

    <p class="text-gray-300">For any <span class="math">x</span> and any complete transcript <span class="math">\\tau</span>, if <span class="math">(x,\\tau)\\in\\mathcal{D}</span>, then <span class="math">V(x,\\tau)=0</span>.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">This follows from the fact that for any complete transcript <span class="math">\\tau</span>, either <span class="math">\\tau</span> is an accepting transcript for <span class="math">V(x)</span> or it is not, and the definition of <span class="math">\\mathcal{D}</span> implies that the probability that <span class="math">\\tau</span> is accepting for <span class="math">V(x)</span> is at most <span class="math">\\epsilon+r\\cdot\\Delta\\epsilon=\\frac{1+\\epsilon}{2}&lt;1</span>. ∎</p>

    <p class="text-gray-300">This completes the proof of Theorem 3.2. ∎</p>

    <p class="text-gray-300">Theorem 1.1 follows as a corollary, also using Proposition 3.6 below.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Proposition 3.6.</h6>

    <p class="text-gray-300">If <span class="math">\\Pi</span> is sound against state restoration attacks, then there exists a <em>super-polynomial</em> <span class="math">q</span> and a negligible function <span class="math">\\epsilon</span> such that <span class="math">\\Pi</span> is <span class="math">(q,\\epsilon)</span>-sound against state restoration attacks.</p>

    <p class="text-gray-300">######</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose that <span class="math">\\Pi</span> is sound against state restoration attacks. This implies that there exist <span class="math">1=N_{0}&lt;N_{1}&lt;N_{2}&lt;\\cdots</span> such that for all <span class="math">n\\geq N_{c}</span> and all <span class="math">x\\in\\{0,1\\}^{n}\\setminus\\mathcal{L}</span>, <span class="math">v\\left(\\mathsf{SR}^{n^{c}}(V(x))\\right)\\leq n^{-c}</span>.</p>

    <p class="text-gray-300">Define <span class="math">q:\\mathbb{Z}^{+}\\to\\mathbb{Z}^{+}</span> as follows. For any <span class="math">n</span>, let <span class="math">c</span> be such that <span class="math">N_{c}\\leq n&lt;N_{c+1}</span> and define <span class="math">q(n)=n^{c}</span>. It follows by definition that <span class="math">q(n)\\geq n^{\\omega(1)}</span> and <span class="math">\\max_{x\\in\\{0,1\\}^{n}\\setminus\\mathcal{L}}\\left\\{v\\left(\\mathsf{SR}^{q(n)}(V(x))\\right)\\right\\}\\leq n^{-\\omega(1)}</span>. ∎</p>

    <p class="text-gray-300">We remark that Proposition 3.6 is very similar to an observation of Bellare <em>[x1]</em> that there is no difference between the following two types of security definition:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every polynomial-time adversary <span class="math">\\mathcal{A}</span>, there exists a negligible function <span class="math">\\epsilon</span> bounding <span class="math">\\mathcal{A}</span>’s advantage in breaking the primitive.</li>

      <li>There exists a negligible function <span class="math">\\epsilon</span> such that for all polynomial-time adversaries <span class="math">\\mathcal{A}</span>, <span class="math">\\epsilon</span> bounds the advantage of <span class="math">\\mathcal{A}</span> in breaking the primitive.</li>

    </ul>

    <h2 id="sec-29" class="text-2xl font-bold">4 Proof of Theorem 1.2</h2>

    <p class="text-gray-300">Let <span class="math">r(\\cdot)</span> be any function with <span class="math">r(n)=\\omega(1)</span>, and consider the <span class="math">r</span>-round public-coin interactive proof <span class="math">\\Pi=(P,V)</span> for the empty language in which all verifier messages are <span class="math">\\log n</span>-bit strings. The verifier accepts if the prover sent only empty strings, and all of the verifier’s messages were the all-zero string. It is easy to see that <span class="math">\\mathsf{FS}[\\Pi,\\mathcal{H}]</span> has soundness error equal to</p>

    <p class="text-gray-300"><span class="math">\\Pr_{H\\leftarrow\\mathcal{H}}\\left[\\forall i\\in[r(n)],H(0^{(i-1)\\cdot\\log n})=0^{\\log n}\\right],</span></p>

    <p class="text-gray-300">which is negligible if <span class="math">\\mathcal{H}</span> is replaced by a random oracle.</p>

    <p class="text-gray-300">However, because each verifier message has only <span class="math">\\log n</span> bits, <span class="math">\\Pi</span> can only possibly have round-by-round soundness error <span class="math">\\epsilon</span> if <span class="math">\\epsilon\\geq\\frac{1}{n}</span>.</p>

    <h2 id="sec-30" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">We thank Fermi Ma and Ron Rothblum for helpful comments on an early draft of this work.</p>

    <h2 id="sec-31" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner, <em>Interactive oracle proofs</em>, TCC (B2), Lecture Notes in Computer Science, vol. 9986, 2016, pp. 31–60.</li>

      <li>[Bel02] Mihir Bellare, <em>A note on negligible functions</em>, J. Cryptology 15 (2002), no. 4, 271–284.</li>

      <li>[CCH^{+}19] Ran Canetti, Yilei Chen, Justin Holmgren, Alex Lombardi, Guy N. Rothblum, Ron D. Rothblum, and Daniel Wichs, <em>Fiat-shamir: from practice to theory</em>, STOC, ACM, 2019, pp. 1082–1090.</li>

      <li>[CGH04] Ran Canetti, Oded Goldreich, and Shai Halevi, <em>The random oracle methodology, revisited</em>, J. ACM 51 (2004), no. 4, 557–594.</li>

      <li>[FS86] Amos Fiat and Adi Shamir, <em>How to prove yourself: Practical solutions to identification and signature problems</em>, Conference on the Theory and Application of Cryptographic Techniques, Springer, 1986, pp. 186–194.</li>

      <li>[PS96] David Pointcheval and Jacques Stern, <em>Security proofs for signature schemes</em>, EUROCRYPT, Lecture Notes in Computer Science, vol. 1070, Springer, 1996, pp. 387–398.</li>

    </ul>

    <p class="text-gray-300">-</p>`;
---

<BaseLayout title="On Round-By-Round Soundness and State Restoration Attacks (2019/1261)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2019 &middot; eprint 2019/1261
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
