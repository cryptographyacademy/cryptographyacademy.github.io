---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2009/370';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A study of pairing computation for elliptic curves with embedding degree 15';
const AUTHORS_HTML = 'Nadia El Mrabet, Nicolas Guillermin, Sorina Ionica';

const CONTENT = `    <p class="text-gray-300">Nadia El Mrabet<span class="math">^{1}</span>, Nicolas Guillermin<span class="math">^{2}</span>, and Sorina Ionica<span class="math">^{3}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> LIRMM, Montpellier <span class="math">^{2}</span> DGA, Rennes</p>

    <p class="text-gray-300"><span class="math">^{3}</span> Université de Versailles Saint-Quentin-en-Yvelines, 45 avenue des États-Unis, 78035 Versailles CEDEX, France nadia.elmrabet@lirmm.fr,sorina.ionica@m4x.org</p>

    <p class="text-gray-300">Abstract. This paper presents the first study of pairing computation on curves with embedding degree 15. We compute the Ate and the twisted Ate pairing for a family of curves with parameter <span class="math">\\rho</span> 1.5 and embedding degree 15. We use a twist of degree 3 to perform most of the operations in <span class="math">\\mathbb{F}_p</span> or <span class="math">\\mathbb{F}_{p^5}</span>. Furthermore, we present a new arithmetic for extension fields of degree 5. Our computations show that these curves give very efficient implementations for pairing-based cryptography at high security levels.</p>

    <p class="text-gray-300">Key-words: Pairing based cryptography, Pairing computation, Arithmetic, Interpolation, Elliptic Curves, Embedding degree, Security level.</p>

    <p class="text-gray-300">Pairings on elliptic curves were introduced by André Weil in 1948 in mathematics [24], but their utilization in cryptography is actually quite recent. They were first used for cryptanalytic purposes, i.e. attacking the discrete logarithm problem on supersingular elliptic curves [2], but nowadays they are also used as building blocks for new cryptographic protocols such as the tripartite Diffie-Hellman protocol [15], identity-based encryption [5], short signatures [6], and others. A pairing is a bilinear map <span class="math">e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_3</span>, where <span class="math">\\mathbb{G}_1</span>, <span class="math">\\mathbb{G}_2</span> and <span class="math">\\mathbb{G}_3</span> are groups of large prime order <span class="math">r</span>. Known pairings on elliptic curves, i.e. the Weil, Tate, Eta and Ate pairings map to the multiplicative group of the minimal extension of the ground field <span class="math">\\mathbb{F}_p</span> containing the <span class="math">r</span>-th roots of unity. The degree of this extension is called the embedding degree with respect to <span class="math">r</span>. The most efficient known method used for pairing computation is Miller's algorithm, whose performance relies heavily on efficient arithmetic of this extension field. It follows that for efficient pairing computation we need curves with a rather small embedding degree.</p>

    <p class="text-gray-300">On the other hand, latest research in efficient computation of pairings focused on the reduction of the loop length in Miller's algorithm. It was proven [23][13] that on most known families of ordinary curves, the complexity of Miller's algorithm is <span class="math">\\mathcal{O}\\left(\\frac{1}{\\varphi(k)}\\log_2(r)\\right)</span>, where <span class="math">k</span> is the embedding degree and <span class="math">\\varphi</span> is Euler's totient function. Consequently, for a fixed level of security and therefore a fixed bit length of <span class="math">r</span>, pairing computation might turn out to be faster on curves with embedding degrees such that the integer <span class="math">\\varphi(k)</span> is large. Moreover, in practice we are looking for curves for which the following value <span class="math">\\rho = \\frac{\\log_2(p)}{\\log_2(r)}</span> is as small as possible, in order to save bandwidth during the calculation.</p>

    <p class="text-gray-300">In this paper, we give the first efficient pairing computation for curves of embedding degree 15. We show that existing constructions of families of curves of degree 15 and <span class="math">j</span>-invariant 0 present multiple advantages. First of all, we show that pairing computation on these curves has loop length <span class="math">\\frac{\\log_2(r)}{8}</span> for the Ate pairing and <span class="math">\\frac{\\log_2(r)}{2}</span> for the twisted Ate pairing. Secondly, we show that by using twists of degree 3 we manage to perform most of the operations in <span class="math">\\mathbb{F}_p</span> or <span class="math">\\mathbb{F}_{p^5}</span>. By making use of an interpolation technique, we also improve the arithmetic of <span class="math">\\mathbb{F}_{p^5}</span> in order to get better results.</p>

    <p class="text-gray-300">Moreover, denominator computation and the final inversion can be avoided by making use of the twist. Our results show that by choosing the optimal arithmetic on <span class="math">\\mathbb{F}_{p^5}</span> and <span class="math">\\mathbb{F}_{p^{15}}</span>, pairing computation</p>

    <p class="text-gray-300">on curves of embedding degree 15 and <span class="math">\\rho=1.5</span> is faster than on Barreto-Naehrig curves for high security levels, i.e. security levels of 192 and 256 bits. Our computations suggest that these curves might be the best choice one could make among known pairing-friendly families of curves for implementations at high security levels.</p>

    <p class="text-gray-300">The remainder of this paper is organized as follows: Section 2 gives the definition and important properties of pairings. In Section 3 we establish the optimal computation of the pairing on curves with embedding degree 15. In Section 4 we describe an interpolation-based algorithm for multiplication over the field <span class="math">\\mathbb{F}_{p^{k}}</span>. Finally, we conclude in Section 5 by giving a global evaluation of the number of operations needed to compute the pairing and by comparing our results to performances obtained on Barreto-Naehrig curves, which are considered as standard at the time this paper was written.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 Background on pairings</h2>

    <p class="text-gray-300">In this section we give a brief overview of the definitions of pairings on elliptic curves and of Miller’s algorithm <em>[20]</em> used in pairing computation. Let <span class="math">p</span> be a prime, <span class="math">E</span> an elliptic curve defined over <span class="math">\\mathbb{F}_{p}</span> by the Weierstrass equation <span class="math">y^{2}=x^{3}+ax+b</span> and <span class="math">r</span> a prime factor of <span class="math">\\#(E(\\mathbb{F}_{p}))</span>. Suppose <span class="math">r^{2}</span> does not divide <span class="math">\\#(E(\\mathbb{F}_{p}))</span> and let <span class="math">k</span> be the embedding degree with respect to <span class="math">r</span>, i.e. the smallest integer such that <span class="math">r</span> divides <span class="math">p^{k}-1</span>. We denote by <span class="math">P_{\\infty}</span> the point at infinity of the elliptic curve.</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">A pairing is a bilinear and non degenerate function:</p>

    <p class="text-gray-300"><span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}</span> <span class="math">\\rightarrow\\mathbb{G}_{3}</span> <span class="math">(P,Q)</span> <span class="math">\\rightarrow e(P,Q)</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> are subgroups of order <span class="math">r</span> on the elliptic curve and <span class="math">\\mathbb{G}_{3}</span> is generally <span class="math">\\mu_{r}</span>, the subgroup of the <span class="math">r</span>-th roots of unity in <span class="math">\\mathbb{F}_{p^{k}}</span>. In general, in cryptographic applications, we take <span class="math">\\mathbb{G}_{1}=E(\\mathbb{F}_{p})[r]</span> and <span class="math">\\mathbb{G}_{2}\\subset E(\\mathbb{F}_{p^{k}})[r]</span>, where we denote by <span class="math">E(K)[r]</span> the subgroup of <span class="math">K</span>-rational points of order <span class="math">r</span> of the elliptic curve <span class="math">E</span>. We also denote <span class="math">E[r]</span> the subgroup of points of order <span class="math">r</span> defined over the algebraic closure of <span class="math">\\mathbb{F}_{p}</span>.</p>

    <p class="text-gray-300">Let <span class="math">P\\in\\mathbb{G}_{1}</span>, <span class="math">Q\\in\\mathbb{G}_{2}</span>. The goal of Miller’s algorithm is to first construct a rational function <span class="math">f_{s,P}</span> associated to the point <span class="math">P</span> and to some integer <span class="math">s</span> and to secondly evaluate this function at the point <span class="math">Q</span> (in fact at a divisor associated to this point). The function <span class="math">f_{s,P}</span> is such that the divisor associated to it is:</p>

    <p class="text-gray-300"><span class="math">\\operatorname{div}(f_{s,P})=s(P)-(sP)-(s-1)(P_{\\infty}).</span></p>

    <p class="text-gray-300">Suppose we want to compute the sum of <span class="math">iP</span> and <span class="math">jP</span>. Take <span class="math">h_{1}</span> the line going through <span class="math">iP</span> and <span class="math">jP</span> and <span class="math">h_{2}</span> the vertical line through <span class="math">(i+j)P</span>. Miller’s idea was to make use of the following relation</p>

    <p class="text-gray-300"><span class="math">f_{i+j,P}=f_{i,P}f_{j,P}\\frac{h_{1}}{h_{2}},</span> (1)</p>

    <p class="text-gray-300">in order to compute <span class="math">f_{s,P}</span> iteratively. Moreover, Miller’s algorithm uses the double-and-add method to compute <span class="math">f_{s,P}</span> in <span class="math">\\log_{2}(s)</span> operations.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">The Tate pairing</h4>

    <p class="text-gray-300">The Tate pairing, denoted <span class="math">e_{Tate}</span>, is defined by:</p>

    <p class="text-gray-300"><span class="math">\\mathbb{G}_{1}\\times\\mathbb{G}_{2}</span> <span class="math">\\mapsto\\mathbb{G}_{3}</span> <span class="math">(P,Q)</span> <span class="math">\\mapsto e_{Tate}(P,Q)=f_{r,P}(Q).</span></p>

    <p class="text-gray-300">Here, the function <span class="math">f_{r,P}</span> is normalized, i.e. <span class="math">(u_{0}^{r}f_{r,P})(P_{\\infty})=1</span> for <span class="math">u_{0}^{r}</span> some <span class="math">\\mathbb{F}_{p}</span>-rational uniformizer at <span class="math">P_{\\infty}</span>. This pairing is only defined up to a representative of <span class="math">(\\mathbb{F}_{p^{k}})^{r}</span>. In order to obtain a unique value we raise it to the power <span class="math">\\frac{p^{k}-1}{r}</span>, obtaining an <span class="math">r</span>-th root of unity that we call the reduced Tate pairing</p>

    <p class="text-gray-300"><span class="math">\\hat{e}_{Tate}(P,Q)=f_{r,P}(Q)^{\\frac{p^{k}-1}{r}}.</span></p>

    <p class="text-gray-300"><span class="math">\\pi_{p}</span> be the Frobenius over the elliptic curve: <span class="math">\\pi_{p}:E\\to E</span>, such that for <span class="math">P=(x_{P},y_{P})</span> <span class="math">\\pi_{p}(P)=(x_{P}^{p},y_{P}^{p})</span>. The trace of the Frobenius is denoted by <span class="math">t</span>. Let <span class="math">T=t-1</span>, <span class="math">\\mathbb{G}_{1}:=E[r]\\cap\\mathrm{Ker}(\\pi_{q}-[1])</span> and <span class="math">\\mathbb{G}_{2}:=E[r]\\cap\\mathrm{Ker}(\\pi_{q}-[q])</span>. Then for two points <span class="math">P\\in\\mathbb{G}_{1}</span> and <span class="math">Q\\in\\mathbb{G}_{2}</span>, the Ate pairing is given by:</p>

    <p class="text-gray-300"><span class="math">e_{ate}(Q,P)=f_{T,Q}(P)^{(p^{k}-1)/r}</span></p>

    <p class="text-gray-300">It was shown in <em>[14]</em> that the Ate pairing is actually a power of the reduced Tate pairing.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">Twisted Ate pairing</h3>

    <p class="text-gray-300">We begin with the following definition.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Definition 2.</h6>

    <p class="text-gray-300">Let <span class="math">E,E^{\\prime}</span> be elliptic curves over <span class="math">F_{p}</span>. Then <span class="math">E^{\\prime}</span> is called a twist of degree <span class="math">d</span> if there exists an isomorphism <span class="math">\\phi_{d}:E^{\\prime}\\to E</span> defined over <span class="math">\\mathbb{F}_{p^{d}}</span> and <span class="math">d</span> is minimal.</p>

    <p class="text-gray-300">Suppose now that <span class="math">E</span> admits a twist <span class="math">E^{\\prime}</span> defined over <span class="math">\\mathbb{F}_{p^{k/d}}</span> of degree <span class="math">d</span>, with <span class="math">d\\mid k</span>. We set <span class="math">m=\\gcd(k,d)</span> and <span class="math">e=k/m</span>. We consider <span class="math">G_{1}</span> and <span class="math">G_{2}</span> as above. Then for <span class="math">P\\in G_{1},Q\\in G_{2}</span> we get <em>[14]</em>:</p>

    <p class="text-gray-300"><span class="math">e_{twisted}(P,Q)=f_{T^{e},P}(Q)^{(p^{k}-1)/r},</span></p>

    <p class="text-gray-300">The twisted Ate pairing is also a power of the reduced Tate pairing. For curves with small trace of the Frobenius, it is clear that the Ate and twisted Ate pairings should be preferred to the Tate pairing, as the loop in Miller’s algorithm will be shorter. Other variants of twisted Ate pairing were obtained in <em>[19]</em> replacing <span class="math">T^{e}</span> with <span class="math">T^{ie}</span>, for any <span class="math">i\\in\\mathbb{Z}</span>. All these variants were given in order to find the smallest possible <span class="math">\\lambda</span> determining the length of the loop in Miller’s algorithm. Hess and Vercauteren exploit these ideas in <em>[13]</em> and <em>[23]</em>, respectively, by making use of lattices.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">Optimal pairing</h3>

    <p class="text-gray-300">Consider <span class="math">s</span> an integer and <span class="math">h=\\sum_{i=0}^{d}h_{i}x^{i}\\in\\mathbb{Z}[x]</span> with <span class="math">h(s)\\equiv 0\\ \\mathrm{mod}\\ r</span>. Let <span class="math">R\\in E(\\mathbb{F}_{q^{k}})</span> and <span class="math">f_{s,h,R}</span> the function whose divisor is</p>

    <p class="text-gray-300"><span class="math">(f_{s,h,R})=\\sum_{i=0}^{d}h_{i}((s^{i}R)-(P_{\\infty}))</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We denote $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{1}=\\sum_{i=0}^{d}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-9" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Let <span class="math">s</span> be any primitive root of unity modulo <span class="math">r^{2}</span> and <span class="math">n</span> an integer dividing <span class="math">\\#\\mathrm{Aut}(E)</span>. Then</p>

    <p class="text-gray-300"><span class="math">a_{s,h}^{twist}:G_{1}\\times G_{2}\\to\\mu_{r}</span> <span class="math">(P,Q)\\to(f_{s,h,P}(Q))^{(q^{k}-1)/r}.</span></p>

    <p class="text-gray-300">defines a bilinear pairing which is non-degenerate if and only if <span class="math">h(s)\\not\\equiv 0\\ \\mathrm{mod}\\ r^{2}</span>. The relation with the Tate pairing is</p>

    <p class="text-gray-300"><span class="math">a_{s,h}^{twist}(P,Q)=t(P,Q)^{h(s)/r}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">There exists an efficiently computable <span class="math">h\\in\\mathbb{Z}</span> with <span class="math">h(s)\\equiv 0\\ \\mathrm{mod}\\ r</span>, <span class="math">\\mathrm{deg}(h)\\leq\\varphi(n)-1</span> and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{1}=\\mathcal{O}(r^{1/\\varphi(n)})<span class="math"> such that the above pairings are non-degenerate. The </span>\\mathcal{O}<span class="math">-constant depends only on </span>n$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">Security aspect</h3>

    <p class="text-gray-300">The security of a pairing based cryptosystem relies on two parameters: the bit length of <span class="math">r</span>, <span class="math">\\log_{2}r</span> and the bit size of the extension field <span class="math">k\\log_{2}p</span>. These parameters have to be chosen large enough to ensure that the discrete logarithm problem will be hard in both the subgroup of points of order <span class="math">r</span> of the curve and the multiplicative group of the finite field <span class="math">\\mathbb{F}_{p^{k}}</span>. The fastest known attack on finite field is the index calculus method, whose complexity is <span class="math">\\mathcal{O}(L_{r}(\\frac{1}{3}))</span>, where <span class="math">L_{r}(\\frac{1}{3})=\\exp\\ ((32/9)^{(1/3)}(\\log\\ r)^{\\frac{1}{3}}\\log(\\log(r))^{\\frac{2}{3}})</span> and <span class="math">c</span> is a constant depending on the characteristic of the finite field <em>[12]</em>. Meanwhile the best attack known</p>

    <p class="text-gray-300">Table 1. Level of security in bit</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">AES security</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">bitsize of r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">bitsize of pk</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">3072</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">384</td>

            <td class="px-3 py-2 border-b border-gray-700">7680</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">15360</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">on elliptic curves DLP is the Pollard-  <span class="math">\\rho</span>  method, whose complexity is  <span class="math">\\mathcal{O}(\\sqrt{r})</span>  [9, Chap. 17]. As a consequence, while the security level will increase, the bound on  <span class="math">k\\log_2(p)</span>  is expected to grow faster than the bound on  <span class="math">\\log_2(r)</span> . Following NIST recommendations [1], Table 1 gives optimal bitsizes of  <span class="math">r</span>  and  <span class="math">p^k</span>  for different security levels.</p>

    <p class="text-gray-300">On the other hand, in practice we are looking for curves for which the following value</p>

    <div class="my-4 text-center"><span class="math-block">\\rho = \\frac {\\log p}{\\log r}</span></div>

    <p class="text-gray-300">is as small as possible, in order to save bandwidth during the calculation. This is due to the fact that for a fixed level of security, efficient implementation of the pairing depends on the size of the ground field, i.e. on the size of  <span class="math">p</span> . So taking greater  <span class="math">k</span>  is a better solution than increasing the bit length of  <span class="math">p</span> .</p>

    <p class="text-gray-300">A first method that could be used in order to build curves with  <span class="math">k = 15</span>  is the Cocks-Pinch method [8]. This method generates curves with arbitrary  <span class="math">r</span>  and  <span class="math">\\rho \\sim 2</span> . Duan and all. [11] showed that by using the Brezing-Weng method we can actually do better. They generated a family of curves with  <span class="math">j</span> -invariant 0, embedding degree 15 and  <span class="math">\\rho \\sim 1.5</span> . This family is given by the following polynomials:</p>

    <div class="my-4 text-center"><span class="math-block">p = 1 / 3 x ^ {1 2} - 2 / 3 x ^ {1 1} + 1 / 3 x ^ {1 0} + 1 / 3 x ^ {7} - 2 / 3 x ^ {6} + 1 / 3 x ^ {5} + 1 / 3 x ^ {2} + 1 / 3 x + 1 / 3</span></div>

    <div class="my-4 text-center"><span class="math-block">r = x ^ {8} - x ^ {7} + x ^ {5} - x ^ {4} + x ^ {3} - x + 1</span></div>

    <div class="my-4 text-center"><span class="math-block">t = x + 1.</span></div>

    <p class="text-gray-300">The remainder of this paper will present efficient computation of pairings on this family of curves. To emphasize the performance of our suggestion, we compare our results to those resulting from efficient implementation of pairings on Barreto-Naehrig curves [4]. We briefly remind that these are curves of embedding degree 12 and  <span class="math">j</span> -invariant 0, given by the following parametrization:</p>

    <div class="my-4 text-center"><span class="math-block">p = 3 6 x ^ {4} + 3 6 x ^ {3} + 2 4 x ^ {2} + 6 x + 1</span></div>

    <div class="my-4 text-center"><span class="math-block">r = 3 6 x ^ {4} + 3 6 x ^ {3} + 1 8 x ^ {2} + 6 x + 1</span></div>

    <div class="my-4 text-center"><span class="math-block">t = 6 x ^ {2} + 1.</span></div>

    <p class="text-gray-300">These curves are preferred in cryptographic applications because they have the  <span class="math">\\rho \\sim 1</span>  and most operations during the pairing computation are done in  <span class="math">\\mathbb{F}_p</span>  or  <span class="math">\\mathbb{F}_{p^2}</span> , thanks to the existence of a twist of degree 6.</p>

    <p class="text-gray-300">Let  <span class="math">E</span>  be an elliptic curve of  <span class="math">j</span> -invariant 0, defined over  <span class="math">\\mathbb{F}_p</span> . Suppose its equation is  <span class="math">y^2 = x^3 + b</span> , with  <span class="math">b \\in \\mathbb{F}_p</span> . Consider  <span class="math">E</span>  over the extension field  <span class="math">\\mathbb{F}_{p^{b/3}}</span> . Then it admits a cubic twist  <span class="math">E&#x27;</span>  of equation  <span class="math">y^2 = x^3 + \\frac{b}{D}</span> ,</p>

    <p class="text-gray-300">with <span class="math">D</span> not a cubic residue <span class="math">D\\in\\mathbb{F}_{q^{k/3}}</span>. The morphism</p>

    <p class="text-gray-300"><span class="math">\\Phi_{3}:E^{\\prime}\\to E:\\Phi_{3}(x,y)=(xD^{1/3},yD^{1/2})</span></p>

    <p class="text-gray-300">maps points in <span class="math">E^{\\prime}(\\mathbb{F}_{p^{k/3}})</span> to points in <span class="math">E(\\mathbb{F}_{p^{k}})</span>. In particular, as <span class="math">r\\mid\\#E^{\\prime}</span>, we may choose <span class="math">Q</span>, the generator of <span class="math">\\mathbb{G}_{2}</span>, as the image of an <span class="math">r</span> order point under this morphism <span class="math">:Q=\\Phi_{3}(Q^{\\prime})</span>, with <span class="math">Q^{\\prime}\\in E^{\\prime}(\\mathbb{F}_{p^{k/3}})</span>. So <span class="math">Q=(D^{1/3}x,D^{1/2}y)</span>, with <span class="math">x,y\\in\\mathbb{F}_{p^{k/3}}</span>. As we will see later, for <span class="math">k=15</span> this will imply that most operations in pairing computation on <span class="math">\\mathbb{G}_{1}\\times\\mathbb{G}_{2}</span> (or <span class="math">\\mathbb{G}_{2}\\times\\mathbb{G}_{1}</span>) are to be done in <span class="math">\\mathbb{F}_{p}</span> or <span class="math">\\mathbb{F}_{p^{5}}</span>.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">3.2 Optimal pairing for <span class="math">k=15</span></h3>

    <p class="text-gray-300">We can easily see that for the family of curves with <span class="math">k=15</span> described above, the length of the Miller’s loop for the twisted Ate pairing is <span class="math">\\frac{5}{2}\\text{log}_{2}r</span>. We will show that the complexity of the computation of the optimal pairing for this family is <span class="math">\\mathcal{O}(\\frac{\\text{log}_{2}\\,r}{2})</span>. Indeed, we apply theorem 1 with <span class="math">n=3</span> and compute the following polynomial using function field LLL (<em>[21]</em>):</p>

    <p class="text-gray-300"><span class="math">h_{15}(x,t)=(x^{3}-x^{2}+1)t-x^{4}+x^{3}-x+1</span></p>

    <p class="text-gray-300">We compute</p>

    <p class="text-gray-300"><span class="math">\\text{div }(f_{s,h,P})=</span> <span class="math">((x^{3}-x^{2}+1)(sP)-((x^{3}-x^{2}+1)sP)-(x^{3}-x^{2})(P_{\\infty}))+((-x^{4}+x^{3}-x+1)(P)</span> <span class="math">-((-x^{4}+x^{3}-x+1)P)-(-x^{4}+x^{3}-x)(P_{\\infty}))+((x^{3}-x^{2}+1)tP)</span> <span class="math">+((-x^{4}+x^{3}-x+1)P)-2(P_{\\infty})=\\text{div }(f_{x^{3}-x^{2}+1,sP})+\\text{div }(f_{-x^{4}+x^{3}-x+1,P})+\\text{div }v_{(x^{3}-x^{2}+1)tP}</span></p>

    <p class="text-gray-300">Now it was shown in <em>[14]</em> that <span class="math">\\mathbb{G}_{1}=E[r]\\cap\\text{Ker}(\\zeta_{3}\\circ\\pi_{p}^{5}-[p^{5}])</span> and <span class="math">\\mathbb{G}_{2}=E[r]\\cap\\text{Ker}(\\zeta_{3}\\circ\\pi_{p^{5}}-[1])</span> and that <span class="math">f_{T^{5},\\zeta_{3}\\circ\\pi_{p}^{5}(P)}\\circ\\zeta_{3}\\circ\\pi_{p}^{5}=f_{T^{5},P}</span>. We conclude that the optimal twisted Ate pairing for this family of curves is given by the formula:</p>

    <p class="text-gray-300"><span class="math">(f_{x^{3}-x^{2}+1,P}^{p^{5}}(Q)f_{-x^{4}+x^{3}-x+1,P}(Q))^{\\frac{p^{15}-1}{r}}.</span></p>

    <p class="text-gray-300">Note that the evaluation at <span class="math">Q</span> of the vertical line <span class="math">v_{(x^{3}-x^{2}+1)tP}</span> can actually be ignored because of the final exponentiation. So we need to compute <span class="math">f_{x,P}(Q)</span>, <span class="math">f_{x^{3},P}(Q)</span>, <span class="math">f_{x^{3},P}(Q)</span> and <span class="math">f_{x^{4},P}(Q)</span> as well the evaluation at <span class="math">Q</span> of the lines <span class="math">l_{x^{3}P,-x^{2}P}</span>, <span class="math">l_{-x^{4},x^{3}}</span>, <span class="math">l_{(-x^{4}+x^{3},-x)}</span>. So we get a complexity of <span class="math">\\mathcal{O}(\\text{log }r/2)</span> for the pairing computation. The twisted Ate pairing has loop length <span class="math">\\frac{\\text{log }r}{2}</span> for Barreto-Naehrig curves, as a search for the optimal pairing on these curves gives, for example,</p>

    <p class="text-gray-300"><span class="math">h_{12}(x,t)=(2x+6x^{2})*t+1+2x</span></p>

    <p class="text-gray-300">So the complexity of Miller’s algorithm is <span class="math">\\frac{\\text{log}_{2}r}{2}</span>. The Ate pairing for <span class="math">k=15</span> is given by <span class="math">f_{x,Q}(P)</span>, so the loop length is <span class="math">\\frac{\\text{log }r}{8}</span>, while the optimal Ate pairing computation for Barreto-Naehrig curves has complexity <span class="math">\\mathcal{O}(\\frac{\\text{log }r}{4})</span>, as shown in <em>[23]</em>. We have also verified with MAGMA that our formulas give bilinear non-degenerated pairings.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.3 Denominator elimination in pairing computation</h3>

    <p class="text-gray-300">We use an idea given in <em>[18]</em>. We observe that the expression of line <span class="math">h_{2}</span> in Equation ( 1) can be written as:</p>

    <p class="text-gray-300"><span class="math">x_{T}-x_{Q}=\\frac{x_{T}^{3}-x_{Q}^{3}}{x_{T}^{2}+x_{T}x_{Q}+x_{Q}^{2}}=\\frac{y_{T}^{2}-y_{Q}^{2}}{x_{T}^{2}+x_{T}x_{Q}+x_{Q}^{2}}.</span></p>

    <p class="text-gray-300">The element <span class="math">(y_{Q}^{2}-y_{T}^{2})</span> is in <span class="math">\\mathbb{F}_{p^{5}}</span> and can be forgotten during the computation of the pairing, because of the final exponentiation. Indeed, <span class="math">p^{5}-1</span> is a divisor of <span class="math">\\frac{p^{15}-1}{r}</span> so multiplication by this term can be omitted. Consequently at each iteration in Miller’s algorithm loop it suffices to multiply by <span class="math">x_{T}^{2}+x_{T}x_{Q}+x_{Q}^{2}</span>, instead of dividing by <span class="math">h_{2}</span>. This saves operations, as we no longer need to compute denominators at each step and also avoids the final inversion, which is important on restricted devices.</p>

    <p class="text-gray-300">3.4 Operation count</p>

    <p class="text-gray-300">Pairing computation on elliptic curves in Weierstrass form is usually performed in Jacobian coordinates (see <em>[7]</em>, <em>[3]</em>), but we find that homogenous coordinates will give better results in our case. Our starting point is a suggestion for pairing computation in homogenous coordinates given in <em>[10]</em>. A point <span class="math">(X,Y,Z)</span> in homogenous coordinates represents the affine point <span class="math">(X/Z,Y/Z)</span> on the elliptic curve of affine equation <span class="math">y^{=}x^{3}+c</span>. Due to denominator elimination, the doubling step of the Miller loop becomes:</p>

    <p class="text-gray-300"><span class="math">(2i)P</span> <span class="math">\\leftarrow 2\\cdot(iP)</span> <span class="math">f_{2i,P}</span> <span class="math">\\leftarrow f_{i,P}^{2}h_{1}(Q)S_{T}(Q)</span></p>

    <p class="text-gray-300">where <span class="math">h_{1}(Q)=2YZy_{Q}-3X^{2}x_{Q}+Y^{2}-3cZ^{2}</span> and <span class="math">S_{T}(Q)=Z^{2}x_{Q}^{2}+XZx_{Q}+X^{2}</span>. We compute <span class="math">(2i)P=(X_{3},Y_{3},Z_{3})</span> as</p>

    <p class="text-gray-300"><span class="math">X_{3}</span> <span class="math">=2XY(Y^{2}-9Z^{2}),</span> <span class="math">Y_{3}</span> <span class="math">=(Y-Z)(Y+3Z)^{3}-8Y^{3}Z,</span> <span class="math">Z_{3}</span> <span class="math">=2Y^{3}Z.</span></p>

    <p class="text-gray-300">We perform the operations in the following order:</p>

    <p class="text-gray-300"><span class="math">A</span> <span class="math">=Y^{2}</span> <span class="math">E</span> <span class="math">=X^{2}</span> <span class="math">B</span> <span class="math">=Z^{2}</span> <span class="math">F</span> <span class="math">=(X+Y)^{2}-E-A</span> <span class="math">C</span> <span class="math">=(Y+Z)^{2}-A-B</span> <span class="math">X_{3}</span> <span class="math">=F\\cdot(A-9B)</span> <span class="math">Z_{3}</span> <span class="math">=4A\\cdot C</span> <span class="math">Y_{3}</span> <span class="math">=(A-3B+C)\\cdot(A+9B+3C)-Z_{3}.</span></p>

    <p class="text-gray-300">We compute <span class="math">h_{1}(Q)\\cdot S_{T}(Q)</span> as:</p>

    <p class="text-gray-300"><span class="math">h_{1}(Q)S_{T}(Q)</span> <span class="math">=(2YZy_{Q}-3X^{2}x_{Q}+Y^{2}-3cZ^{2})(Z^{2}x_{Q}^{2}+XZx_{Q}+X^{2})=</span> <span class="math">2X^{2}YZy_{Q}+2XYZ^{2}x_{Q}y_{Q}+2YZ^{3}x_{Q}^{2}y_{Q}-3X^{4}x_{Q}-3X^{3}Zx_{Q}^{2}-3X^{2}Z^{2}x_{Q}^{3}+</span> <span class="math">+(Y^{2}-3cZ^{2})X^{2}+(Y^{2}-3cZ^{2})XZx_{Q}+(Y^{2}-3cZ^{2})Z^{2}x_{Q}^{2}</span></p>

    <p class="text-gray-300">It follows that we need to perform the following operations:</p>

    <p class="text-gray-300"><span class="math">G</span> <span class="math">=B\\cdot C</span> <span class="math">L</span> <span class="math">=K^{2}</span> <span class="math">M</span> <span class="math">=F^{2}</span> <span class="math">H</span> <span class="math">=B\\cdot F</span> <span class="math">N</span> <span class="math">=(A-3cB)\\cdot K</span> <span class="math">I</span> <span class="math">=E^{2}</span> <span class="math">O</span> <span class="math">=E\\cdot K</span> <span class="math">K</span> <span class="math">\\frac{(X+Z)^{2}-E-B}{2}</span> <span class="math">P</span> <span class="math">=(A-3cB)\\cdot B</span></p>

    <p class="text-gray-300">This gives the following computation for <span class="math">h_{1}(Q)S_{T}(Q)</span>:</p>

    <p class="text-gray-300"><span class="math">h_{1}(Q)S_{T}(Q)=Fy_{Q}+Hx_{Q}y_{Q}+Gx_{Q}^{2}y_{Q}-(3I-N)x_{Q}-(3O-P)x_{Q}^{2}-3Lx_{Q}^{3}+M-3cL</span></p>

    <p class="text-gray-300">We denote by <span class="math">S_{p^{n}}</span> and <span class="math">M_{p^{n}}</span> the cost of a squaring and a multiplication, respectively, in the extension field of degree <span class="math">n</span> of <span class="math">\\mathbb{F}_{p}</span>. We assume that the expressions of <span class="math">x_{Q}</span>, <span class="math">x_{Q}^{2}</span>, <span class="math">y_{Q}</span>, <span class="math">x_{Q}y_{Q}</span>, <span class="math">x_{Q}^{2}y_{Q}</span> are precomputed. As explained in section 3.1, <span class="math">x_{Q}</span> and <span class="math">y_{Q}</span> can be chosen such as the multiplication of any of these expressions</p>

    <p class="text-gray-300">with an element of  <span class="math">\\mathbb{F}_p</span>  costs  <span class="math">5M_p</span> . A count of the operations for the entire doubling step for the twisted Ate pairing gives  <span class="math">9S_{p} + 38M_{p} + S_{p^{15}} + M_{p^{15}}</span> . In the case of the Ate pairing doubling computation,  <span class="math">A,B,C,\\ldots L</span>  are elements of  <span class="math">\\mathbb{F}_{p^5}</span> , so the operation count gives  <span class="math">30M_p + 9S_{p^5} + 8M_{p^5} + S_{p^{15}} + M_{p^{15}}</span> . For pairing computation on Barretto-Naehrig curves we only need to do the doubling of the point and compute  <span class="math">h_1(Q)</span> . The operation count gives  <span class="math">5S_{p} + 15M_{p} + S_{p^{12}} + M_{p^{12}}</span>  for the doubling part of the twisted Ate pairing and  <span class="math">4M_p + 5S_{p^2} + 3M_{p^2} + S_{p^{12}} + M_{p^{12}}</span>  for the Ate pairing.</p>

    <p class="text-gray-300">We compare the complexity of pairing computation for the families of curves presented above, using Karatsuba and Toom Cook multiplication algorithms in the extension fields. The costs of multiplications are given in Table 2. We denote by  <span class="math">A_{p}</span>  the cost of an addition in  <span class="math">\\mathbb{F}_p</span> . Table 3 gives recommended sizes of  <span class="math">r</span>  and  <span class="math">p</span>  for different security levels. Using a classical arithmetic, we count the number of multiplications in  <span class="math">\\mathbb{F}_p</span>  needed for a Miller loop; we do not take into account the cost of the polynomial reduction one has to perform when multiplying two elements of the extension field. Indeed,  <span class="math">\\mathbb{F}_{p^{12}}</span>  is usually constructed as an extension of  <span class="math">\\mathbb{F}_{p^2}</span> , which in turn is constructed as  <span class="math">\\mathbb{F}_p / (X^2 + 1)</span> . The polynomials used to construct the extension fields of degree 2 and 3 over this field then have constant term  <span class="math">\\delta</span>  in  <span class="math">\\mathbb{F}_{p^2}</span> ; depending on the choice of delta (not a square, nor a cube) the multiplication cost may vary. However in this paper we consider this influence negligible. The resulting comparison for the Ate and twisted Ate pairings is given in Table 4.</p>

    <p class="text-gray-300">Table 2. A performance evaluation: arithmetic of  <span class="math">{\\mathbb{F}}_{{p}^{15}}</span>  versus arithmetic of  <span class="math">{\\mathbb{F}}_{{p}^{12}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Mp2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Mp3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Mp5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Mp6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Mp12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Mp15</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3Mp + 4Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">5Mp + 20Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">13Mp + 58Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">15Mp + 72Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">45Mp + 180Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">65Mp + 390Ap</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3. A security evaluation: curves with embedding degree 15 versus Barreto-Naehrig curves</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">AES security</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">recommended group sizes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">group sizes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">group sizes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">bit length of r</td>

            <td class="px-3 py-2 border-b border-gray-700">bit length of p^k</td>

            <td class="px-3 py-2 border-b border-gray-700">k = 15</td>

            <td class="px-3 py-2 border-b border-gray-700">r</td>

            <td class="px-3 py-2 border-b border-gray-700">p</td>

            <td class="px-3 py-2 border-b border-gray-700">r</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">240</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">3072</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">384</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">384</td>

            <td class="px-3 py-2 border-b border-gray-700">7680</td>

            <td class="px-3 py-2 border-b border-gray-700">384</td>

            <td class="px-3 py-2 border-b border-gray-700">576</td>

            <td class="px-3 py-2 border-b border-gray-700">640</td>

            <td class="px-3 py-2 border-b border-gray-700">640</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">15360</td>

            <td class="px-3 py-2 border-b border-gray-700">682</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">1280</td>

            <td class="px-3 py-2 border-b border-gray-700">1280</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4. Pairing evaluation: curves with embedding degree 15 versus Barreto-Naehrig curves</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Security level in bits</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ate pairing</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Twisted Ate pairing</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">k=15</td>

            <td class="px-3 py-2 border-b border-gray-700">k=12</td>

            <td class="px-3 py-2 border-b border-gray-700">k=15</td>

            <td class="px-3 py-2 border-b border-gray-700">k=12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">6710Mp</td>

            <td class="px-3 py-2 border-b border-gray-700">4647Mp</td>

            <td class="px-3 py-2 border-b border-gray-700">12680Mp</td>

            <td class="px-3 py-2 border-b border-gray-700">7800Mp</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">10736Mp</td>

            <td class="px-3 py-2 border-b border-gray-700">7119Mp</td>

            <td class="px-3 py-2 border-b border-gray-700">20288Mp</td>

            <td class="px-3 py-2 border-b border-gray-700">12480Mp</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">16104Mp</td>

            <td class="px-3 py-2 border-b border-gray-700">17007Mp</td>

            <td class="px-3 py-2 border-b border-gray-700">30432Mp</td>

            <td class="px-3 py-2 border-b border-gray-700">31200Mp</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">28601Mp</td>

            <td class="px-3 py-2 border-b border-gray-700">33486Mp</td>

            <td class="px-3 py-2 border-b border-gray-700">54048Mp</td>

            <td class="px-3 py-2 border-b border-gray-700">62400Mp</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It becomes clear that at 80 and 128 bits security levels Barreto-Naehrig curves give most efficient pairing computation. On the other hand, for 192 and 256 security levels, the family of curves with embedding degree 15 and <span class="math">\\rho</span> 1.5 gives pairing computations faster than on Barreto-Naehrig curves. Moreover, note that Karatsuba is optimal for extensions of degree 2, so it seems quite natural to question these results. We propose in the next Section an improvement of the arithmetic on <span class="math">\\mathbb{F}_{p^{5}}</span> using the Newton interpolation method to compute a multiplication between two elements of <span class="math">\\mathbb{F}_{p^{5}}</span>.</p>

    <h2 id="sec-16" class="text-2xl font-bold">4 Finite field arithmetic</h2>

    <p class="text-gray-300">In cryptography, and more generally in arithmetic, we need an efficient polynomial multiplication. The optimization can be in time or elementary operations. Pairing Based Cryptography (PBC) follows the same rules as PBC involves polynomial computations. Indeed <span class="math">A</span> and <span class="math">B\\in\\mathbb{F}_{p^{k}}</span> are represented as polynomials of degree <span class="math">(k-1)</span> in <span class="math">\\gamma</span>, with <span class="math">\\gamma</span> a root in <span class="math">\\mathbb{F}_{p^{k}}</span> of a polynomial of degree <span class="math">k</span>, irreducible over <span class="math">\\mathbb{F}_{p}</span>. If possible, the irreducible polynomial is chosen to be <span class="math">X^{k}-\\beta</span>, with <span class="math">\\beta\\in\\mathbb{F}_{p}</span>. In the case of <span class="math">k=5</span>, this condition is true for every prime <span class="math">p</span> such that <span class="math">p\\equiv 1\\text{mod}(5)</span> <em>[17, Theorem 3.75]</em>.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Theorem 4.1</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}_{p}</span> be a finite field and <span class="math">\\beta</span> be an element of <span class="math">\\mathbb{F}_{p}</span> such that <span class="math">\\beta</span> is not a <span class="math">k</span>-th power of an element of <span class="math">\\mathbb{F}_{p}</span>. Then the polynomial <span class="math">X^{k}-\\beta</span> is irreducible over <span class="math">\\mathbb{F}_{p}</span>.</p>

    <p class="text-gray-300">In extensions of degree 2 or 3 the Karatsuba and Toom Cook multiplications are the most efficient. For higher degree extension, one can use tower field extensions <em>[16]</em> and apply Karatsuba and Toom Cook <em>[25]</em>, or multiplication by interpolation <em>[25]</em>. Generally, interpolation methods have an important drawback: they increase the number of additions during a multiplication. We present a multiplication by Newton interpolation which, despite the extra additions, improves the global complexity of a multiplication in <span class="math">\\mathbb{F}_{p^{5}}</span> when compared to the Karatsuba multiplication.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">4.1 Interpolation</h3>

    <p class="text-gray-300">We denote by <span class="math">A(X)=a_{0}+a_{1}X+\\ldots+a_{k-1}X^{k-1}</span>, <span class="math">B(X)=b_{0}+b_{1}X+\\ldots+b_{k-1}X^{k-1}</span> the polynomials obtained by substituting <span class="math">\\gamma</span> by <span class="math">X</span> in the expressions of <span class="math">A</span> and <span class="math">B</span> in <span class="math">\\mathbb{F}_{p^{k}}</span>. Multiplications by interpolation follow these steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Find <span class="math">2k-1</span> different values in <span class="math">\\mathbb{F}_{p}</span> <span class="math">\\{\\alpha_{0},\\alpha_{1},\\ldots,\\alpha_{2k-2}\\}</span>.</li>

      <li>Evaluate the polynomials <span class="math">A(X)</span> and <span class="math">B(X)</span> at these <span class="math">2k-1</span> values: <span class="math">A(\\alpha_{0}),\\ldots,A(\\alpha_{2k-2}),B(\\alpha_{0}),\\ldots,B(\\alpha_{0})</span>.</li>

      <li>Compute <span class="math">C(X)=A(X)\\times B(X)</span> at these <span class="math">2k-1</span> values <span class="math">C(\\alpha_{i})=A(\\alpha_{i})B(\\alpha_{i})</span>.</li>

      <li>Interpolate <span class="math">C(X)</span> polynomial of degree <span class="math">2k-2</span> either with Lagrange or Newton interpolation.</li>

    </ul>

    <p class="text-gray-300">We describe our method of multiplication using the Newton interpolation, which is more efficient for our purpose than Lagrange interpolation <em>[25]</em>. The use of FFT <em>[25]</em> is not interesting in our case. Indeed, during a FFT multiplication, we have to multiply by roots of unity. As we do not have any control on the characteristic <span class="math">p</span> we work with, the roots of unity do not necessarily have a sparse representation, even after recoding. It follows that multiplications by these roots are expensive. Furthermore, the choice of values of interpolation in Section 4.3 is not interesting for the FFT method. Last but not least, FFT is very interesting for extensions of large even degree, which is not the case for the finite field <span class="math">\\mathbb{F}_{p^{5}}</span>. Consequently, we focused on the Newton interpolation.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">4.2 Newton interpolation</h3>

    <p class="text-gray-300">Newton interpolation constructs the polynomial <span class="math">C(X)</span> in the following way:</p>

    <p class="text-gray-300">\\[ \\begin{cases}c^{\\prime}_{0}=&C(\\alpha_{0})\\\\ c^{\\prime}_{1}=&(C(\\alpha_{1})-c^{\\prime}_{0})\\frac{1}{(\\alpha_{1}-\\alpha_{0})}\\\\ c^{\\prime}_{2}=\\Big{(}(C(\\alpha_{2})-c^{\\prime}_{0})\\frac{1}{(\\alpha_{2}-\\alpha_{0})}-c^{\\prime}_{1}\\Big{)}\\frac{1}{(\\alpha_{2}-\\alpha_{1})}\\\\ \\vdots=&\\vdots\\end{cases} \\]</p>

    <p class="text-gray-300">The reconstruction of <span class="math">C(X)</span> is done by</p>

    <p class="text-gray-300"><span class="math">C(X)=c^{\\prime}_{0}+c^{\\prime}_{1}(X-\\alpha_{0})+c^{\\prime}_{2}(X-\\alpha_{0})(X-\\alpha_{1})+\\ldots+c^{\\prime}_{2k-2}(X-\\alpha_{0})(X-\\alpha_{1})\\ldots(X-\\alpha_{2k-2}).</span></p>

    <p class="text-gray-300">It can be computed using the Horner scheme:</p>

    <p class="text-gray-300"><span class="math">C(X)=c^{\\prime}_{0}+(X-\\alpha_{0})\\left[c^{\\prime}_{1}+(X-\\alpha_{1})\\left(c^{\\prime}_{2}+(X-\\alpha_{2})\\left\\langle\\ldots\\right\\rangle\\right)\\right]</span></p>

    <p class="text-gray-300">So, complexity in term of operation of Newton interpolation is the sum of the complexities of these different operations:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the evaluations in <span class="math">\\alpha_{i}</span> of <span class="math">A(X)</span> et <span class="math">B(X)</span></li>

      <li>the <span class="math">2k-1</span> multiplications in <span class="math">\\mathbb{F}_{p}</span> ( <span class="math">A(\\alpha_{i})\\times B(\\alpha_{i})</span> )</li>

      <li>computation of the <span class="math">c^{\\prime}{}_{i}</span></li>

      <li>the Horner scheme to find the expression of <span class="math">C(X)=A(X)\\times B(X)</span> of degree <span class="math">2k-1</span>.</li>

    </ol>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">4.3 Simplifying operations of the Newton interpolation for <span class="math">k=5</span></h3>

    <p class="text-gray-300">We consider that <span class="math">k=5</span>, the <span class="math">2k-1=9</span> chosen values for the interpolation are:</p>

    <p class="text-gray-300"><span class="math">\\alpha_{0}=0,\\alpha_{1}=1,\\alpha_{2}=-1,\\alpha_{3}=2,\\alpha_{4}=-2,\\alpha_{5}=4,\\alpha_{6}=-4,\\alpha_{7}=3,\\alpha_{8}=\\infty.</span></p>

    <p class="text-gray-300">We choose those value in order to minimize the number of additions and divisions by the differences of the <span class="math">\\alpha_{i}</span> during the interpolation.</p>

    <p class="text-gray-300">In the following section, we denote <span class="math">A_{p}</span> an addition, <span class="math">M_{p}</span> a multiplication, and <span class="math">S_{p}</span> a square in <span class="math">\\mathbb{F}_{p}</span>.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">Complexity of the evaluations in <span class="math">\\alpha_{i}</span> of <span class="math">A</span> and <span class="math">B</span></h4>

    <p class="text-gray-300">First of all, we have to evaluate <span class="math">A(X)</span> and <span class="math">B(X)</span> at the <span class="math">\\alpha_{i}</span>’s. With the chosen values, evaluations of <span class="math">A(X)</span> and <span class="math">B(X)</span> are done using only additions and shifts in <span class="math">\\mathbb{F}_{p}</span>. Indeed, a product by a power of 2 is composed of shifts in binary base, so in order to evaluate <span class="math">A(X)</span> at <span class="math">2^{j}</span>, we compute the products <span class="math">a_{i}\\times(2^{j})^{i}</span>, and perform the additions <span class="math">\\sum_{i=0}^{k-1}a_{i}(2^{j})^{i}</span> using a FFT scheme.</p>

    <p class="text-gray-300">Writing down <span class="math">3=2+1</span>, the evaluation in 3 is only composed of shifts and additions too. Indeed, powers of 3 can be decomposed as sum of powers of 2: <span class="math">3^{2}=2^{3}+1</span>, <span class="math">3^{3}=2^{5}-2^{2}-1</span> et <span class="math">3^{4}=2^{6}+2^{4}+1</span>.</p>

    <p class="text-gray-300">Adding the different costs, evaluations of <span class="math">A(X)</span> and <span class="math">B(X)</span> have a complexity of <span class="math">50A_{p}</span>.</p>

    <p class="text-gray-300">Once we have the evaluations, we have to compute the multiplications <span class="math">A(\\alpha_{i})\\times B(\\alpha_{i})</span> which are obtained with <span class="math">9M_{p}</span>. The complexity of the steps 1 and 2 altogether is then <span class="math">50A_{p}+9M_{p}</span>.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">Complexity of the computations of <span class="math">c^{\\prime}_{j}</span></h4>

    <p class="text-gray-300">In order to compute the coefficients <span class="math">c^{\\prime}_{j}</span> during a Newton interpolation, one has to compute exact divisions by the differences of the <span class="math">\\alpha_{i}\\in\\mathbb{F}_{p}</span>. We call an exact division a division where the dividend is a multiple of the divisor. Among all the differences of the <span class="math">\\alpha_{i}</span> we choose, eleven are not a power of 2. They are given in Table 5. In a binary basis, exact divisions by power of 2 are very simple, they are only shift on the right of the bits. We have to analyze the complexity of divisions by 3, 5 and 7. A precise analysis of these divisions shows they can be computed in only one subtraction.</p>

    <p class="text-gray-300">Table 5. The problematic differences</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">α3-α2=3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">α4-α1=-3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">α5-α1=3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">α5-α2=5</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">α5-α4=6</td>

            <td class="px-3 py-2 border-b border-gray-700">α6-α1=-5</td>

            <td class="px-3 py-2 border-b border-gray-700">α6-α2=-3</td>

            <td class="px-3 py-2 border-b border-gray-700">α6-α3=-6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">α7-α0=3</td>

            <td class="px-3 py-2 border-b border-gray-700">α7-α4=5</td>

            <td class="px-3 py-2 border-b border-gray-700">α7-α6=7</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We describe here the method to execute the exact division. We want to divide  <span class="math">\\delta</span> , a multiple of 3, by 3, i.e.  <span class="math">\\delta</span>  verifies that  <span class="math">\\delta = 3 \\times \\sigma</span>  and we want to find  <span class="math">\\sigma</span> . This equality can be rewritten as  <span class="math">\\sigma = \\delta - 2 \\times \\sigma</span> . If  <span class="math">\\delta = \\sum_{i} \\delta_{i} 2^{i}</span>  and  <span class="math">\\sigma = \\sum_{i} \\sigma_{i} 2^{i}</span>  we can find  <span class="math">\\sigma</span>  bit after bit beginning with the less significant bit. Indeed,  <span class="math">\\sigma = \\delta - 2 \\times \\sigma</span>  gives  <span class="math">\\sigma_{0} = \\delta_{0}</span> . Thus we can find  <span class="math">\\sigma_{1}</span>  as the result of the subtraction:  <span class="math">\\delta_{1} \\delta_{0} - \\sigma_{0} 0 = \\sigma_{1} \\sigma_{0}</span> . By extrapolation we find  <span class="math">\\sigma_{1}</span> , and then  <span class="math">\\sigma_{2}</span>  and the following as explained in Figure 1.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. Scheme for the division by 3 in one addition</p>

    <p class="text-gray-300">Consequently, an exact division by 3 is theoretically done with exactly one subtraction in  <span class="math">\\mathbb{F}_p</span> . The same scheme can be applied to an exact division by 5. Indeed, for  <span class="math">\\chi = 5 \\times \\kappa</span>  (i.e. knowing  <span class="math">\\chi</span>  we want to find  <span class="math">\\kappa</span> ), we just have to consider that  <span class="math">\\kappa = \\chi - 4 \\times \\kappa</span> . Then the exact division by 5 has the complexity of a subtraction.</p>

    <p class="text-gray-300">The cost of an exact division by 7 is the same as the one of an addition in  <span class="math">\\mathbb{F}_p</span> , provided that we find first the negative of the result. We know  <span class="math">\\mu = 7 \\times \\nu</span> , and we want to find  <span class="math">\\nu</span> . We transform the equation:  <span class="math">-\\nu = \\mu - 8 \\times \\nu</span> . So first we find  <span class="math">-\\nu</span>  with an addition in  <span class="math">\\mathbb{F}_p</span> , and then it is quite easy to find  <span class="math">\\nu</span> .</p>

    <p class="text-gray-300">We consider that the complexity of a subtraction is equivalent to the complexity of an addition, which is an upper bound for a subtraction. The implementation aspect is considered in Section 4.4. As a consequence, the exact divisions by 3, 5 and 7 can be computed with only an addition. The eleven divisions by these values have a complexity of  <span class="math">11A_{p}</span> .</p>

    <p class="text-gray-300">In order to have the complexity of the computation of the  <span class="math">c_j&#x27;</span> , we must take into consideration the subtractions. There are 28 subtractions in the formulas of the  <span class="math">c_j&#x27;</span> .</p>

    <p class="text-gray-300">Thus, the complexity of the computation of the  <span class="math">c_j&#x27;</span>  is  <span class="math">39A_p</span> .</p>

    <p class="text-gray-300">Complexity of the polynomial interpolation We use the Horner scheme to find the expression of the product polynomial  <span class="math">C = A \\times B</span> . The Horner scheme consists in writing and computing:</p>

    <div class="my-4 text-center"><span class="math-block">C (X) = (((c _ {8} ^ {\\prime} (X - \\alpha_ {7}) + c _ {7} ^ {\\prime}) (X - \\alpha_ {6}) + c _ {6} ^ {\\prime}) (X - \\alpha_ {5}) + c ^ {\\prime} 5) \\dots + c _ {1} ^ {\\prime}) (X - \\alpha_ {1}) + c ^ {\\prime} 0.</span></div>

    <p class="text-gray-300">We begin to compute from the inside (the parenthesis  <span class="math">(c_8&#x27;(X - \\alpha_7) + c_7&#x27;))</span>  to the outside, i.e. we compute  <span class="math">((c_8&#x27;(X - \\alpha_7) + c_7&#x27;)(X - \\alpha_6) + c_6&#x27;)</span> , and we continue until we arrive at the coefficient  <span class="math">c_0&#x27;</span> . Thus</p>

    <p class="text-gray-300">the construction of the polynomial using the Horner scheme is composed of multiplications of the  <span class="math">i</span> -th parenthesis by  <span class="math">\\alpha_{7-i}</span>  and additions. With the chosen values of  <span class="math">\\alpha_i&#x27;</span> s the Horner scheme is composed only of additions.</p>

    <p class="text-gray-300">So the complexity of the polynomial expression with the Horner scheme is  <span class="math">29A_{p}</span> .</p>

    <p class="text-gray-300">We have described the multiplication by interpolation for an extension of degree 5 of a finite field. Table 6 gives the complexity of multiplications with several methods: the classical Karatsuba and Toom Cook multiplications (KTC), the interpolation multiplication. The third line of Table 6 (Mix) gives the cost of a multiplication in  <span class="math">\\mathbb{F}_{p^{15}}</span>  using a tower of extension fields. We use our Newton multiplication in  <span class="math">\\mathbb{F}_{p^5}</span>  and the Toom Cook method for the extension field of degree 3 over  <span class="math">\\mathbb{F}_{p^5}</span> .</p>

    <p class="text-gray-300">Table 6. Complexity of different method of multiplication</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Extension Method</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Mp2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Mp5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Mp12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Mp15</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KTC</td>

            <td class="px-3 py-2 border-b border-gray-700">3Mp+4Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">13Mp+60Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">45Mp+180Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">65Mp+390Ap</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Interpolation</td>

            <td class="px-3 py-2 border-b border-gray-700">--</td>

            <td class="px-3 py-2 border-b border-gray-700">9Mp+107Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">23Mp+2070Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">29Mp+2136Ap</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Mix</td>

            <td class="px-3 py-2 border-b border-gray-700">--</td>

            <td class="px-3 py-2 border-b border-gray-700">--</td>

            <td class="px-3 py-2 border-b border-gray-700">45Mp+180Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">45Mp+635Ap</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Using these results, it becomes clear that it is better to use a multiplication by interpolation instead of a multiplication using Karatsuba Toom Cook for extension fields of degree 5. We save 4 multiplications in  <span class="math">\\mathbb{F}_p</span>  using interpolation whereas we add 47 additions. The extra cost due to these additions is not as important as the cost to compute 4 multiplications in  <span class="math">\\mathbb{F}_p</span> . Indeed, the complexity of a Karatsuba multiplication in  <span class="math">\\mathbb{F}_p</span>  is</p>

    <div class="my-4 text-center"><span class="math-block">5 N ^ {l o g _ {2} (3)} A _ {w} + N ^ {l o g _ {2} (3)} M _ {w},</span></div>

    <p class="text-gray-300">where  <span class="math">N</span>  is the number of bytes of the considered integers, and where  <span class="math">A_w</span>  and  <span class="math">M_w</span>  represent an addition and a multiplication of a word.</p>

    <p class="text-gray-300">We designed the exact division by 3 on a Stratix 2 FPGA (speed grade 3). The result of this implementation is that the division we present can be done in the same time as an addition. We compute the exact division of an integer of size 240 bits in 13.9 ns, which is an acceptable latency to be executed in one clock cycle. In comparison, on the same FPGA the ripple-carry adder, which takes benefit of carry propagation mechanism, achieves a 14.2 ns latency on an integer addition of the same length. Thus our hypothesis in Section 4.3 is verified and the complexity we give is true.</p>

    <p class="text-gray-300">On the contrary, for extensions of degree 12 and 15, using an interpolation to compute a multiplication is not so interesting. The additional cost of the additions is huge in comparison to the saved multiplications. The interpolation method is very interesting for an extension of degree 5, because we can choose the value of interpolation such that the number of additions does not increase too much in relation with the saved multiplications. Table 7 gives the comparison of a pairing computation considering the number of multiplications and additions at different security levels.</p>

    <p class="text-gray-300">Table 7 gives our final comparison. We used our improved arithmetic for an extension of degree 5 to compute a multiplication in  <span class="math">\\mathbb{F}_{p^5}</span> . We compare our result to the complexity of the pairing computation on Barreto-Naehrig curves.</p>

    <p class="text-gray-300">Note that we have only counted the number of operations in  <span class="math">\\mathbb{F}_p</span> , but the base field has different bitsizes for each family of curves. This means that Barreto Naehrig curves still give the most efficient pairing computation for 80 and 128-bits security levels. On the other hand, for 192 and 256-bits security</p>

    <p class="text-gray-300">Table 7. A performance evaluation of the Ate pairing computation: curves with embedding degree 15 versus Barreto-Naehrig curves</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ate pairing</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Twisted Ate pairing</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AES security</td>

            <td class="px-3 py-2 border-b border-gray-700">k=15</td>

            <td class="px-3 py-2 border-b border-gray-700">k=12</td>

            <td class="px-3 py-2 border-b border-gray-700">k=15</td>

            <td class="px-3 py-2 border-b border-gray-700">k=12</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">80</td>

            <td class="px-3 py-2 border-b border-gray-700">4830Mp+53760Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">4300Mp+13600Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">9880Mp+88900Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">7800Mp+25200Ap</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">7728Mp+86064Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">6900Mp+21760Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">15808Mp+142240Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">12480Mp+40320Ap</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">192</td>

            <td class="px-3 py-2 border-b border-gray-700">11592Mp+129096Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">17007Mp+54400Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">23712Mp+213360Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">31200Mp+100800Ap</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">20587Mp+172128Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">33486Mp+108800Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">42113Mp+284480Ap</td>

            <td class="px-3 py-2 border-b border-gray-700">62400Mp+201600Ap</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">levels, pairing computation is more efficient on curves with embedding degree 15 and  <span class="math">\\rho \\sim 1.5</span>  than on Barreto-Naehrig curves (note that at these security levels the bitlength of  <span class="math">p</span>  is shorter for  <span class="math">k = 15</span> ).</p>

    <p class="text-gray-300">We evaluated the cost of final exponentiation using the techniques proposed in [22] and our computations showed that this operation has approximatively the same cost for curves with  <span class="math">k = 15</span>  and  <span class="math">\\rho \\sim 1.5</span>  and for Barretto-Naehrig curves at 256-bits security level (about 960  <span class="math">S_{p^{15}}</span>  for  <span class="math">k = 15</span>  and 940  <span class="math">S_{p^{12}}</span>  for  <span class="math">k = 12</span> ). However, for lower security levels the final exponentiation will be more expensive for the case  <span class="math">k = 15</span>  because it depends on the value of  <span class="math">\\rho \\sim 1.5</span> . Further work needs to be done to find families of curves of embedding degree 15 with better  <span class="math">\\rho</span>  value if we want to make this case interesting for lower security levels.</p>

    <p class="text-gray-300">In this paper, we give efficient pairing computation for curves of embedding degree 15. We show that existing constructions of families of curves of degree 15 and  <span class="math">j</span> -invariant 0 present multiple advantages. First of all, we show that pairing computation on these curves has loop length  <span class="math">\\frac{\\log r}{8}</span>  for the Ate pairing and  <span class="math">\\frac{\\log r}{2}</span>  for the twisted Ate pairing. Secondly, we show that by using twists of degree 3 we manage to perform most of the operations in  <span class="math">\\mathbb{F}_p</span>  or  <span class="math">\\mathbb{F}_{p^5}</span> . Moreover, denominator computation and the final inversion can be avoided by making use of twists. By using of an interpolation technique, we also improve the arithmetic of  <span class="math">\\mathbb{F}_{p^5}</span>  in order to get better results.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Recommendations for Key Management, 2007. Special Publication 800-57 Part 1.</li>

      <li>S. Vanstone A. Menezes, T. Okamoto. Reducing elliptic curve logarithms in a finite field. IEEE Transactions on Information Theory, 39(5):1639-1646, 1993.</li>

      <li>C. Arne, T. Lange, M. Naehrig, and C. Ritzenhaler. Faster Pairing Computation, 2009. http://eprint.iacr.org/2009/155.</li>

      <li>P. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order. In Selected Areas in Cryptography - SAC 2005, volume 3897 of Lecture Notes in Computer Science, pages 319-331. Springer, 2006.</li>

      <li>D. Boneh and M. K. Franklin. Identity-based encryption from the Weil pairing. In Joe Kilian, editor, Advances in Cryptology - CRYPTO 2001, volume 2139 of Lecture Notes in Computer Science, pages 213-229. Springer Verlag, 2001.</li>

      <li>D. Boneh, B. Lynn, and H. Shacham. Short signatures from the Weil pairing. In Colin Boyd, editor, Advances in Cryptology - ASIACRyPT 2001, volume 2248 of Lecture Notes in Computer Science, pages 514-532. Springer Verlag, 2001.</li>

      <li>Sanjit Chatterjee, Palash Sarkar, and Rana Barua. Efficient computation of tate pairing in projective coordinate over general characteristic fields, 2004.</li>

      <li>C. Cocks and R.G.E. Pinch. Indentity-based cryptosystems based on the Weil pairing. unpublished manuscript, 2001.</li>

      <li>H. Cohen and G. Frey (editors). Handbook of elliptic and hyperelliptic curve cryptography. Discrete Math. Appl., Chapman Hall/CRC, 2006.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[10] C. Costello, H. Hisil, J.M.G. Nieto, and K.K.H. Wong. Faster Pairings on Special Weierstrass Curves. Pairing 2009, 2009. to appear.</li>

      <li>[11] P. Duan, S. Cui, and C.W. Chan. Special polynomial families for generating more suitable elliptic curves for pairing-based cryptosystems. In The 5th WSEAS International Conference on Electronics, Hardware, Wireless Optimal Communications, 2005.</li>

      <li>[12] R. Granger, A.J. Holt, D. Page, N.P. Smart, and F. Vercauteren. Function field sieve in characteristic three. In Applied Cryptography and Network Security) 2004, volume 3076 of Lectures Notes in Computer Science, pages 223–234. Springer, 2004.</li>

      <li>[13] F. Hess. Pairing Lattices. In Steven Galbraith and Kenny Peterson, editors, Pairing 2008, volume 5209 of Lectures Notes in Computer Science, pages 18–38, 2008.</li>

      <li>[14] F. Hess, N. P. Smart, and F. Vercauteren. The Eta Pairing Revisited. IEEE Transactions on Information Theory, 52:4595–4602, 2006.</li>

      <li>[15] A. Joux. A one round protocol for tripartite Diffie-Hellman. Journal of Cryptology, 17(4):263–276, September 2004.</li>

      <li>[16] Neal Koblitz and Alfred Menezes. Pairing-based cryptography at high security levels. In Nigel P. Smart, editor, IMA Int. Conf., volume 3796 of Lectures Notes in Computer Science, pages 13–36, 2005.</li>

      <li>[17] R. Lidl and H. Niederreiter. Finite Fields. 2nd ed., Cambridge University Press, 1997.</li>

      <li>[18] X. Lin, C. Zhao, F. Zhang, and Y. Wang. Computing the Ate Pairing on Elliptic Curves with Embedding Degree k = 9. IEICE Transactions, 91-A(9):2387–2393, 2008.</li>

      <li>[19] Seiichi Matsuda, Naoki Kanayama, Florian Hess, and Eiji Okamoto. Optimised versions of the ate and twisted ate pairings. In the Eleventh IMA International Conference on Cryptography and Coding, pages 302–312. Springer-Verlag, 2007.</li>

      <li>[20] Victor S. Miller. The Weil pairing, and its efficient calculation. Journal of Cryptology, 17(4):235–261, September 2004.</li>

      <li>[21] S. Paulus. Lattice basis reduction in function fields. In Joe Buhler, editor, ANTS III, volume 1423 of Lectures Notes in Computer Science, pages 567–575, 1998.</li>

      <li>[22] M. Scott, N. Benger, M. Charlemagne, L.J.D. Perez, and E.J. Kachisa. On the final exponentiation for calculating pairings on ordinary elliptic curves. to appear in Pairing 2009, 2009.</li>

      <li>[23] Frederik Vercauteren. Optimal Pairings, 2008. http://eprint.iacr.org/2008/096.</li>

      <li>[24] André Weil. Courbes algébriques et variétés abéliennes (in french. Hermann, 1948.</li>

      <li>[25] J. Von ZurGathen and J. Gerhard. Modern Computer Algebra. Cambridge University Press, New York, NY, USA, 2003.</li>

    </ul>`;
---

<BaseLayout title="A study of pairing computation for elliptic curves with embe... (2009/370)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2009 &middot; eprint 2009/370
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
