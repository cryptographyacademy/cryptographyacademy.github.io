---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/233';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Password-Based Authenticated Key Exchange in the Three-Party Setting';
const AUTHORS_HTML = 'Michel Abdalla, Pierre-Alain Fouque, David Pointcheval';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Password-based authenticated key exchange are protocols which are designed to be secure even when the secret key or password shared between two users is drawn from a small set of values.  Due to the low entropy of passwords, such protocols are always subject to on-line guessing attacks.  In these attacks, the adversary may succeed with
non-negligible probability by guessing the password shared between two  users during its on-line attempt to impersonate one of these users.  The main goal of password-based authenticated key exchange protocols is to restrict the adversary to this case only.  In this paper, we consider password-based authenticated key exchange in the three-party scenario, in which the users trying to establish a secret do not share a password between themselves but only with a trusted server.  Towards our goal, we recall some of the existing security notions for password-based authenticated key exchange protocols and introduce new ones that are more suitable to the case of generic constructions.  We then present a natural generic construction of a three-party protocol, based on any two-party authenticated key exchange protocol, and prove its security without making use of the Random Oracle model.  To the best of our knowledge, the new protocol is the first provably-secure password-based protocol in the three-party setting.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Password &middot; authenticated key exchange &middot; key distribution &middot; multi-party protocols.</p>
    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 A generic three-party password-based protocol</h2>

    <p class="text-gray-300">In this section, we introduce a generic construction of a 3-party password-based key exchange protocol in the scenario in which we have an <em>honest-but-curious</em> server. It combines a 2-party password-based key exchange, a secure key distribution protocol and a 2-party MAC-based key exchange and has several attractive features. First, it does not assume the Random Oracle (RO) model [5]. That is, if the underlying primitives do not make use of the RO model, neither does our scheme. Hence, by using schemes such as the KOY protocol [19] for the 2-party password-based key exchange and the 3-party key distribution scheme in [7], one gets a 3-part password-based protocol whose security is in the standard model. Second, if 2-party password-based key exchange protocols already exist between the server and its users in a distributed system, they can be re-used in the construction of our 3-party password-based key exchange.</p>

    <p class="text-gray-300"><strong>Description of the generic solution.</strong> Our generic construction can be seen as a form of compiler transforming any secure 2-party password-based key exchange protocol P into a secure password-based 3-party key exchange protocol P' in the <em>honest-but-curious</em> security model using a secure key distribution KD, a secure MAC scheme, and generic number-theoretic operations in a group  <span class="math">\\mathbb{G}</span>  for which the DDH assumption holds (see Appendix B).</p>

    <p class="text-gray-300">The compiler, depicted in Figure 2, works as follows. First, we use the protocol P between a user A and the server S to establish a secure high-entropy session key  <span class="math">sk_A</span> . Second, we use the protocol P between the server S and the user B in order to establish a session key  <span class="math">sk_B</span> . Third, using a key distribution KD, we have the server S first select a MAC key  <span class="math">k_m</span> , using the key generation of the latter, and then distribute this key to A and B using the session keys  <span class="math">sk_A</span>  and  <span class="math">sk_B</span> , respectively, generated in the first two steps. Finally, S and S use a MAC-based key exchange to establish a session key CDH in an authenticated way.</p>

    <p class="text-gray-300">Semantic security in the Real-Or-Random model. As the following theorem states, the generic scheme GPAKE depicted in Figure 2 is a secure 3-party password-based key exchange protocol as long as the Decisional Diffie-Hellman assumption holds in  <span class="math">\\mathbb{G}</span>  and the underlying primitives it uses are secure.</p>

    <p class="text-gray-300">    <img src="_page_10_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 2. GPAKE: a generic three-party password-based key exchange</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> Let 2PAKE be a secure 2-party password-based Key Exchange, KD be a secure key distribution, and MAC be a secure MAC algorithm. Let  <span class="math">q_{\\rm exe}</span>  and  <span class="math">q_{\\rm test}</span>  represent the number of queries to Execute and Test oracles, and let  <span class="math">q_{\\rm send}^A</span> ,  <span class="math">q_{\\rm send}^B</span> ,  <span class="math">q_{\\rm kd}</span> , and  <span class="math">q_{\\rm ake}</span>  represent the number of queries to the SendClient and SendServer oracles with respect to each of the two 2PAKE protocols, the KD protocol, and the final AKE protocol. Then,</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathbf{Adv}_{\\mathsf{GPAKE},\\mathcal{D}}^{\\mathsf{ror-ake}}(t,q_{\\mathsf{exe}},q_{\\mathsf{test}},q_{\\mathsf{send}}^A,q_{\\mathsf{send}}^B,q_{\\mathsf{kd}},q_{\\mathsf{ake}}) &amp;\\leq \\\\ &amp;4 \\cdot (q_{\\mathsf{exe}} + q_{\\mathsf{kd}}) \\cdot \\mathbf{Adv}_{\\mathsf{KD}}^{\\mathsf{ftg-kd}}(t,1,0) + \\ 2 \\cdot q_{\\mathsf{ake}} \\cdot \\mathbf{Adv}_{\\mathsf{MAC}}^{\\mathsf{euf-cma}}(t,2,0) \\\\ &amp;+ 2 \\cdot \\mathbf{Adv}_{\\mathbb{G}}^{\\mathsf{ddh}}(t + 8(q_{\\mathsf{exe}} + q_{\\mathsf{ake}})\\tau_e) + 4 \\cdot \\mathbf{Adv}_{\\mathsf{2PAKE},\\mathcal{D}}^{\\mathsf{ror-ake}}(t,q_{\\mathsf{exe}},q_{\\mathsf{exe}} + q_{\\mathsf{send}}^A,q_{\\mathsf{send}}^A) \\\\ &amp;+ 4 \\cdot \\mathbf{Adv}_{\\mathsf{2PAKE},\\mathcal{D}}^{\\mathsf{ror-ake}}(t,q_{\\mathsf{exe}},q_{\\mathsf{exe}} + q_{\\mathsf{send}}^B,q_{\\mathsf{send}}^B) \\;, \\end{split}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\tau_e</span>  denotes the exponentiation computational time in  <span class="math">\\mathbb{G}</span> .</p>

    <p class="text-gray-300">Key privacy with respect to the server. As the following theorem states, the generic scheme GPAKE depicted in Figure 2 has key privacy with respect to the server as long as the Decisional Diffie-Hellman assumption holds in  <span class="math">\\mathbb{G}</span> .</p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> Let GPAKE be the 3-party password-based authenticated key exchange scheme depicted in Figure 2. Then,</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}^{\\mathrm{kp-ake}}_{\\mathsf{GPAKE},\\mathcal{D}}(t,q_{\\mathrm{exe}},q_{\\mathrm{test}},q_{\\mathrm{send}}^A,q_{\\mathrm{send}}^B,q_{\\mathrm{kd}},q_{\\mathrm{ake}}) \\leq 2 \\cdot \\mathbf{Adv}^{\\mathsf{ddh}}_{\\mathbb{G}}(t&#x27;) ,</span>$
where  <span class="math">t&#x27; = t + 8 \\cdot (q_{\\mathrm{exe}} + q_{\\mathrm{ake}}) \\cdot \\tau_e</span>  and the other parameters are defined as in Theorem 1.</p>

    <p class="text-gray-300"><strong>Instantiations.</strong> Several practical schemes can be used in the instantiation of the 2-party password-based key exchange of our generic construction. Among them are the KOY protocol [19] and its generalization [13], the PAK suite [25], and several other schemes based on the encrypted key exchange scheme of Bellovin and Merritt [8] (e.g., [10]).</p>

    <p class="text-gray-300">In the instantiation of the key distribution scheme, one could use the original proposal in [7] or any other secure key distribution scheme. In particular, the server could use a chosen-ciphertext secure symmetric encryption scheme to distribute the keys to the users. Independently of the choice, one should keep in mind that the security requirements for the key distribution scheme are very weak. It only needs to provide security with respect to one session.</p>

    <p class="text-gray-300">For the instantiation of the MAC, any particular choice that makes the MAC term in Theorem 1 negligible will do. Possible choices are the HMAC [2] or the CBC MAC.</p>

    <p class="text-gray-300">It is important to notice that, in order for GPAKE to be secure, the underlying 2-party password-based protocol <em>must</em> be secure in the ROR model. A 2-party password-based secure in the FTG model does not suffice to prove the security of GPAKE.</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>5 Concluding remarks</strong></h2>

    <p class="text-gray-300">AUTHENTICATION. In order to take (explicit) authentication into account, one can easily extend our model using definitions similar to those of Bellare <em>et al.</em> [4] for unilateral or mutual authentication. In their definition, an adversary is said to break authentication if it succeeds in making any oracle instance terminate the protocol without a partner oracle. Likewise, one could also use their generic transformation to enhance our generic construction so that it provides unilateral or mutual authentication. The drawback of using their generic transformation is that it requires the random oracle model.</p>

    <p class="text-gray-300">MORE EFFICIENT CONSTRUCTIONS. Even though the generic construction presented in this paper is quite practical, more efficient solutions are possible. One example of such an improvement is a generic construction in which the key distribution and the final key exchange phases are combined into a single phase. One can easily think of different solutions for this scenario that are more efficient that the one we give. However, the overall gain in efficiency would not be very significant since the most expensive part of these two phases, the Diffie-Hellman protocol, seems to be necessary if key privacy with respect to the server is to be achieved. Perhaps the best way to improve the efficiency of 3-party password-based schemes is to adapt specific solutions in the 2-party model to the 3-party model, instead of treating these schemes as black boxes.</p>

    <p class="text-gray-300">RELATION TO SIMULATION MODELS. In [29], the Find-Then-Guess model of [7] is shown to be equivalent to simulation models in the sense that a scheme that is proven secure in one model is also secure in the other model. By closely examining their proof, one can easily see that the equivalence does not apply to the case of password-based protocols due to the non-security-preserving reduction. It seems, however, that their proof of equivalence can be adapted to show the equivalence between the simulation model and the Real-Or-Random model that we introduce in this paper in the case of password-based protocols. This is also the subject of ongoing work.</p>

    </section>

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>Acknowledgements</strong></h2>

    <p class="text-gray-300">The work described in this document has been supported in part by the European Commission through the IST Programme under Contract IST-2002-507932 ECRYPT. The information in this document reflects only the author's views, is provided as is and no guarantee or warranty is given that the information is fit for any particular purpose. The user thereof uses the information at its sole risk and liability</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>References</strong></h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. Abdalla, M. Bellare, and P. Rogaway. The oracle Diffie-Hellman assumptions and an analysis of DHIES. In D. Naccache, editor, <em>CT-RSA 2001</em>, volume 2020 of <em>LNCS</em>, pages 143&ndash;158. Springer-Verlag, Apr. 2001.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. Bellare, R. Canetti, and H. Krawczyk. Keying hash functions for message authentication. In N. Koblitz, editor, <em>CRYPTO'96</em>, volume 1109 of <em>LNCS</em>, pages 1&ndash;15. Springer-Verlag, Aug. 1996.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. Bellare, A. Desai, E. Jokipii, and P. Rogaway. A concrete security treatment of symmetric encryption. In <em>38th FOCS</em>, pages 394&ndash;403. IEEE Computer Society Press, Oct. 1997.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. Bellare, D. Pointcheval, and P. Rogaway. Authenticated key exchange secure against dictionary attacks. In B. Preneel, editor, <em>EUROCRYPT 2000</em>, volume 1807 of <em>LNCS</em>, pages 139&ndash;155. Springer-Verlag, May 2000.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. Bellare and P. Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In <em>ACM CCS 93</em>, pages 62&ndash;73. ACM Press, Nov. 1993.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. Bellare and P. Rogaway. Entity authentication and key distribution. In D. R. Stinson, editor, <em>CRYPTO'93</em>, volume 773 of <em>LNCS</em>. Springer-Verlag, Aug. 1994.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. Bellare and P. Rogaway. Provably secure session key distribution the three party case. In <em>28th ACM STOC</em>, pages 57&ndash;66. ACM Press, May 1996.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>S. M. Bellovin and M. Merritt. Encrypted key exchange: Password-based protocols secure against dictionary attacks. In <em>1992 IEEE Symposium on Security and Privacy</em>, pages 72&ndash;84. IEEE Computer Society Press, May 1992.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>V. Boyko, P. MacKenzie, and S. Patel. Provably secure password-authenticated key exchange using Diffie-Hellman. In B. Preneel, editor, <em>EUROCRYPT 2000</em>, volume 1807 of <em>LNCS</em>, pages 156&ndash;171. Springer-Verlag, May 2000.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>E. Bresson, O. Chevassut, and D. Pointcheval. New security results on encrypted key exchange. In F. Bao, R. Deng, and J. Zhou, editors, <em>PKC 2004</em>, volume 2947 of <em>LNCS</em>, pages 145&ndash;158. Springer-Verlag, Mar. 2004.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>J. W. Byun, I. R. Jeong, D. H. Lee, and C.-S. Park. Password-authenticated key exchange between clients with different passwords. In R. H. Deng, S. Qing, F. Bao, and J. Zhou, editors, <em>ICICS 02</em>, volume 2513 of <em>LNCS</em>, pages 134&ndash;146. Springer-Verlag, Dec. 2002.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Y. Ding and P. Horster. Undetectable on-line password guessing attacks. <em>ACM SIGOPS Operating Systems Review</em>, 29(4):77&ndash;86, Oct. 1995.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>R. Gennaro and Y. Lindell. A framework for password-based authenticated key exchange. In E. Biham, editor, <em>EUROCRYPT 2003</em>, volume 2656 of <em>LNCS</em>, pages 524&ndash;543. Springer-Verlag, May 2003. http: //eprint.iacr.org/2003/032.ps.gz.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>O. Goldreich. <em>Foundations of Cryptography: Basic Tools</em>, volume 1. Cambridge University Press, Cambridge, UK, 2001.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>O. Goldreich and Y. Lindell. Session-key generation using human passwords only. In J. Kilian, editor, <em>CRYPTO 2001</em>, volume 2139 of <em>LNCS</em>, pages 408&ndash;432. Springer-Verlag, Aug. 2001. http://eprint. iacr.org/2000/057.ps.gz.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>L. Gong. Optimal authentication protocols resistant to password guessing attacks. In <em>CSFW'95: The 8th IEEE Computer Security Foundation Workshop</em>, pages 24&ndash;29, Kenmare, County Kerry, Ireland, Mar. 13&ndash;15, 1995. IEEE Computer Society.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>L. Gong, T. M. A. Lomas, R. M. Needham, and J. H. Saltzer. Protecting poorly chosen secrets from guessing attacks. <em>IEEE JSAC</em>, 11(5):648&ndash;656, June 1993.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>S. Halevi and H. Krawczyk. Public-key cryptography and password protocols. In <em>ACM Transactions on Information and System Security</em>, pages 524&ndash;543. ACM, 1999.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>J. Katz, R. Ostrovsky, and M. Yung. Efficient password-authenticated key exchange using human-memorable passwords. In B. Pfitzmann, editor, <em>EUROCRYPT 2001</em>, volume 2045 of <em>LNCS</em>, pages 475&ndash;494. Springer-Verlag, May 2001.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>J. Kim, S. Kim, J. Kwak, and D. Won. Cryptanalysis and improvement of password authenticated key exchange scheme between clients with different passwords. In A. Lagan, M. L. Gavrilova, V. Kumar, Y. Mun, C. J. K. Tan, and O. Gervasi, editors, <em>ICCSA 04</em>, volume 3043 of <em>LNCS</em>, pages 895&ndash;902. Springer-Verlag, May 2004.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>H. Krawczyk. SIGMA: The &quot;SIGn-and-MAc&quot; approach to authenticated Diffie-Hellman and its use in the ike protocols. In D. Boneh, editor, <em>CRYPTO 2003</em>, volume 2729 of <em>LNCS</em>, pages 400&ndash;425. Springer-Verlag, Aug. 2003.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>C.-L. Lin, H.-M. Sun, and T. Hwang. Three-party encrypted key exchange: Attacks and a solution. <em>ACM SIGOPS Operating Systems Review</em>, 34(4):12&ndash;20, Oct. 2000.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>C.-L. Lin, H.-M. Sun, M. Steiner, and T. Hwang. Three-party encrypted key exchange without server publickeys. <em>IEEE Communications Letters</em>, 5(12):497&ndash;499, Dec. 2001.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>P. MacKenzie, S. Patel, and R. Swaminathan. Password-authenticated key exchange based on RSA. In T. Okamoto, editor, <em>ASIACRYPT 2000</em>, volume 1976 of <em>LNCS</em>, pages 599&ndash;613. Springer-Verlag, Dec. 2000.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>P. D. MacKenzie. The PAK suite: Protocols for password-authenticated key exchange. Contributions to IEEE P1363.2, 2002.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>P. D. MacKenzie, T. Shrimpton, and M. Jakobsson. Threshold password-authenticated key exchange. In M. Yung, editor, <em>CRYPTO 2002</em>, volume 2442 of <em>LNCS</em>, pages 385&ndash;400. Springer-Verlag, Aug. 2002.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>R. Needham and M. Schroeder. Using encryption for authentication in large networks of computers. <em>Communications of the ACM</em>, 21(21):993&ndash;999, Dec. 1978.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. D. Raimondo and R. Gennaro. Provably secure threshold password-authenticated key exchange. In E. Biham, editor, <em>EUROCRYPT 2003</em>, volume 2656 of <em>LNCS</em>, pages 507&ndash;523. Springer-Verlag, May 2003.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>V. Shoup. On formal models for secure key exchange. Technical Report RZ 3120, IBM, 1999.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>V. Shoup. OAEP reconsidered. In J. Kilian, editor, <em>CRYPTO 2001</em>, volume 2139 of <em>LNCS</em>, pages 239&ndash;259. Springer-Verlag, Aug. 2001.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>J. G. Steiner, B. C. Neuman, and J. L. Schiller. Kerberos: An authentication service for open networks. In <em>Proceedings of the USENIX Winter Conference</em>, pages 191&ndash;202, Dallas, TX, USA, 1988.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. Steiner, G. Tsudik, and M. Waidner. Refinement and extension of encrypted key exchange. <em>ACM SIGOPS Operating Systems Review</em>, 29(3):22&ndash;30, July 1995.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>G. Tsudik and E. Van Herreweghen. Some remarks on protecting weak keys and poorly-chosen secrets from guessing attacks. In <em>SRDS'93: The 12th Symposium on Reliable Distributed Systems</em>, pages 136&ndash;142, Princeton, New Jersey, USA, Oct. 6&ndash;8, 1993. IEEE Computer Society.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>S. Wang, J. Wang, and M. Xu. Weaknesses of a password-authenticated key exchange protocol between clients with different passwords. In M. Jakobsson, M. Yung, and J. Zhou, editors, <em>ACNS 04</em>, volume 3089 of <em>LNCS</em>, pages 414&ndash;425. Springer-Verlag, June 2004.</li>
    </ul></li>
      <li><p class="text-gray-300">H.-T. Yeh, H.-M. Sun, and T. Hwang. Efficient three-party authentication and key agreement protocols resistant to password guessing attacks. <em>Journal of Information Science and Engineering</em>, 19(6):1059&ndash;1070, Nov. 2003.</p></li>
    </ul>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A Proof of security for GPAKE</h2>

    <p class="text-gray-300">Semantic security of GPAKE in the ROR model. Without loss of generality, we assume the set of honest users contains only users A and B. The solution can be easily extended to the more general case with essentially the same bounds.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal A</span>  be an adversary against the semantic security of GPAKE in the Real-Or-Random sense with time-complexity at most t, and asking at most  <span class="math">q_{\\rm exe}</span>  queries to its <em>Execute</em> oracle,  <span class="math">q_{\\rm test}</span>  queries to its <em>Test</em> oracle,  <span class="math">q_{\\rm send}^A</span>  queries to <em>SendClient</em> and <em>SendServer</em> oracles with respect to the 2PAKE protocol between A and the trusted server S,  <span class="math">q_{\\rm send}^B</span>  queries with respect to the 2PAKE protocol between B and B, B0 queries with respect to the KD protocol, and B1 queries with respect to the final authenticated key exchange protocol.</p>

    <p class="text-gray-300">Our proof consists of a sequence of hybrid experiments, starting with the real attack against GPAKE scheme and ending in an experiment in which the adversary's advantage is 0, and for which we can bound the difference in the adversary's advantage between any two consecutive experiments. For each experiment  <span class="math">\\mathbf{Exp}_n</span> , we define an event  <span class="math">\\mathrm{Succ}_n</span>  corresponding to the case in which the adversary correctly guesses the hidden bit b involved in the Test queries (see Section 3).</p>

    <p class="text-gray-300"><strong>Experiment Exp</strong> <span class="math">_0</span> . This experiment corresponds to the real attack. By definition, we have</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Adv}_{\\mathsf{GPAKE},\\mathcal{D}}^{\\mathsf{ror-ake}}(\\mathcal{A}) = 2 \\cdot \\Pr[\\mathsf{SUCC}_0] - 1 \\tag{1}</span>$</p>

    <p class="text-gray-300"><strong>Experiment</strong>  <span class="math">\\mathbf{Exp}_1</span> . We now modify the simulation of the oracles as follows. We replace the session key  <span class="math">sk_A</span>  used as input to the KD protocol by a random session key  <span class="math">sk_A&#x27;</span>  in all of the sessions. As the following lemma shows, the difference between the success probability of the adversary  <span class="math">\\mathcal{A}</span>  between the current and previous experiments is at most that of breaking the security of the underlying 2PAKE protocol between A and S.</p>

    <p class="text-gray-300"><span class="math">$\\textbf{Lemma 3.} \\ \\left| \\Pr[\\, \\text{SUCC}_1 \\,] - \\Pr[\\, \\text{SUCC}_0 \\,] \\right| \\leq 2 \\cdot \\mathbf{Adv}^{\\text{ror-ake}}_{2\\mathsf{PAKE},\\mathcal{D}}(t,q_{\\text{exe}},q_{\\text{exe}} + q_{\\text{send}}^A,q_{\\text{send}}^A) \\ .</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">\\mathcal{A}_1</span>  be a distinguisher for experiments  <span class="math">\\mathbf{Exp}_1</span>  and  <span class="math">\\mathbf{Exp}_0</span> . We can build an adversary  <span class="math">\\mathcal{A}_{\\mathsf{pake}}</span>  against the semantic security of the 2PAKE protocol between A and S using  <span class="math">\\mathcal{A}_1</span>  as follows.  <span class="math">\\mathcal{A}_{\\mathsf{pake}}</span>  starts by choosing a bit b uniformly at random and selecting the passwords for all users in the system except A according to the distribution of  <span class="math">\\mathcal{D}</span> . Next, it starts running  <span class="math">\\mathcal{A}_1</span> , giving it the passwords for all the malicious clients in the system, and answering to its oracle queries as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>SendClient and SendServer queries. If  <span class="math">\\mathcal{A}_1</span>  asks a SendClient or SendServer query pertaining to an instance of the 2PAKE protocol between B and S, then  <span class="math">\\mathcal{A}_{\\mathsf{pake}}</span>  can answer it using the password of client B that it has picked at the beginning of its execution. If the SendClient or SendServer query pertains to an instance of the 2PAKE protocol between A and S, then  <span class="math">\\mathcal{A}_{\\mathsf{pake}}</span>  can answer it by asking the corresponding query to its Send oracle. If this query forces the given instance of client A or S to accept or reject, then we also</li>
    </ul>

    <p class="text-gray-300">ask a <em>Test</em> query to that instance (unless <em>Test</em> query had already been asked to its partner). The output of this <em>Test</em> query will be used to simulate the key distribution and final key exchange phases of the protocol. All the other <em>SendClient</em> and <em>SendServer</em> queries by  <span class="math">\\mathcal{A}_1</span>  can be easily answered either using the output of the <em>Test</em> queries made to instances of A or S or the session keys computed in the execution of the 2PAKE protocol between A and B.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Execute queries.  <span class="math">A_{pake}</span>  can easily answer these queries using its own Execute oracle and the output of the Test queries.</li>
      <li>Test queries.  <span class="math">A_{pake}</span>  can easily answer these queries using the bit b that it has previously selected and the session keys that it has computed.</li>
    </ul>

    <p class="text-gray-300">Let b' be the output of  <span class="math">A_1</span> . If b' = b, then  <span class="math">A_{pake}</span>  outputs 1. Otherwise, it outputs 0.</p>

    <p class="text-gray-300">One can easily see that the probability that  <span class="math">\\mathcal{A}_{\\text{pake}}</span>  outputs 1 when its Test oracle returns real keys is exactly the probability that  <span class="math">\\mathcal{A}_1</span>  returns 1 in experiment  <span class="math">\\mathbf{Exp}_0</span> . Similarly, the probability that  <span class="math">\\mathcal{A}_{\\text{pake}}</span>  outputs 1 when its Test oracle returns random keys is exactly the probability that  <span class="math">\\mathcal{A}_1</span>  returns 1 in experiment  <span class="math">\\mathbf{Exp}_1</span> . The lemma follows by noticing that  <span class="math">\\mathcal{A}_{\\text{pake}}</span>  has at most time-complexity t and asks at most  <span class="math">q_{\\text{exe}} + q_{\\text{send}}^A</span>  queries to its Test oracle, at most  <span class="math">q_{\\text{exe}}</span>  queries to its Execute oracle, and at most  <span class="math">q_{\\text{send}}^A</span>  queries to its Send oracle.</p>

    <p class="text-gray-300"><strong>Experiment</strong>  <span class="math">\\mathbf{Exp}_2</span> . We modify the previous experiment by replacing the session key  <span class="math">sk_B</span>  used as input to the KD protocol by a random session key  <span class="math">sk_B&#x27;</span>  in all of the sessions. Using similar arguments, one can prove the following lemma.</p>

    <p class="text-gray-300"><strong>Lemma 4.</strong>
<span class="math">$\\left| \\Pr[\\text{SUCC}_2] - \\Pr[\\text{SUCC}_1] \\right| \\le 2 \\cdot \\mathbf{Adv}_{2\\mathsf{PAKE},\\mathcal{D}}^{\\mathsf{ror-ake}}(t, q_{\\mathsf{exe}}, q_{\\mathsf{exe}} + q_{\\mathsf{send}}^B, q_{\\mathsf{send}}^B)</span>$
.</p>

    <p class="text-gray-300"><strong>Experiment</strong>  <span class="math">\\mathbf{Exp}_3</span> . In this experiment, we replace the MAC key  <span class="math">k_m</span>  obtained via the key distribution protocol with a random key in all of the sessions. According to the following lemma, the difference between the success probability of the adversary  <span class="math">\\mathcal{A}</span>  between the current and previous experiments is at most that of breaking the security of the key distribution scheme KD protocol between A, B, and S.</p>

    <p class="text-gray-300">Lemma 5.
<span class="math">$\\left| \\Pr[\\text{SUCC}_3] - \\Pr[\\text{SUCC}_2] \\right| \\le 2 \\left( q_{\\text{exe}} + q_{\\text{kd}} \\right) \\mathbf{Adv}_{\\text{KD}}^{\\text{ftg-kd}}(t, 1)</span>$
.</p>

    <p class="text-gray-300"><em>Proof.</em> The proof of this lemma uses standard hybrid arguments [14] in order to replace each of the key generated by the key distribution scheme KD. We can do so here because the input of the key distribution scheme are all independents since experiment  <span class="math">\\mathbf{Exp}_2</span> .</p>

    <p class="text-gray-300">The hybrids in this case consist of a sequence of random variables  <span class="math">V_i</span> , where  <span class="math">0 \\le i \\le q_s</span>  and  <span class="math">q_s = (q_{\\text{exe}} + q_{\\text{kd}})</span> , such that (1) the random variable  <span class="math">V_i</span>  is constructed as follows: in the first (i-1) sessions, the session keys are generated according to experiment  <span class="math">\\mathbf{Exp}_3</span> , (i.e. at random), and in the  <span class="math">(q_s - i + 1)</span>  sessions, they are generated according to the  <span class="math">\\mathbf{Exp}_2</span> , (i.e. according to the real protocol); (2) extreme hybrids (i=0) and  <span class="math">(i=q_s)</span>  collide with  <span class="math">\\mathbf{Exp}_2</span>  and  <span class="math">\\mathbf{Exp}_3</span>  respectively; (3) random values of each hybrid can be produced by a probabilistic polynomial time algorithm and the session that we modify is independent of the other sessions; and (4) there are only polynomially many hybrids.</p>

    <p class="text-gray-300">The hybrids allow us to define  <span class="math">q_s</span>  different experiments where we only ask queries to the Send oracles of the KD scheme with respect to a single session in each of the hybrids. Indeed, we start with a distinguisher  <span class="math">\\mathcal{A}_{3,i}</span>  for experiments  <span class="math">V_{i-1}</span>  and  <span class="math">V_i</span>  and we build an adversary  <span class="math">\\mathcal{A}^i_{kd}</span>  against the KD protocol. The adversary  <span class="math">\\mathcal{A}^i_{kd}</span>  will choose at random the MAC keys  <span class="math">k_m</span>  for the first i-1 sessions as well as the secret keys  <span class="math">sk_A</span>  and  <span class="math">sk_B</span>  shared between the server and clients A and B, respectively. Hence, it can perfectly answer to the queries made by the adversary  <span class="math">\\mathcal{A}_{3,i}</span>  to SendClient, SendServer, Execute, and Test oracles for the (i-1) first sessions. In the</p>

    <p class="text-gray-300"><em>i</em>-th session of hybrid experiment  <span class="math">\\mathbf{Exp}_{3,i}</span> ,  <span class="math">\\mathcal{A}^i_{kd}</span>  will use the KD oracles to answer its queries. It also makes a <em>Test</em> query with respect to this session to obtain a key  <span class="math">\\tilde{k_m}</span>  and uses it in order to simulate the remainder of the GPAKE protocol for that session.</p>

    <p class="text-gray-300">If the output of the <em>Test</em> query is the real key, then  <span class="math">\\mathcal{A}^i_{kd}</span>  is running  <span class="math">\\mathcal{A}_{3,i}</span>  as in the hybrid experiment  <span class="math">V_{i-1}</span> . If the session key returned by the <em>Test</em> query is a random key, then  <span class="math">\\mathcal{A}^i_{kd}</span>  is running  <span class="math">\\mathcal{A}_{3,i}</span>  as in the hybrid experiment  <span class="math">V_i</span>  Note the number of queries asked by  <span class="math">\\mathcal{A}^i_{kd}</span>  to its <em>Send</em> oracles is at most the maximum number of messages in a single execution of the protocol, c, hence the bound given in the lemma. Finally, when answering to the <em>Test</em> queries made by  <span class="math">\\mathcal{A}_{3,i}</span> ,  <span class="math">\\mathcal{A}^i_{kd}</span>  uses the same random bit b chosen at random at the beginning of its execution. Let b' be the output of adversary  <span class="math">\\mathcal{A}_{3,i}</span> . If b'=b, then  <span class="math">\\mathcal{A}^i_{kd}</span>  returns 1 or 0, otherwise. Using classical probability analysis and the fact that  <span class="math">\\mathcal{A}^i_{kd}</span>  has time-complexity t and asks queries to its <em>Send</em> oracle with respect to a <em>single</em> session and no <em>Reveal</em> queries, we can show that the difference between the probabilities that  <span class="math">\\mathcal{A}^i_{kd}</span>  in experiments  <span class="math">V_i</span>  and  <span class="math">V_{i-1}</span>  is at most  <span class="math">2 \\cdot \\mathbf{Adv}^{\\mathrm{ftg-kd}}_{\\mathrm{KD}}(t,1,0)</span> . The lemma follows immediately by noticing that there are at most  <span class="math">q_s</span>  hybrids.</p>

    <p class="text-gray-300"><strong>Experiment Exp</strong> <span class="math">_4</span> . In this experiment, we modify the oracle instances as follows. If the adversary asks a <em>SendClient</em> query containing a new pair message-MAC not previously generated by an oracle, then we consider the MAC invalid and force the instance in question (which received a forged message) to terminate without accepting. As the following lemma shows, the difference between the current and previous experiments should be negligible if we use a secure MAC scheme.</p>

    <p class="text-gray-300">Lemma 6.
<span class="math">$\\left|\\Pr[\\operatorname{SUCC}_4] - \\Pr[\\operatorname{SUCC}_3]\\right| \\leq q_{\\operatorname{ake}} \\cdot \\mathbf{Adv}_{\\mathsf{MAC}}^{\\operatorname{euf-cma}}(t,2,0)</span>$
.</p>

    <p class="text-gray-300"><em>Proof.</em> The proof of this lemma also uses hybrid arguments in the same as in the proof of Lemma 5. The total number of hybrids in this case is  <span class="math">q_{\\rm ake}</span> , since <em>Execute</em> queries do not need to be taken into account in this case. In hybrid  <span class="math">V_i</span> , where  <span class="math">0 \\le i \\le q_{\\rm ake}</span> , queries in the first i sessions are answered as in experiment  <span class="math">\\mathbf{Exp}_4</span>  and all other queries are answered as in experiment  <span class="math">\\mathbf{Exp}_3</span> . Let  <span class="math">\\mathcal{A}_{4,i}</span>  be a distinguisher for hybrids  <span class="math">V_i</span>  and  <span class="math">V_{i-1}</span> . Using  <span class="math">\\mathcal{A}_{4,i}</span> , we can build an adversary for the MAC scheme as follows.</p>

    <p class="text-gray-300">For the first i-1 sessions, the adversary  <span class="math">\\mathcal{A}_{\\mathsf{mac}}^i</span>  will choose random values for the MAC key and is therefore able to perfect simulate the oracles given to  <span class="math">\\mathcal{A}_{4,i}</span> . In the i-th session,  <span class="math">\\mathcal{A}_{\\mathsf{mac}}^i</span>  makes use of its MAC generation and verification oracles to answer queries from  <span class="math">\\mathcal{A}_{4,i}</span> . If  <span class="math">\\mathcal{A}_{4,i}</span>  generates a pair message-MAC not previously generated by  <span class="math">\\mathcal{A}_{\\mathsf{mac}}^i</span> , then  <span class="math">\\mathcal{A}_{\\mathsf{mac}}^i</span>  halts and outputs that pair as its forgery. If no such pair is generated, we output a failure indication. For all remaining sessions,  <span class="math">\\mathcal{A}_{\\mathsf{mac}}^i</span>  uses the actual MAC keys obtained via the key distribution scheme as in experiment  <span class="math">\\mathbf{Exp}_3</span>  to answer queries from  <span class="math">\\mathcal{A}_{4,i}</span> .</p>

    <p class="text-gray-300">Let F be the event in which a MAC is considered invalid in hybrid  <span class="math">V_i</span>  but valid in hybrid  <span class="math">V_{i-1}</span> . Notice that  <span class="math">\\Pr[F]</span>  is at most the probability that an adversary  <span class="math">\\mathcal{A}^i_{\\mathsf{mac}}</span>  can forge a MAC under a chosen-message attack. Since  <span class="math">\\mathcal{A}^i_{\\mathsf{mac}}</span>  has time-complexity t and makes at most two queries to its MAC generation oracle (to answer the SendClient queries) and no queries to its verification oracle, we have that  <span class="math">\\Pr[F] \\leq \\mathsf{Succ}^{\\mathsf{euf}\\mathsf{-cma}}_{\\mathsf{MAC}}(t,2,0)</span> . Moreover, since the two hybrids proceed identically until F occurs, we have  <span class="math">\\Pr[\\mathsf{Succ}_{V_{i-1}} \\land \\neg F] = \\Pr[\\mathsf{Succ}_{V_i} \\land \\neg F]</span> . By Lemma 1 of [30], we have  <span class="math">|\\Pr[\\mathsf{Succ}_{V_{i-1}}] - \\Pr[\\mathsf{Succ}_{V_i}]| \\leq \\Pr[F]</span> . The lemma follows from the fact that there are at most  <span class="math">q_{\\mathsf{ake}}</span>  hybrids.</p>

    <p class="text-gray-300"><strong>Experiment Exp</strong><sub>5</sub>. In this experiment, we try to avoid the use of the discrete-log of the elements X, Y, Z in the <em>Test</em> queries in order to correctly compute the CDH(X, Y). We thus introduce a random DDH triples (X, Y, Z). Then, using the classical random self-reducibility</p>

    <p class="text-gray-300">of the Diffie-Hellman problem, one can introduce the above triples in all the sessions which can be tested by the adversary. We do not need to modify the other sessions.</p>

    <p class="text-gray-300">The behavior of our simulation in this experiment is as follows. Experiment  <span class="math">\\mathbf{Exp}_5</span>  is identical to experiment  <span class="math">\\mathbf{Exp}_4</span> , except that we apply the following special rules when dealing with  <span class="math">Test(U^i)</span>  and  <span class="math">SendClient(U^i,m)</span>  queries for the last two flows of GPAKE:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>R1:</strong> When processing a  <span class="math">SendClient(A^i, Start)</span>  query, the simulator picks two random values  <span class="math">a_0</span>  and  <span class="math">x_0</span>  in  <span class="math">\\mathbb{Z}q</span> , computes  <span class="math">X_0 = X^{a_0}g^{x_0}</span> , and stores in some  <span class="math">\\mathcal{X}</span> -table  <span class="math">(a_0, x_0, X_0)</span> .</li>
      <li><strong>R2:</strong> When processing a  <span class="math">SendClient(B^j, (X_0, m_0))</span>  query in the last message of the protocol,    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>if the element  <span class="math">X_0</span>  has been computed by our simulator and thus have been stored in the  <span class="math">\\mathcal{X}</span> -table, then it generates the same way its answer by choosing two random values  <span class="math">b_0, y_0 \\stackrel{R}{\\leftarrow} \\mathbb{Z}q</span> , it computes  <span class="math">Y_0 = Y^{b_0}g^{y_0}</span>  and stores in some  <span class="math">\\mathcal{Y}</span> -table  <span class="math">(b_0, y_0, Y_0)</span> . It can now compute  <span class="math">Z_0 = Z^{a_0b_0} \\times Y^{x_0b_0} \\times X^{a_0y_0} \\times g^{x_0y_0}</span>  for the <em>Test</em> queries.</li>
      <li>if the elements  <span class="math">X_0</span>  has not been previously computed by our A-simulation, then it proceeds as in the experiment  <span class="math">\\mathbf{Exp}_4</span> .</li>
    </ul></li>
      <li><strong>R3:</strong> When processing a  <span class="math">Test(U^i)</span>  query, we know that such a query only reveal information about the hidden bit when asked on an accepting instance, and an accepting instance can only happen when the simulator knows the correct value  <span class="math">Z_0</span>  and can answer such query as in the experiment  <span class="math">\\mathbf{Exp}_4</span> .</li>
    </ul>

    <p class="text-gray-300">It is easy to see that in the second case of rule  <span class="math">\\mathbf{R2}</span> , as in experiment  <span class="math">\\mathbf{Exp}_4</span> , the adversary will not been able to forge a MAC tag, and then he will not be able to generate a correct message for either one of the two last flows. Consequently, the session will not be accepted by any party and so the adversary will not be able to send a <em>Test</em> query to any instance. Hence, the simulation will be consistent.</p>

    <p class="text-gray-300">It is then clear that experiments  <span class="math">\\mathbf{Exp}_4</span>  and  <span class="math">\\mathbf{Exp}_5</span>  are equivalent, since we have consistently replaced one set of random variables by another set of identically distributed random variables. In particular,  <span class="math">\\Pr[SUCC_4] = \\Pr[SUCC_5]</span> .</p>

    <p class="text-gray-300"><strong>Experiment Exp</strong><sub>6</sub>. Experiment <strong>Exp</strong><sub>6</sub> is exactly the same as experiment <strong>Exp</strong><sub>5</sub>, except that in all the rules, we use a random triple (X, Y, Z) coming from a random distribution  <span class="math">(g^x, g^y, g^z)</span> , instead of a DDH triple. As the following lemma shows, the difference between the current and previous experiments should be negligible if DDH is hard in  <span class="math">\\mathbb{G}</span> .</p>

    <p class="text-gray-300">Lemma 7.
<span class="math">$\\left| \\Pr[\\text{SUCC}_6] - \\Pr[\\text{SUCC}_5] \\right| \\leq \\mathbf{Adv}_{\\mathbb{G}}^{\\text{ddh}}(t + 8(q_{\\text{exe}} + q_{\\text{ake}})\\tau_e)</span>$
.</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">\\mathcal{A}</span>  be an attacker that breaks the semantic security experiment of GPAKE with a different advantage in Experiment  <span class="math">\\mathbf{Exp}_6</span>  than in Experiment  <span class="math">\\mathbf{Exp}_5</span> . We can build an adversary  <span class="math">\\mathcal{A}_{\\mathsf{ddh}}</span>  for the DDH problem in  <span class="math">\\mathbb{G}</span>  as follows. Let (X,Y,Z) be the input given to  <span class="math">\\mathcal{A}_{\\mathsf{ddh}}</span> . A sks a SendClient, Execute, or Test query, then  <span class="math">\\mathcal{A}_{\\mathsf{ddh}}</span>  computes its output exactly as in the previous experiment but using the triple (X,Y,Z) that it had received as input. Let b' be the output of  <span class="math">\\mathcal{A}</span> . If b'=b, then  <span class="math">\\mathcal{A}_{\\mathsf{ddh}}</span>  returns 1 or 0, otherwise.</p>

    <p class="text-gray-300">Let us now analyze the success probability of  <span class="math">\\mathcal{A}_{ddh}</span> . Clearly, when the triple (X,Y,Z) is a true Diffie-Hellman triple,  <span class="math">\\mathcal{A}_{ddh}</span>  runs  <span class="math">\\mathcal{A}</span>  exactly as in experiment  <span class="math">\\mathbf{Exp}_5</span>  and thus the probability that  <span class="math">\\mathcal{A}_{ddh}</span>  outputs 1 is exactly  <span class="math">\\Pr[\\mathrm{SUCC}_5]</span> . On the other hand, when (X,Y,Z) is a random triple,  <span class="math">\\mathcal{A}_{ddh}</span>  runs  <span class="math">\\mathcal{A}</span>  exactly as in experiment  <span class="math">\\mathbf{Exp}_6</span>  and thus the probability that  <span class="math">\\mathcal{A}_{ddh}</span>  outputs 1 is exactly  <span class="math">\\Pr[\\mathrm{SUCC}_6]</span> . The lemma follows from the fact that  <span class="math">\\mathcal{A}_{ddh}</span>  has time-complexity at most  <span class="math">t+8(q_{\\mathrm{exe}}+q_{\\mathrm{ake}})\\tau_e</span> , due to the additional time for the computations of the random self-reducibility.</p>

    <p class="text-gray-300">Due to the random self-reducibility property of the Diffie-Hellman problem, all the sessions keys  <span class="math">Z_0</span>  used to answer <em>Test</em> queries in experiment  <span class="math">\\mathbf{Exp}_6</span>  are randomly and independently distributed in  <span class="math">\\mathbb{G}</span> . As a result, no information on the hidden bit b used by the <em>Test</em> oracle is leaked to the adversary and thus  <span class="math">\\Pr[SUCC_6] = \\frac{1}{2}</span> . This result combined with the previous lemmas yields the result in Theorem 1.</p>

    <p class="text-gray-300"><strong>Key privacy.</strong> The proof of key privacy uses arguments similar to those used in experiments  <span class="math">\\mathbf{Exp}_5</span>  and  <span class="math">\\mathbf{Exp}_6</span>  in the proof of semantic security of GPAKE. Let  <span class="math">\\mathcal{A}_{kp}</span>  be an adversary against the key privacy of GPAKE with time-complexity at most t, and asking at most  <span class="math">q_{exe}</span>  queries to its <em>Execute</em> oracle,  <span class="math">q_{test}</span>  queries to its <em>TestPair</em> oracle, and  <span class="math">q_{ake}</span>  queries to <em>SendClient</em> oracle with respect to the final MAC-based authenticated key exchange protocol. Using  <span class="math">\\mathcal{A}_{kp}</span> , we can build an adversary  <span class="math">\\mathcal{A}_{ddh}</span>  for the DDH problem in  <span class="math">\\mathbb G</span>  as follows.</p>

    <p class="text-gray-300">Let (X,Y,Z) be the input given to  <span class="math">\\mathcal{A}_{ddh}</span> .  <span class="math">\\mathcal{A}_{ddh}</span>  first chooses the passwords for all users in the system according to the distribution of  <span class="math">\\mathcal{D}</span> . It also chooses a bit b at random that is used to answer queries to the TestPair oracle. It then starts running  <span class="math">\\mathcal{A}_{kp}</span>  giving all the password of all users to it. Since  <span class="math">\\mathcal{A}_{ddh}</span>  knows the password of all users, it can easily answer queries made by  <span class="math">\\mathcal{A}_{kp}</span> . However, in order to use  <span class="math">\\mathcal{A}_{kp}</span>  to help it solve the DDH problem,  <span class="math">\\mathcal{A}_{ddh}</span>  will use the classical random self-reducibility of the Diffie-Hellman problem to introduce its input triple in the answers to SendClient, Execute, and TestPair queries with respect to the last two flows of GPAKE.</p>

    <p class="text-gray-300">To simulate the <em>Execute</em> oracle, we simply use the passwords that we have chosen and <em>SendClient</em> queries. The simulation of the <em>SendClient</em> and <em>TestPair</em> are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>R1:</strong> When processing a  <span class="math">SendClient(A^i, Start)</span>  query,  <span class="math">\\mathcal{A}_{ddh}</span>  picks two random values  <span class="math">a_0</span>  and  <span class="math">x_0</span>  in  <span class="math">\\mathbb{Z}q</span> , computes  <span class="math">X_0 = X^{a_0}g^{x_0}</span> , and stores in some  <span class="math">\\mathcal{X}</span> -table  <span class="math">(a_0, x_0, X_0)</span> .</li>
      <li><strong>R2:</strong> When processing a  <span class="math">SendClient(B^j, (X_0, m_0))</span>  query in the last message of the protocol,    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>if the element  <span class="math">X_0</span>  has been computed by  <span class="math">\\mathcal{A}_{\\mathsf{ddh}}</span>  and thus have been stored in the  <span class="math">\\mathcal{X}</span> -table, then  <span class="math">\\mathcal{A}_{\\mathsf{ddh}}</span>  generates the same way its answer by choosing two random values  <span class="math">b_0, y_0 \\overset{R}{\\leftarrow} \\mathbb{Z}q</span> . It computes  <span class="math">Y_0 = Y^{b_0}g^{y_0}</span>  and stores in some  <span class="math">\\mathcal{Y}</span> -table  <span class="math">(b_0, y_0, Y_0)</span> .  <span class="math">\\mathcal{A}_{\\mathsf{ddh}}</span>  can now compute  <span class="math">Z_0 = Z^{a_0b_0} \\times Y^{x_0b_0} \\times X^{a_0y_0} \\times g^{x_0y_0}</span>  for the <em>TestPair</em> queries.</li>
      <li>if the elements  <span class="math">X_0</span>  has not been previously computed by  <span class="math">\\mathcal{A}_{ddh}</span> , then  <span class="math">\\mathcal{A}_{ddh}</span>  proceeds with the simulation as it would in a real attack.</li>
    </ul></li>
      <li><strong>R3:</strong> When processing a  <span class="math">TestPair(U_1^i, U_2^j)</span>  query,  <span class="math">\\mathcal{A}_{ddh}</span>  first checks whether  <span class="math">U_1^i</span>  and  <span class="math">U_2^j</span>  have both accepted and have the same key. If the check fails, then  <span class="math">\\mathcal{A}_{ddh}</span>  returns  <span class="math">\\bot</span> . If the check passes, then  <span class="math">\\mathcal{A}_{ddh}</span>  knows the corresponding value  <span class="math">Z_0</span>  for the secret key and can answer it based on the hidden bit b it had previously chosen.</li>
    </ul>

    <p class="text-gray-300">Let b' be the output of  <span class="math">A_{kp}</span> . If b' = b, then  <span class="math">A_{ddh}</span>  returns 1 and 0, otherwise.</p>

    <p class="text-gray-300">We would like to observe here that the second case of rule R2 has no influence over TestPair queries, since the latter can only be asked to pair of oracle instances which share the same key. This is because even though the instance involved in the SendClient may itself accept, its partner would not be an oracle instance. Hence, a TestPair query involving this instance would always return the invalid symbol  <span class="math">\\bot</span> .</p>

    <p class="text-gray-300">In order to analyze the success probability of  <span class="math">\\mathcal{A}_{ddh}</span> , first consider the case in which the triple (X,Y,Z) is a true Diffie-Hellman triple. Then, in this case, one can see that simulation of the  <span class="math">\\mathcal{A}_{kp}</span>  oracles is perfect. Hence, the probability that  <span class="math">\\mathcal{A}_{ddh}</span>  outputs 1 is exactly  <span class="math">\\frac{1}{2} + \\frac{1}{2} \\mathbf{A} \\mathbf{d} \\mathbf{v}_{\\mathsf{GPAKE},\\mathcal{D}}^{\\mathsf{kp-ake}}(\\mathcal{A}_{kp})</span> . On the other hand, when (X,Y,Z) is a random triple, the keys  <span class="math">Z_0</span>  used to answer  <span class="math">\\mathit{TestPair}</span>  queries are all random and independent as a result of the random self-reducibility property of the Diffie-Hellman problem. Hence, no information on b is leaked through  <span class="math">\\mathit{TestPair}</span>  queries and the probability that  <span class="math">\\mathcal{A}_{ddh}</span>  outputs 1 is exactly  <span class="math">\\frac{1}{2}</span>  in</p>

    <p class="text-gray-300">this case. The proof of Theorem 2 follows from the fact that  <span class="math">\\mathcal{A}_{\\text{ddh}}</span>  has time-complexity at most  <span class="math">t+8(q_{\\text{exe}}+q_{\\text{ake}})\\tau_e</span> , due to the additional time for the computations of the random self-reducibility.</p>

    </section>

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>B</strong> Building blocks</h2>

    <p class="text-gray-300">In this section, we recall the definitions for the cryptographic primitives that we use in the construction of our generic 3-party password-based authenticated key exchange, GPAKE.</p>

    <p class="text-gray-300"><strong>Decisional Diffie-Hellman assumption: DDH.</strong> The DDH assumption states, roughly, that the distributions  <span class="math">(g^u, g^v, g^{uv})</span>  and  <span class="math">(g^u, g^v, g^w)</span>  are computationally indistinguishable when u, v, w are drawn at random from  <span class="math">\\{1, \\ldots, |\\mathbb{G}|\\}</span> . This can be made more precise by defining two experiments,  <span class="math">\\mathbf{Exp}^{\\mathrm{ddh-real}}_{\\mathbb{G}}(\\mathcal{A})</span>  and  <span class="math">\\mathbf{Exp}^{\\mathrm{ddh-rand}}_{\\mathbb{G}}(\\mathcal{A})</span> . In both experiments, we compute two values  <span class="math">U = g^u</span>  and  <span class="math">V = g^v</span>  to be given to  <span class="math">\\mathcal{A}</span> . But in addition to that, we also provide a third input, which is  <span class="math">g^{uv}</span>  in  <span class="math">\\mathbf{Exp}^{\\mathrm{ddh-real}}_{\\mathbb{G}}(\\mathcal{A})</span>  and  <span class="math">g^z</span>  for a random z in  <span class="math">\\mathbf{Exp}^{\\mathrm{ddh-rand}}_{\\mathbb{G}}(\\mathcal{A})</span> . The goal of the adversary is to guess a bit indicating the experiment it thinks it is in. We define advantage of  <span class="math">\\mathcal{A}</span>  in violating the DDH assumption,  <span class="math">\\mathbf{Adv}^{\\mathrm{ddh}}_{\\mathbb{G}}(\\mathcal{A})</span> , as  <span class="math">\\Pr[\\mathbf{Exp}^{\\mathrm{ddh-real}}_{\\mathbb{G}}(\\mathcal{A}) = 1] - \\Pr[\\mathbf{Exp}^{\\mathrm{ddh-rand}}_{\\mathbb{G}}(\\mathcal{A}) = 1]</span> . The advantage function of the group,  <span class="math">\\mathbf{Adv}^{\\mathrm{ddh}}_{\\mathbb{G}}(t)</span>  is then defined as the maximum value of  <span class="math">\\mathbf{Adv}^{\\mathrm{ddh}}_{\\mathbb{G}}(\\mathcal{A})</span>  over all  <span class="math">\\mathcal{A}</span>  with time-complexity at most t.</p>

    <p class="text-gray-300">Message authentication codes (MAC). A Message Authentication Code MAC = (Key, Tag, Ver) is defined by the following three algorithms: (1) A MAC key generation algorithm Key, which on input  <span class="math">1^k</span>  produces a  <span class="math">\\ell</span> -bit secret-key sk uniformly distributed in  <span class="math">\\{0,1\\}^{\\ell}</span> ; (2) A MAC generation algorithm Tag, possibly probabilistic, which given a message m and a secret key  <span class="math">sk \\in \\{0,1\\}^{\\ell}</span> , produces an authenticator  <span class="math">\\mu</span> ; and (3) A MAC verification algorithm Ver, which given an authenticator  <span class="math">\\mu</span> , a message m, and a secret key sk, outputs 1 if  <span class="math">\\mu</span>  is a valid authenticator for m under sk and 0 otherwise.</p>

    <p class="text-gray-300">Like in signature schemes, the classical security level for a MAC is to prevent existential forgeries, even for an adversary which has access to the generation and verification oracles. We define <strong>advantage</strong> of  <span class="math">\\mathcal{A}</span>  in violating the security of the MAC,  <span class="math">\\mathbf{Adv}_{MAC}^{\\mathrm{euf}-\\mathrm{cma}}(\\mathcal{A})</span> , as</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\,sk \\leftarrow \\{0,1\\}^\\ell, (m,\\mu) \\leftarrow \\mathcal{A}^{\\mathsf{Tag}(sk;\\cdot),\\mathsf{Ver}(sk;\\cdot,\\cdot)}() : \\mathsf{Ver}(sk;m,\\mu) = 1\\,\\right],</span>$</p>

    <p class="text-gray-300">and the <strong>advantage function</strong> of the MAC,  <span class="math">\\mathbf{Adv}_{\\mathsf{MAC}}^{\\mathsf{euf}-\\mathsf{cma}}(t,q_g,q_s)</span> , as the maximum value of  <span class="math">\\mathbf{Adv}_{\\mathsf{MAC}}^{\\mathsf{euf}-\\mathsf{cma}}(\\mathcal{A})</span>  over all  <span class="math">\\mathcal{A}</span>  that asks up to  <span class="math">q_g</span>  and  <span class="math">q_v</span>  queries to the generation and verification oracles, respectively, and with time-complexity at most t. Note that  <span class="math">\\mathcal{A}</span>  wins the above experiment only if it outputs a <em>new</em> valid authenticator.</p>

    <p class="text-gray-300"><strong>3-party key distribution.</strong> A secure key distribution protocol KD is a 3-party protocol between 2 parties and a trusted server S where S picks a session key at random and securely sends it to the users. The security model, formally introduced in [7], is a generalization of that for 2-party authenticated key exchange protocols, to which a new oracle was added to represent the trusted server. Their security is in the Find-Then-Guess model, using the terminology that we introduced for key exchange protocols.</p>

    <p class="text-gray-300">In our generic construction, we only need a KD secure with respect to a single session since the symmetric keys used as input to the key distribution protocol differ from session to session. They are the session keys obtained from the 2-party password-based authenticated key exchange protocols between the server and each of the two parties. Since in this case, both the Find-Then-Guess and Real-Or-Random notions are equivalent, we opted to use their definition (i.e. FTG) adapted to our terminology. That is, we define  <span class="math">\\mathbf{Adv}_{\\mathrm{KD}}^{\\mathrm{ftg}-\\mathrm{kd}}(\\mathcal{A})</span>  as the</p>

    <p class="text-gray-300">advantage of adversary  <span class="math">\\mathcal{A}</span>  in violating the semantic security of a key distribution KD in the FTG sense, and  <span class="math">\\mathbf{Adv}_{\\mathrm{KD}}^{\\mathrm{ftg-kd}}(t,s,r)</span>  as the <strong>advantage function</strong> of KD, which is the maximum value of  <span class="math">\\mathbf{Adv}_{\\mathrm{KD}}^{\\mathrm{ftg-kd}}(\\mathcal{A})</span>  over all  <span class="math">\\mathcal{A}</span>  with time-complexity at most t, asking Send queries with respect to at most s sessions and asking at most t t t t t t t t t t</p>

    </section>

    <section id="app-c" class="mb-10">
      <h2 class="text-2xl font-bold">C Relations between notions</h2>

    <p class="text-gray-300">In this section, we prove the relation between the Find-Then-Guess (FTG) and Real-Or-Random (ROR) notions of security for authenticated key exchange protocols. The relation is not specific to password-based schemes, but its implications are more important in that scenario. We do not present proofs for the forward-secure case as these proofs can be easily derived from the proofs in the non-forward-secure case.</p>

    <p class="text-gray-300"><strong>Lemma 8.</strong> For any AKE,
<span class="math">$\\mathbf{Adv}_{\\mathsf{AKE}}^{\\mathsf{ftg-ake}}(t, q_{\\mathsf{send}}, q_{\\mathsf{reveal}}, q_{\\mathsf{exe}}) \\leq 2 \\cdot \\mathbf{Adv}_{\\mathsf{AKE}}^{\\mathsf{ror-ake}}(t, q_{\\mathsf{send}}, q_{\\mathsf{reveal}}, q_{\\mathsf{exe}}) + 1, q_{\\mathsf{exe}}</span>$
.</p>

    <p class="text-gray-300"><em>Proof.</em> In order to prove this lemma, we show how to build an adversary  <span class="math">\\mathcal{A}_{ror}</span>  against the semantic security of an authenticated key exchange AKE protocol in the ROR model given an adversary  <span class="math">\\mathcal{A}_{ftg}</span>  against the semantic security of the same protocol AKE in the FTG model. We know that  <span class="math">\\mathcal{A}_{ftg}</span>  has time-complexity at most t and that it asks at most  <span class="math">q_{send}</span> ,  <span class="math">q_{reveal}</span> , and  <span class="math">q_{exe}</span>  queries to its Send, Reveal, and Execute oracles, respectively.</p>

    <p class="text-gray-300">The description of  <span class="math">\\mathcal{A}_{ror}</span>  is as follows.  <span class="math">\\mathcal{A}_{ror}</span>  starts by choosing a bit b uniformly at random and starts running  <span class="math">\\mathcal{A}_{ftg}</span> . If  <span class="math">\\mathcal{A}_{ftg}</span>  asks a Send query, then  <span class="math">\\mathcal{A}_{ror}</span>  asks the corresponding query to its Send oracle. If  <span class="math">\\mathcal{A}_{ftg}</span>  asks a Execute query, then  <span class="math">\\mathcal{A}_{ror}</span>  asks the corresponding query to its Execute oracle. If  <span class="math">\\mathcal{A}_{ftg}</span>  asks a Reveal query, then  <span class="math">\\mathcal{A}_{ror}</span>  asks a Test query to its Test oracle and uses the answer it receives as the answer to the Reveal query. If  <span class="math">\\mathcal{A}_{ftg}</span>  asks a Test query, then  <span class="math">\\mathcal{A}_{ror}</span>  asks the corresponding query to its Test oracle. If b=1, then  <span class="math">\\mathcal{A}_{ror}</span>  uses the answer it received as the answer to the Test query. Otherwise, it returns a random key to  <span class="math">\\mathcal{A}_{ftg}</span> . Let b' be the final output of  <span class="math">\\mathcal{A}_{ftg}</span> . If b'=b, then  <span class="math">\\mathcal{A}_{ror}</span>  outputs 1. Otherwise, it outputs 0.</p>

    <p class="text-gray-300">Note that  <span class="math">A_{ror}</span>  has time-complexity at most t and asks at most  <span class="math">q_{send}</span> ,  <span class="math">q_{reveal} + 1</span> , and  <span class="math">q_{exe}</span>  queries to its Send, Test, and Execute oracles, respectively.</p>

    <p class="text-gray-300">In order to analyze the advantage of  <span class="math">\\mathcal{A}_{ror}</span> , first consider the case in which its  <span class="math">\\mathit{Test}</span>  oracle returns random keys. It is easy to see that, in this case,  <span class="math">\\mathcal{A}_{ftg}</span>  cannot gain any information about the hidden bit b used to answer its single  <span class="math">\\mathit{Test}</span> . Therefore, the probability that  <span class="math">\\mathcal{A}_{ror}</span>  is exactly  <span class="math">\\frac{1}{2}</span> . Now consider the case in which its  <span class="math">\\mathit{Test}</span>  oracle returns the actual sessions keys. In this case, the simulation of  <span class="math">\\mathit{Reveal}</span>  is perfect and  <span class="math">\\mathcal{A}_{ror}</span>  runs  <span class="math">\\mathcal{A}_{ftg}</span>  exactly as in the experiment defining the semantic security of  <span class="math">\\mathcal{A}_{ftg}</span>  in the FTG model. Therefore, the probability that  <span class="math">\\mathcal{A}_{ror}</span>  is exactly  <span class="math">\\frac{1}{2} + \\frac{1}{2} \\mathbf{Adv}_{\\mathsf{AKE}}^{\\mathsf{ftg-ake}}(\\mathcal{A}_{\\mathsf{ftg}})</span>  and, as a result,  <span class="math">\\mathbf{Adv}_{\\mathsf{AKE}}^{\\mathsf{ftg-ake}}(\\mathcal{A}_{\\mathsf{ftg}}) \\leq 2 \\cdot \\mathbf{Adv}_{\\mathsf{AKE}}^{\\mathsf{ror-ake}}(\\mathcal{A}_{\\mathsf{ror}}) \\leq \\mathbf{Adv}_{\\mathsf{AKE}}^{\\mathsf{ror-ake}}(t, q_{\\mathsf{send}}, q_{\\mathsf{reveal}} + 1, q_{\\mathsf{exe}})</span> . The lemma follows easily.</p>

    <p class="text-gray-300"><strong>Lemma 9.</strong> For any AKE,
<span class="math">$\\mathbf{Adv}_{\\mathsf{AKE}}^{\\mathsf{ror-ake}}(t, q_{\\mathsf{send}}, q_{\\mathsf{test}}, q_{\\mathsf{exe}}) \\leq q_{\\mathsf{test}} \\cdot \\mathbf{Adv}_{\\mathsf{AKE}}^{\\mathsf{ftg-ake}}(t, q_{\\mathsf{send}}, q_{\\mathsf{test}}, q_{\\mathsf{exe}})</span>$
.</p>

    <p class="text-gray-300"><em>Proof.</em> In order to prove this lemma, we show how to build a sequence of adversaries  <span class="math">\\mathcal{A}^i_{\\mathrm{ftg}}</span>  against the semantic security of an authenticated key exchange AKE protocol in the FTG model given an adversary  <span class="math">\\mathcal{A}_{\\mathrm{ror}}</span>  against the semantic security of the same protocol AKE in the ROR model. We know that  <span class="math">\\mathcal{A}_{\\mathrm{ror}}</span>  has time-complexity at most t and that it asks at most  <span class="math">q_{\\mathrm{send}}</span> ,  <span class="math">q_{\\mathrm{test}}</span> , and  <span class="math">q_{\\mathrm{exe}}</span>  queries to its Send, Test, and Execute oracles, respectively.</p>

    <p class="text-gray-300">The proof uses a standard hybrid argument, in which we define a sequence of  <span class="math">q_{\\text{test}} + 1</span>  hybrid experiments  <span class="math">V_i</span> , where  <span class="math">0 \\le i \\le q_{\\text{test}}</span> . In experiment  <span class="math">V_i</span> , the first i-1 queries to the</p>

    <p class="text-gray-300">Test oracle are answered using a random key and all remaining Test queries are answered using the real key. Please note that the hybrid experiments at the extremes correspond to the real and random experiments in the definition of semantic security in the ROR model. Hence, in order to prove the bound in the lemma, it suffices to prove that the difference in probability that adversary  <span class="math">\\mathcal{A}_{ror}</span>  returns 1 between any two consecutive experiments  <span class="math">V_i</span>  and  <span class="math">V_{i-1}</span>  is at most  <span class="math">\\mathbf{Adv}_{\\mathsf{AKE}}^{\\mathsf{ftg-ake}}(t, q_{\\mathsf{send}}, q_{\\mathsf{test}} - 1, q_{\\mathsf{exe}})</span> . This is achieved by building a sequence of  <span class="math">q_{\\mathsf{test}}</span>  adversaries  <span class="math">\\mathcal{A}_{\\mathsf{ftg}}^i</span> , as described below.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{A}_{\\mathrm{ftg}}^i</span>  be a distinguisher  <span class="math">\\mathcal{A}_{\\mathrm{ftg}}^i</span>  for experiments  <span class="math">V_i</span>  and  <span class="math">V_{i-1}</span> , where  <span class="math">1 \\leq i \\leq q_{\\mathrm{test}}</span> .  <span class="math">\\mathcal{A}_{\\mathrm{ftg}}^i</span>  starts running  <span class="math">\\mathcal{A}_{\\mathrm{ror}}</span>  answering to its queries as follows. If  <span class="math">\\mathcal{A}_{\\mathrm{ror}}</span>  asks a <em>Send</em> or <em>Execute</em> query, then  <span class="math">\\mathcal{A}_{\\mathrm{ftg}}</span>  answers it using its corresponding oracle. If  <span class="math">\\mathcal{A}_{\\mathrm{ror}}</span>  asks a <em>Test</em> query, then  <span class="math">\\mathcal{A}_{\\mathrm{ftg}}</span>  answers it with a random key if this query is among the first i-1. If this is the i-th Test, then  <span class="math">\\mathcal{A}_{\\mathrm{ftg}}</span>  uses its Test oracle to answer it. All remaining Test queries are answered using the output of the Reveal query.  <span class="math">\\mathcal{A}_{\\mathrm{ftg}}</span>  finishes its execution by outputting the same guess bit b outputted by  <span class="math">\\mathcal{A}_{\\mathrm{ror}}</span> .</p>

    <p class="text-gray-300">Note that  <span class="math">\\mathcal{A}_{\\mathrm{ftg}}^i</span>  has time-complexity at most t and asks at most  <span class="math">q_{\\mathrm{send}}</span> ,  <span class="math">q_{\\mathrm{test}}-1</span> , and  <span class="math">q_{\\mathrm{exe}}</span>  queries to its <em>Send</em>, <em>Reveal</em>, and <em>Execute</em> oracles, respectively.</p>

    <p class="text-gray-300">In order to analyze the advantage of  <span class="math">\\mathcal{A}^i_{\\mathrm{ftg}}</span> , first notice that when  <span class="math">\\mathit{Test}</span>  oracle returns a random key,  <span class="math">\\mathcal{A}^i_{\\mathrm{ftg}}</span>  runs  <span class="math">\\mathcal{A}_{\\mathrm{ror}}</span>  exactly as in the experiment  <span class="math">V_i</span> . Next, notice that when  <span class="math">\\mathit{Test}</span>  oracle returns the real key,  <span class="math">\\mathcal{A}^i_{\\mathrm{ftg}}</span>  runs  <span class="math">\\mathcal{A}_{\\mathrm{ror}}</span>  exactly as in the experiment  <span class="math">V_i</span> . It follows that the difference in probability that adversary  <span class="math">\\mathcal{A}_{\\mathrm{ror}}</span>  returns 1 between experiments  <span class="math">V_i</span>  and  <span class="math">V_{i-1}</span>  is at most  <span class="math">\\mathbf{Adv}^{\\mathrm{ftg-ake}}_{\\mathrm{AKE}}(\\mathcal{A}_{\\mathrm{ror}}) \\leq \\mathbf{Adv}^{\\mathrm{ftg-ake}}_{\\mathrm{AKE}}(t,q_{\\mathrm{send}},q_{\\mathrm{test}}-1,q_{\\mathrm{exe}})</span> . The lemma follows easily.</p>

    <p class="text-gray-300">Even though the reduction in Lemma 9 is not security-preserving (i.e., there is a non-constant factor loss in the reduction), it does not imply that a gap really exists&mdash; there might exist a tight reduction between the two notions that we have not yet found. In order to prove that the non-constant factor loss in the reduction is indeed intrinsic, we need to show that there exist schemes for which the gap does exist.</p>

    <p class="text-gray-300">To achieve this goal, one can use techniques similar to those used to prove that a gap exists between the Left-Or-Right and Find-Then-Guess notions of security for symmetric encryption schemes [3]. In that paper, they show how to construct a new symmetric encryption scheme  <span class="math">\\mathcal{E}&#x27;</span>  from a secure encryption scheme  <span class="math">\\mathcal{E}</span>  such that  <span class="math">\\mathcal{E}&#x27;</span>  exhibits the gap.  <span class="math">\\mathcal{E}&#x27;</span>  was constructed in such a way that its encryption function works like the encryption function of  <span class="math">\\mathcal{E}</span>  most of the time, except in a few cases (which are easily identifiable) in which the ciphertext it generates contains the plaintext. The probability in which such bad cases happen in their construction is exactly 1/q, where q is the non-constant factor in the reduction.</p>

    <p class="text-gray-300">A similar technique can be applied to authenticated key exchange protocols. Imagine a secure authenticated key exchange protocol AKE exists. For simplicity, assume  <span class="math">q_{\\rm test}=2^l</span> , for some integer l. We can construct a new scheme AKE' such that the session key k that it generates equals the one generated by AKE most of the time except when the first l bits are 0. In this case, we just make k=0. Using a proof technique similar to that used in [3], one can prove the the gap in Lemma 9 cannot be avoided and we thus omit the detail. But before stating our proposition, we make a final remark that when the underlying scheme AKE is a password-based key exchange, not every choice of parameters will yield the desired result claimed in the proposition. However, there are (easy) choices of parameters for which the gap does exist and that suffices for the purpose of the proposition. We are now ready to state our claim.</p>

    <p class="text-gray-300"><strong>Proposition 10.</strong> The gap exhibited in Lemma 9 is intrinsic and cannot be avoided.</p>

    </section>
`;
---

<BaseLayout title="Password-Based Authenticated Key Exchange in the Three-Party... (2004/233)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/233
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li>
          <a href="#sec-2" class="hover:text-white">Security models for 2-party password-based key exchange</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Communication model</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Security definitions</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">Security models for 3-party password-based key exchange</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">Protocol Syntax</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">Communication model</a></li>
            <li><a href="#sec-3.3" class="hover:text-white">Semantic security</a></li>
            <li><a href="#sec-3.4" class="hover:text-white">Key privacy with respect to the server</a></li>
          </ol>
        </li>
        <li><a href="#sec-4" class="hover:text-white">A generic three-party password-based protocol</a></li>
        <li><a href="#sec-5" class="hover:text-white">Concluding remarks</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li><a href="#app-a" class="hover:text-white">Proof of security for GPAKE</a></li>
        <li><a href="#app-b" class="hover:text-white">Building blocks</a></li>
        <li><a href="#app-c" class="hover:text-white">Relations between notions</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#acknowledgements" class="hover:text-white">Acknowledgements</a></li>
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="password-based-authenticated-key-exchange-in-the-three-2004" />
  </article>
</BaseLayout>
