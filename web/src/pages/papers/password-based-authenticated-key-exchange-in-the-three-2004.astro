---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/233';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Password-Based Authenticated Key Exchange in the Three-Party Setting';
const AUTHORS_HTML = 'Michel Abdalla, Pierre-Alain Fouque, David Pointcheval';

const CONTENT = `    <p class="text-gray-300">Michel Abdalla, Pierre-Alain Fouque, and David Pointcheval</p>

    <p class="text-gray-300">Departement d'Informatique Ecole ´ Normale Superieure ´ 45 Rue d'Ulm, 75230 Paris Cedex 05, France {Michel.Abdalla,Pierre-Alain.Fouque,David.Pointcheval}@ens.fr http://www.di.ens.fr/users/{mabdalla,fouque,pointche}.</p>

    <p class="text-gray-300"><strong>Abstract.</strong> Password-based authenticated key exchange are protocols which are designed to be secure even when the secret key or password shared between two users is drawn from a small set of values. Due to the low entropy of passwords, such protocols are always subject to online guessing attacks. In these attacks, the adversary may succeed with non-negligible probability by guessing the password shared between two users during its on-line attempt to impersonate one of these users. The main goal of password-based authenticated key exchange protocols is to restrict the adversary to this case only. In this paper, we consider password-based authenticated key exchange in the three-party scenario, in which the users trying to establish a secret do not share a password between themselves but only with a trusted server. Towards our goal, we recall some of the existing security notions for password-based authenticated key exchange protocols and introduce new ones that are more suitable to the case of generic constructions. We then present a natural generic construction of a three-party protocol, based on any two-party authenticated key exchange protocol, and prove its security without making use of the Random Oracle model. To the best of our knowledge, the new protocol is the first provably-secure password-based protocol in the three-party setting.</p>

    <p class="text-gray-300"><strong>Keywords.</strong> Password, authenticated key exchange, key distribution, multi-party protocols.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8"><strong>1 Introduction</strong></h3>

    <p class="text-gray-300"><strong>Motivation.</strong> A fundamental problem in cryptography is how to communicate securely over an insecure channel, which might be controlled by an adversary. It is common in this scenario for two parties to encrypt and authenticate their messages in order to protect the privacy and authenticity of these messages. One way of doing so is by using public-key encryption and signatures, but the cost associated with these primitives may be too high for certain applications. Another way of addressing this problem is by means of a key exchange protocol, in which users establish a common key which they can then use in their applications.</p>

    <p class="text-gray-300">In practice, one finds several flavors of key exchange protocols, each with its own benefits and drawbacks. Among the most popular ones is the 3-party <em>Kerberos</em> authentication system [31]. Another one is the 2-party SIGMA protocol [21] used as the basis for the signaturebased modes of the Internet Key Exchange (IKE) protocol. Yet another flavor of key exchange protocols which has received significant attention recently are those based on passwords.</p>

    <p class="text-gray-300">PASSWORD-BASED KEY EXCHANGE. Password-based authenticaded key exchange protocols assume a more realistic scenario in which secret keys are not uniformly distributed over a large space, but rather chosen from a small set of possible values (a four-digit pin, for example). They also seem more convenient since human-memorable passwords are simpler to use than, for example, having additional cryptographic devices capable of storing high-entropy secret keys. The vast majority of protocols found in practice do not account, however, for such scenario and are often subject to so-called <em>dictionary</em> attacks. Dictionary attacks are attacks in which an adversary tries to break the security of a scheme by a brute-force method, in which it tries all possible combinations of secret keys in a given small set of values (i.e., the dictionary). Even though these attacks are not very effective in the case of high-entropy keys, they can be very damaging when the secret key is a password since the attacker has a non-negligible chance of winning. Such attacks are usually divided in two categories: <em>off-line</em> and <em>online</em> dictionary attacks.</p>

    <p class="text-gray-300">To address this problem, several protocols have been designed to be secure even when the secret key is a password. The goal of these protocols is to restrict the adversary's success to on-line guessing attacks only. In these attacks, the adversary must be present and interact with the system in order to be able to verify whether its guess is correct. The security in these systems usually relies on a policy of invalidating or blocking the use of a password if a certain number of failed attempts has occurred.</p>

    <p class="text-gray-300">3-PARTY PASSWORD-BASED KEY EXCHANGE. Passwords are mostly used because they are easier to remember by humans than secret keys with high entropy. Consequently, users prefer to remember very few passwords but not many. However, in scenarios where a user wants to communicate with many other users, then the number of passwords that he or she would need to remember would be linear in the number of possible partners. In order to limit the number of passwords that each user needs to remember, we consider in this paper password-based authenticated key exchange in the 3-party model, where each user only shares a password with a trusted server. The main advantage of this solution is that it provides each user with the capability of communicating securely with other users in the system while only requiring it to remember a single password. This seems to be a more realistic scenario in practice than the one in which users are expected to share multiple passwords, one for each party with which it may communicate privately. Its main drawback is that the server is needed during the establishment of all communication as in the Needham and Schroeder protocol.</p>

    <p class="text-gray-300">KEY PRIVACY. One potential disadvantage of a 3-party model is that the privacy of the communication with respect to the server is not always guaranteed. Since we want to trust as little as possible the third party, we develop a new notion called key privacy which roughly means that, even though the server's help is required to establish a session key between two users in the system, the server should not be able to gain any information on the value of that session key. Here we assume that the server is honest but curious. Please note that key distribution schemes usually do <em>not</em> achieve this property.</p>

    <p class="text-gray-300">INSIDER ATTACKS. One of the main differences between the 2-party and the 3-party scenarios is the existence of insider attacks. To better understand the power of these attacks, consider the protocol in Figure 1, based on the encrypted key exchange of Bellovin and Merritt[8], in which the server simply decrypts the message it receives and re-encrypts it under the other user's password. In this protocol, it is easy to see that one can mount an off-line dictionary by simply playing the role of one of the involved parties. Notice that both A and B can obtain the necessary information to mount an off-line dictionary attack against each other simply by eavesdropping on the messages that are sent out by the server. More specifically, A and B can respectively learn the values  <span class="math">X_S^{\\star} = \\mathcal{E}_{PW_B}(X_S)</span>  and  <span class="math">Y_S^{\\star} = \\mathcal{E}_{PW_A}(Y_S)</span>  and mount a dictionary attack against each other using the fact that  <span class="math">X_S = X_A</span>  and  <span class="math">Y_S = Y_B</span> . Insider attacks do not need be considered explicitly in the case of 2-party protocols due to the independence among the passwords shared between pairs of honest users and those shared with malicious users.</p>

    <p class="text-gray-300">A NEW SECURITY MODEL. In order to analyze the security of 3-party password-based authenticated key exchange protocols, we put forward a new security model and define two notions of security: semantic security of the session key and key privacy with respect to the server. The first of these notions is the usual one and is a straight-forward generalization of the equivalent notion in the 2-party password-based authenticated key exchange model. The second one is new and particular to the new setting, and captures the privacy of the key with respect to the trusted server to which all passwords are known.</p>

    <p class="text-gray-300">Public information: <span class="math-block">\\mathbb{G}, g, p, \\mathcal{E}, \\mathcal{D}, H</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{cccccccccccccccccccccccccccccccccccc</span></div>

    <p class="text-gray-300">Fig. 1. An insecure 3-party password-based encrypted key exchange protocol.</p>

    <p class="text-gray-300">A GENERIC CONSTRUCTION. In this paper, we consider a generic construction of 3-party password-based protocol. Our construction is a natural one, building upon existing 2-party password-based key exchange and 3-party symmetric key distribution schemes, to achieve provable security in the strongest sense. Moreover, our construction is also modular in the sense that it can be broken into two parts, a 3-party password-based key distribution protocol and 2-party authenticated key exchange. The second part is only needed if key privacy with respect to the server is required.</p>

    <p class="text-gray-300">THE NEED FOR NEW SECURITY NOTIONS. Surprisingly, the proof of security for the new scheme <em>does not</em> follow from the usual security notions for the underlying schemes as one would expect and requires a <em>new</em> and <em>stronger</em> notion of security for the underlying 2-party password-based scheme (see Section 2). In fact, this new security notion is not specific to password-based schemes and is one of the main contributions of this paper. Fortunately, we observe that most existing 2-party password-based schemes do in fact satisfy this new property [10, 13, 19, 25]. More specifically, only a few small changes are required in their proof in order to achieve security in the new model. The bounds obtained in their proof remain essentially unchanged.</p>

    <p class="text-gray-300"><strong>Contributions.</strong> In this paper, we consider password-based (implicitly) authenticated key exchange in the 3-party model, where each user only shares a password with a trusted server.</p>

    <p class="text-gray-300">NEW SECURITY MODELS. Towards our goal, we put forth a new formal security model that is appropriate for the 3-party password-based authenticated key exchange scenario and give precise definitions of what it means for it to be secure. Our model builds upon those of Bellare and Rogaway [6, 7] for key distribution schemes and that of Bellare, Pointcheval, and Rogaway [4] for password-based authenticated key exchange.</p>

    <p class="text-gray-300">NEW SECURITY NOTIONS. We also present a new and stronger model for 2-party authenticated key exchange protocols, which we call the Real-Or-Random model. Our new model is provably stronger than the existing model, to which we refer to as the Find-Then-Guess model, in the sense that a scheme proven secure in the new model is also secure in the existing model. However, the reverse is not necessarily true due to an unavoidable non-constant factor loss in the reduction. Such losses in the reduction are extremely important in the case of password-based protocols.</p>

    <p class="text-gray-300">A GENERIC CONSTRUCTION IN THE STANDARD MODEL. We present a generic and natural framework for constructing a 3-party password-based authenticated key exchange protocol from any secure 2-party password-based one. We do so by combining a 3-party key distribution scheme, an authenticated Diffie-Hellman key exchange protocol, and the 2-party password-based authenticated key exchange protocol. The proof of security relies solely on the security properties of underlying primitives it uses and does not assume the Random Oracle model [5]. Hence, when appropriately instantiated, this construction yields a secure protocol in the standard model.</p>

    <p class="text-gray-300">A SEPARATION BETWEEN KEY DISTRIBUTION AND KEY EXCHANGE. In addition to semantic security of the session key, we present a new property, called key privacy, which is specific to key exchange protocols. This new notion captures in a quantitative way the idea that the session key shared between two instances should be only known to these two instances and no one else, including the trusted server.</p>

    <p class="text-gray-300"><strong>Related Work.</strong> Password-based authenticated key exchange has been extensively studied in the last few years [4, 9–13, 15–18, 20, 22–24, 26, 28, 32–35], with a portion of the work dealing with the subject of group key exchange and the vast majority dealing with different aspects of 2-party key exchange. Only a few of them (e.g., [11, 22, 32]) consider passwordbased protocols in the 3-party setting, but none of their schemes enjoys provable security. In fact, our generic construction seems to be the first provably-secure 3-party password-based authenticated key exchange protocol.</p>

    <p class="text-gray-300">Another related line of research is authenticated key exchange <em>in the</em> 3<em>-party setting</em>. The first work in this area is the protocol of Needham and Schroeder [27], which inspired the <em>Kerberos</em> distributed system. Later, Bellare and Rogaway introduced a formal security model in this scenario along with a construction of the first provably-secure symmetric-key-based key distribution scheme [7]. In this paper, we consider the special but important case in which the secret keys are drawn from a small set of values.</p>

    <p class="text-gray-300"><strong>Organization.</strong> In Section 2, we recall the existing security model for 2-party password-based authenticated key exchange and introduce a new one. Next, in Section 3, we introduce new models for 3-party password-based authenticated key exchange. Section 4 then presents our generic construction of a 3-party password-based authenticated key exchange protocol, called GPAKE, along with the security claims and suggestions on how to instantiate it. Some future extensions of this work are presented in Section 5. The proofs of security for GPAKE are given in Appendix A. Also in the appendix are the more detailed descriptions of the cryptographic primitives and assumptions on which GPAKE is based. We conclude by presenting some results in Appendix C regarding the relation between the existing security notions and the new ones being introduced in this paper.</p>

    <h2 id="sec-3" class="text-2xl font-bold"><strong>2 Security models for</strong> 2<strong>-party password-based key exchange</strong></h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A secure 2-party password-based key exchange is a 2PAKE protocol where the parties use their password in order to derive a common session key sk that will be used to build secure channels. Loosely speaking, such protocols are said to be secure against <em>dictionary attacks</em> if the advantage of an attacker in distinguishing a real session key from a random key is less than O(n/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + ε(k) where</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is the size of the dictionary D, n is the number of active sessions and ε(k) is a negligible function depending on the security parameter k.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this section, we recall the security model for 2-party password-based authenticated key exchange protocols introduced by Bellare, Pointcheval, and Rogaway (BPR) [4] and introduce a new one. For reasons that will soon become apparent, we refer to the new model as the Real-Or-Random (ROR) model and to the BPR model as the Find-Then-Guess (FTG) model, following the terminology of Bellare <em>et al.</em>for symmetric encryption schemes [3].</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6"><strong>2.1 Communication model</strong></h4>

    <p class="text-gray-300">PROTOCOL PARTICIPANTS. Each participant in the 2-party password-based key exchange is either a client C ∈ C or a server S ∈ S. The set of all users or participants U is the union C ∪ S.</p>

    <p class="text-gray-300">LONG-LIVED KEYS. Each client C ∈ C holds a password pw <sup>C</sup> . Each server S ∈ S holds a vector pw<sup>S</sup> = hpw<sup>S</sup> [C]iC∈C with an entry for each client, where pw<sup>S</sup> [C] is the transformedpassword, as defined in [4]. In a symmetric model, pw<sup>S</sup> [C] = pwC, but they may be different in some schemes. pw<sup>C</sup> and pw<sup>S</sup> are also called the long-lived keys of client C and server S.</p>

    <p class="text-gray-300">PROTOCOL EXECUTION. The interaction between an adversary A and the protocol participants occurs only via oracle queries, which model the adversary capabilities in a real attack. During the execution, the adversary may create several concurrent instances of a participant. These queries are as follows, where U <sup>i</sup> denotes the instance i of a participant U:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>–</strong> Execute(C i , S j ): This query models passive attacks in which the attacker eavesdrops on honest executions between a client instance C i and a server instance S j . The output of this query consists of the messages that were exchanged during the honest execution of the protocol.</li>

      <li><strong>–</strong> Send (U i , m): This query models an active attack, in which the adversary may intercept a message and then either modify it, create a new one, or simply forward it to the intended participant. The output of this query is the message that the participant instance U <sup>i</sup> would generate upon receipt of message m.</li>

    </ul>

    <h3 id="sec-5" class="text-xl font-semibold mt-8"><strong>2.2 Security definitions</strong></h3>

    <p class="text-gray-300">PARTNERING. We use the notion of partnering based on session identifications (<em>sid</em>), which says that two instances are partnered if they hold the same non-null <em>sid</em>. In practice, the <em>sid</em> is taken to be the partial transcript of the conversation between the client and the server instances before the acceptance.</p>

    <p class="text-gray-300">FRESHNESS. In order to properly formalize security notions for the session key, one has to be careful to avoid cases in which adversary can trivially break the security of the scheme. For example, an adversary who is trying to distinguish the session key of an instance U i from a random key can trivially do so if it obtains the key for that instance through a Reveal query (see definition below) to instance U <sup>i</sup> or its partner. Instead of explicitly defining a notion of freshness and mandating the adversary to only perform tests on <em>fresh</em> instances as in previous work, we opted to embed that notion inside the definition of the oracles.</p>

    <p class="text-gray-300"><strong>Semantic security in the Find-Then-Guess model.</strong> This is the definition currently being used in the literature. In order to measure the semantic security of the session key of user instance, the adversary is given access to two additional oracles: the Reveal oracle, which models the misuse of session keys by a user, and the Test oracle, which tries to capture the adversary's ability (or inability) to tell apart a real session key from a random one. Let b be a bit chosen uniformly at random at the beginning of the experiment defining the semantic security in the Find-Then-Guess model. These oracles are defined as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Reveal  <span class="math">(U^i)</span> : If a session key is not defined for instance  <span class="math">U^i</span>  or if a Test query was asked to either  <span class="math">U^i</span>  or to its partner, then return  <span class="math">\\bot</span> . Otherwise, return the session key held by the instance  <span class="math">U^i</span> .</li>

      <li><span class="math">Test(U^i)</span> : If no session key for instance  <span class="math">U^i</span>  is defined or if a <em>Reveal</em> query was asked to either  <span class="math">U^i</span>  or to its partner, then return the undefined symbol  <span class="math">\\bot</span> . Otherwise, return the session key for instance  <span class="math">U^i</span>  if b=1 or a random of key of the same size if b=0.</li>

    </ul>

    <p class="text-gray-300">The adversary in this case is allowed to ask multiple queries to the <em>Execute</em>, <em>Reveal</em>, and <em>Send</em> oracles, but it is restricted to ask only a <em>single</em> query to the <em>Test</em> oracle. The goal of the adversary is to guess the value of the hidden bit b used by the <em>Test</em> oracle. The adversary is considered successful if it guesses b correctly.</p>

    <p class="text-gray-300">Let SUCC denote the event in which the adversary is successful. The <strong>ftg-ake-advantage</strong> of an adversary  <span class="math">\\mathcal{A}</span>  in violating the semantic security of the protocol P in the Find-Then-Guess sense and the <strong>advantage function</strong> of the protocol P, when passwords are drawn from a dictionary  <span class="math">\\mathcal{D}</span> , are respectively</p>

    <p class="text-gray-300"><span class="math-block">\\mathbf{Adv}_{P,\\mathcal{D}}^{\\mathrm{ftg-ake}}(\\mathcal{A}) = 2 \\cdot \\Pr[\\,\\mathrm{SUCC}\\,] - 1;</span>  and</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Adv}_{P,\\mathcal{D}}^{\\mathrm{ftg-ake}}(t,R) = \\max_{\\mathcal{A}} \\{ \\, \\mathbf{Adv}_{P,\\mathcal{D}}^{\\mathrm{ftg-ake}}(\\mathcal{A}) \\, \\},</span></div>

    <p class="text-gray-300">where the maximum is over all  <span class="math">\\mathcal{A}</span>  with time-complexity at most t and using resources at most R (such as the number of queries to its oracles). The definition of time-complexity that we use henceforth is the usual one, which includes the maximum of all execution times in the experiments defining the security plus the code size [1]. Note that the advantage of an adversary that simply guesses the bit t0 in the above definition due to the rescaling of the probabilities.</p>

    <p class="text-gray-300"><strong>Semantic security in the Real-Or-Random model.</strong> This is a new definition. In the Real-Or-Random model, we only allow the adversary to ask <em>Execute</em>, <em>Send</em>, and <em>Test</em> queries. In other words, the <em>Reveal</em> oracle that exists in the Find-Then-Guess model is no longer available to the adversary. Instead, we allow the adversary to ask as many <em>Test</em> queries as it wants to different instances. All <em>Test</em> queries in this case will be answered using the same value for the hidden bit <em>b</em> that was chosen at the beginning. That is, the keys returned by the <em>Test</em> oracle are either all real or all random. However, in the random case, the same random key value should be returned for <em>Test</em> queries that are asked to two instances which are partnered. <em>P</em>lease note that the <em>Test</em> oracle is the oracle modeling the misuse of keys by a user in this case. The goal of the adversary is still the same: to guess the value of the hidden bit <em>b</em> used to answer <em>Test</em> queries. The adversary is considered successful if it guesses <em>b</em> correctly.</p>

    <p class="text-gray-300">Let SUCC denote the event in which the adversary is successful. The <strong>ror-ake-advantage</strong>  <span class="math">\\mathbf{Adv}^{\\mathrm{ror-ake}}_{P,\\mathcal{D}}(\\mathcal{A})</span>  of an adversary  <span class="math">\\mathcal{A}</span>  in violating the semantic security of the protocol P in the Real-Or-Random sense and the <strong>advantage function</strong>  <span class="math">\\mathbf{Adv}^{\\mathrm{ror-ake}}_{P,\\mathcal{D}}(t,R)</span>  of the protocol P are then defined as in the previous definition.</p>

    <p class="text-gray-300"><strong>Relation between notions.</strong> As we prove in Appendix C, the Real-Or-Random (ROR) security model is actually stronger than the Find-Then-Guess (FTG) security model. More specifically, we show that proofs of security in the ROR model can be easily translated into proofs of security in the FTG model with only a 2 factor loss in the reduction (see Lemma 8). The reverse, however, is not necessarily true since the reduction is not security preserving. There is a loss of non-constant factor in the reduction (see Lemma 9). Moreover, the loss in the reduction cannot be avoided as there exist schemes for which we can prove such a loss in security exists (see Proposition 10).</p>

    <p class="text-gray-300">7</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To better understand the gap between the two notions, imagine a password-based scheme that was proven secure in the FTG model. By definition, the advantage of any adversary is at most O(n/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)+ε(k), where n is the number of active sessions and ε(k) is a negligible term. By applying the reduction, we can show that no adversary can do better than O(n <sup>2</sup>/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)+n · ε(k), which is not enough to guarantee the security of the same scheme in the ROR model. Note that such a gap is not as important in the case where high-entropy keys are used since both terms in the expression would be negligible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As a consequence, we cannot take for granted the security of the existing schemes and new proofs of security need be provided. Fortunately, we would like to point out here that the security proof for several of the existing schemes can be easily modified to meet the new security goals with essentially the same bounds. The reason for that is that the security proofs of most existing password-based schemes in fact prove something stronger than what is required by the security model. More specifically, most proofs generally show that not only the session key being tested looks random, but all the keys that may be involved in a reveal query also look random to an adversary that does not know the secret password, thus satisfying the security requirements of our new model. In particular, this is the case for the KOY protocol [19] and its generalization [13], and some other schemes based on the encrypted key exchange scheme of Bellovin and Merritt [8] (e.g., [10, 25]).</p>

    <p class="text-gray-300">Since most existing password-based schemes do seem to achieve security in the new and stronger security model and since the latter appears to be more applicable to situations in which one wishes to use a password-based key exchange protocol as a black box, we suggest the use of our new model when proving the security of new password-based schemes.</p>

    <p class="text-gray-300">In this section, we put forward new formal security models for 3-party password-authenticated key exchange and key distribution protocols. Our models are generalizations of the model of Bellare and Rogaway [7] for 3-party key distribution schemes to the password case and that of Bellare, Pointcheval, and Rogaway [4] for 2-party password-based authenticated key exchange.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6"><strong>3.1 Protocol Syntax</strong></h4>

    <p class="text-gray-300">PROTOCOL PARTICIPANTS. Each participant in a 3-party password-based key exchange is either a client U ∈ U or a trusted server S ∈ S. The set of clients U is made up of two disjoint sets: C, the set of honest clients, and E, the set of malicious clients. For simplicity, and without loss of generality <sup>1</sup> , we assume the set S to contain only a single trusted server.</p>

    <p class="text-gray-300">The inclusion of the malicious set E among the participants is one the main differences between the 2-party and the 3-party models. Such inclusion is needed in the 3-party model in order to cope with the possibility of insider attacks. The set of malicious users did not need to be considered in the 2-party due to the independence among the passwords shared between pairs of honest participants and those shared with malicious users.</p>

    <p class="text-gray-300">LONG-LIVED KEYS. Each participant U ∈ U holds a password pw<sup>U</sup> . Each server S ∈ S holds a vector pw<sup>S</sup> = hpw<sup>S</sup> [U]iU∈U with an entry for each client, where pw<sup>S</sup> [U] is the transformed-password, following the definition in [4]. In a symmetric model, pw <sup>S</sup> [U] = pw<sup>U</sup> , but they may be different in some schemes. The set of passwords pw <sup>E</sup>, where E ∈ E, is assumed to be known by the adversary.</p>

    <p class="text-gray-300"><sup>1</sup> This is so because we are working in the concurrent model and because all servers in the general case know all users' passwords.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">3.2 Communication model</h4>

    <p class="text-gray-300">The interaction between an adversary A and the protocol participants occurs only via oracle queries, which model the adversary capabilities in a real attack. These queries are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Execute(U_1^{i_1}, S^j, U_2^{i_2})</span> : This query models passive attacks in which the attacker eavesdrops on honest executions among the client instances  <span class="math">U_1^{i_1}</span>  and  <span class="math">U_2^{i_2}</span>  and trusted server instance  <span class="math">S^j</span> . The output of this query consists of the messages that were exchanged during the honest execution of the protocol.</li>

      <li>SendClient( <span class="math">U^i, m</span> ): This query models an active attack, in which the adversary may intercept a message and then modify it, create a new one, or simply forward it to the intended client. The output of this query is the message that client instance  <span class="math">U^i</span>  would generate upon receipt of message m.</li>

      <li><span class="math">SendServer(S^j, m)</span> : This query models an active attack against a server. It outputs the message that server instance  <span class="math">S^j</span>  would generate upon receipt of message m.</li>

    </ul>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">3.3 Semantic security</h3>

    <p class="text-gray-300">The security definitions presented here build upon those of Bellare and Rogaway [6, 7] and that of Bellare, Pointcheval, and Rogaway [4].</p>

    <p class="text-gray-300">NOTATION. Following [6, 7], an instance  <span class="math">U^i</span>  is said to be <em>opened</em> if a query  <span class="math">Reveal(U^i)</span>  has been made by the adversary. We say an instance  <span class="math">U^i</span>  is unopened if it is not opened. Similarly, we say a participant U is corrupted if a query Corrupt(U) has been made by the adversary. A participant U is said to be uncorrupted if it is not corrupted. We say an instance  <span class="math">U^i</span>  has accepted if it goes into an accept mode after receiving the last expected protocol message.</p>

    <p class="text-gray-300">PARTNERING. Our definition of partnering follows that of [4], which uses session identifications (sid). More specifically, two instances  <span class="math">U_1^i</span>  and  <span class="math">U_2^j</span>  are said to be partners if the following conditions are met: (1) Both  <span class="math">U_1^i</span>  and  <span class="math">U_2^j</span>  accept; (2) Both  <span class="math">U_1^i</span>  and  <span class="math">U_2^j</span>  share the same session identifications; (3) The partner identification for  <span class="math">U_1^i</span>  is  <span class="math">U_2^j</span>  and vice-versa; and (4) No instance other than  <span class="math">U_1^i</span>  and  <span class="math">U_2^j</span>  accepts with a partner identification equal to  <span class="math">U_1^i</span>  or  <span class="math">U_2^j</span> . In practice, as in the 2-party case, the sid could be taken to be the partial transcript before the acceptance of the conversation among all the parties involved in the protocol, a solution which may require the forwarding of messages.</p>

    <p class="text-gray-300">FRESHNESS. As in the 2-party case, we opted to embed the notion of freshness inside the definition of the oracles.</p>

    <p class="text-gray-300">Semantic security in Find-Then-Guess model. This definition we give here is the straightforward generalization of that of Bellare, Pointcheval, and Rogaway [4] for the 2-party case, combined with ideas of the model of Bellare and Rogaway [7] for 3-party key distribution. As in the 2-party case, we also define a Reveal oracle to model the misuse of session keys and a Test oracle to capture the adversary's ability to distinguish a real session key from a random one. Let b be a bit chosen uniformly at random at the beginning of the experiment defining the semantic security in the Find-Then-Guess model. These oracles are defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Reveal(U^i)</span> : If a session key is not defined for instance  <span class="math">U^i</span>  or if a Test query was asked to either  <span class="math">U^i</span>  or to its partner, then return  <span class="math">\\bot</span> . Otherwise, return the session key held by the instance  <span class="math">U^i</span> .</li>

      <li><span class="math">Test(U^i)</span> : If no session key is defined for instance  <span class="math">U^i</span>  or if the intended partner of  <span class="math">U^i</span>  is part of the malicious set or if a <em>Reveal</em> query was asked to either  <span class="math">U^i</span>  or to its partner, then return the invalid symbol  <span class="math">\\bot</span> . Otherwise, return either the session key for instance  <span class="math">U^i</span>  if b=1 or a random of key of the same size if b=0.</li>

    </ul>

    <p class="text-gray-300">Consider an execution of the key exchange protocol P by an adversary A, in which the latter is given access to the <em>Reveal</em>, <em>Execute</em>, <em>SendClient</em>, <em>SendServer</em>, and <em>Test</em> oracles and asks a single <em>Test</em> query, and outputs a guess bit b'. Such an adversary is said to win the experiment defining the semantic security if b' = b, where b is the hidden bit used by the <em>Test</em> oracle.</p>

    <p class="text-gray-300">Let SUCC denote the event in which the adversary wins this game. The <strong>ftg-ake-advantage</strong>  <span class="math">\\mathbf{Adv}_{P,\\mathcal{D}}^{\\mathrm{ftg-ake}}(\\mathcal{A})</span>  of an adversary  <span class="math">\\mathcal{A}</span>  in violating the semantic security of the protocol P in the Find-Then-Guess sense and the <strong>advantage function</strong>  <span class="math">\\mathbf{Adv}_{P,\\mathcal{D}}^{\\mathrm{ftg-ake}}(t,R)</span>  of the protocol P are then defined as in previous definitions.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say a 3-party password-based key exchange protocol P is semantically secure in the Find-Then-Guess sense if the advantage  <span class="math">\\mathbf{Adv}_{P,\\mathcal{D}}^{\\mathrm{ftg-ake}}</span>  is only negligibly larger than  $kn/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , where n is number of active sessions and k is a constant. Note that k=1 in the best scenario since an adversary that simply guesses the password in each of the active sessions has an advantage of  </span>n/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Semantic security in Real-Or-Random model.</strong> This is a new definition. In the Real-Or-Random model, <em>Reveal</em> queries are no longer allowed and are replaced by <em>Test</em> queries. In this case, however, the adversary is allowed to ask as many <em>Test</em> queries as it wants.</p>

    <p class="text-gray-300">The modifications to the <em>Test</em> oracle are as follows. If a <em>Test</em> query is asked to a client instance that has not <em>accepted</em>, then return the undefined  <span class="math">\\bot</span> . If a <em>Test</em> query is asked to an instance of an honest client whose intended partner is dishonest or to an instance of a dishonest client, then return the real session key. Otherwise, the <em>Test</em> query returns either the real session key if b=1 and a random one if b=0, where b is the hidden bit selected at random prior to the first call. However, when b=0, the same random key value should be returned for <em>Test</em> queries that are asked to two instances which are partnered. The goal of the adversary is still the same: to guess the value of the hidden bit used by the <em>Test</em> oracle. The adversary is considered successful if it guesses b correctly.</p>

    <p class="text-gray-300">Consider an execution of the key exchange protocol P by an adversary A, in which the latter is given access to the Execute, SendClient, SendServer, and Test oracles, and outputs a guess bit b'. Such an adversary is said to win the experiment defining the semantic security in the ROR sense if b' = b, where b is the hidden bit used by the Test oracle. Let SUCC denote the event in which the adversary wins this game. The  <span class="math">\\mathbf{ror}</span> -ake-advantage  <span class="math">\\mathbf{Adv}_{P,\\mathcal{D}}^{\\mathrm{ror}</span> -ake}( <span class="math">\\mathcal{A}</span> ) of an adversary  <span class="math">\\mathcal{A}</span>  in violating the semantic security of the protocol P in the Real-Or-Random sense and the advantage function  <span class="math">\\mathbf{Adv}_{P,\\mathcal{D}}^{\\mathrm{ror}</span> -ake}(t,R) of the protocol P are then defined as in previous definitions.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">3.4 Key privacy with respect to the server</h4>

    <p class="text-gray-300">Differently from previous work, we define the notion of key privacy to capture, in a quantitative way, the idea that the session key shared between two instances should only be known to these two instances and no one else, including the trusted server. The goal of this new notion is to limit the amount of trust put into the server. That is, even though we rely on the server to help clients establish session keys between themselves, we still want to guarantee the privacy of these session keys with respect to the server. In fact, this is the main difference between a key distribution protocol (in which the session key is known to the server) and a key exchange protocol (for which the session key remains unknown to the server).</p>

    <p class="text-gray-300">In defining the notion of key privacy, we have in mind a server which knows the passwords for all users, but that behaves in an honest but curious manner. For this reason, we imagine an adversary who has access to all the passwords as well as to the <em>Execute</em> and <em>SendClient</em> oracles but not to a <em>Reveal</em> oracle or to a <em>SendServer</em> oracle, since the latter can be easily</p>

    <p class="text-gray-300">simulated using the passwords. To capture the adversary's ability to tell apart the real session key shared between any two instances from a random one, we also introduce a new type of oracle, called <em>TestPair</em>, defined as follows, where <em>b</em> is a bit chosen uniformly at random at the beginning of the experiment defining the notion of key privacy.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">TestPair(U_1^i, U_2^j)</span> : If client instances  <span class="math">U_1^i</span>  and  <span class="math">U_2^j</span>  do not share the same key, then return the undefined symbol  <span class="math">\\bot</span> . Otherwise, return the real session key shared between client instances  <span class="math">U_1^i</span>  and  <span class="math">U_2^j</span>  if b=1 or a random key of the same size if b=0.</li>

    </ul>

    <p class="text-gray-300">Consider an execution of the key exchange protocol P by an adversary A with access to the Execute, SendClient, and TestPair oracles and the passwords of all users, and let b' be its output. Such an adversary is said to win the experiment defining the key privacy if b'=b, where b is the hidden bit used by the TestPair oracle. Let SUCC denote the event in which the adversary guesses b correctly. We can then define the  <span class="math">\\mathbf{kp-advantage}</span>   <span class="math">\\mathbf{Adv}_{P,\\mathcal{D}}^{\\mathrm{kp-ake}}(\\mathcal{A})</span>  of  <span class="math">\\mathcal{A}</span>  in violating the key privacy of the key exchange protocol P and the  <span class="math">\\mathbf{advantage}</span>  function  <span class="math">\\mathbf{Adv}_{P,\\mathcal{D}}^{\\mathrm{kp-ake}}(t,R)</span>  of P as in previous definitions.</p>

    <p class="text-gray-300">Finally, we say an adversary  <span class="math">\\mathcal{A}</span>  succeeds in breaking the key privacy of a protocol P if  <span class="math">\\mathbf{Adv}_{P,\\mathcal{D}}^{\\mathrm{kp-ake}}(\\mathcal{A})</span>  is non-negligible.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">4 A generic three-party password-based protocol</h3>

    <p class="text-gray-300">In this section, we introduce a generic construction of a 3-party password-based key exchange protocol in the scenario in which we have an <em>honest-but-curious</em> server. It combines a 2-party password-based key exchange, a secure key distribution protocol and a 2-party MAC-based key exchange and has several attractive features. First, it does not assume the Random Oracle (RO) model [5]. That is, if the underlying primitives do not make use of the RO model, neither does our scheme. Hence, by using schemes such as the KOY protocol [19] for the 2-party password-based key exchange and the 3-party key distribution scheme in [7], one gets a 3-part password-based protocol whose security is in the standard model. Second, if 2-party password-based key exchange protocols already exist between the server and its users in a distributed system, they can be re-used in the construction of our 3-party password-based key exchange.</p>

    <p class="text-gray-300"><strong>Description of the generic solution.</strong> Our generic construction can be seen as a form of compiler transforming any secure 2-party password-based key exchange protocol P into a secure password-based 3-party key exchange protocol P' in the <em>honest-but-curious</em> security model using a secure key distribution KD, a secure MAC scheme, and generic number-theoretic operations in a group  <span class="math">\\mathbb{G}</span>  for which the DDH assumption holds (see Appendix B).</p>

    <p class="text-gray-300">The compiler, depicted in Figure 2, works as follows. First, we use the protocol P between a user A and the server S to establish a secure high-entropy session key  <span class="math">sk_A</span> . Second, we use the protocol P between the server S and the user B in order to establish a session key  <span class="math">sk_B</span> . Third, using a key distribution KD, we have the server S first select a MAC key  <span class="math">k_m</span> , using the key generation of the latter, and then distribute this key to A and B using the session keys  <span class="math">sk_A</span>  and  <span class="math">sk_B</span> , respectively, generated in the first two steps. Finally, S and S use a MAC-based key exchange to establish a session key CDH in an authenticated way.</p>

    <p class="text-gray-300">Semantic security in the Real-Or-Random model. As the following theorem states, the generic scheme GPAKE depicted in Figure 2 is a secure 3-party password-based key exchange protocol as long as the Decisional Diffie-Hellman assumption holds in  <span class="math">\\mathbb{G}</span>  and the underlying primitives it uses are secure.</p>

    <p class="text-gray-300"><img src="_page_10_Figure_1.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Fig. 2. GPAKE: a generic three-party password-based key exchange</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> Let 2PAKE be a secure 2-party password-based Key Exchange, KD be a secure key distribution, and MAC be a secure MAC algorithm. Let  <span class="math">q_{\\rm exe}</span>  and  <span class="math">q_{\\rm test}</span>  represent the number of queries to Execute and Test oracles, and let  <span class="math">q_{\\rm send}^A</span> ,  <span class="math">q_{\\rm send}^B</span> ,  <span class="math">q_{\\rm kd}</span> , and  <span class="math">q_{\\rm ake}</span>  represent the number of queries to the SendClient and SendServer oracles with respect to each of the two 2PAKE protocols, the KD protocol, and the final AKE protocol. Then,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\mathbf{Adv}_{\\mathsf{GPAKE},\\mathcal{D}}^{\\mathsf{ror-ake}}(t,q_{\\mathsf{exe}},q_{\\mathsf{test}},q_{\\mathsf{send}}^A,q_{\\mathsf{send}}^B,q_{\\mathsf{kd}},q_{\\mathsf{ake}}) &amp;\\leq \\\\ &amp;4 \\cdot (q_{\\mathsf{exe}} + q_{\\mathsf{kd}}) \\cdot \\mathbf{Adv}_{\\mathsf{KD}}^{\\mathsf{ftg-kd}}(t,1,0) + \\ 2 \\cdot q_{\\mathsf{ake}} \\cdot \\mathbf{Adv}_{\\mathsf{MAC}}^{\\mathsf{euf-cma}}(t,2,0) \\\\ &amp;+ 2 \\cdot \\mathbf{Adv}_{\\mathbb{G}}^{\\mathsf{ddh}}(t + 8(q_{\\mathsf{exe}} + q_{\\mathsf{ake}})\\tau_e) + 4 \\cdot \\mathbf{Adv}_{\\mathsf{2PAKE},\\mathcal{D}}^{\\mathsf{ror-ake}}(t,q_{\\mathsf{exe}},q_{\\mathsf{exe}} + q_{\\mathsf{send}}^A,q_{\\mathsf{send}}^A) \\\\ &amp;+ 4 \\cdot \\mathbf{Adv}_{\\mathsf{2PAKE},\\mathcal{D}}^{\\mathsf{ror-ake}}(t,q_{\\mathsf{exe}},q_{\\mathsf{exe}} + q_{\\mathsf{send}}^B,q_{\\mathsf{send}}^B) \\;, \\end{split}</span></div>

    <p class="text-gray-300">where  <span class="math">\\tau_e</span>  denotes the exponentiation computational time in  <span class="math">\\mathbb{G}</span> .</p>

    <p class="text-gray-300">Key privacy with respect to the server. As the following theorem states, the generic scheme GPAKE depicted in Figure 2 has key privacy with respect to the server as long as the Decisional Diffie-Hellman assumption holds in  <span class="math">\\mathbb{G}</span> .</p>

    <p class="text-gray-300"><strong>Theorem 2.</strong> Let GPAKE be the 3-party password-based authenticated key exchange scheme depicted in Figure 2. Then,</p>

    <p class="text-gray-300"><span class="math-block">\\mathbf{Adv}^{\\mathrm{kp-ake}}_{\\mathsf{GPAKE},\\mathcal{D}}(t,q_{\\mathrm{exe}},q_{\\mathrm{test}},q_{\\mathrm{send}}^A,q_{\\mathrm{send}}^B,q_{\\mathrm{kd}},q_{\\mathrm{ake}}) \\leq 2 \\cdot \\mathbf{Adv}^{\\mathsf{ddh}}_{\\mathbb{G}}(t&#x27;) ,</span> where  <span class="math">t&#x27; = t + 8 \\cdot (q_{\\mathrm{exe}} + q_{\\mathrm{ake}}) \\cdot \\tau_e</span>  and the other parameters are defined as in Theorem 1.</p>

    <p class="text-gray-300"><strong>Instantiations.</strong> Several practical schemes can be used in the instantiation of the 2-party password-based key exchange of our generic construction. Among them are the KOY protocol [19] and its generalization [13], the PAK suite [25], and several other schemes based on the encrypted key exchange scheme of Bellovin and Merritt [8] (e.g., [10]).</p>

    <p class="text-gray-300">In the instantiation of the key distribution scheme, one could use the original proposal in [7] or any other secure key distribution scheme. In particular, the server could use a chosen-ciphertext secure symmetric encryption scheme to distribute the keys to the users. Independently of the choice, one should keep in mind that the security requirements for the key distribution scheme are very weak. It only needs to provide security with respect to one session.</p>

    <p class="text-gray-300">For the instantiation of the MAC, any particular choice that makes the MAC term in Theorem 1 negligible will do. Possible choices are the HMAC [2] or the CBC MAC.</p>

    <p class="text-gray-300">It is important to notice that, in order for GPAKE to be secure, the underlying 2-party password-based protocol <em>must</em> be secure in the ROR model. A 2-party password-based secure in the FTG model does not suffice to prove the security of GPAKE.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8"><strong>5 Concluding remarks</strong></h3>

    <p class="text-gray-300">AUTHENTICATION. In order to take (explicit) authentication into account, one can easily extend our model using definitions similar to those of Bellare <em>et al.</em> [4] for unilateral or mutual authentication. In their definition, an adversary is said to break authentication if it succeeds in making any oracle instance terminate the protocol without a partner oracle. Likewise, one could also use their generic transformation to enhance our generic construction so that it provides unilateral or mutual authentication. The drawback of using their generic transformation is that it requires the random oracle model.</p>

    <p class="text-gray-300">MORE EFFICIENT CONSTRUCTIONS. Even though the generic construction presented in this paper is quite practical, more efficient solutions are possible. One example of such an improvement is a generic construction in which the key distribution and the final key exchange phases are combined into a single phase. One can easily think of different solutions for this scenario that are more efficient that the one we give. However, the overall gain in efficiency would not be very significant since the most expensive part of these two phases, the Diffie-Hellman protocol, seems to be necessary if key privacy with respect to the server is to be achieved. Perhaps the best way to improve the efficiency of 3-party password-based schemes is to adapt specific solutions in the 2-party model to the 3-party model, instead of treating these schemes as black boxes.</p>

    <p class="text-gray-300">RELATION TO SIMULATION MODELS. In [29], the Find-Then-Guess model of [7] is shown to be equivalent to simulation models in the sense that a scheme that is proven secure in one model is also secure in the other model. By closely examining their proof, one can easily see that the equivalence does not apply to the case of password-based protocols due to the non-security-preserving reduction. It seems, however, that their proof of equivalence can be adapted to show the equivalence between the simulation model and the Real-Or-Random model that we introduce in this paper in the case of password-based protocols. This is also the subject of ongoing work.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6"><strong>Acknowledgements</strong></h4>

    <p class="text-gray-300">The work described in this document has been supported in part by the European Commission through the IST Programme under Contract IST-2002-507932 ECRYPT. The information in this document reflects only the author's views, is provided as is and no guarantee or warranty is given that the information is fit for any particular purpose. The user thereof uses the information at its sole risk and liability</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8"><strong>References</strong></h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. M. Abdalla, M. Bellare, and P. Rogaway. The oracle Diffie-Hellman assumptions and an analysis of DHIES. In D. Naccache, editor, <em>CT-RSA 2001</em>, volume 2020 of <em>LNCS</em>, pages 143–158. Springer-Verlag, Apr. 2001.</li>

      <li>2. M. Bellare, R. Canetti, and H. Krawczyk. Keying hash functions for message authentication. In N. Koblitz, editor, <em>CRYPTO'96</em>, volume 1109 of <em>LNCS</em>, pages 1–15. Springer-Verlag, Aug. 1996.</li>

      <li>3. M. Bellare, A. Desai, E. Jokipii, and P. Rogaway. A concrete security treatment of symmetric encryption. In <em>38th FOCS</em>, pages 394–403. IEEE Computer Society Press, Oct. 1997.</li>

      <li>4. M. Bellare, D. Pointcheval, and P. Rogaway. Authenticated key exchange secure against dictionary attacks. In B. Preneel, editor, <em>EUROCRYPT 2000</em>, volume 1807 of <em>LNCS</em>, pages 139–155. Springer-Verlag, May 2000.</li>

      <li>5. M. Bellare and P. Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In <em>ACM CCS 93</em>, pages 62–73. ACM Press, Nov. 1993.</li>

      <li>6. M. Bellare and P. Rogaway. Entity authentication and key distribution. In D. R. Stinson, editor, <em>CRYPTO'93</em>, volume 773 of <em>LNCS</em>. Springer-Verlag, Aug. 1994.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>7. M. Bellare and P. Rogaway. Provably secure session key distribution the three party case. In <em>28th ACM STOC</em>, pages 57–66. ACM Press, May 1996.</li>

      <li>8. S. M. Bellovin and M. Merritt. Encrypted key exchange: Password-based protocols secure against dictionary attacks. In <em>1992 IEEE Symposium on Security and Privacy</em>, pages 72–84. IEEE Computer Society Press, May 1992.</li>

      <li>9. V. Boyko, P. MacKenzie, and S. Patel. Provably secure password-authenticated key exchange using Diffie-Hellman. In B. Preneel, editor, <em>EUROCRYPT 2000</em>, volume 1807 of <em>LNCS</em>, pages 156–171. Springer-Verlag, May 2000.</li>

      <li>10. E. Bresson, O. Chevassut, and D. Pointcheval. New security results on encrypted key exchange. In F. Bao, R. Deng, and J. Zhou, editors, <em>PKC 2004</em>, volume 2947 of <em>LNCS</em>, pages 145–158. Springer-Verlag, Mar. 2004.</li>

      <li>11. J. W. Byun, I. R. Jeong, D. H. Lee, and C.-S. Park. Password-authenticated key exchange between clients with different passwords. In R. H. Deng, S. Qing, F. Bao, and J. Zhou, editors, <em>ICICS 02</em>, volume 2513 of <em>LNCS</em>, pages 134–146. Springer-Verlag, Dec. 2002.</li>

      <li>12. Y. Ding and P. Horster. Undetectable on-line password guessing attacks. <em>ACM SIGOPS Operating Systems Review</em>, 29(4):77–86, Oct. 1995.</li>

      <li>13. R. Gennaro and Y. Lindell. A framework for password-based authenticated key exchange. In E. Biham, editor, <em>EUROCRYPT 2003</em>, volume 2656 of <em>LNCS</em>, pages 524–543. Springer-Verlag, May 2003. http: //eprint.iacr.org/2003/032.ps.gz.</li>

      <li>14. O. Goldreich. <em>Foundations of Cryptography: Basic Tools</em>, volume 1. Cambridge University Press, Cambridge, UK, 2001.</li>

      <li>15. O. Goldreich and Y. Lindell. Session-key generation using human passwords only. In J. Kilian, editor, <em>CRYPTO 2001</em>, volume 2139 of <em>LNCS</em>, pages 408–432. Springer-Verlag, Aug. 2001. http://eprint. iacr.org/2000/057.ps.gz.</li>

      <li>16. L. Gong. Optimal authentication protocols resistant to password guessing attacks. In <em>CSFW'95: The 8th IEEE Computer Security Foundation Workshop</em>, pages 24–29, Kenmare, County Kerry, Ireland, Mar. 13–15, 1995. IEEE Computer Society.</li>

      <li>17. L. Gong, T. M. A. Lomas, R. M. Needham, and J. H. Saltzer. Protecting poorly chosen secrets from guessing attacks. <em>IEEE JSAC</em>, 11(5):648–656, June 1993.</li>

      <li>18. S. Halevi and H. Krawczyk. Public-key cryptography and password protocols. In <em>ACM Transactions on Information and System Security</em>, pages 524–543. ACM, 1999.</li>

      <li>19. J. Katz, R. Ostrovsky, and M. Yung. Efficient password-authenticated key exchange using human-memorable passwords. In B. Pfitzmann, editor, <em>EUROCRYPT 2001</em>, volume 2045 of <em>LNCS</em>, pages 475–494. Springer-Verlag, May 2001.</li>

      <li>20. J. Kim, S. Kim, J. Kwak, and D. Won. Cryptanalysis and improvement of password authenticated key exchange scheme between clients with different passwords. In A. Lagan, M. L. Gavrilova, V. Kumar, Y. Mun, C. J. K. Tan, and O. Gervasi, editors, <em>ICCSA 04</em>, volume 3043 of <em>LNCS</em>, pages 895–902. Springer-Verlag, May 2004.</li>

      <li>21. H. Krawczyk. SIGMA: The "SIGn-and-MAc" approach to authenticated Diffie-Hellman and its use in the ike protocols. In D. Boneh, editor, <em>CRYPTO 2003</em>, volume 2729 of <em>LNCS</em>, pages 400–425. Springer-Verlag, Aug. 2003.</li>

      <li>22. C.-L. Lin, H.-M. Sun, and T. Hwang. Three-party encrypted key exchange: Attacks and a solution. <em>ACM SIGOPS Operating Systems Review</em>, 34(4):12–20, Oct. 2000.</li>

      <li>23. C.-L. Lin, H.-M. Sun, M. Steiner, and T. Hwang. Three-party encrypted key exchange without server publickeys. <em>IEEE Communications Letters</em>, 5(12):497–499, Dec. 2001.</li>

      <li>24. P. MacKenzie, S. Patel, and R. Swaminathan. Password-authenticated key exchange based on RSA. In T. Okamoto, editor, <em>ASIACRYPT 2000</em>, volume 1976 of <em>LNCS</em>, pages 599–613. Springer-Verlag, Dec. 2000.</li>

      <li>25. P. D. MacKenzie. The PAK suite: Protocols for password-authenticated key exchange. Contributions to IEEE P1363.2, 2002.</li>

      <li>26. P. D. MacKenzie, T. Shrimpton, and M. Jakobsson. Threshold password-authenticated key exchange. In M. Yung, editor, <em>CRYPTO 2002</em>, volume 2442 of <em>LNCS</em>, pages 385–400. Springer-Verlag, Aug. 2002.</li>

      <li>27. R. Needham and M. Schroeder. Using encryption for authentication in large networks of computers. <em>Communications of the ACM</em>, 21(21):993–999, Dec. 1978.</li>

      <li>28. M. D. Raimondo and R. Gennaro. Provably secure threshold password-authenticated key exchange. In E. Biham, editor, <em>EUROCRYPT 2003</em>, volume 2656 of <em>LNCS</em>, pages 507–523. Springer-Verlag, May 2003.</li>

      <li>29. V. Shoup. On formal models for secure key exchange. Technical Report RZ 3120, IBM, 1999.</li>

      <li>30. V. Shoup. OAEP reconsidered. In J. Kilian, editor, <em>CRYPTO 2001</em>, volume 2139 of <em>LNCS</em>, pages 239–259. Springer-Verlag, Aug. 2001.</li>

      <li>31. J. G. Steiner, B. C. Neuman, and J. L. Schiller. Kerberos: An authentication service for open networks. In <em>Proceedings of the USENIX Winter Conference</em>, pages 191–202, Dallas, TX, USA, 1988.</li>

      <li>32. M. Steiner, G. Tsudik, and M. Waidner. Refinement and extension of encrypted key exchange. <em>ACM SIGOPS Operating Systems Review</em>, 29(3):22–30, July 1995.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>33. G. Tsudik and E. Van Herreweghen. Some remarks on protecting weak keys and poorly-chosen secrets from guessing attacks. In <em>SRDS'93: The 12th Symposium on Reliable Distributed Systems</em>, pages 136–142, Princeton, New Jersey, USA, Oct. 6–8, 1993. IEEE Computer Society.</li>

      <li>34. S. Wang, J. Wang, and M. Xu. Weaknesses of a password-authenticated key exchange protocol between clients with different passwords. In M. Jakobsson, M. Yung, and J. Zhou, editors, <em>ACNS 04</em>, volume 3089 of <em>LNCS</em>, pages 414–425. Springer-Verlag, June 2004.</li>

      <li>H.-T. Yeh, H.-M. Sun, and T. Hwang. Efficient three-party authentication and key agreement protocols resistant to password guessing attacks. <em>Journal of Information Science and Engineering</em>, 19(6):1059–1070, Nov. 2003.</li>

    </ul>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">A Proof of security for GPAKE</h3>

    <p class="text-gray-300">Semantic security of GPAKE in the ROR model. Without loss of generality, we assume the set of honest users contains only users A and B. The solution can be easily extended to the more general case with essentially the same bounds.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal A</span>  be an adversary against the semantic security of GPAKE in the Real-Or-Random sense with time-complexity at most t, and asking at most  <span class="math">q_{\\rm exe}</span>  queries to its <em>Execute</em> oracle,  <span class="math">q_{\\rm test}</span>  queries to its <em>Test</em> oracle,  <span class="math">q_{\\rm send}^A</span>  queries to <em>SendClient</em> and <em>SendServer</em> oracles with respect to the 2PAKE protocol between A and the trusted server S,  <span class="math">q_{\\rm send}^B</span>  queries with respect to the 2PAKE protocol between B and B, B0 queries with respect to the KD protocol, and B1 queries with respect to the final authenticated key exchange protocol.</p>

    <p class="text-gray-300">Our proof consists of a sequence of hybrid experiments, starting with the real attack against GPAKE scheme and ending in an experiment in which the adversary's advantage is 0, and for which we can bound the difference in the adversary's advantage between any two consecutive experiments. For each experiment  <span class="math">\\mathbf{Exp}_n</span> , we define an event  <span class="math">\\mathrm{Succ}_n</span>  corresponding to the case in which the adversary correctly guesses the hidden bit b involved in the Test queries (see Section 3).</p>

    <p class="text-gray-300"><strong>Experiment Exp</strong> <span class="math">_0</span> . This experiment corresponds to the real attack. By definition, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Adv}_{\\mathsf{GPAKE},\\mathcal{D}}^{\\mathsf{ror-ake}}(\\mathcal{A}) = 2 \\cdot \\Pr[\\mathsf{SUCC}_0] - 1 \\tag{1}</span></div>

    <p class="text-gray-300"><strong>Experiment</strong>  <span class="math">\\mathbf{Exp}_1</span> . We now modify the simulation of the oracles as follows. We replace the session key  <span class="math">sk_A</span>  used as input to the KD protocol by a random session key  <span class="math">sk_A&#x27;</span>  in all of the sessions. As the following lemma shows, the difference between the success probability of the adversary  <span class="math">\\mathcal{A}</span>  between the current and previous experiments is at most that of breaking the security of the underlying 2PAKE protocol between A and S.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\textbf{Lemma 3.} \\ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\, \\text{SUCC}_1 \\,] - \\Pr[\\, \\text{SUCC}_0 \\,] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2 \\cdot \\mathbf{Adv}^{\\text{ror-ake}}_{2\\mathsf{PAKE},\\mathcal{D}}(t,q_{\\text{exe}},q_{\\text{exe}} + q_{\\text{send}}^A,q_{\\text{send}}^A) \\ .$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">\\mathcal{A}_1</span>  be a distinguisher for experiments  <span class="math">\\mathbf{Exp}_1</span>  and  <span class="math">\\mathbf{Exp}_0</span> . We can build an adversary  <span class="math">\\mathcal{A}_{\\mathsf{pake}}</span>  against the semantic security of the 2PAKE protocol between A and S using  <span class="math">\\mathcal{A}_1</span>  as follows.  <span class="math">\\mathcal{A}_{\\mathsf{pake}}</span>  starts by choosing a bit b uniformly at random and selecting the passwords for all users in the system except A according to the distribution of  <span class="math">\\mathcal{D}</span> . Next, it starts running  <span class="math">\\mathcal{A}_1</span> , giving it the passwords for all the malicious clients in the system, and answering to its oracle queries as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>SendClient and SendServer queries. If  <span class="math">\\mathcal{A}_1</span>  asks a SendClient or SendServer query pertaining to an instance of the 2PAKE protocol between B and S, then  <span class="math">\\mathcal{A}_{\\mathsf{pake}}</span>  can answer it using the password of client B that it has picked at the beginning of its execution. If the SendClient or SendServer query pertains to an instance of the 2PAKE protocol between A and S, then  <span class="math">\\mathcal{A}_{\\mathsf{pake}}</span>  can answer it by asking the corresponding query to its Send oracle. If this query forces the given instance of client A or S to accept or reject, then we also</li>

    </ul>

    <p class="text-gray-300">ask a <em>Test</em> query to that instance (unless <em>Test</em> query had already been asked to its partner). The output of this <em>Test</em> query will be used to simulate the key distribution and final key exchange phases of the protocol. All the other <em>SendClient</em> and <em>SendServer</em> queries by  <span class="math">\\mathcal{A}_1</span>  can be easily answered either using the output of the <em>Test</em> queries made to instances of A or S or the session keys computed in the execution of the 2PAKE protocol between A and B.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Execute queries.  <span class="math">A_{pake}</span>  can easily answer these queries using its own Execute oracle and the output of the Test queries.</li>

      <li>Test queries.  <span class="math">A_{pake}</span>  can easily answer these queries using the bit b that it has previously selected and the session keys that it has computed.</li>

    </ul>

    <p class="text-gray-300">Let b' be the output of  <span class="math">A_1</span> . If b' = b, then  <span class="math">A_{pake}</span>  outputs 1. Otherwise, it outputs 0.</p>

    <p class="text-gray-300">One can easily see that the probability that  <span class="math">\\mathcal{A}_{\\text{pake}}</span>  outputs 1 when its Test oracle returns real keys is exactly the probability that  <span class="math">\\mathcal{A}_1</span>  returns 1 in experiment  <span class="math">\\mathbf{Exp}_0</span> . Similarly, the probability that  <span class="math">\\mathcal{A}_{\\text{pake}}</span>  outputs 1 when its Test oracle returns random keys is exactly the probability that  <span class="math">\\mathcal{A}_1</span>  returns 1 in experiment  <span class="math">\\mathbf{Exp}_1</span> . The lemma follows by noticing that  <span class="math">\\mathcal{A}_{\\text{pake}}</span>  has at most time-complexity t and asks at most  <span class="math">q_{\\text{exe}} + q_{\\text{send}}^A</span>  queries to its Test oracle, at most  <span class="math">q_{\\text{exe}}</span>  queries to its Execute oracle, and at most  <span class="math">q_{\\text{send}}^A</span>  queries to its Send oracle.</p>

    <p class="text-gray-300"><strong>Experiment</strong>  <span class="math">\\mathbf{Exp}_2</span> . We modify the previous experiment by replacing the session key  <span class="math">sk_B</span>  used as input to the KD protocol by a random session key  <span class="math">sk_B&#x27;</span>  in all of the sessions. Using similar arguments, one can prove the following lemma.</p>

    <p class="text-gray-300"><strong>Lemma 4.</strong></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\text{SUCC}_2] - \\Pr[\\text{SUCC}_1] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\le 2 \\cdot \\mathbf{Adv}_{2\\mathsf{PAKE},\\mathcal{D}}^{\\mathsf{ror-ake}}(t, q_{\\mathsf{exe}}, q_{\\mathsf{exe}} + q_{\\mathsf{send}}^B, q_{\\mathsf{send}}^B)$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300"><strong>Experiment</strong>  <span class="math">\\mathbf{Exp}_3</span> . In this experiment, we replace the MAC key  <span class="math">k_m</span>  obtained via the key distribution protocol with a random key in all of the sessions. According to the following lemma, the difference between the success probability of the adversary  <span class="math">\\mathcal{A}</span>  between the current and previous experiments is at most that of breaking the security of the key distribution scheme KD protocol between A, B, and S.</p>

    <p class="text-gray-300">Lemma 5.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\text{SUCC}_3] - \\Pr[\\text{SUCC}_2] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\le 2 \\left( q_{\\text{exe}} + q_{\\text{kd}} \\right) \\mathbf{Adv}_{\\text{KD}}^{\\text{ftg-kd}}(t, 1)$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300"><em>Proof.</em> The proof of this lemma uses standard hybrid arguments [14] in order to replace each of the key generated by the key distribution scheme KD. We can do so here because the input of the key distribution scheme are all independents since experiment  <span class="math">\\mathbf{Exp}_2</span> .</p>

    <p class="text-gray-300">The hybrids in this case consist of a sequence of random variables  <span class="math">V_i</span> , where  <span class="math">0 \\le i \\le q_s</span>  and  <span class="math">q_s = (q_{\\text{exe}} + q_{\\text{kd}})</span> , such that (1) the random variable  <span class="math">V_i</span>  is constructed as follows: in the first (i-1) sessions, the session keys are generated according to experiment  <span class="math">\\mathbf{Exp}_3</span> , (i.e. at random), and in the  <span class="math">(q_s - i + 1)</span>  sessions, they are generated according to the  <span class="math">\\mathbf{Exp}_2</span> , (i.e. according to the real protocol); (2) extreme hybrids (i=0) and  <span class="math">(i=q_s)</span>  collide with  <span class="math">\\mathbf{Exp}_2</span>  and  <span class="math">\\mathbf{Exp}_3</span>  respectively; (3) random values of each hybrid can be produced by a probabilistic polynomial time algorithm and the session that we modify is independent of the other sessions; and (4) there are only polynomially many hybrids.</p>

    <p class="text-gray-300">The hybrids allow us to define  <span class="math">q_s</span>  different experiments where we only ask queries to the Send oracles of the KD scheme with respect to a single session in each of the hybrids. Indeed, we start with a distinguisher  <span class="math">\\mathcal{A}_{3,i}</span>  for experiments  <span class="math">V_{i-1}</span>  and  <span class="math">V_i</span>  and we build an adversary  <span class="math">\\mathcal{A}^i_{kd}</span>  against the KD protocol. The adversary  <span class="math">\\mathcal{A}^i_{kd}</span>  will choose at random the MAC keys  <span class="math">k_m</span>  for the first i-1 sessions as well as the secret keys  <span class="math">sk_A</span>  and  <span class="math">sk_B</span>  shared between the server and clients A and B, respectively. Hence, it can perfectly answer to the queries made by the adversary  <span class="math">\\mathcal{A}_{3,i}</span>  to SendClient, SendServer, Execute, and Test oracles for the (i-1) first sessions. In the</p>

    <p class="text-gray-300"><em>i</em>-th session of hybrid experiment  <span class="math">\\mathbf{Exp}_{3,i}</span> ,  <span class="math">\\mathcal{A}^i_{kd}</span>  will use the KD oracles to answer its queries. It also makes a <em>Test</em> query with respect to this session to obtain a key  <span class="math">\\tilde{k_m}</span>  and uses it in order to simulate the remainder of the GPAKE protocol for that session.</p>

    <p class="text-gray-300">If the output of the <em>Test</em> query is the real key, then  <span class="math">\\mathcal{A}^i_{kd}</span>  is running  <span class="math">\\mathcal{A}_{3,i}</span>  as in the hybrid experiment  <span class="math">V_{i-1}</span> . If the session key returned by the <em>Test</em> query is a random key, then  <span class="math">\\mathcal{A}^i_{kd}</span>  is running  <span class="math">\\mathcal{A}_{3,i}</span>  as in the hybrid experiment  <span class="math">V_i</span>  Note the number of queries asked by  <span class="math">\\mathcal{A}^i_{kd}</span>  to its <em>Send</em> oracles is at most the maximum number of messages in a single execution of the protocol, c, hence the bound given in the lemma. Finally, when answering to the <em>Test</em> queries made by  <span class="math">\\mathcal{A}_{3,i}</span> ,  <span class="math">\\mathcal{A}^i_{kd}</span>  uses the same random bit b chosen at random at the beginning of its execution. Let b' be the output of adversary  <span class="math">\\mathcal{A}_{3,i}</span> . If b'=b, then  <span class="math">\\mathcal{A}^i_{kd}</span>  returns 1 or 0, otherwise. Using classical probability analysis and the fact that  <span class="math">\\mathcal{A}^i_{kd}</span>  has time-complexity t and asks queries to its <em>Send</em> oracle with respect to a <em>single</em> session and no <em>Reveal</em> queries, we can show that the difference between the probabilities that  <span class="math">\\mathcal{A}^i_{kd}</span>  in experiments  <span class="math">V_i</span>  and  <span class="math">V_{i-1}</span>  is at most  <span class="math">2 \\cdot \\mathbf{Adv}^{\\mathrm{ftg-kd}}_{\\mathrm{KD}}(t,1,0)</span> . The lemma follows immediately by noticing that there are at most  <span class="math">q_s</span>  hybrids.</p>

    <p class="text-gray-300"><strong>Experiment Exp</strong> <span class="math">_4</span> . In this experiment, we modify the oracle instances as follows. If the adversary asks a <em>SendClient</em> query containing a new pair message-MAC not previously generated by an oracle, then we consider the MAC invalid and force the instance in question (which received a forged message) to terminate without accepting. As the following lemma shows, the difference between the current and previous experiments should be negligible if we use a secure MAC scheme.</p>

    <p class="text-gray-300">Lemma 6.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\operatorname{SUCC}_4] - \\Pr[\\operatorname{SUCC}_3]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq q_{\\operatorname{ake}} \\cdot \\mathbf{Adv}_{\\mathsf{MAC}}^{\\operatorname{euf-cma}}(t,2,0)$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300"><em>Proof.</em> The proof of this lemma also uses hybrid arguments in the same as in the proof of Lemma 5. The total number of hybrids in this case is  <span class="math">q_{\\rm ake}</span> , since <em>Execute</em> queries do not need to be taken into account in this case. In hybrid  <span class="math">V_i</span> , where  <span class="math">0 \\le i \\le q_{\\rm ake}</span> , queries in the first i sessions are answered as in experiment  <span class="math">\\mathbf{Exp}_4</span>  and all other queries are answered as in experiment  <span class="math">\\mathbf{Exp}_3</span> . Let  <span class="math">\\mathcal{A}_{4,i}</span>  be a distinguisher for hybrids  <span class="math">V_i</span>  and  <span class="math">V_{i-1}</span> . Using  <span class="math">\\mathcal{A}_{4,i}</span> , we can build an adversary for the MAC scheme as follows.</p>

    <p class="text-gray-300">For the first i-1 sessions, the adversary  <span class="math">\\mathcal{A}_{\\mathsf{mac}}^i</span>  will choose random values for the MAC key and is therefore able to perfect simulate the oracles given to  <span class="math">\\mathcal{A}_{4,i}</span> . In the i-th session,  <span class="math">\\mathcal{A}_{\\mathsf{mac}}^i</span>  makes use of its MAC generation and verification oracles to answer queries from  <span class="math">\\mathcal{A}_{4,i}</span> . If  <span class="math">\\mathcal{A}_{4,i}</span>  generates a pair message-MAC not previously generated by  <span class="math">\\mathcal{A}_{\\mathsf{mac}}^i</span> , then  <span class="math">\\mathcal{A}_{\\mathsf{mac}}^i</span>  halts and outputs that pair as its forgery. If no such pair is generated, we output a failure indication. For all remaining sessions,  <span class="math">\\mathcal{A}_{\\mathsf{mac}}^i</span>  uses the actual MAC keys obtained via the key distribution scheme as in experiment  <span class="math">\\mathbf{Exp}_3</span>  to answer queries from  <span class="math">\\mathcal{A}_{4,i}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let F be the event in which a MAC is considered invalid in hybrid  <span class="math">V_i</span>  but valid in hybrid  <span class="math">V_{i-1}</span> . Notice that  <span class="math">\\Pr[F]</span>  is at most the probability that an adversary  <span class="math">\\mathcal{A}^i_{\\mathsf{mac}}</span>  can forge a MAC under a chosen-message attack. Since  <span class="math">\\mathcal{A}^i_{\\mathsf{mac}}</span>  has time-complexity t and makes at most two queries to its MAC generation oracle (to answer the SendClient queries) and no queries to its verification oracle, we have that  <span class="math">\\Pr[F] \\leq \\mathsf{Succ}^{\\mathsf{euf}\\mathsf{-cma}}_{\\mathsf{MAC}}(t,2,0)</span> . Moreover, since the two hybrids proceed identically until F occurs, we have  <span class="math">\\Pr[\\mathsf{Succ}_{V_{i-1}} \\land \\neg F] = \\Pr[\\mathsf{Succ}_{V_i} \\land \\neg F]</span> . By Lemma 1 of [30], we have  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\mathsf{Succ}_{V_{i-1}}] - \\Pr[\\mathsf{Succ}_{V_i}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\Pr[F]<span class="math"> . The lemma follows from the fact that there are at most  </span>q_{\\mathsf{ake}}$  hybrids.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Experiment Exp</strong><sub>5</sub>. In this experiment, we try to avoid the use of the discrete-log of the elements X, Y, Z in the <em>Test</em> queries in order to correctly compute the CDH(X, Y). We thus introduce a random DDH triples (X, Y, Z). Then, using the classical random self-reducibility</p>

    <p class="text-gray-300">of the Diffie-Hellman problem, one can introduce the above triples in all the sessions which can be tested by the adversary. We do not need to modify the other sessions.</p>

    <p class="text-gray-300">The behavior of our simulation in this experiment is as follows. Experiment  <span class="math">\\mathbf{Exp}_5</span>  is identical to experiment  <span class="math">\\mathbf{Exp}_4</span> , except that we apply the following special rules when dealing with  <span class="math">Test(U^i)</span>  and  <span class="math">SendClient(U^i,m)</span>  queries for the last two flows of GPAKE:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>R1:</strong> When processing a  <span class="math">SendClient(A^i, Start)</span>  query, the simulator picks two random values  <span class="math">a_0</span>  and  <span class="math">x_0</span>  in  <span class="math">\\mathbb{Z}q</span> , computes  <span class="math">X_0 = X^{a_0}g^{x_0}</span> , and stores in some  <span class="math">\\mathcal{X}</span> -table  <span class="math">(a_0, x_0, X_0)</span> .</li>

      <li><strong>R2:</strong> When processing a  <span class="math">SendClient(B^j, (X_0, m_0))</span>  query in the last message of the protocol,</li>

      <li>if the element  <span class="math">X_0</span>  has been computed by our simulator and thus have been stored in the  <span class="math">\\mathcal{X}</span> -table, then it generates the same way its answer by choosing two random values  <span class="math">b_0, y_0 \\stackrel{R}{\\leftarrow} \\mathbb{Z}q</span> , it computes  <span class="math">Y_0 = Y^{b_0}g^{y_0}</span>  and stores in some  <span class="math">\\mathcal{Y}</span> -table  <span class="math">(b_0, y_0, Y_0)</span> . It can now compute  <span class="math">Z_0 = Z^{a_0b_0} \\times Y^{x_0b_0} \\times X^{a_0y_0} \\times g^{x_0y_0}</span>  for the <em>Test</em> queries.</li>

      <li>if the elements  <span class="math">X_0</span>  has not been previously computed by our A-simulation, then it proceeds as in the experiment  <span class="math">\\mathbf{Exp}_4</span> .</li>

      <li><strong>R3:</strong> When processing a  <span class="math">Test(U^i)</span>  query, we know that such a query only reveal information about the hidden bit when asked on an accepting instance, and an accepting instance can only happen when the simulator knows the correct value  <span class="math">Z_0</span>  and can answer such query as in the experiment  <span class="math">\\mathbf{Exp}_4</span> .</li>

    </ul>

    <p class="text-gray-300">It is easy to see that in the second case of rule  <span class="math">\\mathbf{R2}</span> , as in experiment  <span class="math">\\mathbf{Exp}_4</span> , the adversary will not been able to forge a MAC tag, and then he will not be able to generate a correct message for either one of the two last flows. Consequently, the session will not be accepted by any party and so the adversary will not be able to send a <em>Test</em> query to any instance. Hence, the simulation will be consistent.</p>

    <p class="text-gray-300">It is then clear that experiments  <span class="math">\\mathbf{Exp}_4</span>  and  <span class="math">\\mathbf{Exp}_5</span>  are equivalent, since we have consistently replaced one set of random variables by another set of identically distributed random variables. In particular,  <span class="math">\\Pr[SUCC_4] = \\Pr[SUCC_5]</span> .</p>

    <p class="text-gray-300"><strong>Experiment Exp</strong><sub>6</sub>. Experiment <strong>Exp</strong><sub>6</sub> is exactly the same as experiment <strong>Exp</strong><sub>5</sub>, except that in all the rules, we use a random triple (X, Y, Z) coming from a random distribution  <span class="math">(g^x, g^y, g^z)</span> , instead of a DDH triple. As the following lemma shows, the difference between the current and previous experiments should be negligible if DDH is hard in  <span class="math">\\mathbb{G}</span> .</p>

    <p class="text-gray-300">Lemma 7.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\text{SUCC}_6] - \\Pr[\\text{SUCC}_5] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathbf{Adv}_{\\mathbb{G}}^{\\text{ddh}}(t + 8(q_{\\text{exe}} + q_{\\text{ake}})\\tau_e)$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">\\mathcal{A}</span>  be an attacker that breaks the semantic security experiment of GPAKE with a different advantage in Experiment  <span class="math">\\mathbf{Exp}_6</span>  than in Experiment  <span class="math">\\mathbf{Exp}_5</span> . We can build an adversary  <span class="math">\\mathcal{A}_{\\mathsf{ddh}}</span>  for the DDH problem in  <span class="math">\\mathbb{G}</span>  as follows. Let (X,Y,Z) be the input given to  <span class="math">\\mathcal{A}_{\\mathsf{ddh}}</span> . A sks a SendClient, Execute, or Test query, then  <span class="math">\\mathcal{A}_{\\mathsf{ddh}}</span>  computes its output exactly as in the previous experiment but using the triple (X,Y,Z) that it had received as input. Let b' be the output of  <span class="math">\\mathcal{A}</span> . If b'=b, then  <span class="math">\\mathcal{A}_{\\mathsf{ddh}}</span>  returns 1 or 0, otherwise.</p>

    <p class="text-gray-300">Let us now analyze the success probability of  <span class="math">\\mathcal{A}_{ddh}</span> . Clearly, when the triple (X,Y,Z) is a true Diffie-Hellman triple,  <span class="math">\\mathcal{A}_{ddh}</span>  runs  <span class="math">\\mathcal{A}</span>  exactly as in experiment  <span class="math">\\mathbf{Exp}_5</span>  and thus the probability that  <span class="math">\\mathcal{A}_{ddh}</span>  outputs 1 is exactly  <span class="math">\\Pr[\\mathrm{SUCC}_5]</span> . On the other hand, when (X,Y,Z) is a random triple,  <span class="math">\\mathcal{A}_{ddh}</span>  runs  <span class="math">\\mathcal{A}</span>  exactly as in experiment  <span class="math">\\mathbf{Exp}_6</span>  and thus the probability that  <span class="math">\\mathcal{A}_{ddh}</span>  outputs 1 is exactly  <span class="math">\\Pr[\\mathrm{SUCC}_6]</span> . The lemma follows from the fact that  <span class="math">\\mathcal{A}_{ddh}</span>  has time-complexity at most  <span class="math">t+8(q_{\\mathrm{exe}}+q_{\\mathrm{ake}})\\tau_e</span> , due to the additional time for the computations of the random self-reducibility.</p>

    <p class="text-gray-300">Due to the random self-reducibility property of the Diffie-Hellman problem, all the sessions keys  <span class="math">Z_0</span>  used to answer <em>Test</em> queries in experiment  <span class="math">\\mathbf{Exp}_6</span>  are randomly and independently distributed in  <span class="math">\\mathbb{G}</span> . As a result, no information on the hidden bit b used by the <em>Test</em> oracle is leaked to the adversary and thus  <span class="math">\\Pr[SUCC_6] = \\frac{1}{2}</span> . This result combined with the previous lemmas yields the result in Theorem 1.</p>

    <p class="text-gray-300"><strong>Key privacy.</strong> The proof of key privacy uses arguments similar to those used in experiments  <span class="math">\\mathbf{Exp}_5</span>  and  <span class="math">\\mathbf{Exp}_6</span>  in the proof of semantic security of GPAKE. Let  <span class="math">\\mathcal{A}_{kp}</span>  be an adversary against the key privacy of GPAKE with time-complexity at most t, and asking at most  <span class="math">q_{exe}</span>  queries to its <em>Execute</em> oracle,  <span class="math">q_{test}</span>  queries to its <em>TestPair</em> oracle, and  <span class="math">q_{ake}</span>  queries to <em>SendClient</em> oracle with respect to the final MAC-based authenticated key exchange protocol. Using  <span class="math">\\mathcal{A}_{kp}</span> , we can build an adversary  <span class="math">\\mathcal{A}_{ddh}</span>  for the DDH problem in  <span class="math">\\mathbb G</span>  as follows.</p>

    <p class="text-gray-300">Let (X,Y,Z) be the input given to  <span class="math">\\mathcal{A}_{ddh}</span> .  <span class="math">\\mathcal{A}_{ddh}</span>  first chooses the passwords for all users in the system according to the distribution of  <span class="math">\\mathcal{D}</span> . It also chooses a bit b at random that is used to answer queries to the TestPair oracle. It then starts running  <span class="math">\\mathcal{A}_{kp}</span>  giving all the password of all users to it. Since  <span class="math">\\mathcal{A}_{ddh}</span>  knows the password of all users, it can easily answer queries made by  <span class="math">\\mathcal{A}_{kp}</span> . However, in order to use  <span class="math">\\mathcal{A}_{kp}</span>  to help it solve the DDH problem,  <span class="math">\\mathcal{A}_{ddh}</span>  will use the classical random self-reducibility of the Diffie-Hellman problem to introduce its input triple in the answers to SendClient, Execute, and TestPair queries with respect to the last two flows of GPAKE.</p>

    <p class="text-gray-300">To simulate the <em>Execute</em> oracle, we simply use the passwords that we have chosen and <em>SendClient</em> queries. The simulation of the <em>SendClient</em> and <em>TestPair</em> are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>R1:</strong> When processing a  <span class="math">SendClient(A^i, Start)</span>  query,  <span class="math">\\mathcal{A}_{ddh}</span>  picks two random values  <span class="math">a_0</span>  and  <span class="math">x_0</span>  in  <span class="math">\\mathbb{Z}q</span> , computes  <span class="math">X_0 = X^{a_0}g^{x_0}</span> , and stores in some  <span class="math">\\mathcal{X}</span> -table  <span class="math">(a_0, x_0, X_0)</span> .</li>

      <li><strong>R2:</strong> When processing a  <span class="math">SendClient(B^j, (X_0, m_0))</span>  query in the last message of the protocol,</li>

      <li>if the element  <span class="math">X_0</span>  has been computed by  <span class="math">\\mathcal{A}_{\\mathsf{ddh}}</span>  and thus have been stored in the  <span class="math">\\mathcal{X}</span> -table, then  <span class="math">\\mathcal{A}_{\\mathsf{ddh}}</span>  generates the same way its answer by choosing two random values  <span class="math">b_0, y_0 \\overset{R}{\\leftarrow} \\mathbb{Z}q</span> . It computes  <span class="math">Y_0 = Y^{b_0}g^{y_0}</span>  and stores in some  <span class="math">\\mathcal{Y}</span> -table  <span class="math">(b_0, y_0, Y_0)</span> .  <span class="math">\\mathcal{A}_{\\mathsf{ddh}}</span>  can now compute  <span class="math">Z_0 = Z^{a_0b_0} \\times Y^{x_0b_0} \\times X^{a_0y_0} \\times g^{x_0y_0}</span>  for the <em>TestPair</em> queries.</li>

      <li>if the elements  <span class="math">X_0</span>  has not been previously computed by  <span class="math">\\mathcal{A}_{ddh}</span> , then  <span class="math">\\mathcal{A}_{ddh}</span>  proceeds with the simulation as it would in a real attack.</li>

      <li><strong>R3:</strong> When processing a  <span class="math">TestPair(U_1^i, U_2^j)</span>  query,  <span class="math">\\mathcal{A}_{ddh}</span>  first checks whether  <span class="math">U_1^i</span>  and  <span class="math">U_2^j</span>  have both accepted and have the same key. If the check fails, then  <span class="math">\\mathcal{A}_{ddh}</span>  returns  <span class="math">\\bot</span> . If the check passes, then  <span class="math">\\mathcal{A}_{ddh}</span>  knows the corresponding value  <span class="math">Z_0</span>  for the secret key and can answer it based on the hidden bit b it had previously chosen.</li>

    </ul>

    <p class="text-gray-300">Let b' be the output of  <span class="math">A_{kp}</span> . If b' = b, then  <span class="math">A_{ddh}</span>  returns 1 and 0, otherwise.</p>

    <p class="text-gray-300">We would like to observe here that the second case of rule R2 has no influence over TestPair queries, since the latter can only be asked to pair of oracle instances which share the same key. This is because even though the instance involved in the SendClient may itself accept, its partner would not be an oracle instance. Hence, a TestPair query involving this instance would always return the invalid symbol  <span class="math">\\bot</span> .</p>

    <p class="text-gray-300">In order to analyze the success probability of  <span class="math">\\mathcal{A}_{ddh}</span> , first consider the case in which the triple (X,Y,Z) is a true Diffie-Hellman triple. Then, in this case, one can see that simulation of the  <span class="math">\\mathcal{A}_{kp}</span>  oracles is perfect. Hence, the probability that  <span class="math">\\mathcal{A}_{ddh}</span>  outputs 1 is exactly  <span class="math">\\frac{1}{2} + \\frac{1}{2} \\mathbf{A} \\mathbf{d} \\mathbf{v}_{\\mathsf{GPAKE},\\mathcal{D}}^{\\mathsf{kp-ake}}(\\mathcal{A}_{kp})</span> . On the other hand, when (X,Y,Z) is a random triple, the keys  <span class="math">Z_0</span>  used to answer  <span class="math">\\mathit{TestPair}</span>  queries are all random and independent as a result of the random self-reducibility property of the Diffie-Hellman problem. Hence, no information on b is leaked through  <span class="math">\\mathit{TestPair}</span>  queries and the probability that  <span class="math">\\mathcal{A}_{ddh}</span>  outputs 1 is exactly  <span class="math">\\frac{1}{2}</span>  in</p>

    <p class="text-gray-300">this case. The proof of Theorem 2 follows from the fact that  <span class="math">\\mathcal{A}_{\\text{ddh}}</span>  has time-complexity at most  <span class="math">t+8(q_{\\text{exe}}+q_{\\text{ake}})\\tau_e</span> , due to the additional time for the computations of the random self-reducibility.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8"><strong>B</strong> Building blocks</h3>

    <p class="text-gray-300">In this section, we recall the definitions for the cryptographic primitives that we use in the construction of our generic 3-party password-based authenticated key exchange, GPAKE.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Decisional Diffie-Hellman assumption: DDH.</strong> The DDH assumption states, roughly, that the distributions  <span class="math">(g^u, g^v, g^{uv})</span>  and  <span class="math">(g^u, g^v, g^w)</span>  are computationally indistinguishable when u, v, w are drawn at random from  $\\{1, \\ldots,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math"> . This can be made more precise by defining two experiments,  </span>\\mathbf{Exp}^{\\mathrm{ddh-real}}_{\\mathbb{G}}(\\mathcal{A})<span class="math">  and  </span>\\mathbf{Exp}^{\\mathrm{ddh-rand}}_{\\mathbb{G}}(\\mathcal{A})<span class="math"> . In both experiments, we compute two values  </span>U = g^u<span class="math">  and  </span>V = g^v<span class="math">  to be given to  </span>\\mathcal{A}<span class="math"> . But in addition to that, we also provide a third input, which is  </span>g^{uv}<span class="math">  in  </span>\\mathbf{Exp}^{\\mathrm{ddh-real}}_{\\mathbb{G}}(\\mathcal{A})<span class="math">  and  </span>g^z<span class="math">  for a random z in  </span>\\mathbf{Exp}^{\\mathrm{ddh-rand}}_{\\mathbb{G}}(\\mathcal{A})<span class="math"> . The goal of the adversary is to guess a bit indicating the experiment it thinks it is in. We define advantage of  </span>\\mathcal{A}<span class="math">  in violating the DDH assumption,  </span>\\mathbf{Adv}^{\\mathrm{ddh}}_{\\mathbb{G}}(\\mathcal{A})<span class="math"> , as  </span>\\Pr[\\mathbf{Exp}^{\\mathrm{ddh-real}}_{\\mathbb{G}}(\\mathcal{A}) = 1] - \\Pr[\\mathbf{Exp}^{\\mathrm{ddh-rand}}_{\\mathbb{G}}(\\mathcal{A}) = 1]<span class="math"> . The advantage function of the group,  </span>\\mathbf{Adv}^{\\mathrm{ddh}}_{\\mathbb{G}}(t)<span class="math">  is then defined as the maximum value of  </span>\\mathbf{Adv}^{\\mathrm{ddh}}_{\\mathbb{G}}(\\mathcal{A})<span class="math">  over all  </span>\\mathcal{A}$  with time-complexity at most t.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Message authentication codes (MAC). A Message Authentication Code MAC = (Key, Tag, Ver) is defined by the following three algorithms: (1) A MAC key generation algorithm Key, which on input  <span class="math">1^k</span>  produces a  <span class="math">\\ell</span> -bit secret-key sk uniformly distributed in  <span class="math">\\{0,1\\}^{\\ell}</span> ; (2) A MAC generation algorithm Tag, possibly probabilistic, which given a message m and a secret key  <span class="math">sk \\in \\{0,1\\}^{\\ell}</span> , produces an authenticator  <span class="math">\\mu</span> ; and (3) A MAC verification algorithm Ver, which given an authenticator  <span class="math">\\mu</span> , a message m, and a secret key sk, outputs 1 if  <span class="math">\\mu</span>  is a valid authenticator for m under sk and 0 otherwise.</p>

    <p class="text-gray-300">Like in signature schemes, the classical security level for a MAC is to prevent existential forgeries, even for an adversary which has access to the generation and verification oracles. We define <strong>advantage</strong> of  <span class="math">\\mathcal{A}</span>  in violating the security of the MAC,  <span class="math">\\mathbf{Adv}_{MAC}^{\\mathrm{euf}-\\mathrm{cma}}(\\mathcal{A})</span> , as</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr\\left[\\,sk \\leftarrow \\{0,1\\}^\\ell, (m,\\mu) \\leftarrow \\mathcal{A}^{\\mathsf{Tag}(sk;\\cdot),\\mathsf{Ver}(sk;\\cdot,\\cdot)}() : \\mathsf{Ver}(sk;m,\\mu) = 1\\,\\right],</span></div>

    <p class="text-gray-300">and the <strong>advantage function</strong> of the MAC,  <span class="math">\\mathbf{Adv}_{\\mathsf{MAC}}^{\\mathsf{euf}-\\mathsf{cma}}(t,q_g,q_s)</span> , as the maximum value of  <span class="math">\\mathbf{Adv}_{\\mathsf{MAC}}^{\\mathsf{euf}-\\mathsf{cma}}(\\mathcal{A})</span>  over all  <span class="math">\\mathcal{A}</span>  that asks up to  <span class="math">q_g</span>  and  <span class="math">q_v</span>  queries to the generation and verification oracles, respectively, and with time-complexity at most t. Note that  <span class="math">\\mathcal{A}</span>  wins the above experiment only if it outputs a <em>new</em> valid authenticator.</p>

    <p class="text-gray-300"><strong>3-party key distribution.</strong> A secure key distribution protocol KD is a 3-party protocol between 2 parties and a trusted server S where S picks a session key at random and securely sends it to the users. The security model, formally introduced in [7], is a generalization of that for 2-party authenticated key exchange protocols, to which a new oracle was added to represent the trusted server. Their security is in the Find-Then-Guess model, using the terminology that we introduced for key exchange protocols.</p>

    <p class="text-gray-300">In our generic construction, we only need a KD secure with respect to a single session since the symmetric keys used as input to the key distribution protocol differ from session to session. They are the session keys obtained from the 2-party password-based authenticated key exchange protocols between the server and each of the two parties. Since in this case, both the Find-Then-Guess and Real-Or-Random notions are equivalent, we opted to use their definition (i.e. FTG) adapted to our terminology. That is, we define  <span class="math">\\mathbf{Adv}_{\\mathrm{KD}}^{\\mathrm{ftg}-\\mathrm{kd}}(\\mathcal{A})</span>  as the</p>

    <p class="text-gray-300">advantage of adversary  <span class="math">\\mathcal{A}</span>  in violating the semantic security of a key distribution KD in the FTG sense, and  <span class="math">\\mathbf{Adv}_{\\mathrm{KD}}^{\\mathrm{ftg-kd}}(t,s,r)</span>  as the <strong>advantage function</strong> of KD, which is the maximum value of  <span class="math">\\mathbf{Adv}_{\\mathrm{KD}}^{\\mathrm{ftg-kd}}(\\mathcal{A})</span>  over all  <span class="math">\\mathcal{A}</span>  with time-complexity at most t, asking Send queries with respect to at most s sessions and asking at most t t t t t t t t t t</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">C Relations between notions</h4>

    <p class="text-gray-300">In this section, we prove the relation between the Find-Then-Guess (FTG) and Real-Or-Random (ROR) notions of security for authenticated key exchange protocols. The relation is not specific to password-based schemes, but its implications are more important in that scenario. We do not present proofs for the forward-secure case as these proofs can be easily derived from the proofs in the non-forward-secure case.</p>

    <p class="text-gray-300"><strong>Lemma 8.</strong> For any AKE, <span class="math-block">\\mathbf{Adv}_{\\mathsf{AKE}}^{\\mathsf{ftg-ake}}(t, q_{\\mathsf{send}}, q_{\\mathsf{reveal}}, q_{\\mathsf{exe}}) \\leq 2 \\cdot \\mathbf{Adv}_{\\mathsf{AKE}}^{\\mathsf{ror-ake}}(t, q_{\\mathsf{send}}, q_{\\mathsf{reveal}}, q_{\\mathsf{exe}}) + 1, q_{\\mathsf{exe}}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> In order to prove this lemma, we show how to build an adversary  <span class="math">\\mathcal{A}_{ror}</span>  against the semantic security of an authenticated key exchange AKE protocol in the ROR model given an adversary  <span class="math">\\mathcal{A}_{ftg}</span>  against the semantic security of the same protocol AKE in the FTG model. We know that  <span class="math">\\mathcal{A}_{ftg}</span>  has time-complexity at most t and that it asks at most  <span class="math">q_{send}</span> ,  <span class="math">q_{reveal}</span> , and  <span class="math">q_{exe}</span>  queries to its Send, Reveal, and Execute oracles, respectively.</p>

    <p class="text-gray-300">The description of  <span class="math">\\mathcal{A}_{ror}</span>  is as follows.  <span class="math">\\mathcal{A}_{ror}</span>  starts by choosing a bit b uniformly at random and starts running  <span class="math">\\mathcal{A}_{ftg}</span> . If  <span class="math">\\mathcal{A}_{ftg}</span>  asks a Send query, then  <span class="math">\\mathcal{A}_{ror}</span>  asks the corresponding query to its Send oracle. If  <span class="math">\\mathcal{A}_{ftg}</span>  asks a Execute query, then  <span class="math">\\mathcal{A}_{ror}</span>  asks the corresponding query to its Execute oracle. If  <span class="math">\\mathcal{A}_{ftg}</span>  asks a Reveal query, then  <span class="math">\\mathcal{A}_{ror}</span>  asks a Test query to its Test oracle and uses the answer it receives as the answer to the Reveal query. If  <span class="math">\\mathcal{A}_{ftg}</span>  asks a Test query, then  <span class="math">\\mathcal{A}_{ror}</span>  asks the corresponding query to its Test oracle. If b=1, then  <span class="math">\\mathcal{A}_{ror}</span>  uses the answer it received as the answer to the Test query. Otherwise, it returns a random key to  <span class="math">\\mathcal{A}_{ftg}</span> . Let b' be the final output of  <span class="math">\\mathcal{A}_{ftg}</span> . If b'=b, then  <span class="math">\\mathcal{A}_{ror}</span>  outputs 1. Otherwise, it outputs 0.</p>

    <p class="text-gray-300">Note that  <span class="math">A_{ror}</span>  has time-complexity at most t and asks at most  <span class="math">q_{send}</span> ,  <span class="math">q_{reveal} + 1</span> , and  <span class="math">q_{exe}</span>  queries to its Send, Test, and Execute oracles, respectively.</p>

    <p class="text-gray-300">In order to analyze the advantage of  <span class="math">\\mathcal{A}_{ror}</span> , first consider the case in which its  <span class="math">\\mathit{Test}</span>  oracle returns random keys. It is easy to see that, in this case,  <span class="math">\\mathcal{A}_{ftg}</span>  cannot gain any information about the hidden bit b used to answer its single  <span class="math">\\mathit{Test}</span> . Therefore, the probability that  <span class="math">\\mathcal{A}_{ror}</span>  is exactly  <span class="math">\\frac{1}{2}</span> . Now consider the case in which its  <span class="math">\\mathit{Test}</span>  oracle returns the actual sessions keys. In this case, the simulation of  <span class="math">\\mathit{Reveal}</span>  is perfect and  <span class="math">\\mathcal{A}_{ror}</span>  runs  <span class="math">\\mathcal{A}_{ftg}</span>  exactly as in the experiment defining the semantic security of  <span class="math">\\mathcal{A}_{ftg}</span>  in the FTG model. Therefore, the probability that  <span class="math">\\mathcal{A}_{ror}</span>  is exactly  <span class="math">\\frac{1}{2} + \\frac{1}{2} \\mathbf{Adv}_{\\mathsf{AKE}}^{\\mathsf{ftg-ake}}(\\mathcal{A}_{\\mathsf{ftg}})</span>  and, as a result,  <span class="math">\\mathbf{Adv}_{\\mathsf{AKE}}^{\\mathsf{ftg-ake}}(\\mathcal{A}_{\\mathsf{ftg}}) \\leq 2 \\cdot \\mathbf{Adv}_{\\mathsf{AKE}}^{\\mathsf{ror-ake}}(\\mathcal{A}_{\\mathsf{ror}}) \\leq \\mathbf{Adv}_{\\mathsf{AKE}}^{\\mathsf{ror-ake}}(t, q_{\\mathsf{send}}, q_{\\mathsf{reveal}} + 1, q_{\\mathsf{exe}})</span> . The lemma follows easily.</p>

    <p class="text-gray-300"><strong>Lemma 9.</strong> For any AKE, <span class="math-block">\\mathbf{Adv}_{\\mathsf{AKE}}^{\\mathsf{ror-ake}}(t, q_{\\mathsf{send}}, q_{\\mathsf{test}}, q_{\\mathsf{exe}}) \\leq q_{\\mathsf{test}} \\cdot \\mathbf{Adv}_{\\mathsf{AKE}}^{\\mathsf{ftg-ake}}(t, q_{\\mathsf{send}}, q_{\\mathsf{test}}, q_{\\mathsf{exe}})</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> In order to prove this lemma, we show how to build a sequence of adversaries  <span class="math">\\mathcal{A}^i_{\\mathrm{ftg}}</span>  against the semantic security of an authenticated key exchange AKE protocol in the FTG model given an adversary  <span class="math">\\mathcal{A}_{\\mathrm{ror}}</span>  against the semantic security of the same protocol AKE in the ROR model. We know that  <span class="math">\\mathcal{A}_{\\mathrm{ror}}</span>  has time-complexity at most t and that it asks at most  <span class="math">q_{\\mathrm{send}}</span> ,  <span class="math">q_{\\mathrm{test}}</span> , and  <span class="math">q_{\\mathrm{exe}}</span>  queries to its Send, Test, and Execute oracles, respectively.</p>

    <p class="text-gray-300">The proof uses a standard hybrid argument, in which we define a sequence of  <span class="math">q_{\\text{test}} + 1</span>  hybrid experiments  <span class="math">V_i</span> , where  <span class="math">0 \\le i \\le q_{\\text{test}}</span> . In experiment  <span class="math">V_i</span> , the first i-1 queries to the</p>

    <p class="text-gray-300">Test oracle are answered using a random key and all remaining Test queries are answered using the real key. Please note that the hybrid experiments at the extremes correspond to the real and random experiments in the definition of semantic security in the ROR model. Hence, in order to prove the bound in the lemma, it suffices to prove that the difference in probability that adversary  <span class="math">\\mathcal{A}_{ror}</span>  returns 1 between any two consecutive experiments  <span class="math">V_i</span>  and  <span class="math">V_{i-1}</span>  is at most  <span class="math">\\mathbf{Adv}_{\\mathsf{AKE}}^{\\mathsf{ftg-ake}}(t, q_{\\mathsf{send}}, q_{\\mathsf{test}} - 1, q_{\\mathsf{exe}})</span> . This is achieved by building a sequence of  <span class="math">q_{\\mathsf{test}}</span>  adversaries  <span class="math">\\mathcal{A}_{\\mathsf{ftg}}^i</span> , as described below.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{A}_{\\mathrm{ftg}}^i</span>  be a distinguisher  <span class="math">\\mathcal{A}_{\\mathrm{ftg}}^i</span>  for experiments  <span class="math">V_i</span>  and  <span class="math">V_{i-1}</span> , where  <span class="math">1 \\leq i \\leq q_{\\mathrm{test}}</span> .  <span class="math">\\mathcal{A}_{\\mathrm{ftg}}^i</span>  starts running  <span class="math">\\mathcal{A}_{\\mathrm{ror}}</span>  answering to its queries as follows. If  <span class="math">\\mathcal{A}_{\\mathrm{ror}}</span>  asks a <em>Send</em> or <em>Execute</em> query, then  <span class="math">\\mathcal{A}_{\\mathrm{ftg}}</span>  answers it using its corresponding oracle. If  <span class="math">\\mathcal{A}_{\\mathrm{ror}}</span>  asks a <em>Test</em> query, then  <span class="math">\\mathcal{A}_{\\mathrm{ftg}}</span>  answers it with a random key if this query is among the first i-1. If this is the i-th Test, then  <span class="math">\\mathcal{A}_{\\mathrm{ftg}}</span>  uses its Test oracle to answer it. All remaining Test queries are answered using the output of the Reveal query.  <span class="math">\\mathcal{A}_{\\mathrm{ftg}}</span>  finishes its execution by outputting the same guess bit b outputted by  <span class="math">\\mathcal{A}_{\\mathrm{ror}}</span> .</p>

    <p class="text-gray-300">Note that  <span class="math">\\mathcal{A}_{\\mathrm{ftg}}^i</span>  has time-complexity at most t and asks at most  <span class="math">q_{\\mathrm{send}}</span> ,  <span class="math">q_{\\mathrm{test}}-1</span> , and  <span class="math">q_{\\mathrm{exe}}</span>  queries to its <em>Send</em>, <em>Reveal</em>, and <em>Execute</em> oracles, respectively.</p>

    <p class="text-gray-300">In order to analyze the advantage of  <span class="math">\\mathcal{A}^i_{\\mathrm{ftg}}</span> , first notice that when  <span class="math">\\mathit{Test}</span>  oracle returns a random key,  <span class="math">\\mathcal{A}^i_{\\mathrm{ftg}}</span>  runs  <span class="math">\\mathcal{A}_{\\mathrm{ror}}</span>  exactly as in the experiment  <span class="math">V_i</span> . Next, notice that when  <span class="math">\\mathit{Test}</span>  oracle returns the real key,  <span class="math">\\mathcal{A}^i_{\\mathrm{ftg}}</span>  runs  <span class="math">\\mathcal{A}_{\\mathrm{ror}}</span>  exactly as in the experiment  <span class="math">V_i</span> . It follows that the difference in probability that adversary  <span class="math">\\mathcal{A}_{\\mathrm{ror}}</span>  returns 1 between experiments  <span class="math">V_i</span>  and  <span class="math">V_{i-1}</span>  is at most  <span class="math">\\mathbf{Adv}^{\\mathrm{ftg-ake}}_{\\mathrm{AKE}}(\\mathcal{A}_{\\mathrm{ror}}) \\leq \\mathbf{Adv}^{\\mathrm{ftg-ake}}_{\\mathrm{AKE}}(t,q_{\\mathrm{send}},q_{\\mathrm{test}}-1,q_{\\mathrm{exe}})</span> . The lemma follows easily.</p>

    <p class="text-gray-300">Even though the reduction in Lemma 9 is not security-preserving (i.e., there is a non-constant factor loss in the reduction), it does not imply that a gap really exists— there might exist a tight reduction between the two notions that we have not yet found. In order to prove that the non-constant factor loss in the reduction is indeed intrinsic, we need to show that there exist schemes for which the gap does exist.</p>

    <p class="text-gray-300">To achieve this goal, one can use techniques similar to those used to prove that a gap exists between the Left-Or-Right and Find-Then-Guess notions of security for symmetric encryption schemes [3]. In that paper, they show how to construct a new symmetric encryption scheme  <span class="math">\\mathcal{E}&#x27;</span>  from a secure encryption scheme  <span class="math">\\mathcal{E}</span>  such that  <span class="math">\\mathcal{E}&#x27;</span>  exhibits the gap.  <span class="math">\\mathcal{E}&#x27;</span>  was constructed in such a way that its encryption function works like the encryption function of  <span class="math">\\mathcal{E}</span>  most of the time, except in a few cases (which are easily identifiable) in which the ciphertext it generates contains the plaintext. The probability in which such bad cases happen in their construction is exactly 1/q, where q is the non-constant factor in the reduction.</p>

    <p class="text-gray-300">A similar technique can be applied to authenticated key exchange protocols. Imagine a secure authenticated key exchange protocol AKE exists. For simplicity, assume  <span class="math">q_{\\rm test}=2^l</span> , for some integer l. We can construct a new scheme AKE' such that the session key k that it generates equals the one generated by AKE most of the time except when the first l bits are 0. In this case, we just make k=0. Using a proof technique similar to that used in [3], one can prove the the gap in Lemma 9 cannot be avoided and we thus omit the detail. But before stating our proposition, we make a final remark that when the underlying scheme AKE is a password-based key exchange, not every choice of parameters will yield the desired result claimed in the proposition. However, there are (easy) choices of parameters for which the gap does exist and that suffices for the purpose of the proposition. We are now ready to state our claim.</p>

    <p class="text-gray-300"><strong>Proposition 10.</strong> The gap exhibited in Lemma 9 is intrinsic and cannot be avoided.</p>`;
---

<BaseLayout title="Password-Based Authenticated Key Exchange in the Three-Party... (2004/233)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/233
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
