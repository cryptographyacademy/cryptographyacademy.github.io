---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/1069';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Lunar: a Toolbox for More Efficient Universal and Updatable zkSNARKs and Commit-and-Prove Extensions';
const AUTHORS_HTML = 'Matteo Campanelli, Antonio Faonio, Dario Fiore, Anaïs Querol, Hadrián Rodríguez';

const CONTENT = `    <p class="text-gray-300">Lunar: a Toolbox for More Efficient Universal and Updatable zkSNARKs and Commit-and-Prove Extensions</p>

    <p class="text-gray-300">Matteo Campanelli^{1}, Antonio Faonio^{2}, Dario Fiore^{3}, Anaïs Querol^{3,4}, and Hadrián Rodríguez^{3}</p>

    <p class="text-gray-300">^{1} Aarhus University, Denmark matteo@cs.au.dk ^{2} EURECOM, Sophia Antipolis, France antonio.faonio@eurecom.fr ^{3} IMDEA Software Institute, Madrid, Spain {dario.fiore, anais.querol, hadrian.rodriguez}@imdea.org ^{4} Universidad Politécnica de Madrid, Spain</p>

    <p class="text-gray-300">Abstract. We address the problem of constructing zkSNARKs whose SRS is universal—valid for all relations within a size-bound—and updatable—a dynamic set of participants can add secret randomness to it indefinitely thus increasing confidence in the setup. We investigate formal frameworks and techniques to design efficient universal updatable zkSNARKs with linear-size SRS and their commit-and-prove variants.</p>

    <p class="text-gray-300">We achieve a collection of zkSNARKs with different tradeoffs. One of our constructions achieves the smallest proof size and proving time compared to the state of art for proofs for arithmetic circuits. The language supported by this scheme is a variant of R1CS, called R1CS-lite, introduced by this work. Another of our constructions supports directly standard R1CS and improves on previous work achieving the fastest proving time for this type of constraint systems.</p>

    <p class="text-gray-300">We achieve this result via the combination of different contributions: (1) a new algebraically-flavored variant of IOPs that we call Polynomial Holographic IOPs (PHPs), (2) a new compiler that combines our PHPs with commit-and-prove zkSNARKs for committed polynomials, (3) pairing-based realizations of these CP-SNARKs for polynomials, (4) constructions of PHPs for R1CS and R1CS-lite, (5) a variant of the compiler that yields a commit-and-prove universal zkSNARK.</p>

    <p class="text-gray-300">Keywords: cryptographic protocols <span class="math">\\cdot</span> zero knowledge <span class="math">\\cdot</span> succinct arguments <span class="math">\\cdot</span> polynomial commitments <span class="math">\\cdot</span> commit-and-prove <span class="math">\\cdot</span> universal SRS <span class="math">\\cdot</span> IOP</p>

    <p class="text-gray-300">1 Introduction 3 1.1 Our Contribution 4 1.2 Other Related Work 8 1.3 Outline 9</p>

    <p class="text-gray-300">2 Basic Preliminaries 9 3 Polynomial Holographic IOPs 10 3.1 PHP Verifier Relation 12 3.2 Compiling PHPs and AHPs into One Another 13</p>

    <p class="text-gray-300">4 Our PHP Constructions 14 4.1 Algebraic Preliminaries 14 4.2 Rank-1 Constraint Systems 17 4.3 Our PHPs for R1CS-lite 18 4.4 Our PHP for R1CS 29</p>

    <p class="text-gray-300">5 Preliminaries on Commitments and zkSNARKs 36 5.1 Commitment Schemes 36 5.2 Preprocessing zkSNARKs with Universal and Specializable SRS 38 5.3 Universal Commit-and-Prove SNARKs 39</p>

    <p class="text-gray-300">6 Our Compiler from PHPs to zkSNARKs with Universal SRS 41 6.1 Building Blocks 41 6.2 Compiling to Universal Interactive Arguments 42</p>

    <p class="text-gray-300">7 CP-SNARKs for Pairing-Based Polynomial Commitments 45 7.1 Bilinear Groups and Assumptions 45 7.2 The Commitment Schemes 46 7.3 CP-SNARKs for <span class="math">\\mathcal{R}_{\\mathrm{opn}}</span> 47 7.4 CP-SNARK for evaluation of a single polynomial 49 7.5 CP-SNARK for batch evaluation of many polynomials 50 7.6 CP-SNARK for Polynomial Equations 51 7.7 CP-SNARK for <span class="math">\\mathsf{CS}_2</span> for quadratic polynomial equations 53 7.8 CP-SNARKs for degree of committed polynomials 54 7.9 A general-purpose CP-SNARK for <span class="math">\\mathcal{R}_{\\mathrm{php}}</span> 56</p>

    <p class="text-gray-300">8 Our Compiler for Universal Commit-and-Prove zkSNARKs 56 8.1 Compiling to Commit-and-Prove Universal Interactive Arguments 56 8.2 Pairing-Based Instantiations of our Building Blocks 57</p>

    <p class="text-gray-300">9 Instantiating Our Compiler: Our Universal zkSNARKs 64 9.1 Available Options to Compile Our PHPs 64 9.2 Instantiating the PHPs with the appropriate zero-knowledge bounds 65 9.3 Our zkSNARKs 66 9.4 Our CP-SNARKs 67</p>

    <p class="text-gray-300">A Constraint Systems 72 A.1 Proof of Lemma 5 72 A.2 Proof of Lemma 6 73 A.3 Reduction to Arithmetic Circuit Satisfiability 74 A.4 Comparing R1CS and R1CS-lite 75</p>

    <p class="text-gray-300">B Our Protocol for Lincheck 76 B.1 Preliminaries 76 B.2 An Holographic Protocol for Points of Sparse Matrices 77 B.3 The linear check protocol 79</p>

    <p class="text-gray-300">C Additional Material for Section 6</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>C.1 Universal Interactive Arguments in the SRS.</li>

      <li>C.2 Proof of Theorem 5</li>

      <li>C.3 Proof of Theorem 15</li>

      <li>D Experimental Evaluation</li>

    </ul>

    <h2 id="sec-2" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">A zero-knowledge proof system <em>[37]</em> allows a prover to convince a verifier that a non-deterministic computation accepts without revealing more information than its input. In the last decade, there has been growing interest in zero-knowledge proof systems that additionally are succinct and non interactive <em>[46, 53, 35, 14]</em>, the so-called zkSNARKs. These are computationally-sound proof systems (arguments) that are succinct, in that their proofs are short and efficient to verify: the proof size and verification time should be constant or polylogarithmic in the length of the non-deterministic witness.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In circuit-based arguments for general computations the verifier must at least read the statement to be proven which includes both the description of the computation (i.e., the circuit) and its input (i.e., public input). But this is not succinct; by reading the whole circuit, the verifier runs linearly in the size of the computation. Preprocessing zkSNARKs try and work around this problem <em>[38, 50, 34, 15]</em>. Here the verifier generates a structured reference string (SRS) that depends on a certain circuit <span class="math">C</span>; it does this once and for all. This SRS can be used later to verify an unbounded number of proofs for the computation of <span class="math">C</span>. This is a succinct system: while the cost of SRS generation does depend on $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, proof verification does not have to.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Works on subversion-resistance show that CRS can be generated by a verifier with no impact on security <em>[1, 30, 5]</em>. But contexts with many verifiers, e.g. blockchains, require a trusted party. Solutions that mitigate this problem (e.g. MPC secure against dishonest majority <em>[9]</em>) are still expensive and often impractical as they should be carried out for each single computation <span class="math">C</span>. To address this problem, Groth et al. <em>[40]</em> introduced the model of universal and updatable SRS. An SRS is universal if it can be used to generate and verify proofs for all circuits of some bounded size; it is updatable if any user can add randomness to it and a sequence of updates makes it secure if at least one user acted honestly. Groth et al. <em>[40]</em> proposed the first zkSNARK with a universal and updatable SRS. Their scheme, though, requires an SRS of size quadratic in the number of multiplication gates of the supported arithmetic circuits (and similar quadratic update/verification time).</p>

    <p class="text-gray-300">Recent works <em>[51, 23, 60, 33, 24, 26]</em> have improved on this result obtaining universal and updatable SRS whose size is linear in the largest supported circuit. In particular, the current Marlin <em>[24]</em> and PLONK <em>[33]</em> proof systems achieve a proving time concretely faster than that of Sonic <em>[51]</em> while retaining constant-size proofs (<em>[23, 60, 26]</em> have instead polylogarithmic-size proofs). We also mention the very recent works of Bünz, Fisch and Szepieniec <em>[22]</em>, and Chiesa, Ojha and Spooner <em>[25]</em> that proposed zkSNARKs in the uniform random string (URS) model, that is implicitly universal and updatable; their constructions have a short URS and poly-logarithmic-size proofs. Yet another universal zkSNARK construction is that in <em>[47]</em> which, despite its proofs of 4 group elements and comparable proving time, has an SRS which is not updatable.</p>

    <p class="text-gray-300">Many of these efficient constructions (and the ones in this work) follow a similar blueprint to build zkSNARKs, which we now overview.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">The current landscape of zkSNARKs with universal SRS.</h4>

    <p class="text-gray-300">A known modular paradigm to build efficient cryptographic arguments <em>[42, 43]</em> works in two distinct steps. First construct an information-theoretic protocol in an abstract model, e.g., interactive proofs <em>[37]</em>, standard or linear PCPs <em>[15]</em>, IOPs <em>[54, 11]</em>. Then apply a compiler that, taking an abstract protocol as input, transforms it into an efficient computationally sound argument via a cryptographic primitive. This approach has been successfully adopted to construct zkSNARKs with universal SRS in the recent works <em>[33, 24, 22]</em>, in which the information theoretic object</p>

    <p class="text-gray-300">is an algebraically-flavored variant of Interactive Oracle Proofs (IOPs), while the cryptographic primitive are <em>polynomial commitments</em> <em>[45]</em>. Through polynomial commitments, a prover can compress a polynomial <span class="math">p</span> (as a message much shorter than all its concatenated coefficients) and can later open the commitment at evaluations of <span class="math">p</span>, namely to convince a verifier that <span class="math">y=p(x)</span> for public points <span class="math">x</span> and <span class="math">y</span>. In these IOP abstractions—called <em>algebraic holographic proofs</em> (AHP) in <em>[24]</em> and <em>polynomial IOPs</em> in <em>[22]</em>—a prover and a verifier interact, one providing oracle access to a set of polynomials and the other sending random challenges (if public-coin). At the end of the protocol the verifier asks for evaluations of these polynomials and decides to accept or reject based on the responses. The <em>idealized low-degree protocols</em> (ILDPs) abstraction of <em>[33]</em> proceeds similarly except that in the end the verifier asks to verify a set of polynomial identities over the oracles sent by the prover (which can be tested via evaluation on random points). To build a zkSNARK with universal SRS starting from AHPs/ILDPs we let the prover commit to the polynomials obtained from the AHP/ILDP prover, and then use the opening feature of polynomial commitments to respond to the evaluation queries in a sound way. As we detail later, our contribution revisits the aforementioned blueprint to construct universal zkSNARKs.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Our Contribution</h3>

    <p class="text-gray-300">In this work we propose Lunar, a <em>family</em> of new preprocessing zkSNARKs in the universal and updatable SRS model that have constant-size proofs and that improve on previous work <em>[51, 33, 24]</em> in terms of proof size and running time of the prover. Through our results we obtain a collection of zkSNARKs with different tradeoffs (see Table 4 in the Appendix for the full list).</p>

    <p class="text-gray-300">In Table 1, we present a detailed efficiency comparison between prior work and the best representatives of our schemes, when using arithmetic circuit satisfiability as common benchmark. LunarLite has the smallest proof size (384 bytes over the 100-bits-secure curve BN128; 544 bytes over 128-bits-secure BLS12-381) and the lowest proving time compared to the state of art of universal zkSNARKs with constant-size proofs for arithmetic circuits. As we explain later, LunarLite uses a new arithmetization of arithmetic circuit satisfiability that we call R1CS-lite, quite similar to rank-1 constraint systems (R1CS). A precise comparison to PLONK depends on the circuit structure and how the number <span class="math">m</span> of nonzero entries of R1CS-lite matrices depends on the number <span class="math">a</span> of addition gates; for instance, PLONK is faster for circuits with only multiplication gates, but LunarLite is faster when <span class="math">m\\leq 3a</span>.</p>

    <p class="text-gray-300">If we focus the comparison on solutions that directly support R1CS looking at Table 2 (of which Marlin <em>[24]</em> is the most performant among prior work), our scheme Lunar1cs (fast & short) offers the smallest SRS, the smallest proof and the fastest prover. This comes at the price of higher constants for the size of the (specialized) verification key and the verification time. Lunar1cs (short vk) offers a tradeoff: it has smaller verification key and faster verification time than Lunar1cs (fast & short), but slightly larger proofs, <span class="math">3\\times</span> larger SRS, and <span class="math">5m</span> more <span class="math">\\mathbb{G}_{1}</span>-exponentiations at proving time than Lunar1cs (fast & short). Even with this tradeoff, Lunar1cs (short vk) outperforms Marlin in all these measures. We implemented Lunar’s building blocks and we confirm our observations experimentally (Appendix D).</p>

    <p class="text-gray-300">Our main contribution to achieve this result is <em>to revisit the aforementioned blueprint to construct universal zkSNARKs</em> by proposing: (1) a new algebraically-flavored variant of IOPs, <em>Polynomial Holographic IOPs</em> (PHPs), and (2) a new compiler that builds universal zkSNARKs by using our PHPs together with <em>commit-and-prove zkSNARKs (CP-SNARKs) </em>[23]<em> for committed polynomials</em>. Additional contributions include: (3) pairing-based realizations of these CP-SNARKs for polynomials, (4) constructions of PHPs for both R1CS and a novel simplified variant of it, (5) a variant of the compiler (2) that yields a commit-and-prove universal zkSNARK. The latter is the first general compiler from (algebraic) IOPs to commit-and-prove zkSNARKs.</p>

    <p class="text-gray-300">Table 1. Efficiency of universal and updatable practical zkSNARKs for arithmetic circuit satisfiability with constant-size proofs.  <span class="math">n</span> : number of multiplication gates;  <span class="math">a</span> : number of addition gates;  <span class="math">m \\geq  n</span>  : number of nonzero entries in R1CS(-lite) matrices encoding the circuit;  <span class="math">N,N^{*},A</span>  and  <span class="math">M</span>  : largest supported values for  <span class="math">n,a + m,a</span>  and  <span class="math">m</span>  respectively.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">zkSNARK</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">srs</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ekR</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">vkR</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen</td>

            <td class="px-3 py-2 border-b border-gray-700">Derive</td>

            <td class="px-3 py-2 border-b border-gray-700">Prove</td>

            <td class="px-3 py-2 border-b border-gray-700">Verify</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Sonic [51]</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">4N</td>

            <td class="px-3 py-2 border-b border-gray-700">36n</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">4N</td>

            <td class="px-3 py-2 border-b border-gray-700">36n</td>

            <td class="px-3 py-2 border-b border-gray-700">273n</td>

            <td class="px-3 py-2 border-b border-gray-700">7 pairings</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">4N</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">4N</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ+log m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MARLIN [24]</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">3M</td>

            <td class="px-3 py-2 border-b border-gray-700">3m</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">3M</td>

            <td class="px-3 py-2 border-b border-gray-700">12m</td>

            <td class="px-3 py-2 border-b border-gray-700">14n+8m</td>

            <td class="px-3 py-2 border-b border-gray-700">2 pairings</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ+log m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PLONK (small proof) [33]</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">3N*</td>

            <td class="px-3 py-2 border-b border-gray-700">3n+3a</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">3N*</td>

            <td class="px-3 py-2 border-b border-gray-700">8n+8a</td>

            <td class="px-3 py-2 border-b border-gray-700">11n+11a</td>

            <td class="px-3 py-2 border-b border-gray-700">2 pairings</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">O((n+a) log(n+a))</td>

            <td class="px-3 py-2 border-b border-gray-700">O((n+a) log(n+a))</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ+log(n+a))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PLONK (fast prover) [33]</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">N*</td>

            <td class="px-3 py-2 border-b border-gray-700">n+a</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">N*</td>

            <td class="px-3 py-2 border-b border-gray-700">8n+8a</td>

            <td class="px-3 py-2 border-b border-gray-700">9n+9a</td>

            <td class="px-3 py-2 border-b border-gray-700">2 pairings</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">O((n+a) log(n+a))</td>

            <td class="px-3 py-2 border-b border-gray-700">O((n+a) log(n+a))</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ+log(n+a))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LunarLite (this work)</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">m</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">8n+3m</td>

            <td class="px-3 py-2 border-b border-gray-700">7 pairings</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">24m</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ+log m)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2. Efficiency comparison of universal zkSNARKs for R1CS with constant-size proofs.  <span class="math">n</span>  (resp.  <span class="math">m</span> ) is the dimension (resp. the number of nonzero entries) of the R1CS matrices;  <span class="math">N</span>  and  <span class="math">M</span>  are the largest supported values for  <span class="math">n</span>  and  <span class="math">m</span>  respectively. Entries in gray correspond to this work.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">zkSNARK</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">srs</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">ekR</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">vkR</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen</td>

            <td class="px-3 py-2 border-b border-gray-700">Derive</td>

            <td class="px-3 py-2 border-b border-gray-700">Prove</td>

            <td class="px-3 py-2 border-b border-gray-700">Verify</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MARLIN [24]</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">3M</td>

            <td class="px-3 py-2 border-b border-gray-700">3m</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">3M</td>

            <td class="px-3 py-2 border-b border-gray-700">12m</td>

            <td class="px-3 py-2 border-b border-gray-700">14n+8m</td>

            <td class="px-3 py-2 border-b border-gray-700">2 pairings</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ+log m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Lunar1cs (fast & short)</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">m</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">9n+3m</td>

            <td class="px-3 py-2 border-b border-gray-700">7 pairings</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">57m</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ+log m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Lunar1cs (short vk)</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">3M</td>

            <td class="px-3 py-2 border-b border-gray-700">3m</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">3M</td>

            <td class="px-3 py-2 border-b border-gray-700">12m</td>

            <td class="px-3 py-2 border-b border-gray-700">9n+8m</td>

            <td class="px-3 py-2 border-b border-gray-700">2 pairings</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ+log m)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A CP-SNARK permits to verify a proof through a commitment to an input (rather than an input in the clear) that, crucially, we can reuse among proofs. Below we detail our contributions.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Polynomial Holographic IOPs (PHPs).</h4>

    <p class="text-gray-300">Our PHPs generalize AHPs as well as ILDPs. A PHP consists of an interaction between a verifier and a prover sending oracle polynomials, followed by a decision phase in which the verifier outputs a set of polynomial identities to be checked on the prover’s polynomials (such as <span class="math">a(X)b(X)-z\\cdot c(X)\\stackrel{{\\scriptstyle?}}{{=}}0</span>, for oracle polynomials <span class="math">a,b,c</span> and some scalar <span class="math">z</span>), as well as a set of degree tests (e.g. <span class="math">\\mathsf{deg}(a(X))&lt;D</span>). The PHP model is close to ILDPs, but the two differ with respect to zero-knowledge formalizations: while ILDPs lack one altogether, we introduce and formalize a fine-grained notion of zero-knowledge—called <span class="math">(\\mathsf{b}_{1},\\ldots,\\mathsf{b}_{n})</span>-bounded zero-knowledge—where the verifier may learn up to <span class="math">\\mathsf{b}_{i}</span> evaluations of the <span class="math">i</span>-th oracle polynomial. When compared to AHPs, PHP has, again, a more granular notion of zero-knowledge, as well as verification queries that are more expressive than mere polynomial evaluations.</p>

    <p class="text-gray-300">As we shall discuss next, these two properties of PHPs—expressive verifier’s queries and a highly flexible zero-knowledge notion—naturally capture more (and more efficient) strategies when compiling into a cryptographic argument (e.g., we can weaken the required hiding property of the polynomial commitments and the zero-knowledge of the CP-SNARKs used in our compiler).</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">From PHPs to zkSNARKs through another model of polynomial commitments.</h4>

    <p class="text-gray-300">We describe how to compile a (public-coin) PHP into a zkSNARK. For AHPs and ILDPs <em>[33, 24]</em>, compilation works by letting the prover use polynomial commitments on the oracles and then open the commitments to the evaluations asked by the verifier. Our approach, though similar, has a key difference: <em>a different formalization of polynomial commitments with a modular design</em>.</p>

    <p class="text-gray-300">Our notion of polynomial commitments is <em>modular</em>: rather than seeing them as a monolithic primitive—a tuple of algorithms for both commitment and proofs—we split them into two parts, i.e., a regular commitment scheme with polynomials as message space, and a collection of commit-and-prove SNARKs (CP-SNARKs) for proving relations over committed polynomials. We find several advantages in this approach.</p>

    <p class="text-gray-300">As already argued in prior work on modular zkSNARKs through the commit-and-prove strategy <em>[23, 13]</em>, one benefit of this approach is <em>separation of concerns</em>: commitments are required to do one thing independently of the context (committing), whereas what we need to prove about them may depend on <em>where</em> we are applying them. For example, we often want to prove evaluation of committed polynomials: given a commitment <span class="math">c</span> and points <span class="math">x,y</span>, prove that <span class="math">y=p(x)</span> and <span class="math">c</span> opens to <span class="math">p</span>. But to compile a PHP (or AHP/ILDP) we also need to be able to prove other properties about them, such as checking degree bounds or testing equations over committed polynomials. Because these properties—and the techniques to prove them—are somehow independent from each other, we argue they should not be bundled under a bloated notion of polynomial commitment. Going one step further in this direction, we formalize commitment extractability as a proof of knowledge of opening of a polynomial commitment. This modular design allows us to describe an abstract compiler that assumes generic CP-SNARKs for the three aforementioned relations—proof of knowledge of opening, degree bounds and polynomial equations—and can yield zkSNARKs with different tradeoffs depending on how we instantiate them.</p>

    <p class="text-gray-300">We also find additional benefits of the modular abstraction. First, a CP-SNARK for testing equations over committed polynomials more faithfully captures the goal of the PHP verifier (as well as the AHP verifier in virtually all known constructions). Second, we can allow for realizations of CP-SNARKs for equations over polynomials other than the standard one, which reduces the problem of (batched) polynomial evaluations via random point evaluation. As an application, we show a simple scheme for quadratic equations that can even have an empty proof (see below); our most efficient realizations exploit this fact.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">From PHPs to zkSNARKs: fine-grained leakage requirements. Our second contribution on the compiler is to minimize the requirements needed to achieve zero-knowledge. As we shall discuss later, this allows us to obtain more efficient zkSNARKs. A straightforward compiler from PHPs to zkSNARKs would require hiding polynomial commitments and zero-knowledge CP-SNARKs; we weaken both requirements. Instead of “fully” hiding commitments, our compiler requires only somewhat hiding commitments. This new property guarantees, for each committed polynomial, leakage of at most one evaluation on a random point. Instead of compiling through “full” zero-knowledge CP-SNARKs, our compiler requires only <span class="math">(\\mathsf{b}_{1},\\ldots,\\mathsf{b}_{n})</span>-leaky zero-knowledge CP-SNARKs. This new notion is weaker than zero-knowledge and states that the verifier may learn up to <span class="math">\\mathsf{b}_{i}</span> evaluations of the <span class="math">i</span>-th committed polynomial.</p>

    <p class="text-gray-300">We show that by using a somewhat-hiding commitment scheme and a <span class="math">(\\mathsf{b}_{1},\\ldots,\\mathsf{b}_{n})</span>-leaky zero-knowledge CP-SNARK that can prove the checks of the PHP verifier, one can compile a PHP that is <span class="math">(\\mathsf{b}_{1}+1,\\ldots,\\mathsf{b}_{n}+1)</span>-bounded ZK into a fully-zero-knowledge succinct argument.</p>

    <p class="text-gray-300">Although related ideas were used in constructions in previous works <em>[33]</em>, our contribution is to systematically formalize (as well as expand) the properties needed on different fronts: the PHP, the commitment scheme, the CP-SNARKs used as building blocks and the interaction among all these in the compiler.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Pairing-based CP-SNARKs for committed polynomials.</h4>

    <p class="text-gray-300">We consider the basic commitment scheme for polynomials consisting of giving a “secret-point evaluation in the exponent” <em>[38, 45]</em> and then show CP-SNARKs for various relations over that same commitment scheme. In particular, by using techniques from previous works <em>[45, 33, 24]</em> we show CP-SNARKs for: proof of knowledge of an opening in the algebraic group model <em>[31]</em> (which actually comes for free), polynomial evaluation, degree bounds, and polynomial equations. In addition to these, we propose a new CP-SNARK for proving opening of several commitments with a proof consisting of one single group element; the latter relies on the PKE assumption <em>[38]</em> in the random oracle model. Also, we show that for a class of quadratic equations over committed polynomials (notably capturing some of the checks of our PHPs), we can obtain an optimized CP-SNARK in which the proof is empty as the verifier can test the relation using a pairing with the inputs (the inputs are commitments, i.e., group elements). This technique is reminiscent of the compiler from <em>[15]</em> that relies on linear encodings with quadratic tests.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">PHPs for constraint systems.</h4>

    <p class="text-gray-300">We propose a variety of PHPs for the R1CS constraint system and for a simplified variant of it that we call R1CS-lite. In brief, R1CS-lite is defined by two matrices <span class="math">\\bm{L},\\bm{R}</span> and accepts a vector <span class="math">\\bm{x}</span> if there is a <span class="math">\\bm{w}</span> such that, for <span class="math">\\bm{c}=(1,\\bm{x},\\bm{w})</span>, <span class="math">\\bm{L}\\cdot\\bm{c}\\circ\\bm{R}\\cdot\\bm{c}=\\bm{c}</span>. We show that R1CS-lite can express arithmetic circuit satisfiability with essentially the same complexity of R1CS, and its simpler form allows us to design slightly simpler PHPs. We believe this characterization of <span class="math">\\mathsf{NP}</span> problems to be of independent interest.</p>

    <p class="text-gray-300">Part of our techniques stem from those in Marlin <em>[24]</em>: we adopt their encoding of sparse matrices; also one of our main building blocks is the sumcheck protocol from Aurora of Ben-Sasson et. al. <em>[10]</em>. But in our PHPs we explore a different protocol that proves properties of sparse matrices and we introduce a refined efficient technique for zero-knowledge in a univariate sumcheck. In a nutshell, compared to <em>[10]</em> we show how to choose the masking polynomial with a specific sparse distribution that has only a constant-time impact on the prover. This idea and analysis of this technique is possible thanks to our fine-grained ZK formalism for PHPs. By combining this basic skeleton with different techniques we can obtain PHPs with different tradeoffs (see Table 3).</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Commit-and-prove zkSNARKs from PHPs.</h4>

    <p class="text-gray-300">We propose the first general compiler from an information-theoretic object such as (algebraic) IOPs— and more in general PHPs—to Commit-and-Prove zkSNARKs. Recall that the latter is a SNARK where the verifier’s input includes one (or several) reusable hiding commitment(s), i.e., to check that <span class="math">\\mathsf{R}(u_{1},\\ldots,u_{\\ell})</span> holds for a tuple of commitments <span class="math">(\\hat{c}_{j})_{j\\in[\\ell]}</span> such that <span class="math">\\hat{c}_{i}</span> opens</p>

    <p class="text-gray-300">to <span class="math">\\mathsf{u}_{i}</span>. By reusable we mean that these commitments could be used in multiple proofs and with different proof systems since their commitment key is generated before the setup of the proof system. To obtain a CP-SNARK we cannot apply the committing methods for polynomials used in <em>[33, 24]</em>: these require a known bound on how many times we will evaluate the polynomials. This is analogous to knowing a bound on the number of proofs over those same committed polynomials, which may be unknown at commitment time. Therefore we apply more stringent requirements and assume these commitments to be full-fledged hiding rather than just somewhat-hiding.</p>

    <p class="text-gray-300">To obtain our commit-and-prove compiler we adapt our compiler to zkSNARKs to include the following key idea: we prove a “link” between the committed witnesses <span class="math">(\\mathsf{u}_{j})_{j\\in[\\ell]}</span>—which open <em>hiding</em> commitments <span class="math">(\\hat{c}_{j})_{j\\in[\\ell]}</span>—and the PHP polynomials <span class="math">(p_{j})_{j\\in[n]}</span>—which open <em>somewhat-hiding</em> commitments <span class="math">(c_{j})_{j\\in[n]}</span>. . We design a specific CP-SNARK for this task, <span class="math">\\mathsf{CP}_{\\mathsf{link}}</span>. Our construction works for pairing-based commitments and supports a wide class of linking relations which include those in our PHP constructions.</p>

    <p class="text-gray-300">Simplifying a little bit, our techniques involve proving equality of images of distinct (committed) polynomials on distinct domains and they are of independent interest. In particular they can plausibly be adapted to compile other zkSNARKs with similar properties—e.g., Marlin or PLONK <em>[24, 33]</em>—into CP-SNARKs <em>with commitments that can be reused among different proofs</em>.</p>

    <p class="text-gray-300">Efficient CP-SNARKs with a universal setup are strongly motivated by practical applications. One of them is <em>committing-ahead-of-time</em> <em>[23, 12]</em> in which we commit to a value possibly <em>before</em> we can predict what we are going to prove about it. A CP-SNARK with a universal SRS, like those in this work, can be a requirement in the context of committing-ahead-of-time: if the setting requires committing to data <em>before</em> knowing what properties to prove about them (which can happen on-demand), the same setting can benefit from an (unspecialized) SRS string available <em>before</em> knowing what to prove about the committed data.</p>

    <p class="text-gray-300">Our work improves significantly on the efficiency of LegoUAC in <em>[23]</em>, a highly modular CP-SNARK construction with universal setup for universal relations (and the only one in literature to the best of our knowledge). Our results are also complementary to those of <em>[23]</em> (in particular their <em>specialized</em> CP-SNARKs with universal setup) and to those of works on efficient composable CP-SNARKs on commitments in prime order groups, such as <em>[13]</em>: our universal CP-SNARK can be composed with the schemes in these works <em>as they can all be derived from the same SRS</em>, or with some of the transparent instantiations in <em>[13]</em>.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">1.2 Other Related Work</h3>

    <p class="text-gray-300">SNARKs. In this work we focus on practical zkSNARKs with a universal and updatable setup and constant-size proofs. Recent work builds on our formalizations to expand this area designing a fully algebraic framework for modular arguments <em>[55]</em>. Here we briefly survey other works that obtain universality through other approaches at the cost of a larger proof size.</p>

    <p class="text-gray-300">Concurrent work in <em>[48]</em> proposes a new scheme with universal—but not updatable—SRS and an asymptotically linear prover (our prover is quasi-linear due to the use of FFT). By recursive composition they achieve an asymptotically <span class="math">O_{\\lambda}(1)</span>-size proof. In practice this is about <span class="math">9\\times</span> larger than some of our proofs.</p>

    <p class="text-gray-300">Spartan <em>[56]</em> obtains preprocessing arguments with a URS; it trades a transparent setup for larger arguments and less efficient verification, ranging from <span class="math">O(\\log^{2}(n)</span> to <span class="math">O(\\sqrt{n})</span>, depending on the instantiation.</p>

    <p class="text-gray-300">Concurrent work in <em>[49]</em> extends Spartan techniques obtaining a linear-time prover. They obtain asymptotically constant-sized proofs through one step of recursive composition with Groth16 <em>[39]</em>; they do not discuss concrete proof sizes. This, however, yields a scheme with universal but not updatable setup. It would require an existing scheme with universal and updatable setup to achieve the latter; their work can thus be seen as complementary to ours.</p>

    <p class="text-gray-300">Other works obtain universal SNARGS through a transparent setup and by exploiting the structure of the computation for succinctness. They mainly use two classes of techniques: hash-based vector commitments applied to oracle interactive proofs <em>[6, 7, 8]</em> or multivariate polynomial commitments and doubly-efficientinteractive proofs <em>[64, 63, 65, 58, 60, 62]</em>.</p>

    <p class="text-gray-300">Fractal <em>[25]</em> achieves transparent zkSNARKs with recursive composition—the ability of a SNARG to prove computations involving prior SNARGs. Their work also uses an algebraically-flavored variant of interactive oracle proofs that they call <em>Reed–Solomon encoded holographic IOPs</em>.</p>

    <p class="text-gray-300">Another line of work, e.g., <em>[2, 10, 18, 21, 32]</em>, obtains a restricted notion of succinctness with no preprocessing, a linear verifier and sublinear proof size.</p>

    <p class="text-gray-300">CP-SNARKs. The recent work in ECLIPSE <em>[3]</em> also presents a general compiler from information-theoretic objects to CP-SNARKs with a universal-updatable SRS. They instantiate their compiler with MARLIN, PLONK and Sonic <em>[24, 33, 51]</em> obtain different efficiency than ours. While our verification grows only linearly in the number of committed inputs <span class="math">\\ell</span>, theirs grows with the total size of the committed witnesses (which may be <span class="math">\\omega(\\ell)</span>). It is hard to directly compare the proof sizes in our work and theirs since our proofs are <span class="math">O(\\ell)</span>, while theirs grow logarithmically in the total size of the committed witness (their proofs are shorter for settings with many small committed inputs, for example). Other differences between the two works involve: commitment scheme, techniques and generality of the compiler. In <em>[3]</em> inputs are committed with (vector) Pedersen, while we assume a KZG commitment to the polynomial interpolating the input. The different commitments schemes between the two works also determine different techniques in our “linking gadgets” (see also Section 8.2): we use a pairing-based construction to show “shifts” of related polynomials, while they rely on compressed <span class="math">\\Sigma</span>-protocols <em>[4]</em>. Finally, while our compilers are similar in spirit and are both applicable to PHPs (although their formal description is only for AHPs), theirs is slightly less general as it assumes a “decomposition property” among the polynomials in the underlying PHP.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">1.3 Outline</h3>

    <p class="text-gray-300">See Section 2 for basic preliminaries. In Section 3 we define PHPs and we describe our PHP constructions in Section 4. The reader will find some preliminaries on commitment schemes and zkSNARKs in Section 5 Section 6 describes our first compiler from PHPs to universal zkSNARKs. Section 7 describes commitment schemes for polynomials and compatible CP-SNARKs that we use to instantiate our compilers. Section 8 presents our second compiler from PHPs to universal commit-and-prove zkSNARKs, as well as additional building blocks and their instantiations with pairing based commitments. Concrete compilations for the family of Lunar zkSNARKs are in Section 9.</p>

    <p class="text-gray-300">We refer the reader to the appendix for additional preliminaries, details on constraint systems, proofs, as well as our PHP for properties of sparse matrices.</p>

    <h2 id="sec-12" class="text-2xl font-bold">2 Basic Preliminaries</h2>

    <p class="text-gray-300">We denote by <span class="math">\\lambda\\in\\mathbb{N}</span> the security parameter, and by <span class="math">\\mathsf{poly}(\\lambda)</span> and <span class="math">\\mathsf{negl}(\\lambda)</span> the set of polynomial and negligible functions respectively. A function <span class="math">\\varepsilon(\\lambda)</span> is said negligible – denoted <span class="math">\\varepsilon(\\lambda)\\in\\mathsf{negl}(\\lambda)</span> – if <span class="math">\\varepsilon(\\lambda)</span> vanishes faster than the inverse of any polynomial in <span class="math">\\lambda</span>. An adversary <span class="math">\\mathcal{A}</span> is called efficient if <span class="math">\\mathcal{A}</span> is a family <span class="math">\\{\\mathcal{A}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> of nonuniform circuits of size <span class="math">\\mathsf{poly}(\\lambda)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a positive integer <span class="math">n\\in\\mathbb{N}</span> we let <span class="math">[n]:=\\{1,\\ldots,n\\}</span>. For a set <span class="math">S</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes its cardinality, and </span>x\\longleftrightarrow S<span class="math"> denotes the process of selecting </span>x<span class="math"> uniformly at random over </span>S<span class="math">. We write vectors and matrices in boldface font, e.g., </span>\\bm{v},\\bm{V}<span class="math">. So for a set </span>S<span class="math">, </span>\\bm{v}\\in S^{n}<span class="math"> is a short-hand for the tuple </span>(v_{1},\\ldots,v_{n})<span class="math">. Given two vectors </span>\\bm{u}<span class="math"> and </span>\\bm{v}<span class="math"> we denote by </span>\\bm{u}\\circ\\bm{v}$ their entry-wise (aka Hadamard) product.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We denote by <span class="math">\\mathbb{F}</span> a finite field, by <span class="math">\\mathbb{F}[X]</span> the ring of univariate polynomials in variable <span class="math">X</span>, and by <span class="math">\\mathbb{F}_{&lt;d}[X]</span> (resp. <span class="math">\\mathbb{F}_{\\leq d}[X]</span>) the set of polynomials in <span class="math">\\mathbb{F}[X]</span> of degree less (resp. less or equal) than <span class="math">d</span>.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Universal Relations.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A universal relation <span class="math">\\mathcal{R}</span> is a set of triples <span class="math">(\\mathsf{R},\\mathsf{x},\\mathsf{w})</span> where <span class="math">\\mathsf{R}</span> is a relation, <span class="math">\\mathsf{x}\\in\\mathcal{D}_{\\mathsf{x}}</span> is called the instance (or input), <span class="math">\\mathsf{w}\\in\\mathcal{D}_{w}</span> the witness, and <span class="math">\\mathcal{D}_{\\mathsf{x}},\\mathcal{D}_{\\mathsf{w}}</span> are domains that may depend on <span class="math">\\mathsf{R}</span>. Given <span class="math">\\mathcal{R}</span>, the corresponding universal language <span class="math">\\mathcal{L}(\\mathcal{R})</span> is the set <span class="math">\\{(\\mathsf{R},\\mathsf{x}):\\exists\\mathsf{w}:(\\mathsf{R},\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}\\}</span>. For a size bound <span class="math">\\mathsf{N}\\in\\mathbb{N}</span>, <span class="math">\\mathcal{R}_{\\mathsf{N}}</span> denotes the subset of triples <span class="math">(\\mathsf{R},\\mathsf{x},\\mathsf{w})</span> in <span class="math">\\mathcal{R}</span> such that <span class="math">\\mathsf{R}</span> has size at most <span class="math">\\mathsf{N}</span>, i.e. $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathsf{N}<span class="math">. In our work, we also write </span>\\mathcal{R}(\\mathsf{R},\\mathsf{x},\\mathsf{w})=1<span class="math"> (resp. </span>\\mathsf{R}(\\mathsf{x},\\mathsf{w})=1<span class="math">) to denote </span>(\\mathsf{R},\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}<span class="math"> (resp. </span>(\\mathsf{x},\\mathsf{w})\\in\\mathsf{R}$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">When discussing schemes that prove statements on committed values we assume that <span class="math">\\mathcal{D}_{\\mathsf{w}}</span> can be split in two subdomains <span class="math">\\mathcal{D}_{u}\\times\\mathcal{D}_{\\omega}</span>. Finally, we sometimes use an even more fine-grained specification of <span class="math">\\mathcal{D}_{u}</span> assuming we can split it over <span class="math">\\ell</span> arbitrary domains (<span class="math">\\mathcal{D}_{1}\\times\\cdots\\times\\mathcal{D}_{\\ell}</span>) for some arity <span class="math">\\ell</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">3 Polynomial Holographic IOPs</p>

    <p class="text-gray-300">In this section we define our notion of Polynomial Holographic IOPs (PHP). In a nutshell, a PHP is an interactive oracle proof (IOP) system that works for a family of universal relations <span class="math">\\mathcal{R}</span> that is specialized in two main ways. First, it is holographic, in the sense that the verifier has oracle access to the relation encoding, a set of oracle polynomials created by a trusted party, the <em>holographic relation encoder</em> (or simply, <em>encoder</em>) <span class="math">\\mathcal{RE}</span>. Second, it is algebraic in the sense that the system works over a finite field <span class="math">\\mathbb{F}</span>, the prover can at each round send to the verifier field elements or oracle polynomials, and the verifier queries are algebraic checks over these prover messages. For example the verifier can directly check polynomial identities such as <span class="math">p_{1}(X)p_{2}(X)p_{3}(X)+p_{4}(X)\\overset{?}{=}0</span>.</p>

    <p class="text-gray-300">Compared to the AHP notion of <em>[24]</em> and the polynomial IOP of <em>[22]</em>, PHPs have the following differences: the prover can also send actual messages in addition to oracle polynomials, and the verifier queries are more expressive than polynomial evaluations. This richer syntax—as we shall see in Sections 6 and 9—gives us more flexibility when compiling into a cryptographic argument system. Our model is closer to the idealized polynomial protocols of <em>[33]</em> in terms of verifier’s checks, but it adds to it the aforementioned general prover messages and a notion of zero-knowledge.</p>

    <p class="text-gray-300">More formally, a Polynomial Holographic IOP is defined as follows.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 1 (Polynomial Holographic IOP (PHP)).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{F}</span> be a family of finite fields and let <span class="math">\\mathcal{R}</span> be a universal relation. A Polynomial Holographic IOP over <span class="math">\\mathcal{F}</span> for <span class="math">\\mathcal{R}</span> is a tuple <span class="math">\\mathsf{PHP}=(\\mathsf{r},\\mathsf{n},\\mathsf{m},\\mathsf{d},\\mathsf{n}_{\\mathsf{e}},\\mathcal{RE},\\mathcal{P},\\mathcal{V})</span> where <span class="math">\\mathsf{r},\\mathsf{n},\\mathsf{m},\\mathsf{d},\\mathsf{n}_{\\mathsf{e}}:\\{0,1\\}^{*}\\to\\mathbb{N}</span> are polynomial-time computable functions, and <span class="math">\\mathcal{RE},\\mathcal{P},\\mathcal{V}</span> are three algorithms for the encoder, prover and verifier respectively, that work as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Offline phase: The encoder <span class="math">\\mathcal{RE}(\\mathbb{F},\\mathsf{R})</span> is executed on input a field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span> and a relation description <span class="math">\\mathsf{R}</span>, and it returns <span class="math">\\mathsf{n}(0)</span> polynomials <span class="math">\\{p_{0,j}\\}_{j\\in[\\mathsf{n}(0)]}</span> encoding the relation <span class="math">\\mathsf{R}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Online phase: The prover <span class="math">\\mathcal{P}(\\mathbb{F},\\mathsf{R},\\mathsf{x},\\mathsf{w})</span> and the verifier <span class="math">\\mathcal{V}^{\\mathcal{RE}(\\mathbb{F},\\mathsf{R})}(\\mathbb{F},\\mathsf{x})</span> are executed for $\\mathsf{r}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> rounds; the prover has a tuple </span>(\\mathsf{R},\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}<span class="math"> and the verifier has an instance </span>\\mathsf{x}<span class="math"> and oracle access to the polynomials encoding </span>\\mathsf{R}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the <span class="math">i</span>-th round, <span class="math">\\mathcal{V}</span> sends a message <span class="math">\\rho_{i}\\in\\mathbb{F}</span> to the prover, and <span class="math">\\mathcal{P}</span> replies with <span class="math">\\mathsf{m}(i)</span> messages <span class="math">\\{\\pi_{i,j}\\in\\mathbb{F}\\}_{j\\in[\\mathsf{m}(i)]}</span>, and <span class="math">\\mathsf{n}(i)</span> oracle polynomials <span class="math">\\{p_{i,j}\\in\\mathbb{F}[X]\\}_{j\\in[\\mathsf{n}(i)]}</span>, such that $\\mathsf{deg}(p_{i,j})<\\mathsf{d}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,i,j)$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Degree checks: to check a bound on the degree of the polynomials sent by the prover. More in detail, let $\\mathsf{n}_{\\mathsf{p}}=\\sum_{k=1}^{\\mathsf{r}(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathsf{R}</td>

            <td class="px-3 py-2 border-b border-gray-700">)}\\mathsf{n}(k)<span class="math"> and let </span>(p_{1},\\ldots,p_{\\mathsf{n}_{\\mathsf{p}}})<span class="math"> be the polynomials sent by </span>\\mathcal{P}<span class="math">. The verifier specifies a vector of integers </span>\\bm{d}\\in\\mathbb{N}^{\\mathsf{n}_{\\mathsf{p}}}$, which is satisfied if and only if</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\forall k\\in[\\mathsf{n}_{\\mathsf{p}}]:\\mathsf{deg}(p_{k})\\leq d_{k}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Polynomial checks: to check that certain polynomial identities hold between the oracle polynomials and the prover messages. More in detail, let $\\mathsf{n}^{*}=\\sum_{k=0}^{\\mathsf{r}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\mathsf{n}(k)<span class="math"> and </span>\\mathsf{m}^{*}=\\sum_{k=1}^{\\mathsf{r}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\mathsf{m}(k)<span class="math">, and denote by </span>(p_{1},\\ldots,p_{\\mathsf{n}^{<em>}})<span class="math"> and </span>(\\pi_{1},\\ldots,\\pi_{\\mathsf{m}^{</em>}})<span class="math"> all the oracle polynomials (including the </span>\\mathsf{n}(0)<span class="math"> ones from the encoder) and all the messages sent by the prover. The verifier can specify a list of </span>\\mathsf{n}_{\\mathsf{e}}<span class="math"> tuples, each of the form </span>(G,v_{1},\\ldots,v_{\\mathsf{n}^{<em>}})<span class="math">, where </span>G\\in\\mathbb{F}[X,X_{1},\\ldots,X_{\\mathsf{n}^{</em>}},Y_{1},\\ldots,Y_{\\mathsf{m}^{*}}]<span class="math"> and every </span>v_{k}\\in\\mathbb{F}[X]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then a tuple <span class="math">(G,v_{1},\\ldots,v_{\\mathsf{n}^{*}})</span> is satisfied if and only if <span class="math">F(X)\\equiv 0</span> where</p>

    <p class="text-gray-300"><span class="math">F(X):=G(X,\\{p_{k}(v_{k}(X))\\}_{k\\in[\\mathsf{n}^{<em>}]},\\{\\pi_{k}\\}_{k\\in[\\mathsf{m}^{</em>}]})</span></p>

    <p class="text-gray-300">The verifier accepts if and only if all the checks are satisfied.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency Measures. Given the functions <span class="math">\\mathsf{r},\\mathsf{d},\\mathsf{n},\\mathsf{m}</span> in the tuple <span class="math">\\mathsf{PHP}</span>, one can derive some efficiency measures of the protocol <span class="math">\\mathsf{PHP}</span> such as the total number of oracles sent by the encoder, <span class="math">\\mathsf{n}(0)</span>, by the prover <span class="math">\\mathsf{n}_{\\mathsf{p}}</span>, by both in total, <span class="math">\\mathsf{n}^{<em>}</span>; or the number of prover messages <span class="math">\\mathsf{m}^{</em>}</span>. In addition to these, we define below the following shorthands for two more measures of <span class="math">\\mathsf{PHP}</span>, the degree <span class="math">\\mathsf{D}</span> and the proof length $\\mathsf{l}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\[ \\mathsf{D}:=\\max_{\\begin{subarray}{c}\\mathsf{R}\\in\\mathcal{R}\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i\\in[0,\\mathsf{r}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)]\\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">j\\in[\\mathsf{n}(i)]\\end{subarray}}\\mathsf{m}(i)+\\mathsf{d}(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathsf{R}</td>

            <td class="px-3 py-2 border-b border-gray-700">,i,j). \\]</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{PHP}</span> can satisfy completeness, (knowledge) soundness and zero-knowledge, defined as follows.</p>

    <p class="text-gray-300">Completeness. A PHP is complete if for all <span class="math">\\mathbb{F}\\in\\mathcal{F}</span> and any satisfying triple <span class="math">(\\mathsf{R},\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}</span>, the checks returned by <span class="math">\\mathcal{V}^{\\mathcal{R}\\mathcal{E}(\\mathbb{F},\\mathsf{R})}(\\mathbb{F},\\mathsf{x})</span> after interacting with the honest prover <span class="math">\\mathcal{P}(\\mathbb{F},\\mathsf{R},\\mathsf{x},\\mathsf{w})</span>, are satisfied with probability 1.</p>

    <p class="text-gray-300">Soundness. A PHP is <span class="math">\\epsilon</span>-sound if for every field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span>, relation-instance tuple <span class="math">(\\mathsf{R},\\mathsf{x})\\notin\\mathcal{L}(\\mathcal{R})</span> and prover <span class="math">\\mathcal{P}^{*}</span> we have</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\langle\\mathcal{P}^{*},\\mathcal{V}^{\\mathcal{R}\\mathcal{E}(\\mathbb{F},\\mathsf{R})}(\\mathbb{F},\\mathsf{x})\\rangle=1]\\leq\\epsilon</span></p>

    <p class="text-gray-300">Knowledge Soundness. A PHP is <span class="math">\\epsilon</span>-knowledge-sound if there exists a polynomial-time knowledge extractor <span class="math">\\mathcal{E}</span> such that for any prover <span class="math">\\mathcal{P}^{*}</span>, field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span>, relation <span class="math">\\mathsf{R}</span>, instance <span class="math">\\mathsf{x}</span> and auxiliary input <span class="math">z</span>:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\Big{[}(\\mathsf{R},\\mathsf{x},\\mathsf{w})\\in\\mathsf{R}:\\mathsf{w}\\leftarrow\\mathcal{E}^{\\mathcal{P}^{<em>}}(\\mathbb{F},\\mathsf{R},\\mathsf{x},z)\\Big{]}\\geq\\Pr[\\langle\\mathcal{P}^{</em>}(\\mathbb{F},\\mathsf{R},\\mathsf{x},z),\\mathcal{V}^{\\mathcal{R}\\mathcal{E}(\\mathbb{F},\\mathsf{R})}(\\mathbb{F},\\mathsf{x})\\rangle=1]-\\epsilon</span></p>

    <p class="text-gray-300">where <span class="math">\\mathcal{E}</span> has oracle access to <span class="math">\\mathcal{P}^{<em>}</span>, i.e., it can query the next message function of <span class="math">\\mathcal{P}^{</em>}</span> (and also rewind it) and obtain all the messages and polynomials returned by it.</p>

    <p class="text-gray-300">Zero-Knowledge. A PHP is <span class="math">\\epsilon</span>-zero-knowledge if there exists a PPT simulator <span class="math">\\mathcal{S}</span> such that for every field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span>, every triple <span class="math">(\\mathsf{R},\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}</span>, and every algorithm <span class="math">\\mathcal{V}^{*}</span> the following random variables are within <span class="math">\\epsilon</span> statistical distance:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{View}\\big{(}\\mathcal{P}(\\mathbb{F},\\mathsf{R},\\mathsf{x},\\mathsf{w})\\ \\ ,\\mathcal{V}^{<em>}\\big{)}\\approx_{\\epsilon}\\mathsf{View}\\big{(}\\mathcal{S}^{\\mathcal{V}^{</em>}}(\\mathbb{F},\\mathsf{R},\\mathsf{x})\\big{)}</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{View}\\big{(}\\mathcal{P}(\\mathbb{F},\\mathsf{R},\\mathsf{x},\\mathsf{w})\\ \\ ,\\mathcal{V}^{<em>}\\big{)}</span> consists of <span class="math">\\mathcal{V}^{</em>}</span>’s randomness, <span class="math">\\mathcal{P}</span>’s messages <span class="math">\\pi_{1},\\ldots,\\pi_{\\mathsf{m}^{<em>}}</span> (which do not include the oracles) and <span class="math">\\mathcal{V}^{</em>}</span>’s list of checks, while <span class="math">\\mathsf{View}\\big{(}\\mathcal{S}^{\\mathcal{V}^{<em>}}(\\mathbb{F},\\mathsf{R},\\mathsf{x})\\big{)}</span> consists of <span class="math">\\mathcal{V}^{</em>}</span>’s randomness followed by <span class="math">\\mathcal{S}</span>’s output, obtained after having straightline access to <span class="math">\\mathcal{V}^{<em>}</span>, and <span class="math">\\mathcal{V}^{</em>}</span>’s list of checks.</p>

    <p class="text-gray-300">In our PHP notion the use of prover’s messages <span class="math">\\pi_{i}</span> is not strictly necessary as they could be replaced by (degree-0) polynomial oracles evaluated on 0 during the checks. However, having them explicitly is useful for the zero-knowledge definition: while messages are supposed not to leak information on the witness (i.e., they must be simulated), this does not hold for the oracles. Looking ahead to our compiler, this implies that one does not need to hide these messages from the verifier.</p>

    <p class="text-gray-300">On the class of polynomial checks. In the definition above, the class of polynomial checks of the verifier is stated quite generally. For convenience, we note that this class includes low-degree polynomials like <span class="math">G(\\{p_{i}(X)\\}_{i})</span> (e.g., <span class="math">p_{1}(X)p_{2}(X)p_{3}(X)+p_{4}(X)</span>), in which case each <span class="math">v_{i}(X)=X</span>, polynomial evaluations <span class="math">p_{i}(x)</span>, in which case <span class="math">v_{i}(X)=x</span>, tests over <span class="math">\\mathcal{P}</span> messages, e.g., <span class="math">p_{i}(x)-\\pi_{j}</span>, and combinations of all these.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Public coin and non-adaptive queries. A PHP is said to be public coin if each verifier message <span class="math">\\rho_{i}</span>, for $i=1,\\ldots,r(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, is a random element over a prescribed set, and so is an additional value </span>\\rho_{\\mathsf{r}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)+1}$ possibly used by the verifier to generate the final checks. A PHP is non-adaptive if all the verifier’s checks can be fully determined from its inputs and randomness, and thus are independent of the prover’s messages.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Since the PHP verifier’s checks are also polynomials evaluated over the prover’s messages, one may wonder if these are really independent. However, we note that, once having fixed the verifier’s randomness (which is</p>

    <p class="text-gray-300">independent of the prover’s messages), these checks (i.e., the pairs of polynomials <span class="math">(G,\\bm{v})</span> and degrees <span class="math">\\bm{d}</span>) can be fully determined. More formally, this means that the verifier <span class="math">\\mathcal{V}(\\mathbb{F},\\mathsf{x})</span> can be written as the combination of two prover-independent algorithms: a probabilistic sampler <span class="math">S_{\\mathcal{V}}(\\mathbb{F})\\to\\bm{\\rho}:=(\\rho_{1},\\ldots,\\rho_{\\mathsf{r}(\\mathsf{R})+1})</span> and a deterministic algorithm <span class="math">D_{\\mathcal{V}}(\\mathbb{F},\\mathsf{x};\\bm{\\rho})\\to(\\bm{d}\\cup\\{(G_{j},\\bm{v}_{j})\\}_{j\\in[\\mathsf{n}_{\\mathsf{e}}]})</span>.</p>

    <p class="text-gray-300"><em>In our work, we only consider PHPs that are public coin and non-adaptive.</em></p>

    <p class="text-gray-300">In the following we define two additional properties that can be satisfied by a PHP.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Bounded Zero-Knowledge.</h4>

    <p class="text-gray-300">We define a zero-knowledge property for PHPs, which is useful for our compiler of Section 6. Intuitively, this property requires that zero-knowledge holds even if the view includes a bounded number of evaluations of certain oracle polynomials at given points. Since such evaluations may leak information about the witness, this property ensures that this is not the case.</p>

    <p class="text-gray-300">For simplicity, we define this property for our scenario of interest only: for PHPs that are public-coin and with non-adaptive honest verifiers.</p>

    <p class="text-gray-300">The notion below shall guarantee zero-knowledge against verifiers that follow the specification of the protocol (thus, they are honest) but that can also arbitrarily query the polynomials sent by the prover. However, as the polynomials evaluated in some specific points could leak bits of information of the witness, we define a notion of “admissible” evaluations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say that a list <span class="math">\\mathcal{L}=\\{(i_{1},y_{1}),\\ldots\\}</span> is <span class="math">(\\mathsf{b},\\mathsf{C})</span>-bounded where <span class="math">\\mathsf{b}\\in\\mathbb{N}^{\\mathsf{n}_{\\mathsf{p}}}</span> and <span class="math">\\mathsf{C}</span> is a PT algorithm if $\\forall i\\in[\\mathsf{n}_{\\mathsf{p}}]:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{(i,y):(i,y)\\in\\mathcal{L}\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathsf{b}_{i}<span class="math"> and </span>\\forall(i,y)\\in\\mathcal{L}:\\mathsf{C}(i,y)=1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 2 (<span class="math">(\\mathsf{b},\\mathsf{C})</span>-Zero-Knowledge).</h6>

    <p class="text-gray-300">We say that <span class="math">\\mathsf{PHP}</span> is <span class="math">(\\mathsf{b},\\mathsf{C})</span>-Zero-Knowledge if for every triple <span class="math">(\\mathsf{R},\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}</span>, and every <span class="math">(\\mathsf{b},\\mathsf{C})</span>-bounded list <span class="math">\\mathcal{L}</span>, the following random variables are within <span class="math">\\epsilon</span> statistical distance:</p>

    <p class="text-gray-300"><span class="math">\\big{(}\\mathsf{View}\\big{(}\\mathcal{P}(\\mathbb{F},\\mathsf{R},\\mathsf{x},\\mathsf{w})\\ ,\\mathcal{V}\\big{)},(p_{i}(y))_{(i,y)\\in\\mathcal{L}}\\big{)}\\approx_{\\epsilon}\\mathcal{S}(\\mathbb{F},\\mathsf{R},\\mathsf{x},\\mathcal{V}(\\mathbb{F},\\mathsf{x}),\\mathcal{L}).</span></p>

    <p class="text-gray-300">where <span class="math">p_{1},\\ldots,p_{\\mathsf{n}_{\\mathsf{p}}}</span> are the polynomials returned by the prover <span class="math">\\mathcal{P}</span>.</p>

    <p class="text-gray-300">Moreover, we say that <span class="math">\\mathsf{PHP}</span> is <em>honest-verifier zero-knowledge with query bound <span class="math">\\mathsf{b}</span> (<span class="math">\\mathsf{b}</span>-HVZK for short) if there exists a PT algorithm <span class="math">\\mathsf{C}</span> such that <span class="math">\\mathsf{PHP}</span> is <span class="math">(\\mathsf{b},\\mathsf{C})</span>-ZK and for all <span class="math">i\\in\\mathbb{N}</span> we have <span class="math">\\Pr[\\mathsf{C}(i,y)=0]\\in\\mathsf{negl}(\\lambda)</span></em> where <span class="math">y</span> is uniformly sampled over <span class="math">\\mathbb{F}</span>.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Straight-line extractability.</h4>

    <p class="text-gray-300">In our compiler to commit-and-prove zkSNARKs, we consider PHPs where the extractor for the knowledge soundness satisfies a stronger property usually denoted as <em>straight-line extractability</em> in the literature. Informally, we consider an extractor that upon input the polynomials returned by the prover during an interaction with the verifier outputs a valid witness. We formalize this property below:</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 3 (Knowledge Soundness for PHPs with straight-line extractor.).</h6>

    <p class="text-gray-300">A PHP is <span class="math">\\epsilon</span>-knowledge-sound with straight-line extractor if there exists an extractor <span class="math">\\mathsf{WitExtract}</span> such that for any prover <span class="math">\\mathcal{P}^{*}</span>, every field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span>, relation <span class="math">\\mathsf{R}</span>, and instance <span class="math">\\mathsf{x}</span>:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\big{[}(\\mathsf{R},\\mathsf{x},\\mathsf{WitExtract}((p_{j})_{j\\in[\\mathsf{n}_{\\mathsf{p}}]}))\\in\\mathsf{R}\\big{]}\\geq\\Pr[\\langle\\mathcal{P}^{*},\\mathcal{V}^{\\mathcal{R}\\mathcal{E}(\\mathbb{F},\\mathsf{R})}(\\mathbb{F},\\mathsf{x})\\rangle=1]-\\epsilon</span></p>

    <p class="text-gray-300">where <span class="math">(p_{j})_{j\\in[\\mathsf{n}_{\\mathsf{p}}]}</span> are the polynomials output by <span class="math">\\mathcal{P}^{<em>}</span> in an execution of <span class="math">\\langle\\mathcal{P}^{</em>},\\mathcal{V}^{\\mathcal{R}\\mathcal{E}(\\mathbb{F},\\mathsf{R})}(\\mathbb{F},\\mathsf{x})\\rangle</span>.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">3.1 PHP Verifier Relation</h3>

    <p class="text-gray-300">We formalize the definition of an NP relation that models the PHP verifier’s decision phase. We shall use it in our compilers in Sections 6 and 8.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{PHP}=(\\mathsf{r},\\mathsf{n},\\mathsf{m},\\mathsf{d},\\mathsf{n}_{\\mathsf{e}},\\mathcal{R}\\mathcal{E},\\mathcal{P},\\mathcal{V})</span> be a PHP protocol over a finite field family <span class="math">\\mathcal{F}</span> for a universal relation <span class="math">\\mathcal{R}</span>, where <span class="math">\\mathsf{D}</span> is its maximal degree. We define <span class="math">\\mathcal{R}_{\\mathsf{php}}</span> as a family of polynomial-time relations that expresses the checks of <span class="math">\\mathcal{V}</span> over the oracle polynomials, which can be formally defined as follows.</p>

    <p class="text-gray-300">Let <span class="math">\\mathfrak{n}_{\\mathfrak{p}},\\mathfrak{n}^{*}\\in \\mathbb{N}</span> be two positive integers, and consider the following relations:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {R} _ {\\deg} ((d _ {k}) _ {k \\in [ \\mathfrak {n} _ {\\mathfrak {p}} ]}, (p _ {k}) _ {k \\in [ \\mathfrak {n} _ {\\mathfrak {p}} ]}) := \\bigwedge_ {k \\in [ \\mathfrak {n} _ {\\mathfrak {p}} ]} \\deg (p _ {k}) \\stackrel {?} {\\leq} d _ {k}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {R} _ {\\mathsf {e q}} ((G, \\boldsymbol {v}), (p _ {j}) _ {j \\in [ \\mathfrak {n} ^ {*} ]}) := G (X, (p _ {j} (v _ {j} (X))) _ {j \\in [ \\mathfrak {n} ^ {*} ]}) \\stackrel {?} {=} 0</span></div>

    <p class="text-gray-300">where <span class="math">G \\in \\mathbb{F}[X, X_1, \\ldots, X_{\\mathfrak{n}^<em>}]</span> and <span class="math">\\pmb{v} = (v_1, \\dots, v_{\\mathfrak{n}^</em>}) \\in \\mathbb{F}[X]^{\\mathfrak{n}^<em>}</span>. For a PHP verifier that returns a polynomial check <span class="math">(G&#x27;, \\pmb{v})</span>, <span class="math">\\mathsf{R}_{\\mathrm{eq}}</span> expresses such check if one considers <span class="math">G</span> as the partial evaluation of <span class="math">G&#x27;</span> at <span class="math">(Y_1 = \\pi_1, \\dots, Y_{\\mathfrak{m}^</em>} = \\pi_{\\mathfrak{m}^*})</span>. <span class="math">\\mathsf{R}_{\\mathrm{deg}}</span> instead expresses the degree checks of a PHP verifier.</p>

    <p class="text-gray-300">Given two relations <span class="math">\\mathsf{R}_A \\subset \\mathcal{D}_{\\mathbf{x}} \\times \\mathcal{D}_{\\mathbf{w}}</span> and <span class="math">\\mathsf{R}_B \\subset \\mathcal{D}_{\\mathbf{x}}&#x27; \\times \\mathcal{D}_{\\mathbf{w}}</span> with a common domain <span class="math">\\mathcal{D}_{\\mathbf{w}}</span> for the witness, consider the product operation <span class="math">\\mathsf{R}_A \\times \\mathsf{R}_B \\subset \\mathcal{D}_{\\mathbf{x}} \\times \\mathcal{D}_{\\mathbf{x}}&#x27; \\times \\mathcal{D}_{\\mathbf{w}}</span> containing all the tuples <span class="math">(\\mathbf{x}_A, \\mathbf{x}_B, \\mathbf{w})</span> where <span class="math">(\\mathbf{x}_A, \\mathbf{w}) \\in \\mathsf{R}_A</span> and <span class="math">(\\mathbf{x}_B, \\mathbf{w}) \\in \\mathsf{R}_B</span>. For an integer <span class="math">\\mathfrak{n}_{\\mathbf{e}}</span>, let</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {R} _ {\\mathsf {n} ^ {*}, \\mathsf {n} _ {\\mathsf {p}}, \\mathsf {n} _ {\\mathsf {e}}} := \\mathsf {R} _ {\\mathsf {d e g}} \\times \\overbrace {\\mathsf {R} _ {\\mathsf {e q}} \\times \\cdots \\times \\mathsf {R} _ {\\mathsf {e q}}} ^ {\\mathsf {n} _ {\\mathsf {e}} \\text { times}}</span></div>

    <p class="text-gray-300">Then we can define the family <span class="math">\\mathcal{R}_{\\mathrm{php}}</span> as</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {R} _ {\\text {p h p}} := \\left\\{\\mathrm {R} _ {\\mathrm {n} ^ {*} (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm {R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">), \\mathrm {n} _ {\\mathrm {p}} (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm {R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">), \\mathrm {n} _ {\\mathrm {e}} (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm {R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}: \\mathrm {R} \\in \\mathcal {R} \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $\\mathsf{n}^{*}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = \\sum_{j=0}^{\\mathsf{r}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)} \\mathsf{n}(j)<span class="math"> and </span>\\mathsf{n}_{\\mathsf{p}}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = \\sum_{j=1}^{\\mathsf{r}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)} \\mathsf{n}(j)<span class="math"> are the number of total and prover oracle polynomials respectively, in an execution of PHP with relation </span>\\mathsf{R} \\in \\mathcal{R}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-20" class="text-2xl font-bold">3.2 Compiling PHPs and AHPs into One Another</h2>

    <p class="text-gray-300">Here we discuss ways in which the formalisms of PHPs and AHPs are similar and how they can be compiled into each other straightforwardly. Recall that the main difference in the semantics of the two models is that a PHP supports more abstract queries that may not involve actual polynomial evaluations but only polynomial equations. One more difference is in the expressivity of verifiers' decision algorithms (see below).</p>

    <p class="text-gray-300">In the remainder of this section we consider only public-coin AHPs and PHPs with non-adaptive queries. For AHPs, this implies that the last steps of verification can be expressed as a pair of algorithms: one outputs a tuple of queries for the polynomial oracles; the other algorithm, that we denote by <span class="math">\\mathcal{V}_{\\mathrm{AHP}}</span> decides whether to accept or reject and takes the oracle responses and the view of the verifier's randomness as input. We can structure the verifier in a public-coin PHP with non-adaptive queries in an analogous manner.</p>

    <p class="text-gray-300">There is one main difference between the verifiers in the two models: the decision algorithm of a PHP, <span class="math">\\mathcal{V}_{\\mathrm{PHP}}</span>, is completely "algebraic"; <span class="math">\\mathcal{V}_{\\mathrm{AHP}}</span> is an arbitrary algorithm. While <span class="math">\\mathcal{V}_{\\mathrm{PHP}}</span> accepts if and only if all the degree-bounds and polynomial checks hold, <span class="math">\\mathcal{V}_{\\mathrm{AHP}}</span> can (in principle) run any arbitrary subroutine internally. We remark, however, that all the AHP constructions in [24] and several of the polynomial IOPs described in [22] (i.e. Polynomial IOP Starks [7], Spartan [56] and Sonic univariate [51]) actually present a very specific structure: they can all be expressed as a set of randomized zero-tests of low-degree polynomials. We finally assume that the verifier accepts if and only if all tests pass and that all polynomials in a test are sampled on the same unique point. When compiling AHPs into PHPs below, we shall assume this restriction on <span class="math">\\mathcal{V}_{\\mathrm{AHP}}</span>.</p>

    <p class="text-gray-300">Some high-level observations about compilation follow. When compiling AHPs into PHPs, or viceversa, the offline stages and the public coins sent by the verifier are the same. In the compilers below we need to slightly modify the provers in the two models (that we denote respectively by <span class="math">\\mathcal{P}_{\\mathrm{AHP}}</span> and <span class="math">\\mathcal{P}_{\\mathrm{PHP}}</span>) as well as the last steps of the verifiers. We need to take into account that the verifier in an AHP performs point-evaluation queries, whereas a PHP verifier does not. While all communication from <span class="math">\\mathcal{P}_{\\mathrm{PHP}}</span> consists in providing oracle access to some polynomial, in a PHP the prover can also send "messages", scalars whose distribution we require to simulate for zero-knowledge.</p>

    <p class="text-gray-300">13</p>

    <p class="text-gray-300">.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">Compiling PHP <span class="math">\\to</span> AHP:</h4>

    <p class="text-gray-300">The AHP prover <span class="math">\\mathcal{P}_{\\mathrm{AHP}}</span> sends the same oracle polynomials at the same round as <span class="math">\\mathcal{P}_{\\mathrm{PHP}}</span>. It also sends all messages (scalars) from <span class="math">\\mathcal{P}_{\\mathrm{PHP}}</span> at their respective rounds as degree-0 oracle polynomials. We let <span class="math">\\mathcal{V}_{\\mathrm{AHP}}</span> sample <span class="math">K</span> random scalars <span class="math">\\left(r_{i}\\right)_{i\\in[K]}</span>, where <span class="math">K</span> is the number of polynomial tests of <span class="math">\\mathcal{V}_{\\mathrm{PHP}}</span>. It then queries all the oracle polynomials in test <span class="math">i</span> of <span class="math">\\mathcal{V}_{\\mathrm{PHP}}</span> on point <span class="math">r_{i}</span>. Finally, for each of the polynomial checks <span class="math">i</span> in the PHP it evaluates <span class="math">F(r_{i})</span> with <span class="math">F</span> as defined in “Polynomial checks” in Definition 1 (at this point the verifier has all it needs to perform such a computation). It accepts if and only if all the evaluations equal <span class="math">0</span>.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">Compiling AHP <span class="math">\\to</span> PHP:</h4>

    <p class="text-gray-300">The PHP prover <span class="math">\\mathcal{P}_{\\mathrm{PHP}}</span> acts exactly as <span class="math">\\mathcal{P}_{\\mathrm{AHP}}</span> does by sending the same oracle polynomials at their respective rounds (it sends no scalar messages). We let <span class="math">\\mathcal{V}_{\\mathrm{PHP}}</span> perform the same test as <span class="math">\\mathcal{V}_{\\mathrm{AHP}}</span> and encode the queries of <span class="math">\\mathcal{V}_{\\mathrm{AHP}}</span> as constant polynomials <span class="math">v_{j}</span>-s (see “Polynomial checks” in Definition 1) appropriately. More specifically, each of the polynomials <span class="math">v_{j}</span>-s in test <span class="math">i</span> are such that <span class="math">v_{j}(X)=r_{i}</span> where <span class="math">r_{i}</span> is the polynomial we are sampling in test <span class="math">i</span>. The polynomial <span class="math">G</span> for each test is the one derived from the <span class="math">\\mathcal{V}_{\\mathrm{AHP}}</span> in the natural way. We also let <span class="math">\\mathcal{V}_{\\mathrm{PHP}}</span> output an explicit degree check for each of the oracle polynomials.</p>

    <h2 id="sec-23" class="text-2xl font-bold">4 Our PHP Constructions</h2>

    <p class="text-gray-300">In this section we present a collection of PHP constructions for two types of constraint systems: the by now standard rank-1 constraint systems <em>[34]</em> and an equally expressive variant we introduce in Section 4.3 called R1CS-lite. The two differ in the number of matrices used to represent a relation. While any relation for R1CS uses three matrices, instances of R1CS-lite use only two; the R1CS-lite matrices have roughly the same size as the ones in R1CS.</p>

    <p class="text-gray-300">All the PHPs in this section derive from the same (implicit) bare-bone protocols: one for R1CS and another one for R1CS-lite. We then provide variants of these protocols differing in two dimensions: how we encode non-zero entries in matrices—the ones corresponding to the relation—and how low is the degree in the verifier’s checks. In <span class="math">\\mathsf{PHP}_{\\mathsf{lite1}}</span> (resp. <span class="math">\\mathsf{PHP}_{\\mathsf{r1cs1}}</span>), we encode non-zero entries of the matrices using one single mapping, while in <span class="math">\\mathsf{PHP}_{\\mathsf{lite2}}</span> (resp. <span class="math">\\mathsf{PHP}_{\\mathsf{r1cs2}}</span>), each matrix carries its own mapping. In turn, we describe for each of these four constructions <span class="math">\\mathsf{PHP}_{<em>}</span> a slight variant that uses fewer polynomials to represent the relation, that we refer to as <span class="math">\\mathsf{PHP}_{</em>\\mathrm{x}}</span> (intuition: “the fewer polynomials” <span class="math">\\approx</span> “the higher the degree of the verifer checks”). Finally we provide one more construction called <span class="math">\\mathsf{PHP}_{\\mathsf{r1cs3}}</span> that shows an interesting tradeoff between the complexity of the offline phase and the verifier workload.</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">4.1 Algebraic Preliminaries</h3>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">Vanishing and Lagrange Basis Polynomials.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any subset <span class="math">S\\subseteq\\mathbb{F}</span> we denote by <span class="math">\\mathcal{Z}_{S}(X):=\\prod_{s\\in S}(X-s)</span> the <em>vanishing polynomial</em> of <span class="math">S</span>, that is the unique monic polynomial of degree at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> that is zero on every point of </span>S<span class="math">. Also, for any </span>S\\subseteq\\mathbb{F}<span class="math"> we denote by </span>\\mathcal{L}_{s}^{S}(X)<span class="math"> the <em></span>s<span class="math">-th Lagrange basis polynomial</em>, which is the unique polynomial of degree at most </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> such that for any </span>s^{\\prime}\\in S$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\[ \\mathcal{L}_{s}^{S}(s^{\\prime})=\\begin{cases}1&\\text{if }s=s^{\\prime},\\\\ 0&\\text{otherwise}.\\end{cases} \\]</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">Multiplicative subgroups.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this paper we work with subsets of <span class="math">\\mathbb{F}</span> that are <em>multiplicative subgroups</em>. These have nice efficiency properties crucial for our results. If <span class="math">\\mathbb{H}\\subseteq\\mathbb{F}</span> is a multiplicative subgroup of order <span class="math">n</span>, then its vanishing polynomial has a compact representation $\\mathcal{Z}_{\\mathbb{H}}(X)=(X^{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}-1)<span class="math">. Similarly, <em>[44, 57, 59]</em> show that for such specific </span>\\mathbb{H}<span class="math"> every Lagrange polynomial has the following compact representation </span>\\mathcal{L}_{\\eta}^{\\mathbb{H}}(X)=\\frac{\\eta}{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\cdot\\frac{X^{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}-1}{X-\\eta}<span class="math">. Both </span>\\mathcal{Z}_{\\mathbb{H}}(X)<span class="math"> and </span>\\mathcal{L}_{\\eta}^{\\mathbb{H}}(X)<span class="math"> can be evaluated in </span>O(\\log n)<span class="math"> field operations. When </span>\\mathbb{H}<span class="math"> is clear from the context we just write </span>\\mathcal{Z}\\left(X\\right)<span class="math"> instead of </span>\\mathcal{Z}_{\\mathbb{H}}(X)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We assume that <span class="math">\\mathbb{H}</span> comes with a bijection <span class="math">\\phi_{\\mathbb{H}}:\\mathbb{H}\\to[n]</span> (e.g., using a canonical ordering of the elements of <span class="math">\\mathbb{H}</span>). For more compact notation, we use elements of <span class="math">\\mathbb{H}</span> to index the entries of a matrix <span class="math">\\bm{M}\\in\\mathbb{F}^{n\\times n}</span> (resp. vector <span class="math">\\bm{v}\\in\\mathbb{F}^{n}</span>, namely we use <span class="math">\\bm{M}_{\\eta,\\eta^{\\prime}}</span> (resp. <span class="math">\\bm{v}_{\\eta}</span>) to denote <span class="math">\\bm{M}_{\\phi_{\\mathbb{H}}(\\eta),\\phi_{\\mathbb{H}}(\\eta^{\\prime})}</span> (resp. <span class="math">\\bm{v}_{\\phi_{\\mathbb{H}}(\\eta)}</span>).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a multiplicative subgroup <span class="math">\\mathbb{H} \\subseteq \\mathbb{F}</span> of order <span class="math">n</span> and any vector <span class="math">\\mathbf{v} \\in \\mathbb{F}^n</span>, we denote by <span class="math">v(X)</span> its interpolating polynomial in <span class="math">\\mathbb{H}</span>, which is the unique polynomial of degree at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math"> such that, for all </span>\\eta \\in \\mathbb{H}<span class="math">, </span>v(\\eta) = \\mathbf{v}_{\\eta}<span class="math">. Note that </span>v(X)<span class="math"> can be computed from </span>\\mathbf{v}<span class="math"> in time </span>O(n \\log n)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 1 (Polynomial Division).</strong> Given a multiplicative subgroup <span class="math">\\mathbb{H} \\subset \\mathbb{F}</span> and polynomial <span class="math">p \\in \\mathbb{F}_{\\leq d}[X]</span> where <span class="math">d \\geq n</span>, there exist unique quotient and remainder polynomials $q \\in \\mathbb{F}_{\\leq d -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}(X), r \\in \\mathbb{F}_{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2}(X)<span class="math"> and constant </span>c \\in \\mathbb{F}<span class="math"> such that </span>p(X) = q(X) \\cdot \\mathcal{Z}_{\\mathbb{H}}(X) + X \\cdot r(X) + c<span class="math">. We denote by </span>\\mathrm{DivPoly}_{\\mathbb{H}}<span class="math"> the (efficient) procedure that computes these polynomials in </span>O(d \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ time using polynomial long division.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We use the following strategy from [10, 24] as the main tool to define a sumcheck protocol for univariate polynomials over multiplicative subgroups:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 2 (Univariate Sumcheck).</strong> Let <span class="math">p \\in \\mathbb{F}_d[X]</span> and multiplicative subgroup <span class="math">\\mathbb{H} \\subset \\mathbb{F}</span> of order $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\sigma = \\sum_{\\eta \\in \\mathbb{H}} p(\\eta) \\iff \\exists q, r: p(X) = q(X) \\mathcal{Z}_{\\mathbb{H}}(X) + X r(X) + \\frac{\\sigma}{n} \\text{ with } \\deg(r) &amp;lt; n - 1</span></div>

    <p class="text-gray-300"><strong>Proof.</strong> We proceed by proving both directions of the above statement.</p>

    <p class="text-gray-300"><span class="math">(\\Rightarrow)</span> Note that by Lemma ??, <span class="math">p(X)</span> can be uniquely defined as <span class="math">p(X) = q(X)\\mathcal{Z}_{\\mathbb{H}}(X) + Xr(X) + c</span>. Then, proving the above claim is equivalent to proving that the constant term equals <span class="math">\\frac{\\sigma}{n}</span>. Assuming <span class="math">\\sigma = \\sum_{\\eta \\in \\mathbb{H}} p(\\eta)</span>, then <span class="math">\\sigma = \\sum_{\\eta \\in \\mathbb{H}} (q(\\eta)\\mathcal{Z}_{\\mathbb{H}}(\\eta) + \\eta \\cdot r(\\eta) + c)</span>. Since <span class="math">\\mathcal{Z}_{\\mathbb{H}}(\\eta) = 0</span> for all <span class="math">\\eta \\in \\mathbb{H}</span>, the sumcheck above reduces to checking <span class="math">\\sigma = \\sum_{\\eta \\in \\mathbb{H}} (\\eta \\cdot r(\\eta)) + n \\cdot c</span>. Now by the zero sum lemma from the Aurora proof system [10][Remark 5.6], given any polynomial <span class="math">f \\in \\mathbb{F}_{&amp;lt;n}[X]</span> and multiplicative subgroup <span class="math">\\mathbb{H}</span> of size <span class="math">n</span> it holds that <span class="math">\\sum_{\\eta \\in \\mathbb{H}} f(\\eta) = 0</span> if and only if <span class="math">f(0) = 0</span>. Then, <span class="math">\\sum_{\\eta \\in \\mathbb{H}} \\eta \\cdot r(\\eta) = 0</span> because <span class="math">r&#x27;(X) = X \\cdot r(X)</span> is a polynomial of degree less than <span class="math">n</span> with constant term 0. This implies that <span class="math">c = \\frac{\\sigma}{n}</span>.</p>

    <p class="text-gray-300"><span class="math">(\\Leftarrow)</span> Assume polynomial <span class="math">p(X)</span> can be expressed as <span class="math">q(X)\\mathcal{Z}_{\\mathbb{H}}(X) + Xr(X) + \\frac{\\sigma}{n}</span>. Then, the sum of <span class="math">p(X)</span> over the group <span class="math">\\mathbb{H}</span> is <span class="math">\\sum_{\\eta \\in \\mathbb{H}} q(\\eta)\\mathcal{Z}_{\\mathbb{H}}(\\eta) + \\sum_{\\eta \\in \\mathbb{H}} \\eta \\cdot r(\\eta) + n \\cdot \\frac{\\sigma}{n}</span>. Using the same reasoning as above, this equation reduces to <span class="math">\\sum_{\\eta \\in \\mathbb{H}} p(\\eta) = \\sigma</span>, which concludes the proof.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 4 (Masking Polynomial).</strong> Given a subgroup <span class="math">\\mathbb{H} \\subset \\mathbb{F}</span> and an integer <span class="math">b \\geq 1</span>, we denote by <span class="math">\\mathsf{Mask}_b^{\\mathbb{H}}(\\cdot)</span> a method which on input a polynomial $p \\in \\mathbb{F}_{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}[X]<span class="math"> returns a random polynomial </span>p'(X) \\in \\mathbb{F}_{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ b}[X]<span class="math"> that agrees with </span>p(X)<span class="math"> on the points of the subgroup </span>\\mathbb{H}<span class="math">. This is essentially a shorthand for </span>\\mathsf{Mask}_b^{\\mathbb{H}}(p(X)) := p(X) + \\mathcal{Z}_{\\mathbb{H}}(X)\\rho(X)<span class="math"> for a randomly sampled </span>\\rho(X) \\leftrightarrow \\mathbb{F}_{&lt;b}[X]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Definition 5 (Bivariate Lagrange polynomial).</strong> Given a multiplicative subgroup <span class="math">\\mathbb{H} \\subseteq \\mathbb{F}</span>, we define the bivariate Lagrange polynomial <span class="math">\\varLambda_{\\mathbb{H}}(X,Y) := \\frac{\\mathcal{Z}_{\\mathbb{H}}(X) \\cdot Y - X \\cdot \\mathcal{Z}_{\\mathbb{H}}(Y)}{n \\cdot (X - Y)}</span>.</p>

    <p class="text-gray-300">This polynomial has two properties that are interesting for our work. First, for all <span class="math">\\eta \\in \\mathbb{H}</span> it holds that <span class="math">\\varLambda_{\\mathbb{H}}(X,\\eta)=\\mathcal{L}_{\\eta}^{\\mathbb{H}}(X)</span>. Second, its compact representation enables its evaluation in <span class="math">O(\\log n)</span> time.</p>

    <p class="text-gray-300">The first property is a direct corollary of the following lemma.</p>

    <p class="text-gray-300"><strong>Lemma 3.</strong> Let <span class="math">\\mathbb{F}</span> be a finite field and <span class="math">\\mathbb{H} \\subseteq \\mathbb{F}</span> a multiplicative subgroup. Then it holds <span class="math">\\varLambda_{\\mathbb{H}}(X,Y) = \\sum_{\\eta \\in \\mathbb{H}} \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(Y)</span>.</p>

    <p class="text-gray-300">15</p>

    <p class="text-gray-300">Proof. The claim is proven via the following transformations:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_{\\eta \\in \\mathbb{H}} \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(Y) = \\sum_{\\eta \\in \\mathbb{H}} \\frac{\\eta^{2}}{n^{2}} \\frac{\\mathcal{Z}_{\\mathbb{H}}(X) \\cdot \\mathcal{Z}_{\\mathbb{H}}(Y)}{(X - \\eta)(Y - \\eta)} = \\frac{\\mathcal{Z}_{\\mathbb{H}}(X) \\cdot \\mathcal{Z}_{\\mathbb{H}}(Y)}{X - Y} \\sum_{\\eta \\in \\mathbb{H}} \\frac{\\eta^{2}}{n^{2}} \\frac{X - Y}{(X - \\eta)(Y - \\eta)} \\\\ = \\frac{\\mathcal{Z}_{\\mathbb{H}}(X) \\cdot \\mathcal{Z}_{\\mathbb{H}}(Y)}{n \\cdot (X - Y)} \\sum_{\\eta \\in \\mathbb{H}} \\frac{\\eta^{2}}{n} \\left(\\frac{X - \\eta}{(X - \\eta)(Y - \\eta)} + \\frac{X - Y - (X - \\eta)}{(X - \\eta)(Y - \\eta)}\\right) \\\\ = \\frac{\\mathcal{Z}_{\\mathbb{H}}(X) \\cdot \\mathcal{Z}_{\\mathbb{H}}(Y)}{n \\cdot (X - Y)} \\sum_{\\eta \\in \\mathbb{H}} \\frac{\\eta^{2}}{n} \\left(\\frac{1}{Y - \\eta} - \\frac{1}{X - \\eta}\\right) \\\\ = \\frac{1}{n \\cdot (X - Y)} \\left(\\mathcal{Z}_{\\mathbb{H}}(X) \\sum_{\\eta \\in \\mathbb{H}} \\eta \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(Y) - \\mathcal{Z}_{\\mathbb{H}}(Y) \\sum_{\\eta \\in \\mathbb{H}} \\eta \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X)\\right) \\\\ = \\frac{(\\mathcal{Z}_{\\mathbb{H}}(X) \\cdot Y - \\mathcal{Z}_{\\mathbb{H}}(Y) \\cdot X)}{n \\cdot (X - Y)} \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the last step we used the property that any polynomial <span class="math">p(X)</span> of degree $&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> can be written as </span>\\sum_{\\eta \\in \\mathbb{H}} p(\\eta) \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X)<span class="math">, which implies that </span>X = \\sum_{\\eta \\in \\mathbb{H}} \\eta \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sparse Matrix Encodings For a matrix <span class="math">M</span> we denote by $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> the number of its nonzero entries, which we call its density. We will occasionally use encodings for sparse matrices inspired by that of [24]. In brief, a sparse matrix </span>M<span class="math"> can be represented with three polynomials </span>(\\mathsf{val}_M, \\mathsf{row}_M, \\mathsf{col}_M)<span class="math">, where </span>\\mathsf{row}_M: \\mathbb{K} \\to \\mathbb{H}<span class="math"> (resp. </span>\\mathsf{col}_M: \\mathbb{K} \\to \\mathbb{H}<span class="math">) is the function such that </span>\\mathsf{row}_M(\\kappa)<span class="math"> (resp. </span>\\mathsf{col}_M(\\kappa)<span class="math">) is the row (resp. column) index of the </span>\\kappa<span class="math">-th nonzero entry of </span>M<span class="math">, and </span>\\mathsf{val}_M: \\mathbb{K} \\to \\mathbb{F}<span class="math"> is the function that encodes the values of </span>M$ in some arbitrary ordering.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 6 (Sparse Matrix Encodings). Let <span class="math">\\mathbb{H}</span> be a multiplicative subgroup of order <span class="math">n</span>, <span class="math">M \\in \\mathbb{F}^{n \\times n}</span> be a square matrix with elements in <span class="math">\\mathbb{F}</span>, and let <span class="math">\\mathbb{K}</span> be another multiplicative subgroup of <span class="math">\\mathbb{F}</span> whose order is at least the number of nonzero elements of <span class="math">M</span>, namely $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The sparse encoding of <span class="math">M</span> is a triple <span class="math">(\\mathsf{val}_M, \\mathsf{row}_M, \\mathsf{col}_M)</span> of polynomials in $\\mathbb{F}_{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}[X]<span class="math"> such that for all </span>\\kappa \\in \\mathbb{K}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{val}_M(\\kappa) = M_{\\mathsf{row}_M(\\kappa), \\mathsf{col}_M(\\kappa)}</span></div>

    <p class="text-gray-300">We define the matrix-encoding polynomial of <span class="math">M</span> as the bivariate polynomial</p>

    <div class="my-4 text-center"><span class="math-block">V_M(X, Y) := \\sum_{\\kappa \\in \\mathbb{K}} \\mathsf{val}_M(\\kappa) \\cdot \\mathcal{L}_{\\mathsf{row}_M(\\kappa)}^{\\mathbb{H}}(X) \\cdot \\mathcal{L}_{\\mathsf{col}_M(\\kappa)}^{\\mathbb{H}}(Y).</span></div>

    <p class="text-gray-300">Note that the matrix-encoding polynomial of <span class="math">M</span> is such that, for all <span class="math">\\eta, \\eta&#x27; \\in \\mathbb{H}</span>, <span class="math">V_M(\\eta, \\eta&#x27;) = M_{\\eta, \\eta&#x27;}</span>.</p>

    <p class="text-gray-300">When the matrix is obvious from the context, we will not explicitly use the subscript <span class="math">M</span> in these polynomials.</p>

    <p class="text-gray-300">In the following lemma we show how a sparse encoding polynomial of a matrix <span class="math">M</span> can be used to express linear transformations by <span class="math">M</span>.</p>

    <p class="text-gray-300">Lemma 4 (Sparse Linear Encoding). Let <span class="math">M \\in \\mathbb{F}^{n \\times n}</span> be a matrix with a sparse encoding polynomial <span class="math">V_M(X, Y)</span> as per Definition 6. Let <span class="math">\\mathbf{v}, \\mathbf{y} \\in \\mathbb{F}^n</span> be two vectors and <span class="math">v(X), y(X)</span> be their interpolating polynomials over <span class="math">\\mathbb{H}</span>. Then <span class="math">\\mathbf{y} = \\mathbf{M} \\cdot \\mathbf{v}</span> if and only if <span class="math">y(X) = \\sum_{\\eta \\in \\mathbb{H}} v(\\eta) \\cdot V_M(X, \\eta)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9 In the best case, we will have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. But sometimes a subgroup of this size (being FFT-friendly as well) may not exist and we need to pad with dummy zero entries.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">16</p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">This can be seen via the following equality</p>

    <p class="text-gray-300"><span class="math">\\sum_{\\eta,\\eta^{\\prime}\\in\\mathbb{H}}\\bm{M}_{\\eta,\\eta^{\\prime}}\\cdot v(\\eta^{\\prime})\\cdot\\mathcal{L}_{\\eta}^{\\mathbb{H}}(X)</span> <span class="math">=\\sum_{\\kappa\\in\\mathbb{K}}\\mathsf{val}_{M}(\\kappa)\\cdot v(\\mathsf{col}(\\kappa))\\cdot\\mathcal{L}_{\\mathsf{row}(\\kappa)}^{\\mathbb{H}}(X)</span> <span class="math">=\\sum_{\\kappa\\in\\mathbb{K}}\\mathsf{val}_{M}(\\kappa)\\cdot\\sum_{\\eta\\in\\mathbb{H}}v(\\eta)\\cdot\\mathcal{L}_{\\mathsf{col}(\\kappa)}^{\\mathbb{H}}(\\eta)\\cdot\\mathcal{L}_{\\mathsf{row}(\\kappa)}^{\\mathbb{H}}(X)</span> <span class="math">=\\sum_{\\eta\\in\\mathbb{H}}v(\\eta)\\cdot V_{M}(X,\\eta)</span></p>

    <p class="text-gray-300">If <span class="math">\\bm{y}=\\bm{M}\\cdot\\bm{v}</span> then its interpolation <span class="math">y(X)=\\sum_{\\eta\\in\\mathbb{H}}\\bm{y}_{\\eta}\\cdot\\mathcal{L}_{\\eta}^{\\mathbb{H}}(X)</span> can be written <span class="math">y(X)=\\sum_{\\eta,\\eta^{\\prime}\\in\\mathbb{H}}\\bm{M}_{\\eta,\\eta^{\\prime}}\\cdot v(\\eta^{\\prime})\\cdot\\mathcal{L}_{\\eta}^{\\mathbb{H}}(X)</span>, and thus the above equality shows the desired result. On other direction, if <span class="math">y(X)=\\sum_{\\eta\\in\\mathbb{H}}v(\\eta)\\cdot V_{M}(X,\\eta)</span> then by the above equality we have that for all <span class="math">\\eta\\in\\mathbb{H}</span> holds <span class="math">\\bm{y}_{\\eta}=\\sum_{\\eta^{\\prime}\\in\\mathbb{H}}\\bm{M}_{\\eta,\\eta^{\\prime}}\\cdot v(\\eta^{\\prime})</span>, i.e., <span class="math">\\bm{y}=\\bm{M}\\cdot\\bm{v}</span>.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">Joint Sparse Encodings for Multiple Matrices.</h4>

    <p class="text-gray-300">Finally, when working with multiple matrices, it is sometimes convenient to use a sparse encoding that keeps track of entries that are nonzero in either of the matrices. This has the advantage of having a pair of <span class="math">\\mathsf{col},\\mathsf{row}</span> polynomials that is common to all matrices.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Here we show the case of two matrices <span class="math">\\bm{L},\\bm{R}</span>. This can be easily extended to more matrices. Let <span class="math">\\mathcal{S}=\\{(\\eta,\\eta^{\\prime})\\in\\mathbb{H}\\times\\mathbb{H}:\\bm{L}_{\\eta,\\eta^{\\prime}}\\neq 0\\vee\\bm{R}_{\\eta,\\eta^{\\prime}}\\neq 0\\}</span> be the set of indices where either <span class="math">\\bm{L}</span> or <span class="math">\\bm{R}</span> are nonzero. Let <span class="math">\\mathbb{K}</span> be the minimal-size multiplicative subgroup of <span class="math">\\mathbb{F}</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is in the worst case </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Then we can encode matrices </span>\\bm{L},\\bm{R}<span class="math"> similarly to definition 6 by using the same polynomials </span>\\{\\mathsf{row},\\mathsf{col}\\}<span class="math"> to keep track of the indices of their nonzero entries, and the polynomials </span>\\{\\mathsf{val}_{L},\\mathsf{val}_{R}\\}<span class="math"> for their values. Namely, for any </span>\\kappa\\in\\mathbb{K}<span class="math">, the polynomials are defined such that </span>\\mathsf{val}_{L}(\\kappa)=\\bm{L}_{\\mathsf{row}(\\kappa),\\mathsf{col}(\\kappa)}<span class="math"> and </span>\\mathsf{val}_{R}(\\kappa)=\\bm{R}_{\\mathsf{row}(\\kappa),\\mathsf{col}(\\kappa)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">4.2 Rank-1 Constraint Systems</h3>

    <p class="text-gray-300">We recall the definition of the rank-1 constraint systems (R1CS) language.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Definition 7 (R1CS).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a finite field and <span class="math">n,m,\\ell\\in\\mathbb{N}</span> be positive integers. The universal relation <span class="math">\\mathcal{R}_{R1CS}</span> is the set of triples</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{R},\\mathsf{x},\\mathsf{w}):=\\big{(}(\\mathbb{F},n,m,\\ell,\\bm{L},\\bm{R},\\bm{O}),\\bm{x},\\bm{w}\\big{)}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\bm{L},\\bm{R},\\bm{O}\\in\\mathbb{F}^{n\\times n}</span>, $\\max\\{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{O}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}\\leq m<span class="math">, </span>\\bm{x}\\in\\mathbb{F}^{\\ell-1}<span class="math">, </span>\\bm{w}\\in\\mathbb{F}^{n-\\ell}<span class="math">, and for </span>\\bm{z}:=(1,\\bm{x},\\bm{w})$ it holds</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">(\\bm{L}\\cdot\\bm{z})\\circ(\\bm{R}\\cdot\\bm{z})=\\bm{O}\\cdot\\bm{z}</span></p>

    <p class="text-gray-300">We now introduce a new language called R1CS-lite, which can be seen as a simplified version of R1CS with only two matrices. In brief, an R1CS-lite relation is defined by two matrices <span class="math">\\bm{L},\\bm{R}</span> and is satisfied if there exists a vector <span class="math">\\bm{c}</span> such that <span class="math">(\\bm{L}\\cdot\\bm{c})\\circ(\\bm{R}\\cdot\\bm{c})=\\bm{c}</span>. We show that R1CS-lite is as expressive as R1CS as it can be used to express the language of arithmetic circuit satisfiability with essentially the same complexity as R1CS (see Appendix A.3). At the same time, though, the two-matrix form allows us to obtain PHP constructions (and resulting zkSNARKs) that are simpler and more efficient.</p>

    <p class="text-gray-300">More formally, R1CS-lite is defined as follows.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Definition 8 (R1CS-lite).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be a finite field and <span class="math">n,m\\in\\mathbb{N}</span> be positive integers. The universal relation <span class="math">\\mathcal{R}_{R1CS\\text{-}lite}</span> is the set of triples</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{R},\\mathsf{x},\\mathsf{w}):=((\\mathbb{F},n,m,\\ell,\\{\\bm{L},\\bm{R}\\}),\\bm{x},\\bm{w})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\bm{L},\\bm{R}\\in\\mathbb{F}^{n\\times n}</span>, $\\max\\{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}\\leq m<span class="math">, the first </span>\\ell<span class="math"> rows of </span>\\bm{R}<span class="math"> are </span>(-1,0,\\ldots,0)\\in\\mathbb{F}^{1\\times n}<span class="math">, </span>\\bm{x}\\in\\mathbb{F}^{\\ell-1}<span class="math">, </span>\\bm{w}\\in\\mathbb{F}^{n-\\ell}<span class="math">, and for </span>\\bm{c}:=(1,\\bm{x},\\bm{w})$, it holds</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">(\\bm{L}\\bm{c})\\circ(\\bm{R}\\bm{c})=\\bm{c}</span></p>

    <p class="text-gray-300">Summary of our PHP constructions. In the following table, we provide a summary of our constructions for R1CS and R1CS-lite that are described in the next sections:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 3. Comparison of our PHP constructions, all with relation encoder complexity  <span class="math">O(m \\log m)</span> , prover complexity  <span class="math">O(m \\log m + n \\log n)</span>  and verifier complexity  <span class="math">O(\\ell + \\log m + \\log n)</span> . Here,  <span class="math">n</span>  is the dimension of the square matrices. For simplicity of the table, we make the assumption that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= m &gt; 2n<span class="math"> , which is true in many cases. We call  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 5n + 2m - 2\\ell + 2\\mathsf{b}_a + 2\\mathsf{b}_b + 2\\mathsf{b}_s + 6\\mathsf{b}_q - 4<span class="math"> , and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ n - \\ell + \\mathsf{b}_w + 7\\mathsf{b}_q<span class="math"> . For the verifier checks, we denote by &quot;deg&quot; the number of degree checks that require a tight bound; the last two columns show the degree of the two polynomial checks where in the first one we have all  </span>v_j(X) = y<span class="math">  and in the second one all  </span>v_j(X) = X$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PHP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">degree</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">oracles</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">messages</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">proof length</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V checks</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">R£</td>

            <td class="px-3 py-2 border-b border-gray-700">P</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">deg degX,{Xi} (G1)</td>

            <td class="px-3 py-2 border-b border-gray-700">degX,{Xi} (G2)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PHPlite1</td>

            <td class="px-3 py-2 border-b border-gray-700">4.3</td>

            <td class="px-3 py-2 border-b border-gray-700">2m</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700">+ 2m</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PHPlite1x</td>

            <td class="px-3 py-2 border-b border-gray-700">Rk.2</td>

            <td class="px-3 py-2 border-b border-gray-700">2m</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700">+ 2m</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PHPlite2</td>

            <td class="px-3 py-2 border-b border-gray-700">4.3</td>

            <td class="px-3 py-2 border-b border-gray-700">m</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PHPlite2x</td>

            <td class="px-3 py-2 border-b border-gray-700">Rk.3</td>

            <td class="px-3 py-2 border-b border-gray-700">m</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PHPr1cs1</td>

            <td class="px-3 py-2 border-b border-gray-700">4.4</td>

            <td class="px-3 py-2 border-b border-gray-700">3m</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π'</td>

            <td class="px-3 py-2 border-b border-gray-700">+ 4m</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PHPr1cs1x</td>

            <td class="px-3 py-2 border-b border-gray-700">Rk.5</td>

            <td class="px-3 py-2 border-b border-gray-700">3m</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π'</td>

            <td class="px-3 py-2 border-b border-gray-700">+ 4m</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PHPr1cs2</td>

            <td class="px-3 py-2 border-b border-gray-700">4.4</td>

            <td class="px-3 py-2 border-b border-gray-700">m</td>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π'</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PHPr1cs2x</td>

            <td class="px-3 py-2 border-b border-gray-700">Rk.6</td>

            <td class="px-3 py-2 border-b border-gray-700">m</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π'</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PHPr1cs3</td>

            <td class="px-3 py-2 border-b border-gray-700">4.4</td>

            <td class="px-3 py-2 border-b border-gray-700">3m</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π'</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this section we describe a collection of PHPs for the R1CS-lite constraint system. Precisely, we give one main protocol and a few variants of it that offer various efficiency tradeoffs.</p>

    <p class="text-gray-300">In all our constructions we use a variant of R1CS-lite in which we slightly expand the witness, and we express the witnesses and the check into polynomial form.</p>

    <p class="text-gray-300">Definition 9 (Polynomial R1CS-lite). Let  <span class="math">\\mathbb{F}</span>  be a finite field and  <span class="math">n, m \\in \\mathbb{N}</span>  be positive integers. We define the universal relation  <span class="math">\\mathcal{R}_{polyRICS - lite}</span>  as the set of triples</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left(\\mathbb {F}, n, m, \\{\\boldsymbol {L}, \\boldsymbol {R} \\}, \\ell\\right), \\boldsymbol {x}, \\left(a ^ {\\prime} (X), b ^ {\\prime} (X)\\right)\\right)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">\\pmb{L},\\pmb{R}\\in \\mathbb{F}^{n\\times n}</span> ,  $\\max \\{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb {L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb {R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\} \\leq m<span class="math"> ,  </span>\\pmb {x}\\in \\mathbb{F}^{\\ell -1}<span class="math"> ,  </span>a^\\prime (X),b^\\prime (X)\\in \\mathbb{F}_{\\leq n - \\ell -1}[X]<span class="math"> , and such that  </span>\\pmb{x}^{\\prime} = (1,\\pmb {x})<span class="math"> </span>a(X)\\coloneqq \\sum_{\\eta \\in \\mathbb{L}}\\pmb{x}'_{\\phi_{\\mathbb{H}}(\\eta)}\\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) + a'(X)\\cdot \\mathcal{Z}_{\\mathbb{L}}(X)<span class="math">  and  </span>b(X)\\coloneqq 1 + b'(X)\\cdot \\mathcal{Z}_{\\mathbb{L}}(X)<span class="math"> , it holds, over  </span>\\mathbb{F}[X,Z]$ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">a (X) + Z \\cdot b (X) + \\sum_ {\\eta , \\eta^ {\\prime} \\in \\mathbb {H}} \\left(\\boldsymbol {L} _ {\\eta , \\eta^ {\\prime}} + Z \\cdot \\boldsymbol {R} _ {\\eta , \\eta^ {\\prime}}\\right) \\cdot a \\left(\\eta^ {\\prime}\\right) \\cdot b \\left(\\eta^ {\\prime}\\right) \\cdot \\mathcal {L} _ {\\eta} ^ {\\mathbb {H}} (X) = 0 \\tag {1}</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathbb{L} := \\{\\phi_{\\mathbb{H}}^{-1}(1), \\ldots, \\phi_{\\mathbb{H}}^{-1}(\\ell)\\}</span>  (not a group) and  <span class="math">\\mathcal{Z}_{\\mathbb{L}}(X) := \\prod_{\\eta \\in \\mathbb{L}} (X - \\eta)</span> .</p>

    <p class="text-gray-300">The following lemma shows that the two relations are equivalent. For completeness, we give the proof in Appendix A.1.</p>

    <p class="text-gray-300">Lemma 5.  <span class="math">\\mathcal{L}(\\mathcal{R}_{RICS - lite})\\equiv \\mathcal{L}(\\mathcal{R}_{polyRICS - lite}).</span></p>

    <p class="text-gray-300">Our Main PHP for R1CS-lite</p>

    <p class="text-gray-300">We start by describing the main ideas of this PHP protocol, which we denote <span class="math">\\mathsf{PHP}_{\\mathsf{lite1}}</span>. The prover’s goal is to convince the verifier that the polynomials <span class="math">a(X),b(X)</span> satisfy equation (1).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To this end, the relation encoder <span class="math">\\mathcal{RE}</span> encodes the matrices <span class="math">\\bm{L},\\bm{R}</span> by using a joint sparse encoding, as discussed in section 4.1. This encoding consists of four polynomials <span class="math">(\\mathsf{val}_{L},\\mathsf{val}_{R},\\mathsf{col},\\mathsf{row})</span> in $\\mathbb{F}_{<</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}[X]<span class="math">. In this case we use a multiplicative subgroup </span>\\mathbb{K}\\subseteq\\mathbb{F}<span class="math"> of minimal cardinality such that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2m\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By applying the sparse linear encoding of Lemma 4 to the matrices <span class="math">\\bm{L}</span> and <span class="math">\\bm{R}</span> and using the property of the bivariate Lagrange polynomial that <span class="math">\\Lambda_{\\mathbb{H}}(X,\\eta)=\\mathcal{L}^{\\mathbb{H}}_{\\eta}(X)</span>, equation (1) can be expressed as</p>

    <p class="text-gray-300"><span class="math">0</span> <span class="math">=a(X)+Z\\cdot b(X)+\\sum_{\\eta\\in\\mathbb{H}}a(\\eta)\\cdot b(\\eta)\\cdot(V_{L}(X,\\eta)+Z\\cdot V_{R}(X,\\eta))</span> <span class="math">=\\sum_{\\eta\\in\\mathbb{H}}(a(\\eta)+Z\\cdot b(\\eta))\\cdot\\Lambda_{\\mathbb{H}}(X,\\eta)+a(\\eta)\\cdot b(\\eta)\\cdot V_{LR}(X,\\eta,Z)\\in\\mathbb{F}[X,Z]</span> (2)</p>

    <p class="text-gray-300">where, exploiting the use of <span class="math">\\mathsf{col},\\mathsf{row}</span> common to <span class="math">\\bm{L},\\bm{R}</span>, <span class="math">V_{LR}(X,Y,Z)</span> is:</p>

    <p class="text-gray-300"><span class="math">V_{LR}(X,Y,Z)=V_{L}(X,Y)+Z\\cdot V_{R}(X,Y)=\\sum_{\\kappa\\in\\mathbb{K}}(\\mathsf{val}_{L}(\\kappa)+Z\\cdot\\mathsf{val}_{R}(\\kappa))\\cdot\\mathcal{L}^{\\mathbb{H}}_{\\mathsf{row}(\\kappa)}(X)\\cdot\\mathcal{L}^{\\mathbb{H}}_{\\mathsf{col}(\\kappa)}(Y)</span></p>

    <p class="text-gray-300">In order to show that <span class="math">a(X),b(X)</span> satisfy equation (2), the verifier draws random points <span class="math">x,\\alpha\\leftrightarrows\\mathbb{F}</span> that are used to “compress” the equation from <span class="math">\\mathbb{F}[X,Z]</span> to <span class="math">\\mathbb{F}</span>. Then, the prover’s task becomes to show that</p>

    <p class="text-gray-300"><span class="math">\\sum_{\\eta\\in\\mathbb{H}}(a(\\eta)+\\alpha\\cdot b(\\eta))\\cdot\\Lambda_{\\mathbb{H}}(x,\\eta)+a(\\eta)\\cdot b(\\eta)\\cdot V_{LR}(x,\\eta,\\alpha)=0</span></p>

    <p class="text-gray-300">This is done via a univariate sumcheck over <span class="math">p(X):=(a(X)+\\alpha\\cdot b(X))\\cdot\\Lambda_{\\mathbb{H}}(x,X)+a(X)\\cdot b(X)\\cdot V_{LR}(x,X,\\alpha)</span>. However, since <span class="math">p(X)</span> depends on the witness, we make the sumcheck zero-knowledge by doing it over <span class="math">p(X)+s(X)</span> for a random polynomial <span class="math">s(X)</span> sent by the prover in the first round. Although this resembles the zero-knowledge sumcheck technique of <em>[10]</em>, we propose an optimized way to randomly sample a sparse <span class="math">s(X)</span>, which is sufficient for the bounded zero-knowlegde of our PHP. So, for the sumcheck the prover sends two polynomials <span class="math">q(X),r(X)</span> such that <span class="math">s(X)+p(X)=q(X)\\cdot\\varlrcorner_{\\mathbb{H}}(X)+X\\cdot r(X)</span>. The verifier checks this equation by evaluating all the polynomials on a random point <span class="math">y\\leftrightarrows\\mathbb{F}\\setminus\\mathbb{H}</span>. To do this, the verifier can compute on its own (in <span class="math">O(\\log n)</span> time) the polynomials <span class="math">\\Lambda_{\\mathbb{H}}(x,y)</span>, <span class="math">\\varlrcorner_{\\mathbb{H}}(y)</span>, and query all the others, except for <span class="math">V_{LR}(x,y,\\alpha)</span>. For the latter the prover sends a candidate value <span class="math">\\sigma</span> and runs a univariate sumcheck to convince the verifier that <span class="math">\\sigma=\\sum_{\\kappa\\in\\mathbb{K}}(\\mathsf{val}_{L}(\\kappa)+\\alpha\\cdot\\mathsf{val}_{R}(\\kappa))\\cdot\\mathcal{L}^{\\mathbb{H}}_{\\mathsf{row}(\\kappa)}(x)\\cdot\\mathcal{L}^{\\mathbb{H}}_{\\mathsf{col}(\\kappa)}(y)</span>.</p>

    <p class="text-gray-300">In what follows we give a detailed description of the PHP protocol <span class="math">\\mathsf{PHP}_{\\mathsf{lite1}}</span>.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">Offline phase <span class="math">\\mathcal{RE}(\\mathbb{F},n,m,\\{\\bm{L},\\bm{R}\\},\\ell)</span></h4>

    <p class="text-gray-300">The holographic relation encoder takes as input a description of the specific relation and outputs eight polynomials</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\{\\mathsf{col}(X),\\mathsf{row}(X),\\mathsf{cr}(X),\\mathsf{col}^{\\prime}(X),\\mathsf{row}^{\\prime}(X),\\mathsf{cr}^{\\prime}(X),\\mathsf{vcr}_{L}(X),\\mathsf{vcr}_{R}(X)\\}\\in\\mathbb{F}_{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}[X]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">that are computed as follows. First, it finds the polynomials <span class="math">\\{\\mathsf{col},\\mathsf{row},\\mathsf{val}_{L},\\mathsf{val}_{R}\\}</span> described above such that for all <span class="math">\\kappa\\in\\mathbb{K}</span> <span class="math">\\mathsf{val}_{L}(\\kappa)=\\bm{L}_{\\mathsf{row}(\\kappa),\\mathsf{col}(\\kappa)}</span> and <span class="math">\\mathsf{val}_{R}(\\kappa)=\\bm{R}_{\\mathsf{row}(\\kappa),\\mathsf{col}(\\kappa)}</span>. Second, it computes:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{cr}(X)</span> <span class="math">:=\\sum_{\\kappa\\in\\mathbb{K}}\\mathsf{col}(\\kappa)\\cdot\\mathsf{row}(\\kappa)\\cdot\\mathcal{L}^{\\mathbb{K}}_{\\kappa}(X)</span> <span class="math">\\big{\\{}\\mathsf{vcr}_{M}(X)</span> <span class="math">:=\\sum_{\\kappa\\in\\mathbb{K}}\\mathsf{val}_{M}(\\kappa)\\cdot\\mathsf{cr}(\\kappa)\\cdot\\mathcal{L}^{\\mathbb{K}}_{\\kappa}(X)\\big{\\}}_{M\\in\\{L,R\\}}</span> <span class="math">\\mathsf{col}^{\\prime}(X)</span> <span class="math">:=X\\cdot\\mathsf{col}(X),\\quad\\mathsf{row}^{\\prime}(X):=X\\cdot\\mathsf{row}(X),\\quad\\mathsf{cr}^{\\prime}(X):=X\\cdot\\mathsf{cr}(X)</span></p>

    <p class="text-gray-300">Essentially, the polynomials <span class="math">\\mathsf{cr}(X),\\mathsf{vcr}_{L}(X)</span> and <span class="math">\\mathsf{vcr}_{R}(X)</span> are low-degree extensions of the polynomials <span class="math">\\mathsf{col}(X)\\cdot\\mathsf{row}(X)</span>, <span class="math">\\mathsf{val}_{L}(X)\\cdot\\mathsf{col}(X)\\cdot\\mathsf{row}(X)</span> and <span class="math">\\mathsf{val}_{R}(X)\\cdot\\mathsf{col}(X)\\cdot\\mathsf{row}(X)</span> respectively, while <span class="math">\\mathsf{col}^{\\prime},\\mathsf{row}^{\\prime}</span> and <span class="math">\\mathsf{cr}^{\\prime}</span></p>

    <p class="text-gray-300">are a shifted version of  <span class="math">\\mathsf{col}</span> , row and  <span class="math">\\mathsf{cr}</span>  respectively. The intuition behind expanding the sparse encoding of  <span class="math">\\pmb{L}</span> ,  <span class="math">\\pmb{R}</span>  in this way is to keep the polynomial checks of the verifier of the lowest possible degree. In particular we are interested in obtaining a PHP where  <span class="math">\\deg_{X,\\{X_i\\}}(G)\\leq 2</span>  as it enables interesting instantiations of our compiler. As an example, by adding  <span class="math">\\mathsf{cr}(X)</span>  we can replace terms involving  <span class="math">\\mathsf{col}(X)\\cdot \\mathsf{row}(X)</span>  with  <span class="math">\\mathsf{cr}(X)</span> . This shall become more clear when looking at the decision phase.</p>

    <p class="text-gray-300">Online phase  <span class="math">\\langle \\mathcal{P}((\\mathbb{F},n,m,\\{\\pmb {L},\\pmb {R}\\} ,\\ell),\\pmb {x},(a&#x27;(X),b&#x27;(X))),\\mathcal{V}(\\mathbb{F},n,m,\\pmb {x})\\rangle</span></p>

    <p class="text-gray-300">The prover samples two random polynomials</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <p class="text-gray-300">and sets  <span class="math">s(X) \\coloneqq q_s(X) \\cdot \\mathcal{Z}_{\\mathbb{H}}(X) + X \\cdot r_s(X)</span> . Note that, whenever  <span class="math">\\mathsf{b}_r + \\mathsf{b}_q \\leq n</span> , the pair  <span class="math">q_s(X), r_s(X)</span>  is a unique decomposition of  <span class="math">s(X)</span> , and also  <span class="math">s(X) \\in \\mathbb{F}_{\\leq n + \\mathsf{b}_s + \\mathsf{b}_q - 1}[X]</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}</span>  sends to  <span class="math">\\mathcal{V}</span> :  <span class="math">s(X)</span>  and randomized versions of the witness polynomials  <span class="math">\\hat{a}&#x27;(X) \\leftrightarrow \\operatorname{Mask}_{\\mathsf{b}_n + \\mathsf{b}_q}^{\\mathbb{H} \\backslash \\mathbb{L}}(a&#x27;(X)) \\in \\mathbb{F}_{\\leq n - \\ell + \\mathsf{b}_n + \\mathsf{b}_q - 1}[X]</span>  and  <span class="math">\\hat{b}&#x27;(X) \\leftrightarrow \\operatorname{Mask}_{\\mathsf{b}_b + \\mathsf{b}_q}^{\\mathbb{H} \\backslash \\mathbb{L}}(b&#x27;(X)) \\in \\mathbb{F}_{\\leq n - \\ell + \\mathsf{b}_b + \\mathsf{b}_q - 1}[X]</span> .</p>

    <p class="text-gray-300">The verifier sends two random points  <span class="math">x, \\alpha \\gets \\mathbb{F}</span> .</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">The prover uses  <span class="math">x, \\alpha</span>  to "compress" the check of equation (1) over  <span class="math">\\mathbb{F}[X,Z]</span>  into a sumcheck  <span class="math">\\sum_{\\eta \\in \\mathbb{H}} p(\\eta) = 0</span>  over  <span class="math">\\mathbb{F}</span>  for the polynomial</p>

    <div class="my-4 text-center"><span class="math-block">p (X) := (\\hat {a} (X) + \\alpha \\cdot \\hat {b} (X)) \\cdot \\Lambda_ {\\mathbb {H}} (x, X) + \\hat {a} (X) \\cdot \\hat {b} (X) \\cdot V _ {L R} (x, X, \\alpha)</span></div>

    <p class="text-gray-300">where, for  <span class="math">\\pmb{x}^{\\prime} = (1,\\pmb {x})</span>  , we have</p>

    <div class="my-4 text-center"><span class="math-block">\\hat {a} (X) := \\hat {a} ^ {\\prime} (X) \\cdot \\mathcal {Z} _ {\\mathbb {L}} (X) + \\sum_ {\\eta \\in \\mathbb {L}} \\boldsymbol {x} _ {\\phi_ {\\mathbb {H}} (\\eta)} ^ {\\prime} \\cdot \\mathcal {L} _ {\\eta} ^ {\\mathbb {H}} (X) \\in \\mathbb {F} _ {\\leq n + \\mathrm {b} _ {a} + \\mathrm {b} _ {q} - 1} [ X ],</span></div>

    <div class="my-4 text-center"><span class="math-block">\\hat {b} (X) := \\hat {b} ^ {\\prime} (X) \\cdot \\mathcal {Z} _ {\\mathbb {L}} (X) + 1 \\in \\mathbb {F} _ {\\leq n + \\mathrm {b} _ {b} + \\mathrm {b} _ {q} - 1} [ X ],</span></div>

    <p class="text-gray-300">and  <span class="math">\\varLambda_{\\mathbb{H}}(x,X)\\in \\mathbb{F}_{n - 1}[X]</span>  is the minimal degree polynomial such that for all  <span class="math">\\eta \\in \\mathbb{H}</span> :  <span class="math">\\varLambda_{\\mathbb{H}}(x,\\eta)=\\mathcal{L}_{\\eta}^{\\mathbb{H}}(x)</span> .</p>

    <p class="text-gray-300">Next,  <span class="math">\\mathcal{P}</span>  computes and sends polynomials  <span class="math">q(X)\\in \\mathbb{F}_{\\leq 2n + \\mathsf{b}_a + \\mathsf{b}_b + 2\\mathsf{b}_q - 3}[X]</span>  and  <span class="math">r(X)\\in \\mathbb{F}_{\\leq n - 2}[X]</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">s (X) + p (X) = q (X) \\cdot \\mathcal {Z} _ {\\mathbb {H}} (X) + X \\cdot r (X)</span></div>

    <p class="text-gray-300">to prove the univariate sumcheck statement  <span class="math">\\sum_{\\eta \\in \\mathbb{H}}s(\\eta) + p(\\eta) = 0</span></p>

    <p class="text-gray-300">Note that by construction  <span class="math">\\sum_{\\eta \\in \\mathbb{H}} s(\\eta) = 0</span> , and its role here is to (sufficiently) randomize  <span class="math">q(X), r(X)</span>  in such a way that their evaluations do not leak information about the witness (see the proof of bounded zero-knowledge in Theorem 2).</p>

    <p class="text-gray-300">The verifier sends a random point  <span class="math">y\\gets \\mathbb{F}\\setminus \\mathbb{H}</span></p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The prover uses  <span class="math">y</span>  to compute  <span class="math">\\sigma \\gets V_{LR}(x,y,\\alpha)</span>  and then defines the degree-  $(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1)$  polynomial</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">p ^ {\\prime} (X) := \\sum_ {\\kappa \\in \\mathbb {K}} \\left(\\operatorname {v a l} _ {L} (\\kappa) + \\alpha \\cdot \\operatorname {v a l} _ {R} (\\kappa)\\right) \\cdot \\mathcal {L} _ {\\operatorname {r o w} (\\kappa)} ^ {\\mathbb {H}} (x) \\cdot \\mathcal {L} _ {\\operatorname {c o l} (\\kappa)} ^ {\\mathbb {H}} (y) \\cdot \\mathcal {L} _ {\\kappa} ^ {\\mathbb {K}} (X)</span></div>

    <p class="text-gray-300">The goal of the prover is to convince the verifier that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\kappa \\in \\mathbb{K}} p&#x27;(\\kappa) = \\sigma</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall \\kappa \\in \\mathbb{K}: p&#x27;(\\kappa) = (\\mathsf{val}_L(\\kappa) + \\alpha \\cdot \\mathsf{val}_R(\\kappa)) \\cdot \\mathcal{L}_{\\mathsf{row}(\\kappa)}^{\\mathbb{H}}(x) \\cdot \\mathcal{L}_{\\mathsf{col}(\\kappa)}^{\\mathbb{H}}(y)</span></div>

    <p class="text-gray-300">These two statements can be combined in such a way that <span class="math">\\mathcal{P}</span> does not need to send <span class="math">p&#x27;(X)</span>, which is implicitly known by the verifier since it depends only on the polynomials provided by the encoder.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the first statement, since <span class="math">p&#x27;(X)</span> is a polynomial with degree smaller than the size of the subgroup <span class="math">\\mathbb{K}</span>, the univariate sumcheck lemma over $(p'(X) - \\frac{\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> reduces to proving that its constant coefficient is zero. This can be done by computing </span>r'(X) \\in \\mathbb{F}_{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2}[X]<span class="math"> such that </span>p'(X) = X \\cdot r'(X) + \\frac{\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For the second statement, note that by decomposition of the Lagrangians this is equivalent to:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall \\kappa \\in \\mathbb{K}: n^2 \\cdot p&#x27;(\\kappa) \\cdot (x - \\mathsf{row}(\\kappa)) \\cdot (y - \\mathsf{col}(\\kappa)) = (\\mathsf{val}_L(\\kappa) + \\alpha \\cdot \\mathsf{val}_R(\\kappa)) \\cdot \\mathsf{row}(\\kappa) \\cdot \\mathsf{col}(\\kappa) \\cdot \\mathcal{Z}_{\\mathbb{H}}(x) \\cdot \\mathcal{Z}_{\\mathbb{H}}(y)</span></div>

    <p class="text-gray-300">that, by using the definition of <span class="math">p&#x27;(X)</span>, can be written as</p>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\forall \\kappa \\in \\mathbb{K}: \\left( \\kappa \\cdot r'(\\kappa) + \\frac{\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\right) \\cdot n^2 \\cdot (xy + \\mathsf{cr}(\\kappa) - x \\cdot \\mathsf{col}(\\kappa) - y \\cdot \\mathsf{row}(\\kappa)) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\left( \\mathsf{vcr}_L(\\kappa) + \\alpha \\cdot \\mathsf{vcr}_R(\\kappa) \\right) \\cdot \\mathcal{Z}_{\\mathbb{H}}(x) \\cdot \\mathcal{Z}_{\\mathbb{H}}(y) = 0</li>

    </ul>

    <p class="text-gray-300">\\end{aligned} $$</p>

    <p class="text-gray-300">Using the relation polynomials, <span class="math">\\mathcal{P}</span> can define the auxiliary polynomial</p>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t(X) := \\frac{\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot n^2 \\cdot (xy + \\mathsf{cr}(X) - x \\cdot \\mathsf{col}(X) - y \\cdot \\mathsf{row}(X)) + r'(X) \\cdot n^2 \\cdot (xy \\cdot X + \\mathsf{cr}'(X) - x \\cdot \\mathsf{col}'(X) - y \\cdot \\mathsf{row}'(X)) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\left( \\mathsf{vcr}_L(X) + \\alpha \\cdot \\mathsf{vcr}_R(X) \\right) \\cdot \\mathcal{Z}_{\\mathbb{H}}(x) \\cdot \\mathcal{Z}_{\\mathbb{H}}(y)</li>

    </ul>

    <p class="text-gray-300">\\end{aligned} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">of degree $\\leq 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2<span class="math">, that equals 0 on any </span>\\kappa \\in \\mathbb{K}$. By the remainder theorem,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\forall \\kappa \\in \\mathbb{K}: t(X) \\equiv t(\\kappa) \\mod (X - \\kappa) \\iff t(X) \\equiv 0 \\mod \\mathcal{Z}_{\\mathbb{K}}(X)</span></div>

    <p class="text-gray-300">Thus <span class="math">\\mathcal{P}</span> can compute the following polynomial:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q'(X) := \\frac{t(X)}{\\mathcal{Z}_{\\mathbb{K}}(X)} \\in \\mathbb{F}_{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2}[X]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and sends <span class="math">\\sigma</span> and <span class="math">\\{q&#x27;(X), r&#x27;(X)\\}</span> to <span class="math">\\mathcal{V}</span>.</p>

    <p class="text-gray-300">Decision phase. The verifier outputs the following degree checks</p>

    <div class="my-4 text-center"><span class="math-block">\\deg(\\hat{a}&#x27;, \\deg(\\hat{b}&#x27;, \\deg(s), \\deg(q), \\deg(q&#x27;)) \\stackrel{?}{\\leq} \\mathsf{D}_{snd} \\tag{3}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\deg(r) \\stackrel{?}{\\leq} n - 2 \\tag{4}</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\deg(r') \\stackrel{?}{\\leq}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2 \\tag{5}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and the following polynomial checks</p>

    <p class="text-gray-300">$$ \\begin{aligned} s(y) + \\left( \\hat{a}'(y) \\cdot \\mathcal{Z}_{\\mathbb{L}}(y) + \\sum_{\\eta \\in \\mathbb{L}} x'_{\\phi_0(\\eta)} \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(y) \\right) \\cdot \\left( \\Lambda_{\\mathbb{H}}(x, y) + (\\hat{b}'(y) \\cdot \\mathcal{Z}_{\\mathbb{L}}(y) + 1) \\cdot \\sigma \\right) \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(\\hat{b}'(y) \\cdot \\mathcal{Z}_{\\mathbb{L}}(y) + 1) \\cdot \\alpha \\cdot \\Lambda_{\\mathbb{H}}(x, y) - q(y) \\mathcal{Z}_{\\mathbb{H}}(y) - y r(y) \\stackrel{?}{=} 0 \\tag{6}</li>

    </ul>

    <p class="text-gray-300">\\end{aligned} $$</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot n ^ {2} \\cdot \\left(x y + \\operatorname {c r} (X) - x \\cdot \\operatorname {c o l} (X) - y \\cdot \\operatorname {r o w} (X)\\right) + r ^ {\\prime} (X) \\cdot n ^ {2} \\cdot \\left(x y \\cdot X + \\operatorname {c r} ^ {\\prime} (X) - x \\cdot \\operatorname {c o l} ^ {\\prime} (X) - y \\cdot \\operatorname {r o w} ^ {\\prime} (X)\\right) - \\left(\\operatorname {v c r} _ {L} (X) + \\alpha \\cdot \\operatorname {v c r} _ {R} (X)\\right) \\cdot \\mathcal {Z} _ {\\mathbb {H}} (x) \\cdot \\mathcal {Z} _ {\\mathbb {H}} (y) - q ^ {\\prime} (X) \\cdot \\mathcal {Z} _ {\\mathbb {K}} (X) \\stackrel {?} {=} 0 \\tag {7}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where, we recall, <span class="math">\\varLambda_{\\mathbb{H}}(x,y)=\\frac{\\mathcal{Z}_{\\mathbb{H}}(x)\\cdot y-x\\cdot\\mathcal{Z}_{\\mathbb{H}}(y)}{n\\cdot(x-y)}</span>. Above, we highlight the oracle polynomials in <span class="math">gray</span>, the prover messages in blue, and the coefficients of the verifier's polynomial checks in red. This is to help seeing how the above checks fit the ones described in Definition 1.</p>

    <p class="text-gray-300">In the first degree check, <span class="math">\\mathsf{D}_{snd}</span> is an integer that can be chosen by the verifier and governs the soundness error as shown in Theorem 1. While for correctness we need <span class="math">\\mathsf{D}_{snd} \\geq \\mathsf{D} - 1</span>, where <span class="math">\\mathsf{D}</span> is the degree of the PHP (shown below), this bound does not need to be tight (i.e., <span class="math">\\mathsf{D}_{snd} = \\mathsf{D} - 1</span>) as is the case for the degree checks on <span class="math">r</span> and <span class="math">r&#x27;</span>. This observation has an impact on our compiler where, by choosing <span class="math">\\mathsf{D}_{snd}</span> to be the maximal degree supported by the commitment scheme, one does not need to create a proof for degree checks of the form “<span class="math">\\leq \\mathsf{D}_{snd}</span>”.</p>

    <p class="text-gray-300">EFFICIENCY ANALYSIS We analyze the efficiency of the protocol <span class="math">\\mathsf{PHP}_{\\mathrm{lite1}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Relation encoder It creates 8 polynomials, five of degree $\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math"> and three of degree </span>\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; this is doable in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Degree By looking at the polynomials of the highest degree sent by relation encoder and prover, one can see that $\\mathsf{D} = \\max \\{2n + \\mathsf{b}_a + \\mathsf{b}_b + 2\\mathsf{b}_q - 3, n + \\mathsf{b}_s + \\mathsf{b}_q - 1,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math">, whose result depends on the difference between </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and the concrete values of </span>\\mathsf{b}_a, \\mathsf{b}_b, \\mathsf{b}_q, \\mathsf{b}_s<span class="math">. For example, when all these bounds are small constants (as in our use cases) and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, then </span>\\mathsf{D} =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof length. The prover sends one element of <span class="math">\\mathbb{F}</span> and 7 oracle polynomials. By inspection, the proof length is $\\mathsf{l}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = 6n + 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2\\ell + 2\\mathsf{b}_a + 2\\mathsf{b}_b + \\mathsf{b}_s + 5\\mathsf{b}_q - 4<span class="math">. With a closer look at the shape of </span>s(X)<span class="math">, we have that the number of its nonzero coefficients is actually at most </span>\\mathsf{b}_s + 2\\mathsf{b}_q + \\max \\{\\mathsf{b}_s, \\mathsf{b}_r\\}<span class="math">, which gives us a proof length </span>\\mathsf{l}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = 5n + 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2\\ell + 2\\mathsf{b}_a + 2\\mathsf{b}_b + 2\\mathsf{b}_s + 6\\mathsf{b}_q - 4$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover complexity. The total complexity is $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$, which is justified as follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The polynomials sent in the first round can be computed in time $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the second round, the less trivial step is computing <span class="math">V_{LR}(x,X,\\alpha)</span> which we claim doable in time $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> as follows. First, one can precompute all </span>\\mathcal{L}_{\\mathrm{row}(\\kappa)}^{\\mathbb{H}}(x)<span class="math"> in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> since each of them can be computed in </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> time and there are at most </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> of these terms (recall that row maps into </span>\\mathbb{H}$). Second, one can compute all the terms</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\left\\{V_{LR}(x,\\eta ,\\alpha)\\right\\}_{\\eta \\in \\mathbb{H}} = \\left\\{\\sum_{\\substack{\\kappa \\in \\mathbb{K}\\\\ \\operatorname {col}(\\kappa) = \\eta}}\\left(\\mathsf{val}_{L}(\\kappa) + \\alpha \\cdot \\mathsf{val}_{R}(\\kappa)\\right)\\cdot \\mathcal{L}_{\\mathsf{row}(\\kappa)}^{\\mathbb{H}}(x)\\right\\}_{\\eta \\in \\mathbb{H}}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">in time $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> (with </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> memory). This is possible by computing, for every </span>\\kappa \\in \\mathbb{K}<span class="math">, the term </span>(\\mathsf{val}_L(\\kappa) + \\alpha \\cdot \\mathsf{val}_R(\\kappa)) \\cdot \\mathcal{L}_{\\mathrm{row}(\\kappa)}^{\\mathbb{H}}(x)<span class="math">, which can be accumulated into the relevant variable </span>V_{LR}(x,\\eta ,\\alpha)<span class="math"> such that </span>\\eta = \\operatorname {col}(\\kappa)<span class="math">. Finally, </span>V_{LR}(x,X,\\alpha)<span class="math"> is computed by interpolating </span>\\{V_{LR}(x,\\eta ,\\alpha)\\}_{\\eta \\in \\mathbb{H}}<span class="math"> in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Once having computed <span class="math">V_{LR}(x,X,\\alpha)</span>, the polynomials <span class="math">q(X)</span> and <span class="math">r(X)</span> can be obtained using polynomial long division in time $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In round 3, one can compute <span class="math">p&#x27;(X)</span> in time $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> using ideas similar to the ones above, while </span>q'(X), r'(X)<span class="math"> can be computed in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ using polynomial division.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier complexity. This amounts to $O(\\ell + \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> field operations, which are needed to construct the polynomial checks. In particular, notice that: computing evaluations of the vanishing polynomials in </span>\\mathbb{H}<span class="math"> costs </span>O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">; </span>\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> stems from defining the integer </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; and </span>\\ell$ is the cost needed to compute the "shifted polynomial" with the public input.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">SECURITY ANALYSIS</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 1. Our PHP protocol  <span class="math">\\mathsf{PHP}_{\\mathrm{lits1}}</span>  for R1CS-lite.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Theorem 1 (Knowledge Soundness).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The PHP protocol <span class="math">\\mathsf{PHP}_{\\mathsf{lit}\\mathsf{e}\\mathsf{1}}</span> described in section 4.3 is <span class="math">\\epsilon</span>-sound with $\\epsilon=\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\frac{2\\mathsf{D}_{end}+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\setminus\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, and </span>0<span class="math">-knowledge-sound. Furthermore, </span>\\mathsf{PHP}_{\\mathsf{lit}\\mathsf{e}\\mathsf{1}}$ is straightline extractable (Definition 3).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-37" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We begin by proving the soundness of this PHP, and then show its proof of knowledge property.</p>

    <p class="text-gray-300">Soundness. Assume that for the given polynomial R1CS-lite relation <span class="math">\\mathsf{R}=(\\mathbb{F},n,m,\\{\\bm{L},\\bm{R}\\},\\ell)</span> and input <span class="math">\\bm{x}</span> there exists no witness <span class="math">a^{\\prime}(X),b^{\\prime}(X)</span> that satisfies the equation (1) of Definition 9. Then by correctness of the relation encoder’s polynomials, also there is no witness satisfying equation (2).</p>

    <p class="text-gray-300">This means that for the polynomials <span class="math">\\hat{a}^{\\prime}(X),\\hat{b}^{\\prime}(X)</span> sent by the prover in the first round it must be the case that</p>

    <p class="text-gray-300"><span class="math">f(X,Z)=\\sum_{\\eta\\in\\mathbb{H}}(\\hat{a}(\\eta)+Z\\cdot\\hat{b}(\\eta))\\cdot\\Lambda_{\\mathbb{H}}(X,\\eta)+\\hat{a}(\\eta)\\cdot\\hat{b}(\\eta)\\cdot V_{LR}(X,\\eta,Z)\\neq 0\\text{ over }\\mathbb{F}[X,Z].</span></p>

    <p class="text-gray-300">where <span class="math">\\hat{a}(X)</span> and <span class="math">\\hat{b}(X)</span> are appropriately reconstructed as <span class="math">\\hat{a}^{\\prime}(X)\\cdot\\mathfrak{Z}_{\\mathbb{L}}(X)+\\sum_{\\eta\\in\\mathbb{L}}\\bm{x^{\\prime}}_{\\phi_{\\mathbb{H}}(\\eta)}\\cdot\\mathcal{L}_{\\eta}^{\\mathbb{H}}(X)</span> and <span class="math">\\hat{b}^{\\prime}(X)\\cdot\\mathfrak{Z}_{\\mathbb{L}}(X)+1</span> respectively.</p>

    <p class="text-gray-300">Let <span class="math">s(X),\\hat{a}^{\\prime}(X),\\hat{b}^{\\prime}(X),q(X),r(X),q^{\\prime}(X),r^{\\prime}(X)</span> and <span class="math">\\sigma</span> be the polynomials and message sent by the prover <span class="math">\\mathcal{P}^{*}</span>, and <span class="math">x,\\alpha,y</span> be the verifier’s messages. Let us recall that by the order of the messages in the protocol we have: <span class="math">s(X),\\hat{a}^{\\prime}(X),\\hat{b}^{\\prime}(X)</span> are independent of <span class="math">x,\\alpha</span>, and that <span class="math">\\sigma,q(X),r(X)</span> are independent of <span class="math">y</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By considering the polynomial check (7) and by the correctness of the relation encoder’s polynomials we deduce that the polynomial $p^{\\prime}(X):=\\left(X\\cdot r^{\\prime}(X)+\\frac{\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)$ is such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\forall\\ \\kappa\\in\\mathbb{K}:p^{\\prime}(\\kappa)=\\left(\\mathsf{vcr}_{L}(\\kappa)+\\alpha\\cdot\\mathsf{vcr}_{R}(\\kappa)\\right)\\cdot\\frac{\\mathfrak{Z}_{\\mathbb{H}}(x)\\cdot\\mathfrak{Z}_{\\mathbb{H}}(y)}{n^{2}(xy+\\mathsf{cr}(\\kappa)-x\\cdot\\mathsf{col}(\\kappa)-y\\cdot\\mathsf{row}(\\kappa))}</span> <span class="math">\\text{ that is }\\quad\\forall\\kappa\\in\\mathbb{K}:p^{\\prime}(\\kappa)=(\\mathsf{val}_{L}(\\kappa)+\\alpha\\cdot\\mathsf{val}_{R}(\\kappa))\\cdot\\mathcal{L}^{\\mathbb{H}}_{\\mathsf{row}(\\kappa)}(x)\\cdot\\mathcal{L}^{\\mathbb{H}}_{\\mathsf{col}(\\kappa)}(y)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Then, by considering the degree check (5) we have that $r^{\\prime}(X)\\in\\mathbb{F}_{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2}[X]<span class="math">, and thus </span>p^{\\prime}(X)<span class="math"> is a polynomial of degree </span>\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math"> with constant term </span>\\sigma/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Hence by Lemma 2, it holds </span>\\sigma=\\sum_{\\kappa\\in\\mathbb{K}}p^{\\prime}(\\kappa)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Putting this together with the definition of <span class="math">p^{\\prime}(\\kappa)</span> we obtain that <span class="math">\\sigma=V_{LR}(x,y,\\alpha)</span>.</p>

    <p class="text-gray-300">Next, since the polynomials <span class="math">s(X),\\hat{a}(X),\\hat{b}(X),q(X),r(X),V_{LR}(x,X,\\alpha)</span> are independent of <span class="math">y</span>, by Schwartz-Zippel we obtain that the polynomial check (6) (combined with the first degree check (3) and that <span class="math">\\sigma=V_{LR}(x,y,\\alpha)</span>) implies that</p>

    <p class="text-gray-300"><span class="math">s(X)+(\\hat{a}(X)+\\alpha\\cdot\\hat{b}(X))\\cdot\\Lambda_{\\mathbb{H}}(x,X)+\\hat{a}(X)\\cdot\\hat{b}(X)\\cdot V_{LR}(x,X,\\alpha)=q(X)\\cdot\\mathfrak{Z}_{\\mathbb{H}}(X)+X\\cdot r(X)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">holds with probability $\\geq 1-\\frac{2\\mathsf{D}_{end}+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\setminus\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> over the choice of </span>y$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The degree check (4) gives us that <span class="math">r(X)\\in\\mathbb{F}_{\\leq n-2}[X]</span> and thus by Lemma 2 we have that</p>

    <p class="text-gray-300"><span class="math">\\sum_{\\eta\\in\\mathbb{H}}s(\\eta)+f(x,\\alpha)=\\sum_{\\eta\\in\\mathbb{H}}s(\\eta)+(\\hat{a}(\\eta)+\\alpha\\cdot\\hat{b}(\\eta))\\cdot\\Lambda_{\\mathbb{H}}(x,\\eta)+\\hat{a}(\\eta)\\cdot\\hat{b}(\\eta)\\cdot V_{LR}(x,\\eta,\\alpha)=0</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">s^{<em>}=\\sum_{\\eta\\in\\mathbb{H}}s(\\eta)</span>. Since <span class="math">s^{</em>}</span> and <span class="math">f(X,Z)</span> are independent of <span class="math">x,\\alpha</span>, by the Schwartz-Zippel lemma, we have that, over the random choice of <span class="math">x,\\alpha\\leftrightarrows\\mathbb{F}</span>, $\\Pr[f(x,\\alpha)+s^{*}=0]\\leq\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Knowledge-Soundness. We define the extractor <span class="math">\\mathcal{E}</span>, which is simply the algorithm that runs the prover <span class="math">\\mathcal{P}^{*}</span> for the first round, obtains <span class="math">\\hat{a}^{\\prime}(X),\\hat{b}^{\\prime}(X)</span>, and then reconstructs the non randomized witness polynomials <span class="math">a^{\\prime}(X)=\\sum_{\\eta\\in\\mathbb{H}}\\hat{a}^{\\prime}(\\eta)\\mathcal{L}_{\\eta}^{\\mathbb{H}}(X)</span> and <span class="math">b^{\\prime}(X)=\\sum_{\\eta\\in\\mathbb{H}}\\hat{b}^{\\prime}(\\eta)\\mathcal{L}_{\\eta}^{\\mathbb{H}}(X)</span>.</p>

    <p class="text-gray-300">If the verifier accepts with probability greater than the soundness error <span class="math">\\epsilon</span> given above, then the polynomials returned by <span class="math">\\mathcal{E}</span> must encode a valid witness.</p>

    <p class="text-gray-300">Finally, it is straightforward to see the straight-line extractability. The algorithm WitExtract is the one that takes the polynomials <span class="math">\\hat{a}^{\\prime}(X),\\hat{b}^{\\prime}(X)</span>, and reconstructs the R1CS-lite witness by taking the product of their evaluations on the points of <span class="math">\\mathbb{H}\\setminus\\mathbb{L}</span> (see Appendix A.1).</p>

    <p class="text-gray-300">Theorem 2 (Zero-Knowledge). The PHP <span class="math">\\mathsf{PHP}_{\\mathrm{fit}1}</span> described in section 4.3 is perfect zero-knowledge. Furthermore, it is perfect honest-verifier zero-knowledge with query bound <span class="math">\\mathsf{b} = (\\mathsf{b}_a,\\mathsf{b}_b,\\mathsf{b}_s,\\mathsf{b}_q,\\mathsf{b}_r,\\infty ,\\infty)</span>.</p>

    <p class="text-gray-300">Proof. We begin by showing the perfect zero-knowledge. This turns out rather easily. In fact, in the PHP model we do not need to worry about the oracle polynomials, the prover in Section 4.3 sends only one (non-oracle) message, <span class="math">\\sigma</span>. This message, moreover, does not depend on the witness. More formally, we describe a simulator <span class="math">\\mathcal{S}</span> that on input the relation <span class="math">\\mathsf{R} = (\\mathbb{F}, n, m, \\{\\pmb{L}, \\pmb{R}\\}, \\ell)</span> and the input <span class="math">\\pmb{x}</span>, and given oracle access to the verifier <span class="math">\\mathcal{V}^<em></span>, proceeds as follows. It runs <span class="math">\\mathcal{V}^</em></span> to obtain its random messages <span class="math">x, y, \\alpha</span> and its checks. Next, it computes <span class="math">\\sigma = V_{LR}(x, y, \\alpha)</span>, and outputs <span class="math">\\sigma</span> followed by checks obtained from <span class="math">\\mathcal{V}^<em></span>. It is easy to see that <span class="math">\\text{View}\\big(\\mathcal{S}^{\\mathcal{V}^</em>}(\\mathbb{F}, \\mathsf{R}, \\pmb{x})\\big)</span> is identically distributed to <span class="math">\\text{View}\\big(\\mathcal{P}(\\mathbb{F}, \\mathsf{R}, \\pmb{x}, a&#x27;(X), b&#x27;(X)) \\quad \\mathcal{V}^*\\big)</span>.</p>

    <p class="text-gray-300">Next, we prove b-HVZK for bounds <span class="math">\\mathsf{b}_a,\\mathsf{b}_b,\\mathsf{b}_s,\\mathsf{b}_q,\\mathsf{b}_r</span> on the polynomials <span class="math">\\hat{a} &#x27;(X),\\hat{b} &#x27;(X),s(X),q(X),r(X)</span> respectively, whereas for the polynomials <span class="math">q^{\\prime}(X),r^{\\prime}(X)</span> we tolerate unbounded number of evaluations (this is trivial as these polynomials depend on public information only).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathsf{C}(i,\\gamma)</span> be the algorithm that on any pair <span class="math">(i,\\gamma)</span> outputs 1 if and only if <span class="math">i\\in \\{1,\\ldots ,7\\}</span> and <span class="math">\\gamma \\notin \\mathbb{H}</span>. For a <span class="math">\\gamma \\leftarrow_{\\mathrm{s}}\\mathbb{F}</span>, it holds $\\operatorname*{Pr}[\\mathsf{C}(i,\\gamma) = 0] =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, which is negligible for the choices of </span>\\mathbb{F}$ considered in this paper.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The simulator samples a random tape <span class="math">\\pmb{\\rho}</span> for the honest verifier and runs its query sampler <span class="math">(x,y,\\alpha)\\gets Q_{\\mathcal{V}}(\\pmb {\\rho})</span> and its decision algorithm <span class="math">\\{\\pmb {d},\\{(G,\\pmb {v})\\} \\gets D_{\\mathcal{V}}(\\mathbb{F},\\pmb {x};\\pmb {\\rho})</span> to obtain its checks. Then, it simulates answers to polynomial evaluations as follows.</p>

    <p class="text-gray-300">For every pair <span class="math">(i,\\gamma)</span> with <span class="math">i\\in \\{6,7\\}</span> (i.e., for every query on <span class="math">q^{\\prime},r^{\\prime}</span>), the simulator computes <span class="math">t_{i,\\gamma}\\gets p_i(\\gamma)</span> honestly, which is trivial as these polynomials depend only on public information.</p>

    <p class="text-gray-300">For every pair <span class="math">(i,\\gamma)\\in \\mathcal{L}</span> such that <span class="math">i\\in [5]\\setminus \\{4\\}</span> (i.e., every query on <span class="math">\\hat{a}^{\\prime},\\hat{b}^{\\prime},s,r</span>), the simulator samples a random value <span class="math">t_{i,\\gamma}\\gets_{\\mathrm{s}}\\mathbb{F}</span> and stores a tuple <span class="math">(i,\\gamma ,t_{i,\\gamma})</span> in a table T.</p>

    <p class="text-gray-300">For every query <span class="math">(4,\\gamma)</span> it simulates the answer with the value <span class="math">t_{4,\\gamma}</span> computed as follows:</p>

    <div class="my-4 text-center"><span class="math-block">t _ {a, \\gamma} \\leftarrow t _ {1, \\gamma} \\cdot \\mathcal {Z} _ {\\mathbb {L}} (\\gamma) + \\sum_ {\\eta \\in \\mathbb {L}} \\boldsymbol {x} _ {\\phi_ {\\mathbb {H}} (\\eta)} ^ {\\prime} \\cdot \\mathcal {L} _ {\\eta} ^ {\\mathbb {H}} (\\gamma)</span></div>

    <div class="my-4 text-center"><span class="math-block">t _ {b, \\gamma} \\leftarrow t _ {2, \\gamma} \\cdot \\mathcal {Z} _ {\\mathbb {L}} (\\gamma) + 1</span></div>

    <div class="my-4 text-center"><span class="math-block">t _ {p, \\gamma} \\leftarrow \\left(t _ {a, \\gamma} + \\alpha \\cdot t _ {b, \\gamma}\\right) \\cdot \\Lambda_ {\\mathbb {H}} (x, \\gamma) + t _ {a, \\gamma} \\cdot t _ {b, \\gamma} \\cdot V _ {L R} (x, \\gamma , \\alpha)</span></div>

    <div class="my-4 text-center"><span class="math-block">t _ {4, \\gamma} \\leftarrow \\frac {t _ {p , \\gamma} + t _ {3 , \\gamma} - \\gamma \\cdot t _ {5 , \\gamma}}{\\mathcal {Z} _ {\\mathbb {H}} (\\gamma)}</span></div>

    <p class="text-gray-300">While doing the computations above, for <span class="math">j = 1,2,3,5</span>, if an entry <span class="math">(j,\\gamma ,t_{j,\\gamma})</span> already exists in <span class="math">\\mathsf{T}</span>, then the corresponding value <span class="math">t_{j,\\gamma}</span> is used; otherwise a random <span class="math">t_{j,\\gamma} \\leftarrow_{\\mathrm{s}} \\mathbb{F}</span> is sampled and a new entry <span class="math">(j,\\gamma ,t_{j,\\gamma})</span> is added to <span class="math">\\mathsf{T}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{S}</span> returns <span class="math">\\left(\\pmb {\\rho},V_{LR}(x,y,\\alpha),(\\pmb {d},\\{(G,\\pmb {v})\\}),\\{t_{i,\\gamma}\\}_{(i,\\gamma)\\in \\mathcal{L}}\\right)</span></p>

    <p class="text-gray-300">To conclude the proof, we argue that the distribution of <span class="math">\\mathcal{S}</span>'s output is identical to that of</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\operatorname {V i e w} \\left(\\mathcal {P} (\\mathbb {F}, \\mathsf {R}, \\boldsymbol {x}, a ^ {\\prime}, b ^ {\\prime}) \\quad \\mathcal {V}\\right), (p _ {i} (\\gamma)) _ {(i, \\gamma) \\in \\mathcal {L}}\\right).</span></div>

    <p class="text-gray-300">By the <span class="math">(\\mathsf{b}_a + \\mathsf{b}_q)</span>-wise (resp. <span class="math">(\\mathsf{b}_b + \\mathsf{b}_q)</span>-wise) independence of the polynomial <span class="math">\\hat{a}&#x27;(X)</span> (resp. <span class="math">\\hat{b}&#x27;(X)</span>) sampled by the honest prover (and using the fact that they are evaluated on <span class="math">\\mathbb{F} \\setminus \\mathbb{H}</span>), we have that the set of simulated answers <span class="math">\\{t_{1,\\gamma}\\}_{(1,\\gamma)\\in \\mathcal{L}}</span> (resp. <span class="math">\\{t_{2,\\gamma}\\}_{(2,\\gamma)\\in \\mathcal{L}}</span>) are identically distributed (we recall that these sets are of size <span class="math">\\mathsf{b}_a</span> and <span class="math">\\mathsf{b}_b</span> respectively) to those of the real prover.</p>

    <p class="text-gray-300">For the remaining polynomials, let us recall that for the honest prover we have</p>

    <div class="my-4 text-center"><span class="math-block">p (X) = (\\hat {a} (X) + \\alpha \\cdot \\hat {b} (X)) \\cdot \\Lambda_ {\\mathbb {H}} (x, X) + \\hat {a} (X) \\cdot \\hat {b} (X) \\cdot V _ {L R} (x, X, \\alpha)</span></div>

    <div class="my-4 text-center"><span class="math-block">s (X) = q _ {s} (X) \\mathcal {Z} _ {\\mathbb {H}} (X) + X r _ {s} (X)</span></div>

    <p class="text-gray-300">where <span class="math">\\pmb{x}^{\\prime} = (1,\\pmb{x})</span>, <span class="math">\\hat{a}(X) = \\hat{a}^{\\prime}(X) \\cdot \\mathcal{Z}_{\\mathbb{L}}(X) + \\sum_{\\eta \\in \\mathbb{L}} \\pmb{x}_{\\phi_{\\mathbb{H}}(\\eta)}^{\\prime} \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X)</span>, <span class="math">\\hat{b}(X) = \\hat{b}^{\\prime}(X) \\cdot \\mathcal{Z}_{\\mathbb{L}}(X) + 1</span>, and <span class="math">q_{s}(X) \\leftarrow_{\\mathrm{s}} \\mathbb{F}_{\\mathsf{b}_{s} + \\mathsf{b}_{q}}[X]</span> and <span class="math">r_{s}(X) \\leftarrow_{\\mathrm{s}} \\mathbb{F}_{\\mathsf{b}_{r} + \\mathsf{b}_{q}}[X]</span>. Also, let us write <span class="math">p(X) = q_{p}(X) \\mathcal{Z}_{\\mathbb{H}}(X) + X r_{p}(X)</span> for the unique <span class="math">q_{p}(X), r_{p}(X)</span> by polynomial division.</p>

    <p class="text-gray-300">25</p>

    <p class="text-gray-300">By the uniqueness of polynomials <span class="math">q(X)</span> and <span class="math">r(X) \\in \\mathbb{F}_{\\leq n-2}[X]</span> such that <span class="math">s(X) + p(X) = q(X) \\cdot \\mathcal{Z}_{\\mathbb{H}}(X) + X \\cdot r(X)</span>, we have that <span class="math">q(X) = q_p(X) + q_s(X)</span> and <span class="math">r(X) = r_p(X) + r_s(X)</span>.</p>

    <p class="text-gray-300">By the <span class="math">(\\mathsf{b}_r + \\mathsf{b}_q)</span>-wise independence of <span class="math">r_s(X)</span> (and thus of <span class="math">r(X)</span>) we obtain that the set of simulated answers <span class="math">\\{t_{5,\\gamma}\\}_{(5,\\gamma)\\in \\mathcal{L}}</span> (whose cardinality is at most <span class="math">\\mathsf{b}_r</span>) are identically distributed to those, <span class="math">\\{r(\\gamma)\\}_{(5,\\gamma)\\in \\mathcal{L}}</span>, of the real prover. Furthermore, by the <span class="math">(\\mathsf{b}_s + \\mathsf{b}_q)</span>-wise independence of <span class="math">q_s(X)</span> we obtain that the set of simulated answers <span class="math">\\{t_{3,\\gamma}\\}_{(3,\\gamma)\\in \\mathcal{L}}</span> (whose cardinality is at most <span class="math">\\mathsf{b}_s</span>) are identically distributed to those, <span class="math">\\{s(\\gamma)\\}_{(5,\\gamma)\\in \\mathcal{L}}</span>, of the real prover. In particular, for this we use that for <span class="math">\\gamma \\in \\mathbb{F} \\setminus \\mathbb{H}</span>, <span class="math">s(X)</span> is <span class="math">(\\mathsf{b}_s + \\mathsf{b}_q)</span>-wise independent even conditioned on <span class="math">r_s(X)</span>.</p>

    <p class="text-gray-300">To argue the correct distribution of the set of simulated answers <span class="math">\\{t_{4,\\gamma}\\}_{(4,\\gamma)\\in \\mathcal{L}}</span>, we observe that the honest <span class="math">q(X)</span> is determined by <span class="math">(p(X) + s(X) - Xr(X)) / \\mathcal{Z}_{\\mathbb{H}}(X)</span>, where <span class="math">p(X)</span> is defined as above. In particular, an evaluation of <span class="math">q(\\gamma)</span> on <span class="math">\\gamma \\in \\mathbb{F} \\setminus \\mathbb{H}</span> can be obtained as <span class="math">(p(\\gamma) + s(\\gamma) - \\gamma r(\\gamma)) / \\mathcal{Z}_{\\mathbb{H}}(\\gamma)</span>, thus using evaluations of <span class="math">\\hat{a}&#x27;(\\gamma)</span>, <span class="math">\\hat{b}&#x27;(\\gamma)</span>, <span class="math">s(\\gamma)</span>, <span class="math">r(\\gamma)</span>, and evaluations of publicly available polynomials. This explains the simulation strategy of <span class="math">t_{4,\\gamma}</span> by <span class="math">\\mathcal{S}</span>, and these values are identically distributed to <span class="math">q(\\gamma)</span> as the polynomials <span class="math">\\hat{a}&#x27;(X)</span>, <span class="math">\\hat{b}&#x27;(X)</span>, <span class="math">s(X)</span>, and <span class="math">r(X)</span>, each allows <span class="math">\\mathsf{b}_q</span> more evaluations whose outputs are uniformly distributed.</p>

    <p class="text-gray-300">Remark 1 (On degree optimizations). From the proof of the above theorem it turns out that increasing the degrees of polynomials <span class="math">\\hat{a}&#x27;</span>, <span class="math">\\hat{b}&#x27;</span>, <span class="math">s</span>, <span class="math">r</span> by <span class="math">\\mathsf{b}_q</span> may be a too conservative choice. Indeed, additional information about these four polynomials is leaked only if an evaluation <span class="math">q(X)</span> is revealed on a point <span class="math">\\gamma</span> on which these polynomials were not already evaluated. More precisely, if the list <span class="math">\\mathcal{L}</span> is such that the simulation of <span class="math">t_{4,\\gamma}</span> does not require sampling new values <span class="math">t_{j,\\gamma}</span>, <span class="math">j \\in \\{1,2,3,5\\}</span>, then it is sufficient to have <span class="math">\\hat{a}&#x27; \\in \\mathbb{F}_{\\leq n + \\mathsf{b}_a}</span>, <span class="math">\\hat{b}&#x27; \\in \\mathbb{F}_{\\leq n + \\mathsf{b}_b}</span>, <span class="math">q_s \\in \\mathbb{F}_{\\leq \\mathsf{b}_s}</span>, <span class="math">r_s \\in \\mathbb{F}_{\\leq \\mathsf{b}_r}</span>.</p>

    <p class="text-gray-300">Remark 2 ( <span class="math">\\mathsf{PHP}_{\\mathrm{lite1s}}</span>: a variant with fewer relation polynomials). We present a variant of <span class="math">\\mathsf{PHP}_{\\mathrm{lite1}}</span>, that we call <span class="math">\\mathsf{PHP}_{\\mathrm{lite1s}}</span>, which has fewer relation polynomials. In particular, the <span class="math">\\mathcal{RE}</span> of <span class="math">\\mathsf{PHP}_{\\mathrm{lite1s}}</span> does not output <span class="math">\\mathsf{col}&#x27;(X), \\mathsf{row}&#x27;(X)</span> and <span class="math">\\mathsf{cr}&#x27;(X)</span>, and the second polynomial check, of degree 3 with a public term <span class="math">X</span>, becomes:</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n^{2} \\cdot \\left(X \\cdot r^{\\prime}(X) + \\frac{\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\cdot \\left(x y + \\underline{\\operatorname{cr}(X)} - x \\cdot \\underline{\\operatorname{col}(X)} - y \\cdot \\underline{\\operatorname{row}(X)}\\right) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\quad - \\left(\\underline{\\operatorname{vcr}_{L}(X)} + \\alpha \\cdot \\underline{\\operatorname{vcr}_{R}(X)}\\right) \\cdot \\mathcal{Z}_{\\mathbb{H}}(x) \\cdot \\mathcal{Z}_{\\mathbb{H}}(y) - \\underline{q^{\\prime}(X)} \\cdot \\mathcal{Z}_{\\mathbb{K}}(X) \\stackrel{?}{=} 0 \\tag{8} \\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A Variant with Separate Sparse Matrix Encodings We propose a variant of the PHP for R1CS-lite <span class="math">\\mathsf{PHP}_{\\mathrm{lite1}}</span> described in the previous section. We call this protocol <span class="math">\\mathsf{PHP}_{\\mathrm{lite2}}</span>. In <span class="math">\\mathsf{PHP}_{\\mathrm{lite2}}</span>, the matrices <span class="math">\\{\\pmb {L},\\pmb {R}\\}</span> are encoded in sparse form separately, namely without keeping track of common nonzero entries (see Definition 6). The main benefit of this choice is that in this case we can work with a subgroup <span class="math">\\mathbb{K}\\subset \\mathbb{F}</span> of minimal size such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq m<span class="math">, which is half the size of the one needed in </span>\\mathsf{PHP}_{\\mathrm{lite1}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Namely, <span class="math">\\pmb {L},\\pmb{R}</span> can be represented with the functions <span class="math">\\{\\mathsf{val}_M,\\mathsf{row}_M,\\mathsf{col}_M\\}_{M\\in \\{L,R\\}}</span>. Here, for <span class="math">M = \\{L,R\\}</span> and any <span class="math">\\kappa \\in \\mathbb{K}</span>, <span class="math">\\mathsf{val}_M(\\kappa) = M_{\\mathsf{row}_M(\\kappa),\\mathsf{col}_M(\\kappa)}</span>. We can use such sparse encoding of <span class="math">\\pmb{L}</span> and <span class="math">\\pmb{R}</span> to change the <span class="math">V_{LR}(X,Y,Z)</span> polynomial in equation (2) into the following one</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} V_{LR}(X, Y, Z) = V_{L}(X, Y) + Z \\cdot V_{R}(X, Y) \\\\ \\quad = \\sum_{\\kappa \\in \\mathbb{K}} \\left(\\mathsf{val}_{L}(\\kappa) \\cdot \\mathcal{L}_{\\mathsf{row}_{L}(\\kappa)}^{\\mathbb{H}}(X) \\cdot \\mathcal{L}_{\\mathsf{col}_{L}(\\kappa)}^{\\mathbb{H}}(Y) + Z \\cdot \\mathsf{val}_{R}(\\kappa) \\cdot \\mathcal{L}_{\\mathsf{row}_{R}(\\kappa)}^{\\mathbb{H}}(X) \\cdot \\mathcal{L}_{\\mathsf{col}_{R}(\\kappa)}^{\\mathbb{H}}(Y)\\right) \\end{array}</span></div>

    <p class="text-gray-300">Then in this variant the prover's goal is to show that the polynomials sent in the first round satisfy the equation above. This variant proceeds almost identically to the one of section 4.3; the only differences are in the relation polynomials and the third round.</p>

    <p class="text-gray-300">Offline phase <span class="math">\\mathcal{RE}(\\mathbb{F},n,m,\\{\\pmb {L},\\pmb {R}\\} ,\\ell)</span>. The holographic relation encoder outputs 24 polynomials</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{\\left\\{\\operatorname{vcr}_{M,i,j}(X)\\right\\}_{M \\in \\{L,R\\}, \\{i,j\\} \\in \\{0,1\\}}, \\left\\{\\operatorname{cr}_{i,j}(X), \\operatorname{cr}_{i,j}'(X)\\right\\}_{i,j \\in \\{0,1,2\\}^{\\wedge} i \\neq 2 \\neq j} \\right\\} \\in \\mathbb{F}_{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}[X]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">that are computed as follows. First, it finds the polynomials <span class="math">\\{\\mathsf{val}_L,\\mathsf{col}_L,\\mathsf{row}_L,\\mathsf{val}_R,\\mathsf{col}_R,\\mathsf{row}_R\\}</span> such that for all <span class="math">\\kappa \\in \\mathbb{K}</span> <span class="math">\\mathsf{val}_L(\\kappa) = L_{\\mathsf{row}_L(\\kappa),\\mathsf{col}_L(\\kappa)}</span> and <span class="math">\\mathsf{val}_R(\\kappa) = R_{\\mathsf{row}_R(\\kappa),\\mathsf{col}_R(\\kappa)}</span>. Second, it computes:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {v c r} _ {L, 0, 0} (X) := \\sum_ {\\kappa \\in \\mathbb {K}} \\operatorname {v a l} _ {L} (\\kappa) \\cdot \\operatorname {c o l} _ {L} (\\kappa) \\cdot \\operatorname {r o w} _ {L} (\\kappa) \\cdot \\operatorname {c o l} _ {R} (\\kappa) \\cdot \\operatorname {r o w} _ {R} (\\kappa) \\cdot \\mathcal {L} _ {\\kappa} ^ {\\mathbb {K}} (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {v c r} _ {L, 0, 1} (X) := - \\sum_ {\\kappa \\in \\mathbb {K}} \\operatorname {v a l} _ {L} (\\kappa) \\cdot \\operatorname {c o l} _ {L} (\\kappa) \\cdot \\operatorname {r o w} _ {L} (\\kappa) \\cdot \\operatorname {r o w} _ {R} (\\kappa) \\cdot \\mathcal {L} _ {\\kappa} ^ {\\mathbb {K}} (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {v c r} _ {L, 1, 0} (X) := - \\sum_ {\\kappa \\in \\mathbb {K}} \\operatorname {v a l} _ {L} (\\kappa) \\cdot \\operatorname {c o l} _ {L} (\\kappa) \\cdot \\operatorname {r o w} _ {L} (\\kappa) \\cdot \\operatorname {c o l} _ {R} (\\kappa) \\cdot \\mathcal {L} _ {\\kappa} ^ {\\mathbb {K}} (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {v c r} _ {L, 1, 1} (X) := \\sum_ {\\kappa \\in \\mathbb {K}} \\operatorname {v a l} _ {L} (\\kappa) \\cdot \\operatorname {c o l} _ {L} (\\kappa) \\cdot \\operatorname {r o w} _ {L} (\\kappa) \\cdot \\mathcal {L} _ {\\kappa} ^ {\\mathbb {K}} (X)</span></div>

    <p class="text-gray-300">and analogously <span class="math">\\{\\mathsf{vcr}_{R,0,0},\\mathsf{vcr}_{R,0,1},\\mathsf{vcr}_{R,1,0},\\mathsf{vcr}_{R,1,1}\\}</span>. Third, it computes</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {c r} _ {0, 0} (X) := \\sum_ {\\kappa \\in \\mathbb {K}} \\operatorname {c o l} _ {L} (\\kappa) \\cdot \\operatorname {r o w} _ {L} (\\kappa) \\cdot \\operatorname {c o l} _ {R} (\\kappa) \\cdot \\operatorname {r o w} _ {R} (\\kappa) \\cdot \\mathcal {L} _ {\\kappa} ^ {\\mathbb {K}} (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {c r} _ {0, 1} (X) := - \\sum_ {\\kappa \\in \\mathbb {K}} \\operatorname {r o w} _ {L} (\\kappa) \\cdot \\left(\\operatorname {c o l} _ {L} (\\kappa) \\cdot \\operatorname {r o w} _ {R} (\\kappa) + \\operatorname {c o l} _ {R} (\\kappa) \\cdot \\operatorname {r o w} _ {R} (\\kappa)\\right) \\cdot \\mathcal {L} _ {\\kappa} ^ {\\mathbb {K}} (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {c r} _ {1, 0} (X) := - \\sum_ {\\kappa \\in \\mathbb {K}} \\operatorname {c o l} _ {L} (\\kappa) \\cdot \\left(\\operatorname {c o l} _ {R} (\\kappa) \\cdot \\operatorname {r o w} _ {R} (\\kappa) + \\operatorname {c o l} _ {R} (\\kappa) \\cdot \\operatorname {r o w} _ {L} (\\kappa)\\right) \\cdot \\mathcal {L} _ {\\kappa} ^ {\\mathbb {K}} (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {c r} _ {1, 1} (X) := \\sum_ {\\kappa \\in \\mathbb {K}} \\left(\\operatorname {c o l} _ {L} (\\kappa) + \\operatorname {c o l} _ {R} (\\kappa)\\right) \\cdot \\left(\\operatorname {r o w} _ {R} (\\kappa) + \\operatorname {r o w} _ {L} (\\kappa)\\right) \\cdot \\mathcal {L} _ {\\kappa} ^ {\\mathbb {K}} (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {c r} _ {2, 0} (X) := \\sum_ {\\kappa \\in \\mathbb {K}} \\operatorname {c o l} _ {L} (\\kappa) \\cdot \\operatorname {c o l} _ {R} (\\kappa) \\cdot \\mathcal {L} _ {\\kappa} ^ {\\mathbb {K}} (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {c r} _ {0, 2} (X) := \\sum_ {\\kappa \\in \\mathbb {K}} \\operatorname {r o w} _ {L} (\\kappa) \\cdot \\operatorname {r o w} _ {R} (\\kappa) \\cdot \\mathcal {L} _ {\\kappa} ^ {\\mathbb {K}} (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {c r} _ {1, 2} (X) := - \\sum_ {\\kappa \\in \\mathbb {K}} \\left(\\operatorname {r o w} _ {L} (\\kappa) + \\operatorname {r o w} _ {R} (\\kappa)\\right) \\cdot \\mathcal {L} _ {\\kappa} ^ {\\mathbb {K}} (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {c r} _ {2, 1} (X) := - \\sum_ {\\kappa \\in \\mathbb {K}} \\left(\\operatorname {c o l} _ {L} (\\kappa) + \\operatorname {c o l} _ {R} (\\kappa)\\right) \\cdot \\mathcal {L} _ {\\kappa} ^ {\\mathbb {K}} (X)</span></div>

    <p class="text-gray-300">as well as <span class="math">\\{\\mathsf{cr}_{i,j}&#x27;(X) := X \\cdot \\mathsf{cr}_{i,j}(X)\\}</span></p>

    <p class="text-gray-300">Online phase <span class="math">\\langle \\mathcal{P}((\\mathbb{F},n,m,\\{\\pmb {L},\\pmb {R}\\} ,\\ell),\\pmb {x},(a&#x27;(X),b&#x27;(X))\\rangle ,\\mathcal{V}(\\mathbb{F},n,m,\\mathsf{x})\\rangle</span>. Round 1 and 2 proceed identically to the PHP of section 4.3 except for the different definition of the polynomial <span class="math">V_{LR}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Round 3 The verifier sends a random point <span class="math">y \\gets \\mathbb{F} \\setminus \\mathbb{H}</span>. The prover uses <span class="math">y</span> to compute <span class="math">\\sigma \\gets V_{LR}(x, y, \\alpha)</span> and then defines the degree- $(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1)$ polynomial</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">p ^ {\\prime} (X) := \\sum_ {\\kappa \\in \\mathbb {K}} \\left(\\mathsf {v a l} _ {L} (\\kappa) \\cdot \\mathcal {L} _ {\\mathsf {r o w} _ {L} (\\kappa)} ^ {\\mathbb {H}} (x) \\cdot \\mathcal {L} _ {\\mathsf {c o l} _ {L} (\\kappa)} ^ {\\mathbb {H}} (y) + \\alpha \\cdot \\mathsf {v a l} _ {R} (\\kappa) \\cdot \\mathcal {L} _ {\\mathsf {r o w} _ {R} (\\kappa)} ^ {\\mathbb {H}} (x) \\cdot \\mathcal {L} _ {\\mathsf {c o l} _ {R} (\\kappa)} ^ {\\mathbb {H}} (y)\\right) \\cdot \\mathcal {L} _ {\\kappa} ^ {\\mathbb {K}} (X)</span></div>

    <p class="text-gray-300">The goal of the prover is to convince the verifier that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {\\kappa \\in \\mathbb {K}} p ^ {\\prime} (\\kappa) = \\sigma</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall \\kappa \\in \\mathbb {K}: p ^ {\\prime} (\\kappa) = \\operatorname {v a l} _ {L} (\\kappa) \\cdot \\mathcal {L} _ {\\operatorname {r o w} _ {L} (\\kappa)} ^ {\\mathbb {H}} (x) \\cdot \\mathcal {L} _ {\\operatorname {c o l} _ {L} (\\kappa)} ^ {\\mathbb {H}} (y) + \\alpha \\cdot \\operatorname {v a l} _ {R} (\\kappa) \\cdot \\mathcal {L} _ {\\operatorname {r o w} _ {R} (\\kappa)} ^ {\\mathbb {H}} (x) \\cdot \\mathcal {L} _ {\\operatorname {c o l} _ {R} (\\kappa)} ^ {\\mathbb {H}} (y)</span></div>

    <p class="text-gray-300">and for this it computes</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r ^ {\\prime} (X) := \\frac {p ^ {\\prime} (X) - \\sigma /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{X} \\in \\mathbb {F} _ {\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2} [ X ]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} t (X) = \\frac {\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot n ^ {2} \\cdot \\sum_ {i, j \\in [ 0, 2 ]} x ^ {i} y ^ {j} \\cdot \\operatorname {c r} _ {i, j} (X) + r ^ {\\prime} (X) \\cdot n ^ {2} \\cdot \\sum_ {i, j \\in [ 0, 2 ]} x ^ {i} y ^ {j} \\cdot \\operatorname {c r} _ {i, j} ^ {\\prime} (X) \\\\ - \\mathcal {Z} _ {\\mathbb {H}} (x) \\cdot \\mathcal {Z} _ {\\mathbb {H}} (y) \\cdot \\sum_ {i, j \\in [ 0, 1 ]} x ^ {i} y ^ {j} \\left(\\operatorname {v c r} _ {L, i, j} (X) + \\alpha \\cdot \\operatorname {v c r} _ {R, i, j} (X)\\right) \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where  <span class="math">\\mathsf{cr}_{2,2}(X) := 1</span>  and  <span class="math">\\mathsf{cr}_{2,2}&#x27;(X) := X</span> , defines polynomial</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">q ^ {\\prime} (X) := \\frac {t (X)}{\\mathcal {Z} _ {\\mathbb {K}} (X)} \\in \\mathbb {F} _ {\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2} [ X ]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and sends  <span class="math">\\{q^{\\prime}(X),r^{\\prime}(X)\\}</span>  to  <span class="math">\\mathcal{V}</span> .</p>

    <p class="text-gray-300">Decision phase. The degree checks and first polynomial check stay the same, while the second polynomial check is as follows</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\frac {\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot n ^ {2} \\cdot \\sum_ {i, j \\in [ 0, 2 ]} x ^ {i} y ^ {j} \\cdot \\boxed {\\mathsf {c r} _ {i, j} (X)} + \\boxed {r ^ {\\prime} (X)} \\cdot n ^ {2} \\cdot \\sum_ {i, j \\in [ 0, 2 ]} x ^ {i} y ^ {j} \\cdot \\boxed {\\mathsf {c r} _ {i, j} ^ {\\prime} (X)} \\\\ - \\mathcal {Z} _ {\\mathbb {H}} (x) \\cdot \\mathcal {Z} _ {\\mathbb {H}} (y) \\cdot \\sum_ {i, j \\in [ 0, 1 ]} x ^ {i} y ^ {j} \\left(\\boxed {\\operatorname {v c r} _ {L, i, j} (X)} + \\alpha \\cdot \\boxed {\\operatorname {v c r} _ {R, i, j} (X)}\\right) - \\boxed {q ^ {\\prime} (X)} \\cdot \\mathcal {Z} _ {\\mathbb {K}} (X) \\stackrel {?} {=} 0 \\tag {9} \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where  <span class="math">\\mathsf{cr}_{2,2}(X) \\coloneqq 1</span>  and  <span class="math">\\mathsf{cr}_{2,2}&#x27;(X) \\coloneqq X</span> .</p>

    <p class="text-gray-300">By construction of the relation polynomials, observe that the check of equation (9) is equivalent to checking</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\left(X \\cdot r ^ {\\prime} (X) + \\frac {\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\cdot n ^ {2} \\cdot \\prod_ {M \\in \\{L, R \\}} \\left(x - \\operatorname {r o w} _ {M} (X)\\right) \\cdot \\left(y - \\operatorname {c o l} _ {M} (X)\\right) \\\\ - \\mathcal {Z} _ {\\mathbb {H}} (x) \\cdot \\mathcal {Z} _ {\\mathbb {H}} (y) \\cdot \\left(\\operatorname {v a l} _ {L} (X) \\operatorname {c o l} _ {L} (X) \\operatorname {r o w} _ {L} (X) \\left(x - \\operatorname {r o w} _ {R} (X)\\right) \\left(y - \\operatorname {c o l} _ {R} (X)\\right) \\right. \\\\ + \\alpha \\cdot \\operatorname {v a l} _ {R} (X) \\operatorname {c o l} _ {R} (X) \\operatorname {r o w} _ {R} (X) (x - \\operatorname {r o w} _ {L} (X)) (y - \\operatorname {c o l} _ {L} (R)) \\big) \\stackrel {?} {=} 0 \\bmod \\mathcal {Z} _ {\\mathbb {K}} (X) \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Knowledge soundness and zero-knowledge of  <span class="math">\\mathsf{PHP}_{\\mathrm{lite2}}</span>  are essentially identical to those of  <span class="math">\\mathsf{PHP}_{\\mathrm{lite1}}</span> . The only differences concern polynomials that are produced by the relation encoder and thus are correct by definition.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency analysis. The relation encoder creates 24 polynomials of degree  $\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , doable in time  </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> . If expressed as functions of  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , the degree, proof length, prover complexity and verifier complexity are the same as in section 4.3. The only notable difference is that in this construction, in which we use separate sparse encodings for the matrices  </span>\\pmb{L},\\pmb{R}<span class="math"> , we have  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq m<span class="math"> , unlike in the previous construction where it was  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2m$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 3 ( <span class="math">\\mathsf{PHP}_{\\mathrm{lite2x}}</span> : a variant with fewer relation polynomials). We present a variant of  <span class="math">\\mathsf{PHP}_{\\mathrm{lite2}}</span> , that we call  <span class="math">\\mathsf{PHP}_{\\mathrm{lite2x}}</span> , whose difference with the former is a reduced number of relation polynomials. In particular, the offline phase of  <span class="math">\\mathsf{PHP}_{\\mathrm{lite2x}}</span>  outputs 8 less polynomials  <span class="math">\\mathsf{cr}_{i,j}&#x27;(X)</span> . Here the second polynomial check has degree 3, with a publicly computable term  <span class="math">X</span> :</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} n ^ {2} \\cdot \\left(X \\cdot r ^ {\\prime} (X) + \\frac {\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\cdot \\sum_ {i, j \\in [ 0, 2 ]} x ^ {i} y ^ {j} \\cdot \\boxed {\\mathsf {c r} _ {i, j} (X)} \\\\ - \\mathcal {Z} _ {\\mathbb {H}} (x) \\cdot \\mathcal {Z} _ {\\mathbb {H}} (y) \\cdot \\sum_ {i, j \\in [ 0, 1 ]} x ^ {i} y ^ {j} \\left(\\boxed {\\operatorname {v c r} _ {L, i, j} (X)} + \\alpha \\cdot \\boxed {\\operatorname {v c r} _ {R, i, j} (X)}\\right) - \\boxed {q ^ {\\prime} (X)} \\cdot \\mathcal {Z} _ {\\mathbb {K}} (X) \\stackrel {?} {=} 0 \\tag {10} \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">4.4 Our PHP for R1CS</p>

    <p class="text-gray-300">In this section we present our constructions of PHPs for R1CS. We give three constructions and two more variants that achieve different tradeoffs.</p>

    <p class="text-gray-300">Recall that in R1CS we have a claim of the form <span class="math">(\\mathbf{L} \\cdot \\mathbf{z}) \\circ (\\mathbf{R} \\cdot \\mathbf{z}) = \\mathbf{O} \\cdot \\mathbf{z}</span>. In all our constructions we consider an equivalence of the R1CS relation in which we express all the checks merged into polynomial format as follows.</p>

    <p class="text-gray-300"><strong>Definition 10 (Polynomial R1CS).</strong> Let <span class="math">\\mathbb{F}</span> be a finite field and <span class="math">n, m \\in \\mathbb{N}</span> be positive integers. We define the universal relation <span class="math">\\mathcal{R}_{polyRICS}</span> as the set of triples</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left(\\mathbb {F}, n, m, \\{\\boldsymbol {L}, \\boldsymbol {R}, \\boldsymbol {O} \\}, \\ell\\right), \\boldsymbol {x}, (a (X), b (X), w (X))\\right)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\mathbf{L},\\mathbf{R},\\mathbf{O}\\in \\mathbb{F}^{n\\times n}</span>, $\\max \\{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{O}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\} \\leq m<span class="math">, </span>\\pmb {x}\\in \\mathbb{F}^{\\ell -1}<span class="math">, </span>a(X),b(X)\\in \\mathbb{F}_{\\leq n - 1}[X]<span class="math">, and such that, for </span>\\pmb{x}^{\\prime} = (1,\\pmb {x})<span class="math">, </span>w(X)\\coloneqq \\sum_{\\eta \\in \\mathbb{H}\\backslash \\mathbb{L}}\\pmb{w}_{\\phi_{\\mathbb{H}}(\\eta)}\\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X)<span class="math"> and </span>z(X)\\coloneqq \\sum_{\\eta \\in \\mathbb{L}}\\pmb{x}'_{\\phi_{\\mathbb{H}}(\\eta)}\\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) + w(X)\\cdot \\mathcal{Z}_{\\mathbb{L}}(X)$ it holds</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {\\eta \\in \\mathbb {H}} \\left(Z _ {L} \\cdot a (\\eta) + Z _ {R} \\cdot b (\\eta) - Z _ {O} \\cdot a (\\eta) b (\\eta)\\right) \\cdot \\mathcal {L} _ {\\eta} ^ {\\mathbb {H}} (X) + \\sum_ {\\substack {\\eta , \\eta^ {\\prime} \\in \\mathbb {S} \\\\ M \\in \\{L, R, O \\}}} Z _ {M} \\cdot \\boldsymbol {M} _ {\\eta , \\eta^ {\\prime}} \\cdot z (\\eta^ {\\prime}) \\cdot \\mathcal {L} _ {\\eta} ^ {\\mathbb {H}} (X) = 0 \\tag{11}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbb{L} \\coloneqq \\{\\phi_{\\mathbb{H}}^{-1}(1), \\ldots, \\phi_{\\mathbb{H}}^{-1}(\\ell)\\}</span> and the above is a polynomial over <span class="math">\\mathbb{F}[X,Z_L,Z_R,Z_O]</span>.</p>

    <p class="text-gray-300">The following simple lemma shows that the two relations are equivalent. For completeness, we give the proof in Appendix A.2.</p>

    <p class="text-gray-300"><strong>Lemma 6.</strong> <span class="math">\\mathcal{L}(\\mathcal{R}_{RICS})\\equiv \\mathcal{L}(\\mathcal{R}_{polyRICS})</span></p>

    <p class="text-gray-300"><strong>Our Main PHP for R1CS</strong> Here we present our first PHP for R1CS that we call <span class="math">\\mathsf{PHP}_{\\mathsf{r1cs1}}</span> and that uses a joint sparse encoding as stated in definition 7. The differences with <span class="math">\\mathsf{PHP}_{\\mathsf{lite1}}</span> are very subtle, and for this reason we only highlight the main keypoints and then show the full PHP in Figure 2.</p>

    <p class="text-gray-300">Because <span class="math">\\mathcal{R}_{polyRICS}</span> requires one more matrix than <span class="math">\\mathcal{R}_{polyRICS\\text{-lite}}</span>, we must modify the main equation accordingly. In particular, we define a new matrix encoding polynomial <span class="math">V_{LRO}</span>. The holographic relation encoder of this PHP requires more polynomials than in <span class="math">\\mathsf{PHP}_{\\mathsf{lite1}}</span>, for the same reason. The protocol follows directly from these modifications, and the fact that the prover sends one more oracle, <span class="math">\\hat{w}(X)</span>, in the first round.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this setting, we will need a multiplicative the subgroup be such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 3m<span class="math"> for any </span>\\pmb{M} \\in \\{\\pmb{L}, \\pmb{R}, \\pmb{O}\\}<span class="math">. The prover&#x27;s goal is to convince the verifier that the polynomials </span>a(X), b(X), z(X)$ satisfy equation (11), which can be expressed as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_ {\\eta \\in \\mathbb {H}} \\left(Z _ {L} \\cdot a (\\eta) + Z _ {R} \\cdot b (\\eta) - Z _ {O} \\cdot a (\\eta) b (\\eta)\\right) \\Lambda_ {\\mathbb {H}} (X, \\eta) + z (\\eta) \\cdot V _ {L R O} (X, \\eta , Z _ {L}, Z _ {R}, Z _ {O}) \\tag {12}</span></div>

    <p class="text-gray-300">where <span class="math">V_{LRO} \\in \\mathbb{F}[X, Y, Z_L, Z_R, Z_O]</span> is the following polynomial,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} V _ {L R O} (X, Y, Z _ {L}, Z _ {R}, Z _ {O}) = Z _ {L} \\cdot V _ {L} (X, Y) + Z _ {R} \\cdot V _ {R} (X, Y) + Z _ {O} \\cdot V _ {O} (X, Y) \\\\ = \\sum_{\\substack{\\kappa \\in \\mathbb{K}\\\\ M\\in \\{L,R,O\\}}}Z_{M}\\cdot \\mathsf{val}_{\\mathsf{M}}(\\kappa)\\cdot \\mathcal{L}_{\\mathsf{row}(\\kappa)}^{\\mathbb{H}}(X)\\cdot \\mathcal{L}_{\\mathsf{col}(\\kappa)}^{\\mathbb{H}}(Y) \\\\ \\end{array}</span></div>

    <p class="text-gray-300"><strong>Offline phase</strong> <span class="math">\\mathcal{R}\\mathcal{E}(\\mathbb{F},n,m,\\{\\pmb {L},\\pmb {R},\\pmb {O}\\} ,\\ell)</span>. The holographic relation encoder takes as input a description of the specific relation and outputs 9 polynomials</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{\\mathsf {r o w} (X), \\mathsf {c o l} (X), \\mathsf {c r} (X), \\mathsf {r o w} ^ {\\prime} (X), \\mathsf {c o l} ^ {\\prime} (X), \\mathsf {c r} ^ {\\prime} (X), \\{\\mathsf {v c r} _ {M} (X) \\} _ {M \\in \\{L, R, O \\}} \\right\\} \\in \\mathbb {F} _ {\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1} [ X ]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 2. Our PHP proQol PHPr1cs1 for R1CS.</p>

    <p class="text-gray-300">Online phase <span class="math">\\langle \\mathcal{P}((\\mathbb{F}, n, m, \\{\\boldsymbol{L}, \\boldsymbol{R}, \\boldsymbol{O}\\}, \\ell), \\boldsymbol{x}, (a(X), b(X), w(X))), \\mathcal{V}(\\mathbb{F}, n, m, \\boldsymbol{x}) \\rangle</span>. The online phase of <span class="math">\\mathsf{PHP}_{\\mathsf{r1cs1}}</span> proceeds with the same round structure as in <span class="math">\\mathsf{PHP}_{\\mathsf{lite1}}</span>. We refer the reader to Figure 2 for the full description of the protocol.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">EFFICIENCY ANALYSIS We analyze the efficiency of our PHP protocol for R1CS with joint sparse encoding and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 3m$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Relation encoder</strong> It creates 9 polynomials, six of degree $\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math"> and the other three of degree </span>\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, doable in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Degree</strong> By looking at the polynomials of the highest degree sent by indexer and prover, one can see that $D = \\max \\{2n + \\mathsf{b}_a + \\mathsf{b}_b + 2\\mathsf{b}_q - 3, n + \\mathsf{b}_s + \\mathsf{b}_q - 1,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math">, which depends on the difference between </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and the concrete values of </span>\\mathsf{b}_a, \\mathsf{b}_b, \\mathsf{b}_q, \\mathsf{b}_s<span class="math">, which are small constants in our use cases. For example, when </span>m \\geq n<span class="math"> (which holds for matrices that encode arithmetic circuits), then </span>D =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof length.</strong> The prover sends one element of <span class="math">\\mathbb{F}</span> and 8 oracle polynomials. By inspection, the proof length is $\\mathsf{l}(\\mathsf{R}) = 7n + 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\ell + 2\\mathsf{b}_a + 2\\mathsf{b}_b + \\mathsf{b}_w + \\mathsf{b}_s + 6\\mathsf{b}_q - 4<span class="math">. By the structure of </span>s(X)<span class="math">, we have that its number of nonzero coefficients is upperbounded by </span>\\mathsf{b}_s + 2\\mathsf{b}_q + \\max \\{\\mathsf{b}_s, \\mathsf{b}_r\\}<span class="math">, what gives us a proof length </span>\\mathsf{l}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = 6n + 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\ell + 2\\mathsf{b}_a + 2\\mathsf{b}_b + \\mathsf{b}_w + 2\\mathsf{b}_s + 7\\mathsf{b}_q - 4$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Prover complexity.</strong> Using ideas similar to the ones for R1CS-lite, the total complexity is $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Verifier complexity.</strong> Similarly to the PHP for R1CS-lite, this amounts to $O(\\ell + \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ field operations, which are needed to construct the polynomial checks.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-38" class="text-2xl font-bold">SECURITY ANALYSIS</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Theorem 3 (Knowledge Soundness).</strong> The PHP protocol <span class="math">\\mathsf{PHP}_{\\mathsf{r1cs1}}</span> described in section 4.4 is <span class="math">\\epsilon</span>-sound with $\\epsilon = \\frac{2\\mathsf{D}_{end} +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\backslash\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\mathbb{F}}$, and 0-knowledge sound.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> First we prove the soundness of this PHP, and then show its proof of knowledge property.</p>

    <p class="text-gray-300"><strong>Soundness.</strong> Given the polynomial R1CS relation <span class="math">\\mathsf{R} = (\\mathbb{F}, n, m, \\{\\boldsymbol{L}, \\boldsymbol{R}, \\boldsymbol{O}\\}, \\ell)</span> and input <span class="math">\\boldsymbol{x}</span>, assume there exists no witness <span class="math">a(X), b(X), w(X)</span> that satisfies the equation (11) of Definition 10. Since the relation encoder's polynomials are generated honestly (and thus are correct), there is no witness satisfying the equivalent equation (12) either. Then, for whatever polynomials <span class="math">\\hat{a}(X), \\hat{b}(X), \\hat{w}(X)</span> sent by the prover <span class="math">\\mathcal{P}^*</span> in the first round, it must be the case that</p>

    <div class="my-4 text-center"><span class="math-block">f (X, Z _ {L}, Z _ {R}, Z _ {O}) := \\sum_ {\\eta \\in \\mathbb {H}} \\left(Z _ {L} \\cdot \\hat {a} (\\eta) + Z _ {R} \\cdot \\hat {b} (\\eta) - Z _ {O} \\cdot \\hat {a} (\\eta) \\hat {b} (\\eta)\\right) \\Lambda_ {\\mathbb {H}} (X, \\eta) + \\hat {z} (\\eta) \\cdot V _ {L R O} (X, \\eta , Z _ {L}, Z _ {R}, Z _ {O}) \\neq 0</span></div>

    <p class="text-gray-300">for properly reconstructed <span class="math">\\hat{z}(X) \\coloneqq \\sum_{\\eta \\in \\mathbb{L}} \\boldsymbol{x}&#x27;_{\\phi_{\\mathbb{H}}(\\eta)} \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) + \\hat{w}(X) \\cdot \\mathcal{Z}_{\\mathbb{L}}(X)</span>.</p>

    <p class="text-gray-300">Let the protocol run as usual, then <span class="math">\\hat{a}(X), \\hat{b}(X), \\hat{w}(X), s(X), q(X), r(X), q&#x27;(X), r&#x27;(X)</span> and <span class="math">\\sigma</span> are the polynomials and message sent by <span class="math">\\mathcal{P}^*</span>, and <span class="math">x, \\alpha_L, \\alpha_R, \\alpha_O, y</span> are the messages from <span class="math">\\mathcal{V}</span>. Due to the order of the messages, we know that <span class="math">\\hat{a}(X), \\hat{b}(X), \\hat{w}(X), s(X)</span> are independent of answers <span class="math">x, \\{\\alpha_M\\}</span>, and <span class="math">\\sigma, q(X), r(X)</span> are independent of <span class="math">y</span>.</p>

    <p class="text-gray-300">Conditioned on the verifier accepting the proof, meaning that all degree and both polynomial checks are satisfied, we denote with <span class="math">\\mathsf{bad}_1</span> and <span class="math">\\mathsf{bad}_2</span> the events that the first and second polynomial checks hold when there exists no satisfying witness for the R1CS relation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given that the verifier accepted and the second polynomial check is deterministic, <span class="math">\\operatorname{Pr}(\\mathsf{bad}_2) = 0</span>. This means that for all <span class="math">\\kappa \\in \\mathbb{K}</span>, the prover will find a polynomial <span class="math">p&#x27;(X)</span> such that <span class="math">p&#x27;(\\kappa) = \\sum_{M \\in \\{L, R, O\\}} \\alpha_M \\cdot \\mathsf{val}_M(\\kappa) \\cdot \\mathcal{L}_{\\mathsf{row}(\\kappa)}^{\\mathbb{H}}(x) \\cdot \\mathcal{L}_{\\mathsf{col}(\\kappa)}^{\\mathbb{H}}(y)</span>, as it does not depend on the witness. Considering the degree check on <span class="math">r&#x27;(X)</span>, we have that $p'(X) := (X \\cdot r'(X) + \\frac{\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> is a polynomial of degree </span>\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math"> that sums to </span>\\sigma<span class="math"> on </span>\\mathbb{K}<span class="math">. Putting all of this together and considering the definition of </span>p'(X)<span class="math">, we have that </span>\\sigma = V_{LRO}(x, y, \\alpha_L, \\alpha_R, \\alpha_O)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">31</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, since the polynomials <span class="math">\\hat{a}(X), \\hat{b}(X), \\hat{w}(X), s(X), q(X), r(X), V_{LRO}(x, X, \\alpha_L, \\alpha_R, \\alpha_O)</span> are independent of <span class="math">y</span>, by the Schwartz-Zippel lemma we obtain that the first polynomial and degree checks imply that <span class="math">q(X) \\mathcal{Z}_{\\mathbb{H}}(X) + Xr(X) = s(X) + p(X)</span> holds with probability $\\geq 1 - \\frac{2\\mathsf{D}_{end} +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F} \\setminus \\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> over the choice of </span>y \\in \\mathbb{F} \\setminus \\mathbb{H}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By the assumption on the nonexistence of a satisfying witness, the above equality can only hold when <span class="math">y</span> happens to be a root</p>

    <div class="my-4 text-center"><span class="math-block">s (y) + \\left(\\alpha_ {L} \\hat {a} (y) + \\alpha_ {R} \\hat {b} (y) - \\alpha_ {O} \\hat {a} (y) \\hat {b} (y)\\right) \\Lambda_ {\\mathbb {H}} (x, y) + \\hat {z} (y) V _ {L R O} (x, y, \\alpha_ {L}, \\alpha_ {R}, \\alpha_ {O}) - q (y) \\mathcal {Z} _ {\\mathbb {H}} (y) - y r (y) = 0,</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which occurs with probability at most $\\operatorname*{Pr}(\\mathsf{bad}_1) \\leq \\frac{2\\mathsf{D}_{end} +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\setminus\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The remaining degree check gives us that <span class="math">r(X) \\in \\mathbb{F}_{\\leq n - 2}[X]</span>, and thus by Lemma 2, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {\\eta \\in \\mathbb {H}} s (\\eta) + f (x, \\alpha_ {L}, \\alpha_ {R}, \\alpha_ {O}) = 0</span></div>

    <p class="text-gray-300">Let <span class="math">\\varsigma = \\sum_{\\eta \\in \\mathbb{H}} s(\\eta)</span>, since <span class="math">\\varsigma</span> and <span class="math">f(X, Z_L, Z_R, Z_O)</span> are independent of <span class="math">x, \\{\\alpha_M\\}</span>, by Schwartz-Zippel we have that <span class="math">\\operatorname*{Pr}[f(x, \\alpha_L, \\alpha_R, \\alpha_O) + \\varsigma = 0] \\leq \\frac{\\mathbb{H}}{\\mathbb{F}}</span> over the choice of <span class="math">x, \\{\\alpha_M\\} \\gets \\mathbb{F}</span>.</p>

    <p class="text-gray-300">KNOWLEDGE SOUNDNESS. We define the extractor algorithm <span class="math">\\mathcal{E}</span> that runs the prover <span class="math">\\mathcal{P}^*</span> for the first round, obtains <span class="math">\\hat{a}(X), \\hat{b}(X), \\hat{w}(X)</span>, and reconstructs the nonrandomized witness polynomials by interpolation as <span class="math">a(X) = \\sum_{\\eta \\in \\mathbb{H}} \\hat{a}(\\eta) \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X), b(X) = \\sum_{\\eta \\in \\mathbb{H}} \\hat{b}(\\eta) \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X), w(X) = \\sum_{\\eta \\in \\mathbb{H}} \\hat{w}(\\eta) \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X)</span>.</p>

    <p class="text-gray-300">If the verifier accepts with probability greater than the soundness error <span class="math">\\epsilon</span> given above, then the polynomials returned by <span class="math">\\mathcal{E}</span> must encode a valid witness.</p>

    <p class="text-gray-300">Finally, it is easy to see the straight-line extractability. The algorithm WitExtract is the one that takes the polynomial <span class="math">\\hat{w}(X)</span>, and reconstructs the R1CS witness <span class="math">\\boldsymbol{w}</span> by taking its evaluations on the points of <span class="math">\\mathbb{H} \\setminus \\mathbb{L}</span>—recall <span class="math">w(X) := \\sum_{\\eta \\in \\mathbb{H} \\setminus \\mathbb{L}} \\boldsymbol{w}_{\\phi_{\\mathbb{H}}(\\eta)} \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X)</span>.</p>

    <p class="text-gray-300">Theorem 4 (Zero-Knowledge). The PHP <span class="math">\\mathsf{PHP}_{\\mathsf{r1cs1}}</span> described in section 4.4 is perfect zero-knowledge. Furthermore, it is perfect honest-verifier zero-knowledge with query bound <span class="math">\\mathsf{b} = (\\mathsf{b}_a, \\mathsf{b}_b, \\mathsf{b}_w, \\mathsf{b}_s, \\mathsf{b}_q, \\mathsf{b}_r, \\infty, \\infty)</span>.</p>

    <p class="text-gray-300">Proof. We begin by showing the perfect zero-knowledge. As this scheme lies on the PHP model, there is no need to worry about oracle polynomials. Thus, we set our focus on the single non-oracle message <span class="math">\\sigma</span> that the prover sends throughout the rounds, which by the way does not depend on the witness. More formally, we describe a simulator <span class="math">\\mathcal{S}</span> that on input the relation <span class="math">\\mathsf{R} = (\\mathbb{F}, n, m, \\{\\boldsymbol{L}, \\boldsymbol{R}\\}, \\ell)</span> and the input <span class="math">\\boldsymbol{x}</span>, and given oracle access to the verifier <span class="math">\\mathcal{V}^<em></span>, proceeds as follows. It runs <span class="math">\\mathcal{V}^</em></span> to obtain its random messages <span class="math">x, y, \\alpha</span> and its checks. Next, it computes <span class="math">\\sigma = V_{LR}(x, y, \\alpha_L, \\alpha_R, \\alpha_O)</span>, and outputs <span class="math">\\sigma</span> followed by checks obtained from <span class="math">\\mathcal{V}^<em></span>. Note that <span class="math">\\text{View}\\big(\\mathcal{S}^{\\mathcal{V}^</em>}(\\mathbb{F}, \\mathsf{R}, \\boldsymbol{x})\\big)</span> is identically distributed to <span class="math">\\text{View}\\big(\\mathcal{P}(\\mathbb{F}, \\mathsf{R}, \\boldsymbol{x}, a(X), b(X), w(X)) \\quad \\mathcal{V}^*\\big)</span>.</p>

    <p class="text-gray-300">Next, we prove b-HVZK for bounds <span class="math">\\mathsf{b}_a,\\mathsf{b}_b,\\mathsf{b}_w,\\mathsf{b}_s,\\mathsf{b}_q,\\mathsf{b}_r</span> on the polynomials <span class="math">\\hat{a} (X),\\hat{b} (X),\\hat{w} (X),s(X),</span> <span class="math">q(X),r(X)</span> respectively, whereas for the polynomials <span class="math">q^{\\prime}(X),r^{\\prime}(X)</span> we tolerate unbounded number of evaluations (this is trivial as these polynomials depend on public information only).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathsf{C}(i,\\gamma)</span> be the algorithm that on any pair <span class="math">(i,\\gamma)</span> outputs 1 if and only if <span class="math">i\\in \\{1,\\ldots ,8\\}</span> and <span class="math">\\gamma \\notin \\mathbb{H}</span>. For a <span class="math">\\gamma \\gets \\mathbb{F}</span>, it holds $\\operatorname*{Pr}[\\mathsf{C}(i,\\gamma) = 0] =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, which is negligible for the choices of </span>\\mathbb{F}$ considered in this paper.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The simulator samples a random tape <span class="math">\\pmb{\\rho}</span> for the honest verifier and runs <span class="math">Q_{\\mathcal{V}}(\\pmb{\\rho})</span> to sample queries <span class="math">(x,y,\\{\\alpha_M\\}_{M\\in \\{L,R,O\\}})</span>, and its decision algorithm <span class="math">\\{\\pmb{d},\\{(G,\\pmb{v})\\} \\gets D_{\\mathcal{V}}(\\mathbb{F},\\pmb{x};\\pmb{\\rho})</span> to obtain its checks. Then, it simulates answers to polynomial evaluations as follows.</p>

    <p class="text-gray-300">For every pair <span class="math">(i,\\gamma)</span> with <span class="math">i\\in \\{7,8\\}</span> (i.e., for every query on <span class="math">q^{\\prime},r^{\\prime}</span>), the simulator computes <span class="math">t_{i,\\gamma}\\gets p_i(\\gamma)</span> honestly, which is trivial as these polynomials depend only on public information.</p>

    <p class="text-gray-300">For every pair <span class="math">(i,\\gamma)\\in \\mathcal{L}</span> such that <span class="math">i\\in [6]\\setminus \\{5\\}</span> (i.e., every query on <span class="math">\\hat{a},\\hat{b},\\hat{w},s,r</span>), the simulator samples a random value <span class="math">t_{i,\\gamma}\\gets \\mathbb{F}</span> and stores a tuple <span class="math">(i,\\gamma ,t_{i,\\gamma})</span> in a table T.</p>

    <p class="text-gray-300">32</p>

    <p class="text-gray-300">For every query <span class="math">(5,\\gamma)</span> it simulates the answer with the value <span class="math">t_{5,\\gamma}</span> computed as follows:</p>

    <p class="text-gray-300"><span class="math">t_{z,\\gamma}</span> <span class="math">\\leftarrow t_{3,\\gamma}\\cdot\\mathfrak{Z}_{\\mathbb{L}}(\\gamma)+\\sum_{\\eta\\in\\mathbb{L}}\\boldsymbol{x^{\\prime}}_{\\phi_{\\mathbb{H}}(\\eta)}\\cdot\\mathcal{L}^{\\mathbb{H}}_{\\eta}(\\gamma)</span> <span class="math">t_{p,\\gamma}</span> <span class="math">\\leftarrow(\\alpha_{L}\\cdot t_{1,\\gamma}+\\alpha_{R}\\cdot t_{2,\\gamma}-\\alpha_{O}\\cdot t_{1,\\gamma}\\cdot t_{2,\\gamma})\\cdot\\Lambda_{\\mathbb{H}}(x,\\gamma)+t_{z,\\gamma}\\cdot V_{\\{L,R,O\\}}(x,\\gamma,\\alpha_{L},\\alpha_{R},\\alpha_{O})</span> <span class="math">t_{5,\\gamma}</span> <span class="math">\\leftarrow\\frac{t_{p,\\gamma}+t_{4,\\gamma}-\\gamma\\cdot t_{6,\\gamma}}{\\mathfrak{Z}_{\\mathbb{H}}(\\gamma)}</span></p>

    <p class="text-gray-300">While doing the computations above, for <span class="math">j=1,2,3,4,6</span>, if an entry <span class="math">(j,\\gamma,t_{j,\\gamma})</span> already exists in <span class="math">\\mathsf{T}</span>, then the corresponding value <span class="math">t_{j,\\gamma}</span> is used; otherwise a random <span class="math">t_{j,\\gamma}\\leftrightarrows\\mathbb{F}</span> is sampled and a new entry <span class="math">(j,\\gamma,t_{j,\\gamma})</span> is added to <span class="math">\\mathsf{T}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{S}</span> returns <span class="math">\\big{(}\\boldsymbol{\\rho},V_{LR}(x,y,\\alpha_{L},\\alpha_{R},\\alpha_{O}),(\\boldsymbol{d},\\{(G,\\boldsymbol{v})\\}),\\{t_{i,\\gamma}\\}_{(i,\\gamma)\\in\\mathcal{L}}\\big{)}</span>.</p>

    <p class="text-gray-300">To conclude the proof, we argue that the distribution of <span class="math">\\mathcal{S}</span>’s output is identical to that of</p>

    <p class="text-gray-300"><span class="math">\\big{(}\\textsf{View}\\big{(}\\mathcal{P}(\\mathbb{F},\\mathsf{R},\\boldsymbol{x},a,b,w)\\ \\ ,\\mathcal{V}\\big{)},(p_{i}(\\gamma))_{(i,\\gamma)\\in\\mathcal{L}}\\big{)}\\,.</span></p>

    <p class="text-gray-300">By the <span class="math">(\\mathsf{b}_{a}+\\mathsf{b}_{q})</span>-wise (resp. <span class="math">(\\mathsf{b}_{b}+\\mathsf{b}_{q})</span> and <span class="math">(\\mathsf{b}_{w}+\\mathsf{b}_{q})</span>-wise) independence of the polynomial <span class="math">\\hat{a}(X)</span> (resp. <span class="math">\\hat{b}(X)</span> and <span class="math">\\hat{w}(X)</span>) sampled by the honest prover (and using the fact that they are evaluated on <span class="math">\\mathbb{F}\\setminus\\mathbb{H}</span>), we have that the set of simulated answers <span class="math">\\{t_{i,\\gamma}\\}_{i\\in[3]:(i,\\gamma)\\in\\mathcal{L}}</span> are identically distributed (we recall that these sets are of size <span class="math">\\mathsf{b}_{a}</span>, <span class="math">\\mathsf{b}_{b}</span> and <span class="math">\\mathsf{b}_{w}</span> respectively) to those of the real prover.</p>

    <p class="text-gray-300">For the remaining polynomials, let us recall that for the honest prover we have</p>

    <p class="text-gray-300"><span class="math">p(X)</span> <span class="math">=\\big{(}\\alpha_{L}\\cdot\\hat{a}(X)+\\alpha_{R}\\cdot\\hat{b}(X)-\\alpha_{O}\\cdot\\hat{a}(X)\\cdot\\hat{b}(X)\\big{)}\\cdot\\Lambda_{\\mathbb{H}}(x,X)+\\hat{z}(X)\\cdot V_{LRO}(x,X,\\alpha_{L},\\alpha_{R},\\alpha_{O})</span> <span class="math">s(X)</span> <span class="math">=q_{s}(X)\\mathfrak{Z}_{\\mathbb{H}}(X)+Xr_{s}(X)</span></p>

    <p class="text-gray-300">where <span class="math">\\hat{z}(X)=\\hat{w}(X)\\cdot\\mathfrak{Z}_{\\mathbb{L}}(X)+\\sum_{\\eta\\in\\mathbb{L}}\\boldsymbol{x^{\\prime}}_{\\phi_{\\mathbb{H}}(\\eta)}\\cdot\\mathcal{L}^{\\mathbb{H}}_{\\eta}(X)</span>, <span class="math">q_{s}(X)\\leftrightarrows\\mathbb{F}_{\\mathsf{b}_{s}+\\mathsf{b}_{q}}[X]</span> and <span class="math">r_{s}(X)\\leftrightarrows\\mathbb{F}_{\\mathsf{b}_{r}+\\mathsf{b}_{q}}[X]</span>. Also, let us write <span class="math">p(X)=q_{p}(X)\\mathfrak{Z}_{\\mathbb{H}}(X)+Xr_{p}(X)</span> for the unique <span class="math">q_{p}(X),r_{p}(X)</span> by polynomial division.</p>

    <p class="text-gray-300">By the uniqueness of polynomials <span class="math">q(X)</span> and <span class="math">r(X)\\in\\mathbb{F}_{\\leq n-2}[X]</span> such that <span class="math">s(X)+p(X)=q(X)\\cdot\\mathfrak{Z}_{\\mathbb{H}}(X)+X\\cdot r(X)</span>, we have that <span class="math">q(X)=q_{p}(X)+q_{s}(X)</span> and <span class="math">r(X)=r_{p}(X)+r_{s}(X)</span>.</p>

    <p class="text-gray-300">By the <span class="math">(\\mathsf{b}_{r}+\\mathsf{b}_{q})</span>-wise independence of <span class="math">r_{s}(X)</span> (and thus of <span class="math">r(X)</span>) we obtain that the set of simulated answers <span class="math">\\{t_{6,\\gamma}\\}_{(6,\\gamma)\\in\\mathcal{L}}</span> (whose cardinality is at most <span class="math">\\mathsf{b}_{r}</span>) are identically distributed to those, <span class="math">\\{r(\\gamma)\\}_{(6,\\gamma)\\in\\mathcal{L}}</span>, of the real prover. Furthermore, by the <span class="math">(\\mathsf{b}_{s}+\\mathsf{b}_{q})</span>-wise independence of <span class="math">q_{s}(X)</span> we obtain that the set of simulated answers <span class="math">\\{t_{4,\\gamma}\\}_{(4,\\gamma)\\in\\mathcal{L}}</span> (whose cardinality is at most <span class="math">\\mathsf{b}_{s}</span>) are identically distributed to those, <span class="math">\\{s(\\gamma)\\}_{(4,\\gamma)\\in\\mathcal{L}}</span>, of the real prover. In particular, for this we use that for <span class="math">\\gamma\\in\\mathbb{F}\\setminus\\mathbb{H}</span>, <span class="math">s(X)</span> is <span class="math">(\\mathsf{b}_{s}+\\mathsf{b}_{q})</span>-wise independent even conditioned on <span class="math">r_{s}(X)</span>.</p>

    <p class="text-gray-300">To argue the correct distribution of the set of simulated answers <span class="math">\\{t_{5,\\gamma}\\}_{(5,\\gamma)\\in\\mathcal{L}}</span>, we observe that the honest <span class="math">q(X)</span> is determined by <span class="math">(p(X)+s(X)-Xr(X))/\\mathfrak{Z}_{\\mathbb{H}}(X)</span>, where <span class="math">p(X)</span> is defined as above. In particular, an evaluation of <span class="math">q(\\gamma)</span> on <span class="math">\\gamma\\in\\mathbb{F}\\setminus\\mathbb{H}</span> can be obtained as <span class="math">(p(\\gamma)+s(\\gamma)-\\gamma r(\\gamma))/\\mathfrak{Z}_{\\mathbb{H}}(\\gamma)</span>, thus using evaluations of <span class="math">\\hat{a}(\\gamma)</span>, <span class="math">\\hat{b}(\\gamma)</span>, <span class="math">\\hat{w}(\\gamma)</span>, <span class="math">s(\\gamma)</span>, <span class="math">r(\\gamma)</span>, and evaluations of publicly available polynomials. This explains the simulation strategy of <span class="math">t_{5,\\gamma}</span> by <span class="math">\\mathcal{S}</span>, and these values are identically distributed to <span class="math">q(\\gamma)</span> as the polynomials <span class="math">\\hat{a}(X)</span>, <span class="math">\\hat{b}(X)</span>, <span class="math">\\hat{w}(X)</span>, <span class="math">s(X)</span>, and <span class="math">r(X)</span>, each allows <span class="math">\\mathsf{b}_{q}</span> more evaluations whose outputs are uniformly distributed.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Remark 4 (On degree optimizations).</h6>

    <p class="text-gray-300">From the proof of the above theorem it turns out that increasing the degrees of polynomials <span class="math">\\hat{a}</span>, <span class="math">\\hat{b}</span>, <span class="math">\\hat{w}</span>, <span class="math">s</span>, <span class="math">r</span> by <span class="math">\\mathsf{b}_{q}</span> may be a too conservative choice. Indeed, additional information about these four polynomials is leaked only if an evaluation <span class="math">q(X)</span> is revealed on a point <span class="math">\\gamma</span> on which these polynomials were not already evaluated. More precisely, if the list <span class="math">\\mathcal{L}</span> is such that the simulation of <span class="math">t_{5,\\gamma}</span> does not require sampling new values <span class="math">t_{j,\\gamma}</span>, <span class="math">j\\in\\{1,2,3,4,6\\}</span>, then it is sufficient to have <span class="math">\\hat{a}\\in\\mathbb{F}_{\\leq n+\\mathsf{b}_{a}}</span>, <span class="math">\\hat{b}\\in\\mathbb{F}_{\\leq n+\\mathsf{b}_{b}}</span>, <span class="math">\\hat{w}\\in\\mathbb{F}_{\\leq n+\\mathsf{b}_{w}}</span>, <span class="math">q_{s}\\in\\mathbb{F}_{\\leq\\mathsf{b}_{s}}</span>, <span class="math">r_{s}\\in\\mathbb{F}_{\\leq\\mathsf{b}_{r}}</span>.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Remark 5 (On the number of relation polynomials).</h6>

    <p class="text-gray-300">We present a variant of <span class="math">\\mathsf{PHP_{r1cs1}}</span>, that we call <span class="math">\\mathsf{PHP_{r1cs1s}}</span>, whose difference with the former is a reduced number of relation polynomials. In particular, the offline phase</p>

    <p class="text-gray-300">of <span class="math">\\mathsf{PHP}_{\\mathsf{r1cs1x}}</span> outputs three less polynomials <span class="math">\\mathsf{col}&#x27;(X), \\mathsf{row}&#x27;(X)</span> and <span class="math">\\mathsf{cr}&#x27;(X)</span>. Here the second polynomial check has degree 3, with a publicly computable term <span class="math">X</span>:</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n^{2} \\cdot \\left(X \\cdot r^{\\prime}(X) + \\frac{\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\cdot \\left(x y - x \\cdot \\operatorname{col}(X) - y \\cdot \\operatorname{row}(X) + \\operatorname{cr}(X)\\right) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\quad - \\mathcal{Z}_{\\mathbb{H}}(x) \\cdot \\mathcal{Z}_{\\mathbb{H}}(y) \\cdot \\sum_{M \\in \\{L, R, O\\}} \\alpha_{M} \\cdot \\operatorname{vcr}_{M}(X) - q^{\\prime}(X) \\cdot \\mathcal{Z}_{\\mathbb{K}}(X) \\stackrel{?}{=} 0 \\tag{13} \\end{array} $$</p>

    <h2 id="sec-41" class="text-2xl font-bold">A Variant with Separate Sparse Matrix Encodings</h2>

    <p class="text-gray-300">Here we show a variant of our PHP for R1CS, in which the matrices <span class="math">\\{\\pmb{L},\\pmb{R},\\pmb{O}\\}</span> are encoded separately as in definition 6. We call this scheme <span class="math">\\mathsf{PHP}_{\\mathsf{r1cs2}}</span>.</p>

    <p class="text-gray-300">We can use such sparse encoding of <span class="math">\\pmb{L}</span>, <span class="math">\\pmb{R}</span> and <span class="math">\\pmb{O}</span> to change the <span class="math">V_{LRO}(X,Y,Z_L,Z_R,Z_O)</span> polynomial in equation (12) into the following one:</p>

    <div class="my-4 text-center"><span class="math-block">V_{LRO}(X,Y,Z_{L},Z_{R},Z_{O}) = \\sum_{\\substack{\\kappa \\in \\mathbb{K}\\\\ M\\in \\{L,R,O\\}}}Z_{M}\\cdot \\mathsf{val}_{\\mathsf{M}}(\\kappa)\\cdot \\mathcal{L}_{\\mathsf{row}_{\\mathsf{M}}(\\kappa)}^{\\mathbb{H}}(X)\\cdot \\mathcal{L}_{\\mathsf{col}_{\\mathsf{M}}(\\kappa)}^{\\mathbb{H}}(Y)</span></div>

    <p class="text-gray-300">Then in this variant the prover's goal is to show that the polynomials sent in the first round satisfy the equation above. This variant proceeds almost identically to the one of section 4.4; the main differences are in the relation polynomials and the third round.</p>

    <p class="text-gray-300"><strong>Offline phase</strong> <span class="math">\\mathcal{R}\\mathcal{E}(\\mathbb{F},n,m,\\{\\pmb {L},\\pmb {R},\\pmb {O}\\} ,\\ell)</span>. The holographic relation encoder outputs 57 polynomials,</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{\\left\\{\\operatorname{cr}_{i,j}(X)\\right\\}_{i,j \\in [0,3] \\wedge i \\neq 3 \\neq j}, \\left\\{\\operatorname{vcr}_{M,i,j}(X)\\right\\}_{M \\in \\{L,R,O\\} \\wedge i,j \\in [0,2]}\\right\\} \\in \\mathbb{F}_{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}[X] \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">where <span class="math">\\mathsf{cr}_{i,j}(X)</span> and <span class="math">\\mathsf{vcr}_{M,i,j}(X)</span> are obtained by computing low-degree extensions of the polynomials that represent the coefficients accompanying the <span class="math">x^i\\cdot y^j</span> terms of the following polynomials, respectively:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\prod_{M \\in \\{L, R, O\\}} (x - \\mathsf{row}_{\\mathsf{M}}(X)) \\cdot (y - \\mathsf{col}_{\\mathsf{M}}(X)) \\\\ \\sum_{M \\in \\{L, R, O\\}} \\mathsf{val}_{\\mathsf{M}}(X) \\cdot \\mathsf{row}_{\\mathsf{M}}(X) \\cdot \\mathsf{col}_{\\mathsf{M}}(X) \\cdot \\prod_{M&#x27; \\neq M} (x - \\mathsf{row}_{\\mathsf{M}&#x27;}(X)) \\cdot (y - \\mathsf{col}_{\\mathsf{M}&#x27;}(X)) \\end{array}</span></div>

    <p class="text-gray-300">Similarly to <span class="math">\\mathsf{PHP}_{\\mathrm{lite2}}</span>, the goal of all these polynomials is to obtain a verifier polynomial check that has at most degree 2 in the oracle polynomials.</p>

    <p class="text-gray-300"><strong>Online phase</strong> <span class="math">\\langle \\mathcal{P}((\\mathbb{F},n,m,\\{\\pmb {L},\\pmb {R},\\pmb {O}\\} ,\\ell),\\pmb {x},(a(X),b(X),w(X))),\\mathcal{V}(\\mathbb{F},n,m,\\mathsf{x})\\rangle</span>. Round 1 and 2 proceed identically to the PHP of section 4.4 except for the different definition of the polynomial <span class="math">V_{LRO}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Round 3</strong> The verifier sends a random point <span class="math">y \\longleftrightarrow \\mathbb{F} \\backslash \\mathbb{H}</span>. The prover uses <span class="math">y</span> to compute <span class="math">\\sigma \\gets V_{LRO}(x, y, \\alpha_L, \\alpha_R, \\alpha_O)</span> and then defines the degree- $(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1)$ polynomial</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">V_{LRO}(X,Y,Z_{L},Z_{R},Z_{O}) = \\sum_{\\substack{\\kappa \\in \\mathbb{K}\\\\ M\\in \\{L,R,O\\}}}Z_{M}\\cdot \\mathsf{val}_{\\mathsf{M}}(\\kappa)\\cdot \\mathcal{L}_{\\mathsf{row}_{\\mathsf{M}}(\\kappa)}^{\\mathbb{H}}(X)\\cdot \\mathcal{L}_{\\mathsf{col}_{\\mathsf{M}}(\\kappa)}^{\\mathbb{H}}(Y)</span></div>

    <p class="text-gray-300">The goal of the prover is to convince the verifier that <span class="math">\\sum_{\\kappa \\in \\mathbb{K}} p&#x27;(\\kappa) = \\sigma</span> and for all <span class="math">\\kappa \\in \\mathbb{K}</span></p>

    <div class="my-4 text-center"><span class="math-block">p^{\\prime}(\\kappa) = \\sum_{M\\in \\{L,R,O\\}}\\alpha_{M}\\mathsf{val}_{\\mathsf{M}}(\\kappa)\\mathcal{L}_{\\mathsf{row}_{\\mathsf{M}}(\\kappa)}^{\\mathbb{H}}(x)\\mathcal{L}_{\\mathsf{col}_{\\mathsf{M}}(\\kappa)}^{\\mathbb{H}}(y)</span></div>

    <p class="text-gray-300">Note that by decomposition of the Lagrangians this is equivalent to</p>

    <div class="my-4 text-center"><span class="math-block">\\forall \\kappa \\in \\mathbb {K}: \\quad n ^ {2} p ^ {\\prime} (\\kappa) \\prod_ {M \\in \\{L, R, O \\}} (x - \\operatorname {r o w} _ {\\mathrm {M}} (\\kappa)) (y - \\operatorname {c o l} _ {\\mathrm {M}} (\\kappa)) -</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{Z}_{\\mathbb{H}}(x)\\mathcal{Z}_{\\mathbb{H}}(y)\\sum_{M\\in \\{L,R,O\\}}\\alpha_{M}\\mathsf{val}_{\\mathsf{M}}(\\kappa)\\mathsf{row}_{\\mathsf{M}}(\\kappa)\\mathsf{col}_{\\mathsf{M}}(\\kappa)\\prod_{M^{\\prime}\\neq M}(x - \\mathsf{row}_{\\mathsf{M}^{\\prime}}(\\kappa))(y - \\mathsf{col}_{\\mathsf{M}^{\\prime}}(\\kappa)) = 0</span></div>

    <p class="text-gray-300">that by using 42 of the relation polynomials and  <span class="math">\\mathsf{cr}_{3,3}(X) = 1</span>  can be rewritten as</p>

    <div class="my-4 text-center"><span class="math-block">\\forall \\kappa \\in \\mathbb{K}:n^{2}p^{\\prime}(\\kappa)\\sum_{i,j\\in [0,3]}x^{i}\\cdot y^{j}\\cdot \\mathsf{cr}_{i,j}(\\kappa) - \\mathcal{Z}_{\\mathbb{H}}(x)\\cdot \\mathcal{Z}_{\\mathbb{H}}(y)\\sum_{\\substack{i,j\\in [0,2]\\\\ M\\in \\{L,R,O\\}}}\\alpha_{M}\\cdot x^{i}\\cdot y^{j}\\cdot \\mathsf{vcr}_{M,i,j}(\\kappa) = 0</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Then,  <span class="math">\\mathcal{P}</span>  computes  $r'(X) = (p'(X) - \\frac{\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}) / X \\in \\mathbb{F}_{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2}[X]<span class="math">  and  </span>q'(X) := \\frac{t(X)}{\\mathcal{Z}_{\\mathbb{K}}(X)} \\in \\mathbb{F}_{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2}[X]$  with</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t(X) = n^{2}p^{\\prime}(X)\\sum_{i,j\\in [0,3]}x^{i}y^{j}\\mathsf{cr}_{i,j}(X) - \\mathcal{Z}_{\\mathbb{H}}(x)\\mathcal{Z}_{\\mathbb{H}}(y)\\sum_{\\substack{i,j\\in [0,2]\\\\ M\\in \\{L,R,O\\}}}\\alpha_{M}x^{i}y^{j}\\mathsf{vcr}_{M,i,j}(X)\\in \\mathbb{F}_{\\leq 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2}[X]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and sends  <span class="math">\\{q^{\\prime}(X),r^{\\prime}(X)\\}</span>  to  <span class="math">\\mathcal{V}</span></p>

    <p class="text-gray-300">Decision phase. The degree checks and first polynomial check stay the same, while the second polynomial check using the 57 relation polynomials becomes the following</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} n ^ {2} \\frac {\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\sum_ {i, j \\in [ 0, 3 ]} x ^ {i} y ^ {j} \\underline {{\\operatorname {c r}}} _ {i, j} (X) + n ^ {2} \\underline {{r ^ {\\prime} (X)}} \\sum_ {i, j \\in [ 0, 3 ]} x ^ {i} y ^ {j} \\underline {{\\operatorname {c r}}} _ {i, j} ^ {\\prime} (X) \\\\ - \\mathcal {Z} _ {\\mathbb {H}} (x) \\mathcal {Z} _ {\\mathbb {H}} (y) \\sum_ {\\substack {i, j \\in [ 0, 2 ] \\\\ M \\in \\{L, R, O \\}}} \\alpha_ {M} x ^ {i} y ^ {j} \\underline {{\\operatorname {v c r}}} _ {M, i, j} (X) - q ^ {\\prime} (X) \\mathcal {Z} _ {\\mathbb {K}} (X) \\stackrel {?} {=} 0 \\tag{14} \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">with  <span class="math">\\mathsf{cr}_{3,3}(X) = 1</span>  and  <span class="math">\\mathsf{cr}_{3,3}&#x27;(X) = X</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency analysis. In this variant where nonzero entries are treated separately  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq m<span class="math"> , unlike in the previous construction where it was  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 3m<span class="math"> . The relation encoder creates 42 polynomials of degree  </span>\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math">  and 15 of degree  </span>\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , doable in time  </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> . The degree, proof length, prover complexity and verifier complexity are the same as in section 4.4. To summarize, the degree is  </span>D = \\max \\{2n + \\mathsf{b}_a + \\mathsf{b}_b + 2\\mathsf{b}_q - 3, n + \\mathsf{b}_s + \\mathsf{b}_q - 1,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math"> , proof length is  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 6n + 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\ell + 2\\mathsf{b}_a + 2\\mathsf{b}_b + \\mathsf{b}_w + 2\\mathsf{b}_s + 7\\mathsf{b}_q - 4<span class="math"> , prover complexity is  </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> , while verifier&#x27;s is  </span>O(\\ell + \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 6 (On the number of relation polynomials). We present a variant of  <span class="math">\\mathsf{PHP}_{\\mathsf{r1cs2}}</span> , that we call  <span class="math">\\mathsf{PHP}_{\\mathsf{r1cs2x}}</span> , whose difference with the former is a reduced number of relation polynomials. In particular, the offline phase of  <span class="math">\\mathsf{PHP}_{\\mathsf{r1cs2x}}</span>  outputs 15 less polynomials  <span class="math">\\mathsf{cr}_{i,j}&#x27;(X)</span> . Here the second polynomial check has degree 3, with a publicly computable term  <span class="math">X</span> :</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n ^ {2} \\left(X r ^ {\\prime} (X) + \\frac {\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\sum_ {i, j \\in [ 0, 3 ]} x ^ {i} y ^ {j} \\underline {{\\operatorname {c r}}} _ {i, j} (X) - \\mathcal {Z} _ {\\mathbb {H}} (x) \\mathcal {Z} _ {\\mathbb {H}} (y) \\sum_ {\\substack {i, j \\in [ 0, 2 ] \\\\ M \\in \\{L, R, O \\}}} \\alpha_ {M} x ^ {i} y ^ {j} \\underline {{\\operatorname {v c r}}} _ {M, i, j} (X) - q ^ {\\prime} (X) \\mathcal {Z} _ {\\mathbb {K}} (X) \\stackrel {?} {=} 0 \\tag{15}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">A Variant with Better Tradeoffs Here we show another variant of a PHP for R1CS that presents a tradeoff between the number of relation polynomials and the degree of the second polynomial check. We call it  <span class="math">\\mathsf{PHP}_{\\mathsf{r1cs3}}</span> , and it will follow the separate sparse encoding of definition 6.</p>

    <p class="text-gray-300">We will proceed as in  <span class="math">\\mathsf{PHP}_{\\mathsf{r1cs2}}</span> , which also follows this encoding. The main differences we highlight are in the relation polynomials and the final round.</p>

    <p class="text-gray-300">.</p>

    <h5 id="sec-42" class="text-base font-semibold mt-4">Offline phase <span class="math">\\mathcal{R}\\mathcal{E}(\\mathbb{F},n,m,\\{\\bm{L},\\bm{R},\\bm{O}\\},\\ell)</span></h5>

    <p class="text-gray-300">The holographic relation encoder outputs 12 polynomials describing the matrices of the R1CS,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\{\\mathsf{row}_{\\mathsf{M}},\\mathsf{col}_{\\mathsf{M}},\\mathsf{cr}_{\\mathsf{M}},\\mathsf{vcr}_{\\mathsf{M}},\\}_{\\mathcal{M}\\in\\{L,R,O\\}}\\in\\mathbb{F}_{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}[X]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\mathsf{cr}_{\\mathsf{M}}(X):=\\sum_{\\kappa\\in\\mathbb{K}}\\mathsf{col}_{\\mathsf{M}}(\\kappa)\\cdot\\mathsf{row}_{\\mathsf{M}}(\\kappa)\\cdot\\mathcal{L}^{\\mathbb{K}}_{\\kappa}(X)</span> and <span class="math">\\mathsf{vcr}_{\\mathsf{M}}(X):=\\sum_{\\kappa\\in\\mathbb{K}}\\mathsf{val}_{\\mathsf{M}}(\\kappa)\\cdot\\mathsf{col}_{\\mathsf{M}}(\\kappa)\\cdot\\mathsf{row}_{\\mathsf{M}}(\\kappa)\\cdot\\mathcal{L}^{\\mathbb{K}}_{\\kappa}(X)</span>.</p>

    <h5 id="sec-43" class="text-base font-semibold mt-4">Online phase <span class="math">\\langle\\mathcal{P}\\left((\\mathbb{F},n,m,\\{\\bm{L},\\bm{R},\\bm{O}\\},\\ell),\\bm{x},(a(X),b(X),w(X))\\right),\\mathcal{V}(\\mathbb{F},n,m,\\mathsf{x})\\rangle</span></h5>

    <p class="text-gray-300">Round 1 and 2 proceed identically to the PHP of section 4.4, using the same definition of polynomial <span class="math">V_{LRO}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Round 3 Here, the only difference comes when redefining the polynomial <span class="math">t(X)</span> which is now defined over $\\mathbb{F}_{\\leq 7</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-7}[X]$. This can be done using 9 relation polynomials as:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">t(X)</span> <span class="math">:=n^{2}\\cdot p^{\\prime}(X)\\prod_{M\\in\\{L,R,O\\}}\\big{(}x-\\mathsf{row}_{\\mathsf{M}}(X)\\big{)}\\big{(}y-\\mathsf{col}_{\\mathsf{M}}(X)\\big{)}</span> <span class="math">-\\mathcal{Z}_{\\mathbb{H}}(x)\\mathcal{Z}_{\\mathbb{H}}(y)\\sum_{M\\in\\{L,R,O\\}}\\alpha_{M}\\cdot\\mathsf{val}_{\\mathsf{M}}(X)\\ \\mathsf{col}_{\\mathsf{M}}(X)\\ \\mathsf{row}_{\\mathsf{M}}(X)\\prod_{M^{\\prime}\\neq M}\\big{(}x-\\mathsf{row}_{\\mathsf{M^{\\prime}}}(X)\\big{)}\\big{(}y-\\mathsf{col}_{\\mathsf{M^{\\prime}}}(X)\\big{)}</span></p>

    <p class="text-gray-300">Nonetheless, this option will lead to a polynomial degree check of degree 8, which is undesirable for the verifier. Instead, we can make use of the other relation polynomials to obtain an equivalent definition of <span class="math">t(X)</span> with at most degree-5 checks:</p>

    <p class="text-gray-300"><span class="math">t(X)</span> <span class="math">:=n^{2}\\cdot p^{\\prime}(X)\\prod_{M\\in\\{L,R,O\\}}\\big{(}xy-y\\mathsf{row}_{\\mathsf{M}}(X)-x\\mathsf{col}_{\\mathsf{M}}(X)+\\mathsf{cr}_{\\mathsf{M}}(X)\\big{)}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$-\\mathcal{Z}_{\\mathbb{H}}(x)\\mathcal{Z}_{\\mathbb{H}}(y)\\sum_{M\\in\\{L,R,O\\}}\\alpha_{M}\\cdot\\mathsf{vcr}_{\\mathsf{M}}(X)\\prod_{M^{\\prime}\\neq M}\\big{(}xy-y\\mathsf{row}_{\\mathsf{M^{\\prime}}}(X)-x\\mathsf{col}_{\\mathsf{M^{\\prime}}}(X)+\\mathsf{cr}_{\\mathsf{M^{\\prime}}}(X)\\big{)}\\in\\mathbb{F}_{\\leq 4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-4}[X]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As usual, the prover will send <span class="math">\\{q^{\\prime},r^{\\prime}\\}</span> to the verifier, such that $r^{\\prime}(X)=(p^{\\prime}(X)-\\frac{\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})/X\\in\\mathbb{F}_{\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2}[X]<span class="math"> and </span>q^{\\prime}(X):=\\frac{t(X)}{\\mathcal{Z}_{\\mathbb{H}}(X)}\\in\\mathbb{F}_{\\leq 3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-4}[X]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-44" class="text-base font-semibold mt-4">Decision phase</h5>

    <p class="text-gray-300">The degree checks and first polynomial check stay the same, while the second one becomes the following check using the 9 relation polynomials</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$-\\overline{q^{\\prime}(X)}\\ \\mathcal{Z}_{\\mathbb{K}}(X)+n^{2}\\left(X\\cdot\\ \\overline{r^{\\prime}(X)}\\ +\\frac{\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)\\prod_{M\\in\\{L,R,O\\}}\\big{(}xy-y\\ \\mathsf{row}_{\\mathsf{M}}(X)\\ -x\\ \\mathsf{col}_{\\mathsf{M}}(X)\\ +\\ \\overline{\\mathsf{cr}_{\\mathsf{M}}(X)}\\ \\big{)}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">-\\mathcal{Z}_{\\mathbb{H}}(x)\\mathcal{Z}_{\\mathbb{H}}(y)\\sum_{M\\in\\{L,R,O\\}}\\alpha_{M}\\ \\mathsf{vcr}_{\\mathsf{M}}(X)\\ \\prod_{M^{\\prime}\\neq M}\\big{(}xy-y\\ \\mathsf{row}_{\\mathsf{M^{\\prime}}}(X)\\ -x\\ \\mathsf{col}_{\\mathsf{M^{\\prime}}}(X)\\ +\\ \\overline{\\mathsf{cr}_{\\mathsf{M^{\\prime}}}(X)}\\ \\big{)}\\stackrel{{\\scriptstyle?}}{{=}}0</span> (16)</p>

    <h5 id="sec-45" class="text-base font-semibold mt-4">Efficiency analysis</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this variant where nonzero entries are treated separately, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq m<span class="math"> as well. The relation encoder creates 12 polynomials of degree </span>\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1<span class="math">, doable in time </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Note that the quotient polynomial sent in the third round has much larger degree now, which becomes </span>D=\\max(2n+\\mathsf{b}_{a}+\\mathsf{b}_{b}+2\\mathsf{b}_{q}-3,3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-4)<span class="math">. The proof length, prover complexity and verifier complexity are the same as in section 4.4. To summarize, the proof length is </span>\\mathsf{l}(\\mathsf{R})\\leq 6n+2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\ell+2\\mathsf{b}_{a}+2\\mathsf{b}_{b}+\\mathsf{b}_{w}+2\\mathsf{b}_{s}+7\\mathsf{b}_{q}-4<span class="math">, prover complexity is </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, while verifier’s is </span>O(\\ell+\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-46" class="text-2xl font-bold">5 Preliminaries on Commitments and zkSNARKs</h2>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">5.1 Commitment Schemes</h3>

    <p class="text-gray-300">In our work we use the notion of <em>type-based commitments</em> (Definition 11). Type-based commitments, introduced by Escala and Groth <em>[28]</em>, are a generalization of regular commitments that unify several committing</p>

    <p class="text-gray-300">methods into the same scheme. This capability can be useful when committing to values from different domains (e.g., elements from one of the bilinear groups  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2</span> , as in the original motivation of [28]), or when creating commitments with different security properties (e.g., some that are hiding and some that are not). As done in [13], in this work we will exploit the formalism of type-based commitments to describe commit-and-prove zero-knowledge proofs that work with commitments of different types <span class="math">^{11}</span> .</p>

    <p class="text-gray-300">More in detail, a type-based commitment scheme is a tuple of algorithms  <span class="math">\\mathsf{CS} = (\\mathsf{Setup},\\mathsf{Commit},\\mathsf{VerCom})</span>  that works as a commitment scheme with the difference that the Commit and VerCom algorithms take an extra input type that represents the type of  <span class="math">c</span> . All the possible types are included in the type space  <span class="math">\\mathcal{T}</span> .</p>

    <p class="text-gray-300">Definition 11 (Type-Based Commitment Schemes). A type-based commitment scheme for a set of types  <span class="math">\\mathcal{T}</span>  and with message space  <span class="math">\\mathcal{M}</span>  is a tuple of algorithms  <span class="math">\\mathsf{CS} = (\\mathsf{Setup},\\mathsf{Commit},\\mathsf{VerCom})</span>  that work as follows:</p>

    <p class="text-gray-300">Setup  <span class="math">(1^{\\lambda})\\to \\mathsf{ck}</span>  takes the security parameter and outputs a commitment key ck.</p>

    <p class="text-gray-300">Commit(ck, type,  <span class="math">m) \\to (c, o)</span> : takes the commitment key ck, a type type  <span class="math">\\in \\mathcal{T}</span>  and a message  <span class="math">m \\in \\mathcal{M}</span> , and outputs a commitment  <span class="math">c</span>  and an opening  <span class="math">o</span> . We assume  <span class="math">c</span>  contains information about its type, which we denote by type(c).</p>

    <p class="text-gray-300"><span class="math">\\mathsf{VerCom}(\\mathsf{ck},\\mathsf{type},c,m,o)\\to b:</span>  takes as input the commitment key ck, a type type  <span class="math">\\in \\mathcal{T}</span>  , a commitment  <span class="math">c</span>  , a message  <span class="math">m\\in \\mathcal{M}</span>  and an opening  <span class="math">o</span>  , and it accepts  <span class="math">(b = 1)</span>  or rejects  <span class="math">(b = 0)</span>  . By default it outputs O if type(c)  <span class="math">\\neq</span>  type. Additionally we define VerCom(ck,c,f,o) that runs VerCom(ck,type(c),c,f,o).</p>

    <p class="text-gray-300">CS satisfies correctness, type-typed binding and type-typed trapdoor-hiding properties defined below:</p>

    <p class="text-gray-300">Correctness. For any  <span class="math">\\lambda \\in \\mathbb{N}</span> , any commitment key  <span class="math">\\mathsf{ck} \\gets \\mathsf{Setup}(1^{\\lambda})</span> , type type  <span class="math">\\in \\mathcal{T}</span> , message  <span class="math">m \\in \\mathcal{M}</span> , and for any honestly generated commitment-opening  <span class="math">(c,o) \\gets \\mathsf{Commit}(\\mathsf{ck},\\mathsf{type},m)</span> , we have that  <span class="math">\\mathsf{VerCom}(\\mathsf{ck},\\mathsf{type},c,m,o) = 1</span> ;</p>

    <p class="text-gray-300">type-typed Binding. Let type  <span class="math">\\in \\mathcal{T}</span> , CS is type-typed (computationally) binding if for every (non-uniform) efficient adversary  <span class="math">\\mathcal{A}</span>  we have  <span class="math">\\operatorname*{Pr}[\\mathsf{Game}_{\\mathcal{A}}^{\\mathsf{bind}}(\\lambda) = 1] = \\mathsf{negl}(\\lambda)</span>  where:</p>

    <p class="text-gray-300">|  GameA bind(λ)  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  ck← Setup(1λ)  |</p>

    <p class="text-gray-300">|  c,m,o,m',o'← A(ck,type,auxZ)  |</p>

    <p class="text-gray-300">|  return VerCom(ck,type,c,m,o) = 1 ∧ VerCom(ck,type,c,m',o') = 1 ∧ m ≠ m'  |</p>

    <p class="text-gray-300">We simply say that CS is binding if it is type-typed binding for any type  <span class="math">\\in \\mathcal{T}</span> .</p>

    <p class="text-gray-300">type-typed Trapdoor-Hiding. There exist three algorithms  <span class="math">(\\mathsf{ck},\\mathsf{td})\\gets S_{\\mathsf{ck}}(1^{\\lambda})</span> <span class="math">(c,st)\\gets \\mathsf{TdCom}(\\mathsf{td},\\mathsf{type})</span>  and  <span class="math">o\\gets \\mathsf{TdOpen}(\\mathsf{td},st,\\mathsf{type},c,m)</span>  such that: the distribution of the commitment key returned by  <span class="math">S_{\\mathsf{ck}}</span>  is perfectly/ statistically close to the one of the key returned by Setup; for any  <span class="math">m\\in \\mathcal{M}</span> <span class="math">(c,o)\\approx (c^{\\prime},o^{\\prime})</span>  where  <span class="math">(c,o)\\gets</span>  Commit(ck,m),  <span class="math">(c^{\\prime},st)\\gets \\mathsf{TdCom}(\\mathsf{td},\\mathsf{type})</span>  and  <span class="math">o^\\prime \\gets \\mathsf{TdOpen}(\\mathsf{td},st,\\mathsf{type}c&#x27;,m)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 12 (Succinct Commitments). A commitment scheme CS is said succinct if there is a fixed polynomial that bounds the size of every commitment  <span class="math">c</span>  returned by Commit; in particular  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  may be independent of the size of the message.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In a recent work, Groth et al. [40] introduced the notion of (preprocessing) zkSNARKs with specializable universal structured reference string (SRS). In a nutshell, this notion formalizes the idea that key generation for  <span class="math">\\mathsf{R} \\in \\mathcal{R}</span>  can be seen as the sequential combination of two steps: a first probabilistic algorithm that generates an SRS for the universal relation  <span class="math">\\mathcal{R}</span>  and a second deterministic algorithm that specializes this universal SRS into one for a specific  <span class="math">\\mathsf{R}</span> . We remark that by considering "universal relations"  <span class="math">\\mathcal{R}</span>  that contain a single  <span class="math">\\mathsf{R}</span> , and by having Derive as the identity function, one recovers the usual zkSNARK notion.</p>

    <p class="text-gray-300">We consider families of relations parametrized by the output of a probabilistic algorithm  <span class="math">\\mathsf{ParGen}(1^{\\lambda}) \\to \\mathsf{pp}</span>  that takes as input the security parameter and outputs a set of relation parameters  <span class="math">\\mathsf{pp}</span> . The families also depend on a size bound  <span class="math">\\mathsf{N}</span> ; we denote them as a tuple  <span class="math">\\left(\\mathsf{ParGen}, \\{\\mathcal{R}_{\\mathsf{pp},\\mathsf{N}}\\}_{\\mathsf{pp} \\in \\{0,1\\}^*, \\mathsf{N} \\in \\mathbb{N}}\\right)</span> . Occasionally, as in the definition of CP-SNARK, we will consider "simple" relation families  <span class="math">\\mathcal{R}</span>  parametrized only by a bound  <span class="math">\\mathsf{N} \\in \\mathbb{N}</span> .</p>

    <p class="text-gray-300">Definition 13 (Universal zkSNARK). A zkSNARK with specializable universal SRS (Definition ??) for a family of relations  <span class="math">\\left(\\mathsf{ParGen},\\{\\mathcal{R}_{\\mathsf{pp},\\mathsf{N}}\\}_{\\mathsf{pp}\\in \\{0,1\\}^*,\\mathsf{N}\\in \\mathbb{N}}\\right)</span>  is a tuple of algorithms  <span class="math">\\Pi = (\\mathsf{KeyGen},\\mathsf{Derive},\\mathsf{Prove},\\mathsf{Verify})</span>  that work as described below and that satisfy the notions of completeness, succinctness and knowledge-soundness defined below. If  <span class="math">\\Pi</span>  also satisfies zero-knowledge we call it a universal zkSNARK.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>KeyGen(pp, N)  <span class="math">\\rightarrow</span>  (srs, td_k) is a probabilistic algorithm that takes as input the public parameters for the relation family and it outputs a srs := (ek, vk). We assume without loss of generality that srs contains pp output of ParGen.</li>

      <li>Derive(srs, R)  <span class="math">\\rightarrow</span>  (ekR, vkR) is a deterministic algorithm that takes as input an srs produced by KeyGen(pp, N), and a relation  <span class="math">R \\in \\mathcal{R}_N</span> , and outputs specialized keys  <span class="math">\\mathsf{srs}_R := (\\mathsf{ek}_R, \\mathsf{vk}_R)</span> .</li>

      <li>Prove  <span class="math">(\\mathsf{ek}_{\\mathsf{R}}, \\mathsf{x}, \\mathsf{w}) \\to \\pi</span>  takes a proving key  <span class="math">\\mathsf{ek}_{\\mathsf{R}}</span>  for a relation  <span class="math">\\mathsf{R}</span> , a statement  <span class="math">\\mathsf{x}</span> , and a witness  <span class="math">\\mathsf{w}</span>  such that  <span class="math">\\mathsf{R}(\\mathsf{x}, \\mathsf{w})</span>  holds, and returns a proof  <span class="math">\\pi</span> .</li>

      <li>Verify  <span class="math">(\\mathsf{vk}_{\\mathsf{R}}, \\mathsf{x}, \\pi) \\to b</span>  takes a verification key for a relation  <span class="math">\\mathsf{R}</span> , a statement  <span class="math">\\mathsf{x}</span> , and either accepts  <span class="math">(b = 1)</span>  or rejects  <span class="math">(b = 0)</span>  the proof  <span class="math">\\pi</span> .</li>

    </ul>

    <p class="text-gray-300">Completeness. For all  <span class="math">\\mathsf{pp} \\in \\mathsf{Range}(\\mathsf{ParGen}), \\mathsf{N} \\in \\mathbb{N}</span> ,  <span class="math">\\mathsf{R} \\in \\mathcal{R}_{\\mathsf{pp},\\mathsf{N}}</span>  and  <span class="math">(\\mathsf{x},\\mathsf{w})</span>  such that  <span class="math">\\mathsf{R}(\\mathsf{x},\\mathsf{w}) = 1</span> , it holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} (\\mathsf {s r s}, \\mathsf {t d} _ {\\mathsf {k}}) \\leftarrow \\mathsf {K e y G e n} (\\mathsf {p p}, \\mathsf {N}) \\\\ (\\mathsf {e k} _ {\\mathsf {R}}, \\mathsf {v k} _ {\\mathsf {R}}) \\leftarrow \\mathsf {D e r i v e} (\\mathsf {s r s}, \\mathsf {R}) : \\mathsf {V e r i f y} (\\mathsf {v k} _ {\\mathsf {R}}, \\mathsf {x}, \\pi) = 1 \\\\ \\pi \\leftarrow \\mathsf {P r o v e} (\\mathsf {e k} _ {\\mathsf {R}}, \\mathsf {x}, \\mathsf {w}) \\end{array} \\right] = 1</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Succinctness.  <span class="math">\\Pi</span>  is said succinct if the running time of Verify is  $\\mathsf{poly}(\\lambda +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  and the proof size is  </span>\\mathsf{poly}(\\lambda + \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Knowledge Soundness. Let  <span class="math">\\mathsf{N} = \\mathsf{poly}(\\lambda)</span> , we say  <span class="math">\\Pi</span>  has knowledge soundness for an auxiliary input distribution  <span class="math">\\mathcal{Z}</span> , denoted  <span class="math">\\mathsf{KSND}(\\mathcal{Z})</span>  for brevity, if for every (non-uniform) efficient adversary  <span class="math">\\mathcal{A}</span>  there exists a (non-uniform) efficient extractor  <span class="math">\\mathcal{E}</span>  such that  <span class="math">\\operatorname*{Pr}\\left[\\mathsf{Game}_{\\mathcal{Z},\\mathcal{A},\\mathcal{E}}^{\\mathsf{KSND}}(\\lambda) = 1\\right] = \\mathsf{negl}(\\lambda)</span> . We say that  <span class="math">\\Pi</span>  is knowledge-sound if there exists benign  <span class="math">\\mathcal{Z}</span>  such that  <span class="math">\\Pi</span>  is  <span class="math">\\mathsf{KSND}(\\mathcal{Z})</span> .</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{c} \\mathsf {G a m e} _ {\\mathcal {R G}, \\mathcal {Z}, \\mathcal {A}, \\mathcal {E}} ^ {\\mathsf {K S N D}} (\\lambda) \\to b \\\\ \\hline \\mathsf {p p} \\leftarrow \\mathsf {P a r G e n} (1 ^ {\\lambda}) \\\\ (\\mathsf {s r s}, \\mathsf {t d} _ {\\mathsf {k}}) \\leftarrow \\mathsf {K e y G e n} (\\mathsf {p p}, \\mathsf {N}) \\\\ \\mathsf {a u x} _ {\\mathcal {Z}} \\leftarrow \\mathcal {Z} (\\mathsf {s r s}) \\\\ (\\mathsf {R}, \\mathsf {x}, \\pi) \\leftarrow \\mathcal {A} (\\mathsf {s r s}, \\mathsf {a u x} _ {\\mathcal {Z}}) \\\\ \\mathsf {w} \\leftarrow \\mathcal {E} (\\mathsf {s r s}, \\mathsf {a u x} _ {\\mathcal {Z}}) \\\\ \\mathsf {v k} _ {\\mathsf {R}} \\leftarrow \\mathsf {D e r i v e} (\\mathsf {s r s}, \\mathsf {R}) \\\\ b = \\mathsf {V e r i f y} (\\mathsf {v k} _ {\\mathsf {R}}, \\mathsf {x}, \\pi) \\wedge \\neg \\mathsf {R} (\\mathsf {x}, \\mathsf {w}) \\end{array}</span></div>

    <p class="text-gray-300">Zero-Knowledge in SRS Model. We say  <span class="math">\\Pi</span>  is zero-knowledge if there exists a simulator  <span class="math">S</span>  such that for all adversaries  <span class="math">\\mathcal{A}</span> , for all  <span class="math">\\mathsf{pp} \\in \\mathsf{Range}(\\mathsf{ParGen}), \\mathsf{N} \\in \\mathbb{N}</span> , for all  <span class="math">\\mathsf{R} \\in \\mathcal{R}_{\\mathsf{pp},\\mathsf{N}}</span> , and for all  <span class="math">(\\mathsf{x},\\mathsf{w})</span>  such that  <span class="math">\\mathsf{R}(\\mathsf{x},\\mathsf{w}) = 1</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c} \\mathsf {p p} \\leftarrow \\mathsf {P a r G e n} (1 ^ {\\lambda}) \\\\ (\\mathsf {s r s}, \\mathsf {t d} _ {\\mathsf {k}}) \\leftarrow \\mathsf {K e y G e n} (\\mathsf {p p}, \\mathsf {N}) \\\\ \\mathsf {s r s} _ {\\mathsf {R}} \\leftarrow \\mathsf {D e r i v e} (\\mathsf {s r s}, \\mathsf {R}) \\\\ \\pi \\leftarrow \\mathsf {P r o v e} (\\mathsf {s r s} _ {\\mathsf {R}}, \\mathsf {x}, \\mathsf {w}) \\end{array} : \\mathcal {A} (\\mathsf {s r s}, \\mathsf {t d} _ {\\mathsf {k}}, \\mathsf {R}, \\mathsf {x}, \\mathsf {w}, \\pi) = 1 \\right] \\approx \\\\ \\Pr \\left[ \\begin{array}{c} \\mathsf {p p} \\leftarrow \\mathsf {P a r G e n} (1 ^ {\\lambda}) \\\\ (\\mathsf {s r s}, \\mathsf {t d} _ {\\mathsf {k}}) \\leftarrow \\mathsf {K e y G e n} (\\mathsf {p p}, \\mathsf {N}): \\mathcal {A} (\\mathsf {s r s}, \\mathsf {t d} _ {\\mathsf {k}}, \\mathsf {R}, \\mathsf {x}, \\mathsf {w}, \\pi) = 1 \\\\ \\pi \\leftarrow \\mathcal {S} (\\mathsf {t d} _ {\\mathsf {k}}, \\mathsf {R}, \\mathsf {x}) \\end{array} \\right] \\\\ \\end{array}</span></div>

    <p class="text-gray-300">We adapt the notion of commit-and-prove SNARKs of [23] to universal relations.</p>

    <p class="text-gray-300">Definition 14 (Universal CP-SNARKs). Let  <span class="math">\\{\\mathcal{R}_{\\mathsf{N}}\\}_{\\mathsf{N}\\in \\mathbb{N}}</span>  be a simple family of relations  <span class="math">\\mathsf{R}</span>  over  <span class="math">\\mathcal{D}_{\\mathbf{x}}\\times</span> <span class="math">\\mathcal{D}_{\\mathbf{u}}\\times \\mathcal{D}_{\\omega}</span>  such that  <span class="math">\\mathcal{D}_{\\mathbf{u}}</span>  splits over  <span class="math">\\ell</span>  arbitrary domains  <span class="math">(\\mathcal{D}_1\\times \\dots \\times \\mathcal{D}_\\ell)</span>  for some arity parameter  <span class="math">\\ell \\geq 1</span> . Let  <span class="math">\\mathsf{CS} = (\\mathsf{Setup},\\mathsf{Commit},\\mathsf{VerCom})</span>  be a commitment scheme (as per Definition 11) whose input space  <span class="math">\\mathcal{D}</span>  is such that  <span class="math">\\mathcal{D}_i\\subset \\mathcal{D}</span>  for all  <span class="math">i\\in [\\ell ]</span> . A universal commit and prove zkSNARK for CS and  <span class="math">\\{\\mathcal{R}_{\\mathsf{N}}\\}_{\\mathsf{N}\\in \\mathbb{N}}</span>  is a zkSNARK for a family of relations  <span class="math">(\\mathsf{ParGen} = \\mathsf{CS}. \\mathsf{Setup},\\{\\mathcal{R}_{\\mathsf{ck},\\mathsf{N}}^{\\mathsf{Com}}\\}_{\\mathsf{ck}\\in \\{0,1\\} ^*,\\mathsf{N}\\in \\mathbb{N}})</span>  such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>every  <span class="math">\\mathsf{R}_{\\mathsf{ck},\\mathsf{N}}^{\\mathsf{Com}}</span>  is represented by a pair  <span class="math">(\\mathsf{ck},\\mathsf{R})</span>  where  <span class="math">\\mathsf{N} = \\mathsf{poly}(\\lambda)</span> ,  <span class="math">\\mathsf{ck} \\in \\mathsf{Setup}(1^{\\lambda})</span>  and  <span class="math">\\mathsf{R} \\in \\mathcal{R}_{\\mathsf{N}}</span> ;</li>

      <li><span class="math">\\mathsf{R}_{\\mathsf{ck},\\mathsf{N}}^{\\mathsf{Com}}</span>  is over pairs  <span class="math">(\\hat{\\mathbf{x}},\\hat{\\mathbf{w}})</span>  where the statement is  <span class="math">\\hat{\\mathbf{x}} := (\\mathbf{x},(c_j)_{j\\in [\\ell]})\\in \\mathcal{D}_{\\mathbf{x}}\\times \\mathcal{C}^{\\ell}</span> , the witness is  <span class="math">\\hat{\\mathbf{w}} := ((u_j)_{j\\in [\\ell]},(o_j)_{j\\in [\\ell]},\\omega)\\in \\mathcal{D}_1\\times \\dots \\times \\mathcal{D}_\\ell \\times \\mathcal{O}^\\ell \\times \\mathcal{D}_\\omega</span> , and the relation  <span class="math">\\mathsf{R}_{\\mathsf{ck},\\mathsf{N}}^{\\mathsf{Com}}</span>  holds if and only if</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\bigwedge_ {j \\in [ \\ell ]} \\operatorname {V e r C o m} (\\mathrm {c k}, c _ {j}, \\mathrm {u} _ {j}, o _ {j}) = 1 \\wedge \\mathrm {R} (\\mathrm {x}, (\\mathrm {u} _ {j}) _ {j \\in [ \\ell ]}, \\omega) = 1</span></div>

    <p class="text-gray-300">We denote a Universal CP-SNARK as a tuple of algorithms  <span class="math">\\mathsf{CP} = (\\mathsf{KeyGen},\\mathsf{Derive},\\mathsf{Prove},\\mathsf{Verify})</span> . For ease of exposition, in our constructions we adopt the syntax for CP's algorithms defined below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>KeyGen(ck, N)  <span class="math">\\rightarrow</span>  srs := (ek, vk) generates the structured reference string.</li>

      <li>Derive(srs, R)  <span class="math">\\rightarrow</span>  vkR is a deterministic algorithm that takes as input a srs produced by KeyGen(ck, N), and a relation  <span class="math">R \\in \\mathcal{R}_N</span> .</li>

      <li>Prove  <span class="math">(\\mathsf{ek},\\mathsf{x},(c_j)_{j\\in [\\ell]},(\\mathsf{u}_j)_{j\\in [\\ell]},(o_j)_{j\\in [\\ell]},\\omega)\\to \\pi</span>  outputs the proof for  <span class="math">(\\mathsf{x},\\mathsf{w})\\in \\mathsf{R}</span>  and  <span class="math">\\mathsf{w} = (\\mathsf{u}_1,\\ldots ,\\mathsf{u}_\\ell ,\\omega)</span> .</li>

      <li>Verify  <span class="math">(\\mathsf{vk}_{\\mathsf{R}},\\mathsf{x},(c_j)_{j\\in [\\ell]},\\pi)\\to b\\in \\{0,1\\}</span>  rejects or accepts the proof.</li>

    </ul>

    <p class="text-gray-300">Type-restricted completeness. In the completeness notion of Universal CP-SNARKs (Definition 14), the CP-SNARK is required to work on commitments of any type. Here we define a weaker notion of completeness in which the CP-SNARK works only when certain witnesses are committed with a specific type. This is useful if we want to use a CP-SNARK that supports only a subset of the types of the commitment scheme. We give a few examples. Suppose the commitment scheme has two different types,  <span class="math">\\text{type}_1, \\text{type}_2</span> , and there exists a CP-SNARK that only works with commitments of  <span class="math">\\text{type}_1</span> . Alternatively, a CP-SNARK for a relation with  <span class="math">\\ell_1 + \\ell_2</span>  committed witnesses could work only when the first  <span class="math">\\ell_1</span>  commitments are of type  <span class="math">\\text{type}_1</span>  and the subsequent  <span class="math">\\ell_2</span>  commitments are of type  <span class="math">\\text{type}_2</span> . And clearly, more fine-grained combinations are possible. The following definition formalizes this completeness notion of CP-SNARKs:</p>

    <p class="text-gray-300">Definition 15. Let  <span class="math">\\{\\mathcal{R}_{\\mathsf{N}}\\}_{\\mathsf{N}\\in \\mathbb{N}}</span>  be a family of relations  <span class="math">\\mathsf{R}</span>  over  <span class="math">\\mathcal{D}_{\\mathbf{x}}\\times \\mathcal{D}_{\\mathbf{u}}\\times \\mathcal{D}_{\\omega}</span>  such that  <span class="math">\\mathcal{D}_{\\mathbf{u}} = \\mathcal{D}^{\\ell}</span>  for  <span class="math">\\ell \\in \\mathbb{N}</span> . Let CS be a commitment scheme with types set  <span class="math">\\mathcal{T}</span>  and message space  <span class="math">\\mathcal{D}\\subseteq \\mathcal{M}</span>  and let  <span class="math">T\\in \\mathcal{T}^{\\ell}</span> .</p>

    <p class="text-gray-300">A CP-SNARK scheme CP is  <span class="math">T</span> -restricted complete if for every  <span class="math">\\mathsf{N} \\in \\mathbb{N}</span> ,  <span class="math">\\mathsf{R} \\in \\mathcal{R}_{\\mathsf{N}}</span> ,  <span class="math">\\mathsf{ck}</span>  and  <span class="math">((\\mathsf{x}, (c_j)_{j \\in [\\ell]}), \\hat{\\mathsf{w}})</span>  such that  <span class="math">\\mathsf{R}_{\\mathsf{ck},\\mathsf{N}}^{\\mathsf{Com}}((\\mathsf{x}, (c_j)_{j \\in [\\ell]}), \\hat{\\mathsf{w}}) = 1</span> , and for all  <span class="math">j \\in [\\ell] : \\mathsf{type}(c_j) = T_j</span>  it holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} (\\mathsf {e k}, \\mathsf {v k}) \\leftarrow \\mathsf {K e y G e n} (\\mathsf {c k}, \\mathsf {N}), \\\\ \\pi \\leftarrow \\mathsf {P r o v e} (\\mathsf {e k}, \\hat {\\mathsf {x}}, \\hat {\\mathsf {w}}) \\end{array} : \\mathsf {V e r i f y} (\\mathsf {D e r i v e} (\\mathsf {s r s}, \\mathsf {R}), \\hat {\\mathsf {x}}, \\pi) = 1 \\right] = 1</span></div>

    <p class="text-gray-300">For  <span class="math">\\mathcal{T}&#x27; \\subset \\mathcal{T}^\\ell</span>  we say that CP-SNARK scheme CP is  <span class="math">\\mathcal{T}&#x27;</span> -restricted complete if for all  <span class="math">T \\in \\mathcal{T}&#x27;</span>  it is  <span class="math">T</span> -restricted complete.</p>

    <p class="text-gray-300">Commitment-only SRS. The following definition formalizes a property common to several schemes.</p>

    <p class="text-gray-300">Definition 16 (Commitment-only SRS). We say that a universal CP-SNARK has a commitment-only SRS if the key generation algorithm is deterministic.</p>

    <p class="text-gray-300">Notice that for universal CP-SNARK with commitment-only SRS the notion of zero-knowledge defined in Definition 13 is not achievable. In fact, formally speaking, the commitment key  <span class="math">\\mathsf{ck}</span>  is part of the description of a relation; thus, the actual SRS of the CP-SNARK would be the empty string. However, the classical result of [36] shows that NIZK in the plain model exists only for trivial languages. Therefore we consider a weaker notion of zero-knowledge where the trapdoor necessary for simulation comes from the commitment key of CS.</p>

    <p class="text-gray-300">Definition 17. A universal CP-SNARK CP is trapdoor-commitment zero-knowledge in the SRS model for a family of universal relations  <span class="math">\\{\\mathcal{R}_{\\mathbb{N}}\\}_{\\mathbb{N}\\in \\mathbb{N}}</span>  if there exists a simulator  <span class="math">\\mathcal{S}</span>  such that for all adversaries  <span class="math">\\mathcal{A}</span> ,  <span class="math">\\mathsf{N}\\in \\mathbb{N}</span> ,  <span class="math">\\mathsf{R}\\in \\mathcal{R}_{\\mathbb{N}}</span> ,  <span class="math">(\\mathsf{ck},\\mathsf{td})\\in S_{\\mathsf{ck}}(1^{\\lambda})</span> , and  <span class="math">\\hat{\\mathbf{x}},\\hat{\\mathbf{w}}</span>  such that  <span class="math">\\mathsf{R}_{\\mathsf{ck},\\mathsf{N}}^{\\mathsf{Com}}(\\hat{\\mathbf{x}},\\hat{\\mathbf{w}}) = 1</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c} (\\mathsf {s r s}, \\mathsf {t d} _ {\\mathsf {k}}) \\leftarrow \\mathsf {K e y G e n} (\\mathsf {c k}, \\mathsf {N}) \\\\ \\quad \\mathsf {s r s} _ {\\mathsf {R}} \\leftarrow \\mathsf {D e r i v e} (\\mathsf {s r s}, \\mathsf {R}): \\mathcal {A} (\\mathsf {s r s}, \\mathsf {t d} _ {\\mathsf {k}}, \\mathsf {t d}, \\mathsf {R}, \\mathsf {x}, \\mathsf {w}, \\pi) = 1 \\\\ \\quad \\pi \\leftarrow \\mathsf {P r o v e} (\\mathsf {s r s} _ {\\mathsf {R}}, \\mathsf {x}, \\mathsf {w}) \\end{array} \\right] \\approx \\\\ \\Pr \\left[ \\begin{array}{c} (\\mathsf {s r s}, \\mathsf {t d} _ {\\mathsf {k}}) \\leftarrow \\mathsf {K e y G e n} (\\mathsf {c k}, \\mathsf {N}) \\\\ \\pi \\leftarrow \\mathcal {S} (\\mathsf {t d} _ {\\mathsf {k}}, \\mathsf {t d}, \\mathsf {R}, \\mathsf {x}): \\mathcal {A} (\\mathsf {s r s}, \\mathsf {t d} _ {\\mathsf {k}}, \\mathsf {t d}, \\mathsf {R}, \\mathsf {x}, \\mathsf {w}, \\pi) = 1 \\end{array} \\right] \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where  <span class="math">\\hat{\\mathbf{x}} = (\\mathbf{x},(c_j)_{j\\in [\\ell ]})</span>  and  <span class="math">\\hat{\\mathbf{w}} = ((\\mathbf{u}_j)_{j\\in [\\ell ]},(o_j)_{j\\in [\\ell ]},\\omega)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lastly, when the CP-SNARK CP is for a family of relations  <span class="math">\\{\\mathcal{R}_{\\mathbb{N}}\\}_{\\mathbb{N}\\in \\mathbb{N}}</span>  and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}_{\\mathbb{N}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math">  for all  </span>\\mathbb{N}$  then we omit the algorithm Derive and drop the adjective universal.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Knowledge Soundness with Partial Opening. Sometimes, we consider a more general notion of knowledge soundness for CP-SNARKs introduced by Benarroch et al. [13] named knowledge soundness with partial opening (Definition 18). The intuition is to consider adversaries that explicitly return a valid opening for a subset of the commitments that they return. This models scenarios in which these commitments are not extractable and trusted by the verifier.</p>

    <p class="text-gray-300">Definition 18 (Knowledge Soundness with Partial Opening). We say that  <span class="math">\\Pi</span>  has knowledge soundness with partial opening for a commitment scheme CS and an auxiliary input distribution  <span class="math">\\mathcal{Z}</span> , denoted poKSND(CS,  <span class="math">\\mathcal{Z}</span> ) for brevity, if for every (non-uniform) efficient adversary  <span class="math">\\mathcal{A}</span>  there exists a (non-uniform) efficient extractor  <span class="math">\\mathcal{E}</span>  such that  <span class="math">\\operatorname*{Pr}\\left[\\mathrm{Game}_{\\mathcal{Z},\\mathcal{A},\\mathcal{E}}^{\\mathrm{poKSND}}(\\lambda) = 1\\right] = \\mathrm{negl}(\\lambda)</span> , where the experiment is defined as follows.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{c} \\mathsf {G a m e} _ {\\mathsf {C S}, \\mathcal {Z}, \\mathcal {A}, \\mathcal {E}} ^ {\\mathsf {p o K S N D}} \\to b \\end{array}</span></div>

    <p class="text-gray-300"><span class="math">\\mathsf{ck}\\gets \\mathsf{CS}.Set\\mathsf{up}(1^{\\lambda});\\quad (\\mathsf{srs},\\mathsf{td}_{\\mathsf{k}})\\gets \\mathsf{KeyGen}(\\mathsf{ck},\\mathsf{N});\\quad \\mathsf{aux}_{\\mathcal{Z}}\\gets \\mathcal{Z}(\\mathsf{srs})</span></p>

    <p class="text-gray-300"><span class="math">\\left(\\mathsf{R},\\mathsf{x},(c_{j})_{j\\in [\\ell ]},(\\mathsf{u}_{j})_{j\\in [\\ell^{\\prime}]},(o_{j})_{j\\in [\\ell^{\\prime}]},\\pi\\right)\\gets \\mathcal{A}(\\mathsf{srs},\\mathsf{aux}_{\\mathcal{Z}})</span></p>

    <p class="text-gray-300"><span class="math">\\left((\\mathsf{u}_j)_{j\\in [\\ell ]},(o_j)_{j\\in [\\ell ]},\\omega\\right)\\gets \\mathcal{E}(\\mathsf{srs},\\mathsf{aux}_{\\mathcal{Z}})</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{vk}_{\\mathsf{R}}\\gets \\mathsf{Derive}(\\mathsf{srs},\\mathsf{R})</span></p>

    <p class="text-gray-300"><span class="math">b = \\mathsf{Verify}(\\mathsf{vk}_{\\mathsf{R}},\\mathsf{x},\\pi)\\wedge \\neg \\big(\\bigwedge_{j\\in [\\ell ]}\\mathsf{VerCom}(\\mathsf{ck},c_j,\\mathsf{u}_j,o_j)\\stackrel {?}{=}\\wedge \\mathsf{R}(\\mathsf{x},(\\mathsf{u}_j)_{j\\in [\\ell ]},\\omega)\\big)</span></p>

    <p class="text-gray-300">6 Our Compiler from PHPs to zkSNARKs with Universal SRS</p>

    <p class="text-gray-300">In this section we show how to compile PHPs into zkSNARKs. At a high level, we follow the known paradigm stemming from Kilian’s work <em>[46]</em> (and the extension to non-interactive arguments by Micali <em>[52]</em>) in which the prover commits to the oracles, answers the verifier’s queries generated using a random oracle and proves correctness of these answers.</p>

    <p class="text-gray-300">We first introduce some required building blocks in Section 6.1 and then describe our compiler in two steps: in Section 6.2 we convert a PHP into a public coin interactive argument system in the structured reference string model (SRS), and then remove interaction through the Fiat-Shamir transform. The proofs of the theorems in this section can be found in Appendix C.</p>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">6.1 Building Blocks</h3>

    <p class="text-gray-300">In our compiler we make use of the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a PHP protocol PHP over a finite field <span class="math">\\mathbb{F}</span>;</li>

      <li>a commitment scheme CS for polynomials in <span class="math">\\mathbb{F}[X]</span>;</li>

      <li>a CP-SNARK CP_{opn} proving knowledge of the committed polynomials;</li>

      <li>a CP-SNARK CP_{php} proving that the PHP verifier accepts, namely for the family of relations <span class="math">\\mathcal{R}_{\\text{php}}</span> defined in Section 3.1, which corresponds to the PHP verifier’s degree and polynomial checks.</li>

    </ul>

    <p class="text-gray-300">We now describe some of the properties we require from our commitment scheme for polynomials and from CP-SNARKs for them.</p>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">Commitments to Polynomials</h4>

    <p class="text-gray-300">Recall that a PHP verifier has access to two sets of oracle polynomials: those from the relation encoder (which roughly describe the relation) and those from the prover (which should supposedly persuade the verifier to accept a public input x). During compilation, we shall commit to polynomials in both sets; we will require all these commitments to be binding, but not to fully hide any of these polynomials.</p>

    <p class="text-gray-300">The commitments for the relation encoding polynomials—whose type we denote by rel—do not need to hide anything: they open to polynomials representing the relation, which is public information. The polynomial commitments of type rel have weaker requirements for one more reason. Besides not requiring them to be hiding, we will not require them to be extractable (i.e., we do not assume a CP-SNARK that has knowledge soundness for them, here is the reason to use the notion of knowledge soundness with partial opening).</p>

    <p class="text-gray-300">Above, we ignored leakage when committing to relation encoding polynomials; we cannot do the same when committing to the polynomials from the PHP prover: they contain information about the witness. If we do not prevent <em>some</em> leakage we will lose zero-knowledge. At the same time we will show that we do not need full hiding for these polynomials either, just a relaxed property that may hold even for a deterministic commitment algorithm. We call this property <em>somewhat-hiding</em>—defined below— and denote its type by swh.</p>

    <p class="text-gray-300">In the remainder of this section we will assume CS to be a polynomial commitment scheme; i.e., a commitment scheme (see Definition 11) in which the message space <span class="math">\\mathcal{M}</span> is <span class="math">\\mathbb{F}_{\\leq d}[X]</span> for a finite field <span class="math">\\mathbb{F}\\in\\mathcal{F}</span> and an integer <span class="math">d\\in\\mathbb{N}</span>. Without loss of generality we assume <span class="math">d</span> to be an input parameter of Setup.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Definition 19 (Somewhat-Hiding Polynomial Commitments)</h6>

    <p class="text-gray-300">Let <span class="math">\\texttt{CS}=\\texttt{(Setup, Commit, VerCom)}</span> be a type-based commitment scheme for a class of polynomials <span class="math">\\mathbb{F}_{\\leq d}[X]</span> and a class of types <span class="math">\\mathcal{T}</span>, and that works as in Definition 11, but where we allow Commit to be deterministic.</p>

    <p class="text-gray-300">We say that CS is somewhat-hiding for type type if it satisfies the following property.</p>

    <p class="text-gray-300">type-typed Somewhat Hiding. There exist three algorithms <span class="math">(\\mathsf{ck},\\mathsf{td}=(\\mathsf{td}^{\\prime},s))\\leftarrow\\mathcal{S}_{\\mathsf{ck}}(s)</span> where <span class="math">s\\in\\mathbb{F}</span>, <span class="math">(c,st)\\leftarrow\\mathsf{TdCom}(\\mathsf{td},\\gamma)</span> and <span class="math">o\\leftarrow\\mathsf{TdOpen}(\\mathsf{td},st,c,f)</span> such that: (1) the distribution of the commitment key returned by <span class="math">\\mathcal{S}_{\\mathsf{ck}}</span> with a uniformly random <span class="math">s\\leftarrow\\ast\\mathbb{F}</span> as input is identical to the one of the key returned by <span class="math">\\mathsf{Setup}</span>; (2) for any <span class="math">f\\in\\mathbb{F}_{&lt;d}[X]</span>, <span class="math">(c,o)\\approx(c^{\\prime},o^{\\prime})</span> where <span class="math">(c,o)\\leftarrow\\mathsf{Commit}(\\mathsf{ck},\\mathsf{type},f)</span>, <span class="math">(c^{\\prime},st)\\leftarrow\\mathsf{TdCom}(\\mathsf{td},f(s))</span> and <span class="math">o^{\\prime}\\leftarrow\\mathsf{TdOpen}(\\mathsf{td},st,c^{\\prime},f)</span>.</p>

    <p class="text-gray-300">For our first compiler (Section 6.2) we assume <span class="math">\\mathsf{CS}</span> to be a type-based commitment scheme with type set <span class="math">\\mathcal{T}=\\{\\mathsf{rel},\\mathsf{swh}\\}</span> that is binding for all types and <span class="math">\\mathsf{swh}</span>-typed somewhat-hiding. We summarize this requirement in the following definition.</p>

    <p class="text-gray-300"><strong>Definition 20 (Compiling Commitment Scheme).</strong> Let <span class="math">\\mathsf{CS} = (\\mathsf{Setup},\\mathsf{Commit},\\mathsf{VerCom})</span> be a type-based commitment scheme for a class of polynomials <span class="math">\\mathbb{F}_{&lt;d}[X]</span> and a class of types <span class="math">\\mathcal{T} = \\{\\mathsf{rel},\\mathsf{swh}\\}</span>. We say <span class="math">\\mathsf{CS}</span> is a compiling commitment scheme if it is <span class="math">\\mathcal{T}</span>-binding and <span class="math">\\mathsf{swh}</span>-somewhat-hiding.</p>

    <p class="text-gray-300"><strong>CP-SNARKs for CS.</strong> We assume that the commitment scheme CS is equipped with a CP-SNARK <span class="math">\\mathsf{CP}_{\\mathsf{php}} = (\\mathsf{KeyGen}_{\\mathsf{php}},\\mathsf{Prove}_{\\mathsf{php}},\\mathsf{Verify}_{\\mathsf{php}})</span> for a relation family <span class="math">\\mathcal{R}&#x27; \\supseteq \\mathcal{R}_{\\mathsf{php}}</span> (we defined <span class="math">\\mathcal{R}_{\\mathsf{php}}</span> in Section 3.1), and with a CP-SNARK <span class="math">\\mathsf{CP}_{\\mathsf{opn}} = (\\mathsf{KeyGen}_{\\mathsf{opn}},\\mathsf{Prove}_{\\mathsf{opn}},\\mathsf{Verify}_{\\mathsf{opn}})</span> for the (trivial) relation family <span class="math">\\mathcal{R}_{\\mathsf{opn}} = \\{\\psi, (p_j)_{j \\in [\\ell]} : \\ell \\in \\mathbb{N}\\}</span> whose instance is the empty string <span class="math">\\psi</span> and witnesses are tuples of polynomials. A CP-SNARK for <span class="math">\\mathcal{R}_{\\mathsf{opn}}</span> is essentially a proof of knowledge of the openings of <span class="math">\\ell</span> commitments.</p>

    <p class="text-gray-300">Additionally, we define a weaker zero-knowledge notion that is sufficient to be satisfied by the <span class="math">\\mathsf{CP}_{\\mathsf{php}}</span> CP-SNARK in our compiler. This new property allows better efficiency and flexibility of the compiled protocols.</p>

    <p class="text-gray-300"><strong>Leaky Zero-Knowledge.</strong> Intuitively, a CP-SNARK for relations over committed polynomials is leaky zero-knowledge if its proofs may leak information about a bounded number of evaluations of these polynomials. This is formalized by letting the zero-knowledge simulator have access to a list <span class="math">\\{\\mathsf{u}_i(y)\\}_i</span> as a hint for the simulation of proofs. The formal definition follows.</p>

    <p class="text-gray-300"><strong>Definition 21.</strong> A CP-SNARK CP is <span class="math">(\\mathsf{b},\\mathsf{C})</span>-leaky zero-knowledge for a family of relations <span class="math">\\{\\mathcal{R}_{\\mathsf{N}}\\}_{\\mathsf{N}\\in \\mathbb{N}}</span> if there exists a simulator <span class="math">\\mathcal{S} = (\\mathcal{S}_{\\mathrm{leak}},\\mathcal{S}_{\\mathrm{prv}})</span> such that for all adversaries <span class="math">\\mathcal{A}</span>, for all <span class="math">\\mathsf{N}\\in \\mathbb{N}</span>, for all <span class="math">\\mathsf{R}\\in \\mathcal{R}_{\\mathsf{N}}</span>, the following two properties hold.</p>

    <p class="text-gray-300"><strong>PROOF INDISTINGUISHABILITY.</strong> For all <span class="math">(\\mathsf{ck},\\mathsf{td})\\in \\mathcal{S}_{\\mathsf{ck}}(1^{\\lambda})</span>, for all <span class="math">\\hat{\\mathbf{x}},\\hat{\\mathbf{w}}</span> where <span class="math">\\hat{\\mathbf{x}} = (\\mathbf{x},(c_j)_{j\\in [\\ell]})</span> and <span class="math">\\hat{\\mathbf{w}} = ((\\mathbf{u}_j)_{j\\in [\\ell]},(o_j)_{j\\in [\\ell]},\\omega)</span> and such that <span class="math">\\mathsf{R}_{\\mathsf{ck},\\mathsf{N}}^{\\mathsf{Com}}(\\hat{\\mathbf{x}},\\hat{\\mathbf{w}}) = 1</span>, for any <span class="math">\\mathcal{L}\\gets \\mathcal{S}_{\\mathrm{leak}}(1^{\\lambda},\\mathbf{x})</span> let <span class="math">\\text{Leak}:= \\{(j,\\mathbf{u}_j(x))\\}_{(j,x)\\in \\mathcal{L}}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c} (\\mathsf{srs}, \\mathsf{td}_k) \\leftarrow \\mathsf{KeyGen}(\\mathsf{ck}, \\mathsf{N}) \\\\ \\pi \\leftarrow \\mathsf{Prove}(\\mathsf{Derive}(\\mathsf{srs}, \\mathsf{R}), \\hat{\\mathbf{x}}, \\hat{\\mathbf{w}}): \\mathcal{A}(\\mathsf{srs}, \\mathsf{td}_k, \\mathsf{td}, \\mathsf{R}, \\hat{\\mathbf{x}}, \\hat{\\mathbf{w}}, \\pi) = 1 \\end{array} \\right] = \\\\ \\Pr \\left[ \\begin{array}{l} (\\mathsf{srs}, \\mathsf{td}_k) \\leftarrow \\mathsf{KeyGen}(\\mathsf{ck}, \\mathsf{N}) \\\\ \\pi \\leftarrow \\mathcal{S}(\\mathsf{td}_k, \\mathsf{td}, \\mathsf{R}, \\hat{\\mathbf{x}}, \\mathsf{Leak}): \\mathcal{A}(\\mathsf{srs}, \\mathsf{td}_k, \\mathsf{td}, \\mathsf{R}, \\hat{\\mathbf{x}}, \\hat{\\mathbf{w}}, \\pi) = 1 \\end{array} \\right] \\end{array}</span></div>

    <p class="text-gray-300"><strong>BOUNDED LEAKAGE.</strong> For any <span class="math">\\mathbf{x}</span>, and any <span class="math">\\mathcal{L} \\leftarrow \\ast \\mathcal{S}_{\\mathrm{leak}}(1^{\\lambda}, \\mathbf{x})</span>, the list <span class="math">\\mathcal{L}</span> is <span class="math">(\\mathsf{b}, \\mathsf{C})</span>-bounded with overwhelming probability over the security parameter.</p>

    <h2 id="sec-53" class="text-2xl font-bold">6.2 Compiling to Universal Interactive Arguments</h2>

    <p class="text-gray-300">We describe our compiled universal succinct interactive argument (UIA) system in the SRS model in Figure 3. A high-level description of UIA follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At key-generation time we run the setup of the commitment scheme CS and generate keys for the auxiliary CP-SNARKs.</li>

      <li>When deriving a specialized SRS for a specific relation <span class="math">\\mathsf{R}</span> we commit to all the polynomials returned by the relation encoder <span class="math">\\mathcal{RE}(\\mathsf{R})</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover acts the same at every round except for the last. If we are not at the last round then it commits to the polynomials from the PHP prover <span class="math">\\mathcal{P}</span>, proves it knows their openings and propagates the rest of the messages from <span class="math">\\mathcal{P}</span>. At the last round it proves that the <span class="math">PHP</span> verifier <span class="math">\\mathcal{V}</span> would accept. In order to do that it first runs the decision stage of <span class="math">\\mathcal{V}</span>, thus obtaining a vector of degree checks <span class="math">(d_{j})_{j}</span> and descriptions of polynomial equations <span class="math">(G_{j},\\bm{v}_{j})_{j}</span>. It then partially evaluates the polynomials <span class="math">G_{j}</span>-s on the prover’s message and uses them—together with the other checks—to prove <span class="math">\\mathcal{V}</span> would accept.</li>

      <li>At every round that is not the last, the verifier simply propagates the messages from <span class="math">\\mathcal{V}</span>. At the last round, it obtains the checks from the decision stage of the PHP verifier. It then checks the prover’s final PHP proof as well as all the opening proofs received throughout the interaction.</li>

    </ul>

    <h6 id="sec-54" class="text-base font-medium mt-4">Theorem 5.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{PHP}=(\\mathsf{r},\\mathsf{n},\\mathsf{m},\\mathsf{d},\\mathsf{n}_{\\mathsf{e}},\\mathcal{R}\\mathcal{E},\\mathcal{P},\\mathcal{V})</span> be a non-adaptive public-coin PHP over a finite field family <span class="math">\\mathcal{F}</span> and for a universal relation <span class="math">\\mathcal{R}</span>. Let <span class="math">\\mathsf{CS}</span> be a compiling commitment scheme (Definition 20) equipped with CP-SNARKs <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> for <span class="math">\\mathcal{R}_{\\mathsf{opn}}</span> and <span class="math">\\mathsf{CP}_{\\mathsf{php}}</span> for <span class="math">\\mathcal{R}_{\\mathsf{php}}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The scheme <span class="math">\\Pi=(\\mathsf{KeyGen},\\mathsf{Derive},\\mathsf{Prove},\\mathsf{Verify})</span> defined in Figure 3 is a zkSNARK with specializable universal SRS for the family of relations <span class="math">\\mathcal{R}</span>.</li>

      <li>If <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> is TP-ZK, and, for a checker <span class="math">\\mathsf{C}</span>, <span class="math">\\mathsf{PHP}</span> (resp. <span class="math">\\mathsf{CP}_{\\mathsf{php}}</span>) is <span class="math">(\\mathsf{b}+\\mathsf{1},\\mathsf{C})</span>-bounded honest-verifier zero-knowledge (resp. <span class="math">(\\mathsf{b},\\mathsf{C})</span>-leaky zero-knowledge) then <span class="math">\\Pi</span> is zero-knowledge in the SRS model.</li>

    </ul>

    <h6 id="sec-55" class="text-base font-medium mt-4">Remark 7 (On the completness requirements).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It is sufficient for <span class="math">\\mathsf{CP}_{\\mathsf{php}}</span> to be <span class="math">T</span>-restricted complete, with $T=\\big{(}(\\mathsf{rel})^{\\mathsf{n}(0)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\mathsf{swh})^{\\mathsf{n}_{\\mathsf{p}}}\\big{)}\\in\\mathcal{T}^{\\mathsf{n}^{*}}<span class="math">, to obtain the completeness of </span>\\Pi$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-56" class="text-base font-medium mt-4">Remark 8 (On updatable SRS).</h6>

    <p class="text-gray-300">If the commitment key generated by <span class="math">\\mathsf{Setup}</span> is updatable <em>[40, 26]</em>, and <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> and <span class="math">\\mathsf{CP}_{\\mathsf{php}}</span> have commitment-only SRS (see Definition 16) then the SRS of <span class="math">\\Pi</span> is updatable.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Remark 9 (Efficiency of the resulting zkSNARK).</h6>

    <p class="text-gray-300">From the construction one can see that in <span class="math">\\Pi</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Derive}</span> outputs a specialized verification key that consists of <span class="math">\\mathsf{n}(0)</span> commitments;</li>

      <li>the prover sends: <span class="math">\\mathsf{m}^{*}</span> field elements, <span class="math">\\mathsf{n}_{\\mathsf{p}}</span> commitments, <span class="math">\\mathsf{r}</span> proofs of <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span>, and one proof of <span class="math">\\mathsf{CP}_{\\mathsf{php}}</span>;</li>

      <li>the verifier’s running time is that of the PHP verifier, plus the sum of running <span class="math">\\mathsf{Verify}_{\\mathsf{opn}}</span> and <span class="math">\\mathsf{Verify}_{\\mathsf{php}}</span> and <span class="math">\\mathsf{r}</span> cryptographic hash function evaluations.</li>

    </ul>

    <p class="text-gray-300">Combining the above observations with the succinctness of the commitment scheme <span class="math">\\mathsf{CS}</span> (Definition 12) and of the CP-SNARKs <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> and <span class="math">\\mathsf{CP}_{\\mathsf{php}}</span>, we obtain the succinctness of <span class="math">\\Pi</span>.</p>

    <h5 id="sec-58" class="text-base font-semibold mt-4">Intuition on Security Proof.</h5>

    <p class="text-gray-300">We refer the reader to Appendix C for a formal proof of Theorem 5; here we provide an intuition. By the knowledge-soundness property of PHPs we know we can extract a valid witness from the interaction with a PHP prover. Let’s call this extractor <span class="math">\\mathcal{E}_{\\mathsf{PHP}}</span> and let us assume the verifier accepts. The high-level idea is to simulate the interaction between <span class="math">\\mathcal{E}_{\\mathsf{PHP}}</span> and a PHP prover as follows: whenever <span class="math">\\mathcal{E}_{\\mathsf{PHP}}</span> queries a polynomial we run the extractor for <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> and respond with the corresponding polynomial (we are ignoring messages in this proof intuition). Call <span class="math">\\tilde{\\mathsf{w}}</span> the output of <span class="math">\\mathcal{E}_{\\mathsf{PHP}}</span> at the end of the interaction. If this is not a valid witness with high probability then we broke the assumption on knowledge-soundness of the PHP. To see why: consider the extractor for <span class="math">\\mathsf{CP}_{\\mathsf{php}}</span>, if we run it on <span class="math">\\mathfrak{\\pi}_{\\mathsf{php}}</span> then we can obtain polynomials that make the PHP verifier accept (if given oracle access to them). These polynomials must be identical to the ones we can extract through <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span>, otherwise we could break binding. If <span class="math">\\tilde{\\mathsf{w}}</span> were not a valid witness then we could construct a PHP prover that makes the verifier accept but without being able to extract a valid witness from it breaking knowledge-soundness of the PHP.</p>

    <p class="text-gray-300">We now provide an intuition about zero-knowledge; for simplicity we shall describe it as if the protocol involved a single committed polynomial. First, observe that we assume a PHP with <span class="math">b+1</span>-bounded ZK—i.e., we can simulate interaction with an honest prover even after we have leaked <span class="math">b+1</span> evaluations of the polynomial. Since we assume a commitment scheme that is only somewhat-hiding (Definition 19), we are actually leaking one evaluation of the committed polynomial (in particular on a random point). We now</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">KeyGen(1λ,N) → (ek, vk)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Derive(vk,R) → (ekR, vkR)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">// Let D be the max degree of PHP (Definition 1)</td>

            <td class="px-3 py-2 border-b border-gray-700">p0← RE(F,R)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ck← CS.Setup(1λ,D)</td>

            <td class="px-3 py-2 border-b border-gray-700">(c0, o0)←Commit(ck, rel, p0)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(ekopn, vkopn)← KeyGenopn(ck)</td>

            <td class="px-3 py-2 border-b border-gray-700">vkR := (vk, c0)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(ekphp, vkphp)← KeyGenphp(ck)</td>

            <td class="px-3 py-2 border-b border-gray-700">ekR := (ek, R, p0, o0)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  ek := (ck, ekphp, ekopn); vk := (vkphp, vkopn) |   |</p>

    <p class="text-gray-300">|  F(ekR, x, w, p1, ..., p_i) → πi  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let r := r(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  // Get polynomials and messages from PHP prover  |   |</p>

    <p class="text-gray-300">|  (pi, πi) ← P(F, R, x, w, p1, ..., p_i)  |   |</p>

    <p class="text-gray-300">|  (ci, oi) ← Commit(ck, swh, pi)  |   |</p>

    <p class="text-gray-300">|  πopn,i ← Proveopn(ekopn, ci, oi)  |   |</p>

    <p class="text-gray-300">|  πi := (ci, πi, πopn,i)  |   |</p>

    <p class="text-gray-300">|  else  |   |</p>

    <p class="text-gray-300">|  // Get checks from PHP verifier  |   |</p>

    <p class="text-gray-300">|  ((dj)j∈[np], (Gj, vj)j∈[ne]) ← Dv(F, x, p1, ..., p_r+1)  |   |</p>

    <p class="text-gray-300">|  xphp := ((dj)j∈[np], (Gj', vj)j∈[ne])  |   |</p>

    <p class="text-gray-300">|  where Gk' partially evaluates Gk, i.e., for k ∈ [ne]:  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Gk'(X, (Xj)j∈[n<em>]) := Gk(X, (Xj)j∈[n</em>], (π1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">πr))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">πphp ← Provephp(ekphp, xphp, (c0</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">...</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">cr), wphp)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  πr+1 := πphp  |   |</p>

    <p class="text-gray-300">|  V(srs, vk, x, π1, ..., πi) → p_i  |   |</p>

    <p class="text-gray-300">|  if i ≤ r then  |   |</p>

    <p class="text-gray-300">|  ρi ← V(F, x, π1, ..., πi-1)  |   |</p>

    <p class="text-gray-300">|  p_i := ρi  |   |</p>

    <p class="text-gray-300">|  else  |   |</p>

    <p class="text-gray-300">|  xphp := ((dj)j∈[np], (Gj', vj)j∈[ne])  |   |</p>

    <p class="text-gray-300">|  where Gk' partially evaluates Gk, i.e., for k ∈ [ne]:  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Gk'(X, (Xj)j∈[n<em>]) := Gk(X, (Xj)j∈[n</em>], (π1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">...</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">πr))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  b^i ← Verifyopn(vkopn, (ci,j)j∈n(i), πi) for i ∈ [r]  |   |</p>

    <p class="text-gray-300">|  Accept iff (∧i∈[r] b^i ∧ b)  |   |</p>

    <p class="text-gray-300">Above we use a shortcut notation for committing to whole vectors of polynomials in one go. That is, given a commitment type  <span class="math">t</span>  and a vector of polynomials  <span class="math">\\pmb{p}</span>  of size  <span class="math">m</span> , above we write  <span class="math">(\\pmb{c},\\pmb{o}) \\gets \\mathsf{Commit}(\\mathsf{ck},t,\\pmb{p})</span>  to mean that for each  <span class="math">j \\in [m]</span> <span class="math">(c_{j},o_{j}) \\gets \\mathsf{Commit}(\\mathsf{ck},t,p_{j})</span> ,  <span class="math">\\pmb{c} = (c_{1},\\dots,c_{m})</span>  and  <span class="math">\\pmb{o} = (o_{1},\\dots,o_{m})</span> .</p>

    <p class="text-gray-300">Fig. 3. Compiler from PHP to UIA.</p>

    <p class="text-gray-300">combine this fact with the ZK property we are assuming on the CP-SNARKs in the computer—<span class="math">b</span>-leaky ZK—and this allows us to still simulate an interaction with an honest prover that is indistinguishable after further <span class="math">b</span> leaked evaluations<span class="math">^{13}</span>.</p>

    <h2 id="sec-59" class="text-2xl font-bold">7 CP-SNARKs for Pairing-Based Polynomial Commitments</h2>

    <p class="text-gray-300">In this section we present constructions of (type-based) commitment schemes for polynomials that work in bilinear groups, and a collection of CP-SNARKs for various relations over such committed polynomials. The commitment of a polynomial <span class="math">p</span> is essentially the “evaluation in the exponent” of <span class="math">p</span> in a secret point <span class="math">s</span>, following the scheme of Groth <em>[38]</em> and Kate et al. <em>[45]</em>.</p>

    <p class="text-gray-300">We show various CP-SNARKs for various relations over polynomials committed using <span class="math">\\mathsf{CS}_{1}</span> or <span class="math">\\mathsf{CS}_{2}</span>; more details on the CP-SNARKs follow. Our CP-SNARKs work over both commitment schemes unless explicitly stated otherwise.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>“I know <span class="math">p:c</span> opens to <span class="math">p</span>”: two CP-SNARKs <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> for proof of knowledge of opening, secure respectively in the algebraic group model and under the mPKE assumption (Section 7.3);</li>

      <li>“<span class="math">p(x)=y</span>”: a CP-SNARK for polynomial evaluation, <span class="math">\\mathsf{CP}_{\\mathsf{eval},1}</span>, secure under the d-SDH assumption (Section 7.4). We then extend this CP-SNARK as <span class="math">\\mathsf{CP}_{\\mathsf{eval}}</span> to support batching—“<span class="math">\\big{(}p_{i}(x_{i})=y_{i}\\big{)}_{i\\in[t]}</span>”— in Section 7.5;</li>

      <li>a very general construction for a CP-SNARK for polynomial equations<span class="math">^{14}</span>, <span class="math">\\mathsf{CP}_{\\mathsf{eq}}</span>, relying mainly on <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> and <span class="math">\\mathsf{CP}_{\\mathsf{eval}}</span> (Section 7.6);</li>

      <li>a CP-SNARK, <span class="math">\\mathsf{CP}_{\\mathsf{neq}}</span>, for quadratic polynomial equations<span class="math">^{15}</span> specific to commitment scheme <span class="math">\\mathsf{CS}_{2}</span> (Section 7.7); although less general than <span class="math">\\mathsf{CP}_{\\mathsf{eq}}</span>, <span class="math">\\mathsf{CP}_{\\mathsf{neq}}</span> is more efficient since its proof may simply be empty, while verification consists of some pairing checks over the commitments.</li>

      <li>“<span class="math">\\mathsf{deg}(p)\\leq d</span>”: two CP-SNARKs for degree bounds, <span class="math">\\mathsf{CP}_{\\mathsf{deg}}^{(\\star)}</span> and <span class="math">\\mathsf{CP}_{\\mathsf{deg}}^{(2)}</span>, both secure if <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> and <span class="math">\\mathsf{CP}_{\\mathsf{eq}}</span> are secure; while <span class="math">\\mathsf{CP}_{\\mathsf{deg}}^{(\\star)}</span> works over both commitment schemes, <span class="math">\\mathsf{CP}_{\\mathsf{deg}}^{(2)}</span> works only over <span class="math">\\mathsf{CS}_{2}</span>;</li>

      <li>a CP-SNARK <span class="math">\\mathsf{CP}_{\\mathsf{link}}</span>, a key ingredient in our compiler to universal CP-SNARKs, to link polynomial commitments of different types; see “Additional building blocks” 8.1 for further motivation.</li>

    </ul>

    <h3 id="sec-60" class="text-xl font-semibold mt-8">7.1 Bilinear Groups and Assumptions</h3>

    <p class="text-gray-300">A bilinear group generator <span class="math">\\mathsf{GenG}(1^{\\lambda})</span> outputs <span class="math">\\mathsf{bgp}:=(q,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e)</span>, where <span class="math">\\mathbb{G}_{1}</span>, <span class="math">\\mathbb{G}_{2}</span>, <span class="math">\\mathbb{G}_{T}</span> are additive groups of prime order <span class="math">q</span>, and <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}</span> is an efficiently computable, non-degenerate, bilinear map. We focus Type-3 groups where it is assumed there is no efficiently computable isomorphism between <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>. We use the bracket notation of <em>[29]</em>, i.e., for <span class="math">g\\in\\{1,2,T\\}</span> and <span class="math">a\\in\\mathbb{Z}_{q}</span>, we write <span class="math">[a]_{g}</span> to denote <span class="math">a\\cdot P_{g}\\in\\mathbb{G}_{g}</span>, where <span class="math">P_{s}</span> is a fixed generator of <span class="math">\\mathbb{G}_{g}</span>. From an element <span class="math">[a]_{g}\\in\\mathbb{G}_{g}</span> and a scalar <span class="math">b</span> it is possible to efficiently compute <span class="math">[ab]\\in\\mathbb{G}_{g}</span>. Also, given elements <span class="math">[a]_{1}\\in\\mathbb{G}_{1}</span> and <span class="math">[b]_{2}\\in\\mathbb{G}_{2}</span>, one can efficiently compute <span class="math">[a\\cdot b]_{T}</span> by using the pairing <span class="math">e([a]_{1},[b]_{2})</span>, that we compactly denote with <span class="math">[a]_{1}\\cdot[b]_{2}</span>.</p>

    <p class="text-gray-300">In our constructions we make use of the following assumptions over a group generator <span class="math">\\mathsf{GenG}</span>.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Assumption 1 (<span class="math">d</span>-Power Discrete Logarithm <em>[50]</em>)</h6>

    <p class="text-gray-300">Given a degree bound <span class="math">d\\in\\mathbb{N}</span>, the <span class="math">d</span>-Power Discrete Logarithm (<span class="math">d</span>-DLOG) assumption holds for a bilinear group generator <span class="math">\\mathsf{GenG}</span> if for every efficient non-uniform adversary <span class="math">\\mathcal{A}</span> the following probability is negligible in <span class="math">\\lambda</span>:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[s^{\\prime}=s:\\begin{array}[]{c}\\mathsf{bgp}\\longleftrightarrow\\mathsf{GenG}(1^{\\lambda});\\ s\\longleftrightarrow\\mathbb{Z}_{q};\\\\ s^{\\prime}\\leftarrow\\mathcal{A}(\\mathsf{bgp},\\{[s^{j}]_{1},[s^{j}]_{2}\\}_{j\\in[0,d]})\\end{array}\\right]. \\]</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Assumption 2 (d-Strong Diffie-Hellman [16]) Given a degree bound  <span class="math">d \\in \\mathbb{N}</span> , the  <span class="math">d</span> -Strong Diffie-Hellman (d-SDH) assumption holds for a bilinear group generator GenG if for every efficient non-uniform adversary  <span class="math">\\mathcal{A}</span>  the following probability is negligible in  <span class="math">\\lambda</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ C = [ (s + c) ^ {- 1} ] _ {1}: \\begin{array}{c} \\mathsf {b g p} \\leftrightarrows \\mathsf {G e n G} (1 ^ {\\lambda}); s \\leftrightarrows \\mathbb {Z} _ {q}; \\\\ (c, C) \\leftarrow \\mathcal {A} (\\mathsf {b g p}, \\{[ s ^ {j} ] _ {1}, [ s ^ {j} ] _ {2} \\} _ {j \\in [ 0, d ]}) \\end{array} \\right].</span></div>

    <p class="text-gray-300">We consider a slight variant of the Power Knowledge of the Exponent (PKE) Assumption of Groth [38]. This variant, also used in [24], considers an adversary (resp. an extractor) that outputs a vector of group elements (resp. of tuples of field elements), and is implied by the PKE assumption.</p>

    <p class="text-gray-300">Assumption 3 (mPKE) The (multi-instance) Power Knowledge of Exponent (mPKE) assumption holds for a bilinear group generator GenG if for every efficient non-uniform adversary  <span class="math">\\mathcal{A}</span>  and a degree bound  <span class="math">d\\in \\mathbb{N}</span>  there exists an efficient extractor  <span class="math">\\mathcal{E}</span>  such that for any benign distribution  <span class="math">\\mathcal{Z}</span>  the following probability is negligible in  <span class="math">\\lambda</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c c} &amp;amp; \\mathsf {b g p} \\leftrightarrows \\mathsf {G e n G} (1 ^ {\\lambda}); \\\\ \\exists j: \\begin{array}{c} d _ {j} = \\gamma \\cdot c _ {j} \\wedge \\\\ c _ {j} \\neq \\sum_ {k} a _ {k} ^ {(j)} s ^ {j} \\end{array} : \\begin{array}{c} \\mathsf {a u x} _ {Z} \\leftarrow \\mathcal {Z} (\\mathsf {b g p}); \\\\ s, \\gamma \\leftrightarrows \\mathbb {Z} _ {q}; \\\\ \\Sigma = \\left([ s ^ {j} ] _ {1}, [ s ^ {j} ] _ {2}, [ \\gamma s ^ {j} ] _ {1}, [ \\gamma ] _ {2}\\right) _ {j \\in [ 0, d ]}; \\\\ (c _ {j}) _ {j \\in [ \\ell^ {\\prime} ]}, (d _ {j}) _ {j \\in [ \\ell^ {\\prime} ]} \\leftarrow \\mathcal {A} (\\mathsf {b g p}, \\Sigma , \\mathsf {a u x} _ {Z}); \\\\ (\\boldsymbol {a} ^ {(j)}) _ {j \\in [ \\ell^ {\\prime} ]} \\leftarrow \\mathcal {E} (\\mathsf {b g p}, \\Sigma , \\mathsf {a u x} _ {Z}) \\end{array} \\right].</span></div>

    <h2 id="sec-62" class="text-2xl font-bold">7.2 The Commitment Schemes</h2>

    <p class="text-gray-300">We show two type-based commitment schemes,  <span class="math">\\mathsf{CS}_1</span>  and  <span class="math">\\mathsf{CS}_2</span> , with type set  <span class="math">\\{\\mathsf{rel}, \\mathsf{swh}\\}</span>  and for degree- <span class="math">d</span>  polynomials. We begin with an informal explanation of them.</p>

    <p class="text-gray-300">In both schemes,  <span class="math">\\mathsf{ck}</span>  contains encodings of powers of a secret point  <span class="math">s</span> , a commitment of type  <span class="math">\\mathsf{swh}</span>  to a polynomial  <span class="math">p(X)</span>  is a group element  <span class="math">[p(s)]_1</span> . The only difference between the two schemes being the commitments of type  <span class="math">\\mathsf{rel}</span> , which in  <span class="math">\\mathsf{CS}_1</span>  are  <span class="math">[p(s)]_1</span>  whereas in  <span class="math">\\mathsf{CS}_2</span>  are  <span class="math">[p(s)]_2</span> . As we shall see in Section 7.7, the advantage of having some polynomials committed in  <span class="math">\\mathbb{G}_2</span>  is that one immediately gets a way to test quadratic equations over polynomials where each quadratic term involves exactly one polynomial of type  <span class="math">\\mathsf{rel}</span> . Both types of commitments are computationally binding under the power-discrete logarithm assumption [50]; we prove commitments of type  <span class="math">\\mathsf{swh}</span>  to also be somewhat hiding.</p>

    <p class="text-gray-300">Below we describe the commitment schemes in more detail. To keep the presentation compact, we describe them as a single scheme  <span class="math">\\mathsf{CS}_g</span>  parametrized by the following function, for  <span class="math">g\\in \\{1,2\\}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\mu_ {g} (\\text {type}) = \\left\\{ \\begin{array}{l l} g \\text { if type = rel} \\\\ 1 \\text { if type = swh} \\end{array} \\right.</span></div>

    <p class="text-gray-300">The function essentially dictates in which group is a type-rel commitment.</p>

    <p class="text-gray-300">The algorithms (Setup, Commit, VerCom) of  <span class="math">\\mathsf{CS}_g</span>  are defined as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{CS}_g.\\mathsf{Setup}(1^\\lambda, d)</span> : run  <span class="math">\\mathsf{bgp} \\leftrightarrows \\mathsf{GenG}(1^\\lambda)</span>  to generate the bilinear groups description, set the message space to be  <span class="math">\\mathbb{F}_{\\leq d}[X]</span>  where  <span class="math">\\mathbb{F} := \\mathbb{Z}_q</span> . Next, sample  <span class="math">s \\leftrightarrows \\mathbb{Z}_q</span>  uniformly at random, compute and output:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {c k} = \\left\\{ \\begin{array}{l l} \\big (([ s ^ {j} ] _ {1}) _ {j \\in [ 0, d ]}, [ s ] _ {2} \\big) &amp;amp; \\text { if } g = 1, \\\\ \\big ([ s ^ {j} ] _ {1}, [ s ^ {j} ] _ {2}) _ {j \\in [ 0, d ]} &amp;amp; \\text { if } g = 2. \\end{array} \\right.</span></div>

    <p class="text-gray-300"><span class="math">\\mathsf{CS}_g.\\mathsf{Commit}(\\mathsf{ck},\\mathsf{type},p)\\to (c,o)</span> : Let  <span class="math">\\hat{g}\\gets \\mu_g(\\mathsf{type})</span> , and output the commitment  <span class="math">c\\coloneqq [p(s)]_{\\hat{g}}</span>  (the opening  <span class="math">o</span>  is empty).</p>

    <p class="text-gray-300">16 For this reason, all the CP-SNARKs given for this commitment scheme will omit  <span class="math">o</span>  from the prover's inputs.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{CS}_{g}.\\mathsf{VerCom}(\\mathsf{ck},\\mathsf{type},c,p,o)</span>: set <span class="math">\\hat{g}\\leftarrow\\mu_{g}(\\mathsf{type})</span>, and check if <span class="math">c\\stackrel{{\\scriptstyle?}}{{=}}p([s]_{\\hat{g}})</span>.</p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Remark 10.</h6>

    <p class="text-gray-300">We note that in <span class="math">\\mathsf{CS}_{1}</span>, the elements <span class="math">[1,s]_{2}</span> are not needed to commit and verify openings, but they are useful to verify the correctness of <span class="math">\\mathsf{ck}</span> (which is useful when generating <span class="math">\\mathsf{ck}</span> in an updatable way).</p>

    <p class="text-gray-300">In the following theorem we state the security of the scheme.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Theorem 6.</h6>

    <p class="text-gray-300"><span class="math">\\mathsf{CS}_{g}</span> is binding under the <span class="math">d</span>-DLOG assumption for <span class="math">\\mathsf{GenG}</span>, and perfectly somewhat-hiding.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Binding is essentially the same as in <em>[38]</em>. Assume the adversary produces two polynomials <span class="math">p</span> and <span class="math">p^{\\prime}</span> that evaluate to the same value on the point <span class="math">s</span>. Then by finding the <span class="math">0</span>’s of the polynomial <span class="math">p(X)-p^{\\prime}(X)</span> we can find <span class="math">s</span> and break the <span class="math">d</span>-DLOG assumption.</p>

    <p class="text-gray-300">For somewhat-hiding, we notice that the polynomial commitment scheme does not need any trapdoor opening information, thus the <span class="math">\\mathsf{TdCom}</span> algorithm we define next sets <span class="math">st</span> to be the empty string and there is no need for the <span class="math">\\mathsf{TdOpen}</span> algorithm. We define algorithms <span class="math">\\mathcal{S}_{\\mathsf{ck}}</span> and <span class="math">\\mathsf{TdCom}</span> and show that the distributions produced by the algorithms are indistinguishable from the distributions produced by <span class="math">\\mathsf{Setup}</span> and <span class="math">\\mathsf{Commit}</span>:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{S}_{\\mathsf{ck}}(s)\\rightarrow(\\mathsf{ck},\\mathsf{td})</span>: use <span class="math">s</span> to compute <span class="math">\\mathsf{ck}</span> as in <span class="math">\\mathsf{Setup}</span> and output <span class="math">\\mathsf{ck}</span> and <span class="math">\\mathsf{td}=s</span>. <span class="math">\\mathsf{TdCom}(\\mathsf{ck},\\mathsf{type},p(s))\\rightarrow(c,st)</span>: let <span class="math">\\mu_{g}(\\mathsf{type})=g</span> and output <span class="math">[p(s)]_{g}</span>.</p>

    <p class="text-gray-300">Clearly for an uniformly random <span class="math">s</span> the distributions of the outputs of <span class="math">\\mathcal{S}_{\\mathsf{ck}}</span> and <span class="math">\\mathsf{Setup}</span> are identical.</p>

    <h3 id="sec-66" class="text-xl font-semibold mt-8">7.3 CP-SNARKs for <span class="math">\\mathcal{R}_{\\mathsf{opn}}</span></h3>

    <p class="text-gray-300">Here we present two CP-SNARKs for the commitment schemes <span class="math">\\mathsf{CS}_{1},\\mathsf{CS}_{2}</span> and the relation <span class="math">\\mathcal{R}_{\\mathsf{opn}}</span> (which essentially provides a proof of knowledge of the committed polynomials). For our results, we are interested in proving this relation only over commitments of type <span class="math">\\mathsf{swh}</span>.</p>

    <h4 id="sec-67" class="text-lg font-semibold mt-6">A CP-SNARK in the algebraic group model.</h4>

    <p class="text-gray-300">The first CP-SNARK, <span class="math">\\mathsf{CP}_{\\mathsf{opn}}^{\\mathsf{AGM}}</span>, is actually a trivial scheme in which the proof is the empty string. Its knowledge-soundness, can be shown in the algebraic group model <em>[31]</em> where any adversary that returns a commitment is assumed to know coefficients which explain it as a linear combination of the public parameters, the <span class="math">\\mathsf{ck}</span>. This is an observation already done in previous work, e.g., <em>[33, 24]</em>), and thus we omit the details of the analysis.</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Theorem 7.</h6>

    <p class="text-gray-300"><span class="math">\\mathsf{CP}_{\\mathsf{opn}}^{\\mathsf{AGM}}</span> is a CP-SNARK for <span class="math">\\mathcal{R}_{\\mathsf{opn}}</span> over <span class="math">\\mathsf{CS}_{1}</span> (resp. <span class="math">\\mathsf{CS}_{2}</span>) that is <span class="math">\\mathsf{swh}^{\\ell}</span>-restricted complete, perfectly zero-knowledge and knowledge-sound in the algebraic group model.</p>

    <h4 id="sec-69" class="text-lg font-semibold mt-6">A CP-SNARK under the mPKE assumption.</h4>

    <p class="text-gray-300">The second CP-SNARK, <span class="math">\\mathsf{CP}_{\\mathsf{opn}}^{\\mathsf{PKE}}</span>, is novel and provides extractability based on the mPKE assumption and, when used on more than one commitment, on the random oracle heuristic. In a nutshell, this scheme uses the classical technique of giving as a proof a group element <span class="math">\\mathfrak{\\pi}_{\\mathsf{opn}}</span> such that <span class="math">\\mathfrak{\\pi}_{\\mathsf{opn}}=\\gamma\\cdot c</span> for some secret <span class="math">\\gamma\\in\\mathbb{F}</span>, and this <span class="math">\\mathfrak{\\pi}_{\\mathsf{opn}}</span> can be honestly computed by using the same linear combination used to compute <span class="math">c</span>. What is new in our scheme is a way to batch this proof for <span class="math">\\ell</span> commitments in such a way that we have only one extra group element as a proof, instead of <span class="math">\\ell</span> elements.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{CP}_{\\mathsf{opn}}^{\\mathsf{PKE}}.\\mathsf{KeyGen}(\\mathsf{ck})</span>: parse <span class="math">\\mathsf{ck}</span> as <span class="math">(\\mathsf{ck}_{1},\\mathsf{ck}_{2})</span> with <span class="math">\\mathsf{ck}_{1}\\in\\mathbb{G}_{1}^{d+1}</span>, sample <span class="math">\\gamma\\longleftrightarrow\\mathbb{F}</span>, define <span class="math">\\mathsf{ek}:=(\\mathsf{ck},\\gamma\\cdot\\mathsf{ck}_{1})</span> and <span class="math">\\mathsf{vk}:=[1,\\gamma]_{2}</span>, and return <span class="math">\\mathsf{srs}:=(\\mathsf{ek},\\mathsf{vk})</span>. <span class="math">\\mathsf{CP}_{\\mathsf{opn}}^{\\mathsf{PKE}}.\\mathsf{Prove}(\\mathsf{ek},(c_{j})_{j\\in[\\ell]},(p_{j})_{j\\in[\\ell]})</span>: for <span class="math">j\\in[\\ell]</span> compute <span class="math">\\mathfrak{\\pi}_{j}\\leftarrow[\\gamma\\cdot p_{j}(s)]_{1}</span>, next compute <span class="math">(\\rho_{1},\\ldots,\\rho_{\\ell})\\leftarrow\\mathcal{H}((c_{j})_{j\\in[\\ell]})</span> and output <span class="math">\\mathfrak{\\pi}_{\\mathsf{opn}}:=\\sum_{j}\\rho_{j}\\mathfrak{\\pi}_{j}</span>. <span class="math">\\mathsf{CP}_{\\mathsf{opn}}^{\\mathsf{PKE}}.\\mathsf{Verify}(\\mathsf{vk},(c_{j})_{j\\in[\\ell]},\\mathfrak{\\pi}_{\\mathsf{opn}})</span>: compute <span class="math">(\\rho_{1},\\ldots,\\rho_{\\ell})\\leftarrow\\mathcal{H}((c_{j})_{j\\in[\\ell]})</span> and <span class="math">c:=\\sum_{j}\\rho_{j}c_{j}</span>. Output <span class="math">1</span> if and only if <span class="math">e(c,[\\gamma]_{2})=e(\\mathfrak{\\pi}_{\\mathsf{opn}},[1]_{2})</span>.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">Remark 11 (On Updatable SRS generation).</p>

    <p class="text-gray-300">Note that the SRS of this CP-SNARK can be generated by having access to the commitment key (without need of knowing its trapdoor), and it is easy to see how it can be generated in an updatable fashion, and the correctness of every element can be efficiently checked using a pairing. Generating the SRS of <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> after the commitment key ck would however require an additional sequence of rounds in the SRS ceremony. Although this can be still useful when re-using an existing commitment key, it is annoying if the goal is to generate ck and the <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> SRS together. In the latter case, however, it is easy to see that they can be generated together with a single sequence of rounds in the ceremony, i.e., such that at every round the <span class="math">i</span>-th participant outputs its version of <span class="math">(\\mathsf{ck},\\gamma\\cdot\\mathsf{ck}_{1})</span>.</p>

    <p class="text-gray-300">Efficiency. Key generation requires <span class="math">d + 1</span> exponentiations in <span class="math">\\mathbb{G}_1</span> to generate <span class="math">\\gamma \\cdot \\mathsf{ck}_1</span>, and one in <span class="math">\\mathbb{G}_2</span> to compute <span class="math">[\\gamma]_2</span>. The prover can be implemented so as to require <span class="math">d^<em></span> <span class="math">\\mathbb{G}_1</span>-exponentiations and <span class="math">O(\\ell \\cdot d^</em>)</span> <span class="math">\\mathbb{F}</span>-operations, where <span class="math">d^<em>\\max_{j\\in [\\ell ]}\\{\\deg (p_j)\\}</span>. This is done by computing <span class="math">p^{</em>}(X)\\gets \\sum_{j}\\rho_{j}p_{j}(X)</span> and then <span class="math">\\pi_{\\mathrm{opn}}\\gets [\\gamma \\cdot p^{*}(s)]_{1}</span>. Verification requires: 2 pairings, <span class="math">\\ell</span> <span class="math">\\mathbb{G}_1</span>-exponentiations, and one hash computation.</p>

    <p class="text-gray-300">Security. In the following theorem we state the security of <span class="math">\\mathsf{CP}_{\\mathsf{opn}}^{\\mathsf{PKE}}</span>.</p>

    <p class="text-gray-300">Theorem 8. <span class="math">\\mathsf{CP}_{\\mathsf{opn}}^{\\mathsf{PKE}}</span> is a CP-SNARK for <span class="math">\\mathcal{R}_{\\mathrm{opn}}</span> over <span class="math">\\mathsf{CS}_1</span> (resp. <span class="math">\\mathsf{CS}_2</span>) that is <span class="math">\\mathsf{swh}^{\\ell}</span>-restricted complete, perfectly zero-knowledge and knowledge-sound under the mPKE assumption in the random oracle model.</p>

    <p class="text-gray-300">Proof. Completeness is obvious. Zero-knowledge is also rather easy to see: a simulator that knows <span class="math">\\gamma</span> can perfectly simulate proofs without knowing the witness. Before proving knowledge soundness we recall an useful form of the Chernoff-Hoeffding bound [27].</p>

    <p class="text-gray-300">Lemma 7. Let <span class="math">X \\coloneqq \\sum_{j \\in [n]} X_i</span> where <span class="math">X_1, \\ldots, X_n</span> are independently distributed in <span class="math">[0,1]</span>. Then for all <span class="math">t &amp;gt; 0</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr [ X &amp;lt;   E [ X ] - t ] \\leq 2 ^ {- 2 t ^ {2} / n}</span></div>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be an (non-uniform PT) adversary and <span class="math">\\mathcal{Z}</span> be an auxiliary input distribution such that for any <span class="math">\\mathcal{E}</span> the probability that <span class="math">\\mathcal{A}</span> outputs a statement <span class="math">(c_{j})_{j\\in [\\ell ]}</span> and a valid proof <span class="math">\\pi</span> is <span class="math">\\epsilon</span> in the game GameKND <span class="math">\\mathcal{RG},\\mathcal{Z},\\mathcal{A},\\mathcal{E}</span> (where <span class="math">\\mathcal{RG}</span> is the dummy algorithm that outputs <span class="math">\\mathcal{R}_{\\mathrm{opn}}</span>). Moreover, let <span class="math">W</span> be the event that the adversary outputs a valid statement-proof tuple. (Obviously, <span class="math">\\operatorname*{Pr}[W] = \\epsilon</span>.)</p>

    <p class="text-gray-300">Consider the following adversary <span class="math">\\mathcal{B}</span> and auxiliary distribution <span class="math">\\mathcal{Z}&#x27;</span> against the mPKE assumption. The distribution <span class="math">\\mathcal{Z}&#x27;(\\Sigma)</span> computes the structured reference string <span class="math">\\mathbf{srs}</span> of <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> from <span class="math">\\Sigma</span>, runs <span class="math">\\mathsf{aux}_Z \\gets \\mathcal{Z}(\\mathcal{R}_{\\mathsf{opn}}, \\mathbf{srs})</span> and outputs <span class="math">\\mathbf{srs}, \\mathbf{aux}_Z</span>.</p>

    <p class="text-gray-300">Adversary <span class="math">\\mathcal{B}_{i,h}(\\Sigma, (\\mathsf{srs}, \\mathsf{aux}_Z); \\rho)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">K = 2\\ell \\epsilon^{-1}q(1 + \\lambda)</span>, parse <span class="math">\\rho = (h_k^{(j)})_{i &amp;lt; k\\leq q,j\\in [K]}</span> where <span class="math">h_k^{(j)}\\in \\mathbb{Z}_q^\\ell</span> and <span class="math">q</span> is the maximum amount of random oracle queries made by an execution of <span class="math">\\mathcal{A}</span>.</li>

      <li>Compute ck from <span class="math">\\Sigma</span>, run <span class="math">\\mathcal{A}(\\mathcal{R}_{\\mathrm{opn}},\\mathsf{ck},\\mathsf{srs},\\mathsf{aux}_Z)</span> and answer the first <span class="math">i - 1</span> queries of <span class="math">\\mathcal{A}</span> to the random oracle with the values <span class="math">\\pmb {h} = h_{1},\\dots ,h_{i - 1}</span>. Let <span class="math">st</span> the state of <span class="math">\\mathcal{A}</span> just before the <span class="math">i</span>-th queried is sent.</li>

      <li>For <span class="math">j = 1\\dots K</span> run the following:</li>

    </ol>

    <p class="text-gray-300">(a) Run <span class="math">\\mathcal{A}</span> feeding it with the value <span class="math">h_k^{(j)}</span> at the <span class="math">k</span>-th query.</p>

    <p class="text-gray-300">Let <span class="math">\\hat{\\mathbf{x}}_j, \\pi_j</span> be the output of <span class="math">\\mathcal{A}</span> and let <span class="math">b_j \\gets \\text{Verify}(\\mathbf{srs}, \\hat{\\mathbf{x}}_j, \\pi_j)</span>.</p>

    <p class="text-gray-300">(b) Rewind <span class="math">\\mathcal{A}</span> to the state <span class="math">st</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Assert <span class="math">\\sum_{j} b_{j} \\geq \\ell</span>, let <span class="math">H</span> be a subset of cardinality <span class="math">\\ell</span> of the indexes <span class="math">j</span> such that <span class="math">b_{j} = 1</span>, we define the square matrix <span class="math">M</span> which columns are the vectors <span class="math">h_i^{(j)} \\in \\mathbb{Z}_q^\\ell</span> and <span class="math">j \\in H</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Assert that <span class="math">M</span> is full rank.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Assert that for all <span class="math">j, j&#x27;</span> we have <span class="math">\\hat{\\mathbf{x}}_j = \\hat{\\mathbf{x}}_{j&#x27;}</span>. If so parse them as <span class="math">(c_j)_{j \\in [\\ell]}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">(d_j)_{j\\in [\\ell ]} = (\\pi_j)_{j\\in H}M^{-1}</span> and output <span class="math">(c_{j})_{j\\in [\\ell ]},(d_{j})_{j\\in [\\ell ]}</span>.</li>

    </ol>

    <p class="text-gray-300">The adversary <span class="math">\\mathcal{B}</span> is parameterized by an index <span class="math">i</span> and values <span class="math">h_1, \\ldots, h_{1-1}</span> where <span class="math">h_j \\in \\mathbb{Z}_q^\\ell</span>.</p>

    <p class="text-gray-300">First we notice that if the adversary <span class="math">\\mathcal{B}</span> does not abort then it outputs values <span class="math">(c_j)_{j\\in [\\ell]}</span> and <span class="math">(d_j)_{j\\in [\\ell]}</span> such that for all <span class="math">j\\in \\ell : \\gamma \\cdot c_j = d_j</span>. Indeed the verification in step 3a, for any <span class="math">j</span>, we set <span class="math">b_j</span> to 1 if and only if <span class="math">\\gamma \\cdot \\sum_k h_{j,k} c_k = \\pi_j</span> where we parse <span class="math">h_i^{(j)} = x_{j,1}, \\ldots, \\rho_{j,\\ell}</span>, thus <span class="math">(\\pi_j)_{j\\in H} = (c_j)_{j\\in [\\ell]} \\cdot M</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We analyze the probability that <span class="math">\\mathcal{B}</span> does not abort. Let <span class="math">Q_{j}</span> be the event that the adversary <span class="math">\\mathcal{A}</span> queries the random oracle with <span class="math">(c_{j})_{j\\in [\\ell]}</span> (the output instance) at the <span class="math">j</span>-th random oracle query. Let <span class="math">i</span> be the index that maximizes the probability <span class="math">\\operatorname<em>{Pr}[W\\wedge Q_i]</span>. It is easy to see that <span class="math">\\operatorname</em>{Pr}[W\\wedge Q_i]\\geq \\frac{\\epsilon}{q}</span>. Let <span class="math">\\pmb{h}</span> be the assignment of the first <span class="math">i - 1</span> queries that maximize the probability <span class="math">\\operatorname<em>{Pr}[W\\wedge Q_i]</span>, by average argument, we notice that there must exist <span class="math">\\pmb{h}</span> such that, conditioned on the assignment $\\operatorname</em>{Pr}[W\\wedge Q_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb{h}]\\geq \\frac{\\epsilon}{q}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given an assignment <span class="math">\\mathsf{aux}_Z</span>, we call it good if $\\operatorname*{Pr}[W\\wedge Q_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pmb{h},\\mathsf{aux}_Z]\\geq \\frac{\\epsilon}{2q}<span class="math">. By a simple average argument we have that with probability </span>\\frac{1}{2}<span class="math"> an output </span>\\mathsf{aux}_Z<span class="math"> of </span>\\mathcal{Z}<span class="math"> is good. Also we notice that if we fix </span>\\pmb{h}<span class="math"> and </span>\\mathsf{aux}_Z<span class="math"> then the random variables </span>b_{1},\\ldots ,b_{K}<span class="math"> are independent and if </span>\\mathsf{aux}_Z<span class="math"> is good then each of them has average greater or equal to </span>\\frac{\\epsilon}{2q}$, thus by the Chernoff-Hoeffding bound we have that:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\sum_ {j} b _ {j} \\geq \\ell \\mid \\boldsymbol {h}, \\operatorname {a u x} _ {Z} \\right] \\geq 1 - \\operatorname {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">Thus the assertion in step 4 passes with overwhelming probability. We notice that the assertion in step 5 passes with overwhelming probability as the rows of <span class="math">M</span> are random vectors in <span class="math">\\mathbb{Z}_q^\\ell</span>, also the assertion in step 6 passes always cause fixing <span class="math">\\pmb{h}</span> and <span class="math">\\mathsf{aux}_Z</span> the <span class="math">i</span>-th query of the adversary <span class="math">\\mathcal{A}</span> is deterministic function of srs. Putting all together the probability that <span class="math">\\mathcal{B}</span> does not abort is greater than <span class="math">\\frac{1}{2} - \\mathrm{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">We are ready to define the extractor for the knowledge soundness experiment. Roughly speaking the extractor calls the extractor of <span class="math">\\mathcal{B}</span>, however the reduction <span class="math">\\mathcal{B}</span> is a probabilistic polynomial time algorithm. Thanks to the non-uniformity we can fix the randomness of <span class="math">\\mathcal{B}</span> to a string <span class="math">\\rho</span> that maximizes the probability of <span class="math">\\mathcal{B}</span> outputting valid tuples. Thus let <span class="math">\\mathcal{B}&#x27;</span> such non-uniform PT that runs <span class="math">\\mathcal{B}</span> with randomness set to <span class="math">\\rho</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{E}</span> be the extractor of <span class="math">\\mathcal{B}&#x27;</span>, assumed to exist thanks to the mKEA assumption. The extractor outputs vectors <span class="math">\\pmb{a}^{(j)}</span> for any <span class="math">j \\in [\\ell]</span>. We let the extractor for <span class="math">\\mathcal{A}</span> simply run <span class="math">\\mathcal{E}</span> and output what it does. By the mPKE assumption, we have <span class="math">c_{j} = \\sum_{k} a_{k}^{(j)} s^{k}</span> (as otherwise <span class="math">\\mathcal{B}</span> would break the mPKE assumption).</p>

    <p class="text-gray-300">Remark 12. (Efficiently composing <span class="math">\\mathsf{CP}_{\\mathrm{opn}}</span> with other SNARKs) All of the CP-SNARKs in this section apply <span class="math">\\mathsf{CP}_{\\mathrm{opn}}</span> to obtain extractability of the committed polynomials. More precisely, this is true only for polynomials of type swh; we assume the adversary always opens commitments of type rel. The proofs of the CP-SNARKs we present in this section are all of the form <span class="math">(\\pi_{\\mathrm{opn}}, \\pi)</span> where the first part, <span class="math">\\pi_{\\mathrm{opn}}</span>, is a proof of knowledge of a valid opening for the commitments in input. A straightforward composition of these CP-SNARKs would incur in redundantly proving the knowledge of the openings of the same commitments; therefore, we do not use black-box composition: given a CP-SNARK <span class="math">\\mathsf{CP} = (\\mathsf{KeyGen}, \\mathsf{Prove}, \\mathsf{Verify})</span> we define the algorithms <span class="math">\\overline{\\mathsf{Prove}}</span> and <span class="math">\\overline{\\mathsf{Verify}}</span> respectively working just as <span class="math">\\mathsf{Prove}</span> and <span class="math">\\mathsf{Verify}</span>, except that they do not compute/verify the proof <span class="math">\\pi_{\\mathrm{opn}}</span>.</p>

    <h2 id="sec-70" class="text-2xl font-bold">7.4 CP-SNARK for evaluation of a single polynomial</h2>

    <p class="text-gray-300">We define a CP-SNARK <span class="math">\\mathsf{CP}_{\\mathrm{eval},1}</span> for the relation <span class="math">\\mathsf{R}_{\\mathrm{eval},1}((a,b),p)\\coloneqq p(a)\\stackrel {?}{=}b</span>, where <span class="math">p</span> is committed as <span class="math">[p(s)]_1</span>. Hence <span class="math">\\mathsf{CP}_{\\mathrm{eval},1}</span> is complete for <span class="math">\\mathsf{CS}_1</span>, and <span class="math">\\mathsf{swb}</span>-restricted complete for <span class="math">\\mathsf{CS}_2</span>. This scheme is essentially the evaluation proof technique of [45] with an additional proof of knowledge.</p>

    <p class="text-gray-300">KeyGeneval1(ck): execute <span class="math">(\\mathsf{ek}_{\\mathrm{opn}},\\mathsf{vk}_{\\mathrm{opn}})\\gets \\mathsf{KeyGen}_{\\mathrm{opn}}(\\mathsf{ck})</span>, parse ck as <span class="math">([s^j ]_1,[s^j ]_2)_{j\\in [0,d]}</span> define <span class="math">\\mathsf{ek} := (\\mathsf{ck},\\mathsf{ek}_{\\mathrm{opn}})</span> and <span class="math">\\mathsf{vk} := ([1,s]_2,\\mathsf{vk}_{\\mathrm{opn}})</span>, and return <span class="math">\\mathsf{srs} := (\\mathsf{ek},\\mathsf{vk})</span>.</p>

    <p class="text-gray-300">Proveeval1(ek, (a, b), c, p): Compute a proof <span class="math">\\pi_{\\mathrm{opn}} \\gets \\mathsf{Prove}_{\\mathrm{opn}}(\\mathsf{ek}_{\\mathrm{opn}}, c, p)</span>, the polynomial <span class="math">w(X)</span> such that <span class="math">w(X) \\cdot (X - a) \\equiv p(X) - b</span> set <span class="math">\\pi \\gets [w(s)]_1</span>, and output <span class="math">(\\pi_{\\mathrm{opn}}, \\pi)</span>.</p>

    <p class="text-gray-300">49</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Verify}_{\\mathsf{eval1}}(\\mathsf{vk},(a,b),c,\\pi)</span>: Parse <span class="math">\\pi = (\\pi_{\\mathrm{opn}},[w]_1)</span>, and output 1 iff:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Verify}_{\\mathsf{opn}}(\\mathsf{vk}_{\\mathsf{opn}},c,\\pi_{\\mathsf{opn}}) = 1</span> and</li>

      <li><span class="math">e([w]_1,[s - a]_2) = e(c - [b]_1,[1]_2)</span>.</li>

    </ol>

    <p class="text-gray-300">Efficiency. We give efficiency ignoring the costs of <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span>. Generating a proof requires <span class="math">\\deg(p) \\mathbb{G}_1</span>-exponentiations to compute <span class="math">\\pi</span> and <span class="math">O(\\deg(p))</span> <span class="math">\\mathbb{F}</span>-operations to compute the polynomial <span class="math">w(X)</span>. Verification requires: 2 pairings.</p>

    <p class="text-gray-300">Security. In the following theorem we state the security of <span class="math">\\mathsf{CP}_{\\mathsf{eval},1}</span>.</p>

    <p class="text-gray-300">Theorem 9. If <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> is a <span class="math">\\mathsf{swh}</span>-restricted CP-SNARK for <span class="math">\\mathcal{R}_{\\mathsf{opn}}</span> and the <span class="math">d</span>-SDH assumption holds for <span class="math">\\mathsf{GenG}</span>, then <span class="math">\\mathsf{CP}_{\\mathsf{eval},1}</span> is a complete (resp. <span class="math">\\mathsf{swh}</span>-restricted complete), knowledge sound, and trapdoor-commitment zero-knowledge CP-SNARK for <span class="math">\\mathsf{R}_{\\mathsf{eval},1}</span> for <span class="math">\\mathsf{CS}_1</span> (resp. <span class="math">\\mathsf{CS}_2</span>). Moreover, if <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> has commitment-only SRS then <span class="math">\\mathsf{CP}_{\\mathsf{eval},1}</span> has commitment-only SRS.</p>

    <p class="text-gray-300">Proof. The proof of completeness and knowledge soundness follow from previous works [45, 24] and is therefore omitted. To see trapdoor-commitment zero-knowledge, notice that with the trapdoor <span class="math">s \\in \\mathbb{Z}_q</span> we can compute <span class="math">[w]_1 := (c - [b]_1) / (s - a)</span>, moreover, we can simulate <span class="math">\\pi_{\\mathrm{opn}}</span> using the simulator of <span class="math">\\mathsf{CP}_{\\mathrm{opn}}</span>.</p>

    <h2 id="sec-71" class="text-2xl font-bold">7.5 CP-SNARK for batch evaluation of many polynomials</h2>

    <p class="text-gray-300">We define a CP-SNARK <span class="math">\\mathsf{CP}_{\\mathsf{eval}}</span> for the commitment schemes <span class="math">\\mathsf{CS}_1</span>, <span class="math">\\mathsf{CS}_2</span> and the relation <span class="math">\\mathsf{R}_{\\mathsf{eval}}</span> which is the Cartesian product of <span class="math">\\ell \\in \\mathbb{N}</span> instances of <span class="math">\\mathsf{R}_{\\mathsf{eval},1}</span>. The <span class="math">\\mathsf{CP}_{\\mathsf{eval}}</span> we propose is complete for <span class="math">\\mathsf{CS}_1</span> and <span class="math">\\mathsf{swh}^{\\ell}</span>-restricted complete for <span class="math">\\mathsf{CS}_2</span>. This scheme is essentially a CP-SNARK version of the batched polynomial commitment evaluation technique in [33, 24].</p>

    <p class="text-gray-300">The intuition for the construction is as follows. To prove that two polynomials <span class="math">p</span> and <span class="math">p&#x27;</span> committed to <span class="math">c</span> and <span class="math">c&#x27;</span> evaluate to <span class="math">b</span> and <span class="math">b&#x27;</span> on the point <span class="math">a</span>, by linearity of the polynomials and classical batch argument we can simply show that a random linear combination <span class="math">p^<em> = \\rho p + \\rho&#x27; p&#x27;</span> of <span class="math">p</span> and <span class="math">p&#x27;</span> evaluate to <span class="math">\\rho b + \\rho&#x27; b&#x27;</span>. Notice that by the homomorphic property of the commitment scheme we can compute <span class="math">c^</em> = \\rho c + \\rho&#x27; c&#x27;</span> which is a valid commitment of <span class="math">p^<em></span>. Generalizing, of the <span class="math">\\ell</span> points <span class="math">a_1, \\ldots, a_\\ell</span> on which we want to evaluate the proofs, we gather the <span class="math">\\ell^</em></span> distinct ones. For each of these we compute an evaluation proof by batching the polynomials together.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{KeyGen}_{\\mathsf{eval}}(\\mathsf{ck})</span>: this proceeds identically as the key generation of <span class="math">\\mathsf{CP}_{\\mathsf{eval},1}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Prove}_{\\mathsf{eval}}(\\mathsf{ek},(a_j,b_j)_{j\\in [\\ell]},(c_j)_{j\\in [\\ell]},(p_j)_{j\\in [\\ell]})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">W \\coloneqq \\{j \\in [\\ell] : \\text{type}(c_j) = \\text{swh}\\}</span> be the set of indices of type-<span class="math">\\mathsf{swh}</span> commitments. Compute <span class="math">\\pi_{\\mathrm{opn}} \\gets \\mathsf{Prove}_{\\mathrm{opn}}(\\mathsf{ek}_{\\mathrm{opn}},(c_j)_{j \\in W},(p_j)_{j \\in W})</span>;</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. For <span class="math">j \\in [\\ell]</span> set $\\rho_j \\gets \\mathcal{H}(\\hat{\\mathbf{x}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j)<span class="math"> and let </span>\\{a_1^<em>, \\ldots, a_{\\ell^</em>}^<em>\\} = \\{a_j\\}_{j \\in [\\ell]}<span class="math"> (repeated values are not counted), let </span>P_1, \\ldots, P_{\\ell^</em>}<span class="math"> be a partition of the set </span>[\\ell]<span class="math"> such that </span>P_k = \\{j : a_j = a_k^*\\}$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">k \\in [\\ell^<em>]</span> compute <span class="math">c_k^</em> \\gets \\sum_{j \\in P_k} \\rho_j \\cdot c_j</span>, <span class="math">p_k^<em> = \\sum_{j \\in P_k} \\rho_j \\cdot p_j</span>, and <span class="math">b_k^</em> = p_k^<em>(a_k^</em>)</span>; Compute <span class="math">\\pi_k \\gets \\overline{\\text{Prove}_{\\text{eval1}}}(\\text{ek}, (a_k^<em>, b_k^</em>), c_k^<em>, p_k^</em>)</span>.</li>

      <li>Return <span class="math">\\pi = (\\pi_{\\mathrm{opn}}, (\\pi_j)_{j \\in [\\ell^*]})</span>.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{Verify}_{\\mathsf{eval}}(\\mathsf{vk},(a_j,b_j)_{j\\in [\\ell]},(c_j)_{j\\in [\\ell]},\\pi)</span>: Compute <span class="math">W</span> as described in the step 1 of the prover, and compute <span class="math">(\\rho_j)_{j\\in [\\ell]},(a_j^<em>)_{j\\in [\\ell^</em>]},(c_j^<em>)_{j\\in [\\ell^</em>}]</span> and <span class="math">(P_j)_{j\\in [\\ell^<em>}]</span> as described in steps 2 and 3 of the prover. Parse <span class="math">\\pi = (\\pi_{\\mathrm{opn}}, (\\pi_j)_{j\\in [\\ell^</em>}]</span> and return 1 iff:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Verify}_{\\mathsf{opn}}(\\mathsf{srs},(c_j)_{j\\in W},\\pi_{\\mathsf{opn}}) = 1</span> and,</li>

      <li>for all <span class="math">k \\in [\\ell^<em>]</span> we have <span class="math">\\overline{\\mathsf{Verify}_{\\mathsf{eval1}}}(\\mathsf{vk},(a_k^</em>,b_k^<em>),c_k^</em>,\\pi_k) = 1</span>.</li>

    </ol>

    <p class="text-gray-300">Efficiency. We give efficiency ignoring the costs of <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span>. Generating a proof requires <span class="math">\\deg(p_k^<em>) \\mathbb{G}_1</span>-exponentiations and <span class="math">O(\\deg(p_k^</em>)) \\mathbb{F}</span>-operations to compute each <span class="math">\\pi_k</span>. Verification requires <span class="math">2\\ell^*</span> pairings, which can be reduced to a total of 2 using standard batching techniques.</p>

    <p class="text-gray-300">Security. In the following theorem we state the security of <span class="math">\\mathsf{CP}_{\\mathsf{eval}}</span>.</p>

    <p class="text-gray-300">Theorem 10. If <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> is a <span class="math">\\mathsf{swh}^{\\ell}</span>-restricted CP-SNARK for <span class="math">\\mathcal{R}_{\\mathsf{opn}}</span> and the <span class="math">d</span>-SDH assumption holds for <span class="math">\\mathsf{GenG}</span>, then <span class="math">\\mathsf{CP}_{\\mathsf{eval}}</span> is a CP-SNARK for <span class="math">\\mathsf{CS}_1</span> (resp. <span class="math">\\mathsf{CS}_2</span>) that is: complete (resp. <span class="math">\\mathsf{swh}^{\\ell}</span>-restricted complete), knowledge-sound (with partial opening of type-re1 commitments) in the random oracle model, and trapdoor-commitment zero-knowledge in the SRS model. Moreover, if <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> has commitment-only SRS then <span class="math">\\mathsf{CP}_{\\mathsf{eval}}</span> has commitment-only SRS.</p>

    <p class="text-gray-300">Proof (Proof sketch). The proof of this theorem is an extension of the one of Theorem 9; we only provide a sketch. The main difference is in the knowledge soundness. First, notice that by Theorem 9 we have that each of the <span class="math">\\ell^{*}</span> polynomial evaluations is correct. The correctness of all the <span class="math">\\ell</span> evaluations then follows from a classical batching argument using the randomizers <span class="math">\\rho_{1},\\ldots ,\\rho_{\\ell}</span>.</p>

    <h2 id="sec-72" class="text-2xl font-bold">7.6 CP-SNARK for Polynomial Equations</h2>

    <p class="text-gray-300">We describe a CP-SNARK for polynomial equations that relies on the one for batched polynomial evaluations given in the previous section. This CP-SNARK is based on the optimizations proposed by [33].</p>

    <p class="text-gray-300">Although the formal general treatment of our scheme has several technical details, its intuition is simple. At the high-level, we verify each polynomial equation by sampling a random point, exploiting the Schwartz-Zippel Lemma and reducing the problem to proving polynomial evaluation. For example, we pick random point <span class="math">u</span> and then reduce proving <span class="math">a(X)b(X)c(X) + d(X) = 0</span> to <span class="math">a(u)b(u)c(u) + d(u) = 0</span>. Then, for each monomial of degree <span class="math">d</span> at least 2 in the polynomial equation, we recursively prove evaluation for a monomial of degree <span class="math">d - 1</span>. For example, assume monomial <span class="math">a(u)b(u)c(u)</span> above equals value <span class="math">y</span>, then we could reduce to <span class="math">y_{a}b(u)c(u) = y</span> by providing <span class="math">y_{a}</span> and relative proof to the verifier. We could then do this again for <span class="math">b</span> by providing a proof that <span class="math">b(u) = y_{b}</span>, <span class="math">y_{b}</span> and then reducing to <span class="math">y_{a}y_{b}c(u) = y</span>. At this point we obtained a linear equation and we can use the approach of <span class="math">\\mathsf{Prove}_{\\mathsf{eval}}</span>. In the example above we first started from <span class="math">a</span> and then moved to <span class="math">b</span> leaving <span class="math">c</span> last, but clearly there are different recursion strategies. Some of them will be more efficient than others. Below, we abstracted away this aspect through minimal set <span class="math">S</span> defined as in the pseudocode.</p>

    <p class="text-gray-300">We define a class of CP-SNARKs for subsets of the relation <span class="math">\\mathsf{R}_{\\mathrm{eq}}</span> (see Section 3.1). In particular, let <span class="math">\\mathsf{C}</span> be a checker, we implicitly parameterize the CP-SNARK with the checker <span class="math">\\mathsf{C}</span>. Consider the following relation:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {R} _ {\\mathsf {e q}, \\mathsf {C}} = \\left\\{(G ^ {(j)}, \\boldsymbol {v} ^ {(j)}) _ {j \\in [ k ]}, (p _ {j}) _ {j \\in [ \\ell ]}: \\begin{array}{c} \\forall i \\in [ \\ell ], x \\in \\mathbb {Z} _ {q}: \\mathsf {C} (i, v _ {i} (x)) = 1 \\wedge \\\\ \\mathsf {R} _ {\\mathsf {e q}} ((G, \\boldsymbol {v}), (p _ {j}) _ {j \\in [ \\ell ]}) = 1 \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">We define a <span class="math">(\\mathbf{1},\\mathsf{C})</span>-leaky zero-knowledge CP-SNARK <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span> for the commitment scheme CS and the relation <span class="math">\\mathsf{R}_{\\mathrm{eq},\\mathsf{C}}</span>. Let <span class="math">\\mathcal{H}</span> be a random oracle from <span class="math">\\{0,1\\}^*</span> to <span class="math">\\mathbb{Z}_q</span>.</p>

    <p class="text-gray-300">KeyGen_eq(ck): execute <span class="math">(\\mathsf{ek}_{\\mathsf{opn}},\\mathsf{vk}_{\\mathsf{opn}})\\gets \\mathsf{KeyGen}_{\\mathsf{opn}}(\\mathsf{ck})</span> and <span class="math">(\\mathsf{ek}_{\\mathsf{eval}},\\mathsf{vk}_{\\mathsf{eval}})\\gets \\mathsf{KeyGen}_{\\mathsf{eval}}(\\mathsf{ck})</span> define <span class="math">\\mathsf{ek} := (\\mathsf{ek}_{\\mathsf{opn}},\\mathsf{ek}_{\\mathsf{eval}})</span> and <span class="math">\\mathsf{vk} := (\\mathsf{vk}_{\\mathsf{opn}},\\mathsf{vk}_{\\mathsf{eval}})</span>, and return <span class="math">\\mathsf{srs} := (\\mathsf{ek},\\mathsf{vk})</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Prove}_{\\mathsf{eq}}(\\mathsf{ek},(G,\\pmb {v}),(c_j)_{j\\in [\\ell ]},(p_j)_{j\\in [\\ell ]})</span>: Execute the following steps.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">W \\coloneqq \\{j \\in [\\ell] : \\text{type}(c_j) = \\text{swh}\\}</span> be the set of indices of type-swh commitments. Compute <span class="math">\\pi_{\\mathrm{opn}} \\gets \\text{Prove}_{\\mathrm{opn}}(\\mathsf{ek}_{\\mathrm{opn}}, (c_j)_{j \\in W}, (p_j)_{j \\in W})</span>;</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Let <span class="math">\\hat{\\mathbf{x}} := ((G^{(j)}, \\pmb{v}^{(j)})_{j \\in [k]}, (c_j)_{j \\in [\\ell]})</span> and set $\\rho \\gets \\mathcal{H}(\\hat{\\mathbf{x}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\mathrm{opn}})<span class="math">. For any </span>l \\in [k]<span class="math"> if </span>\\deg_X(G^{(l)}(X, v_1^{(l)}(X), \\ldots, v_l^{(l)}(X))) &gt; 0<span class="math">, and, for </span>j \\in [\\ell]<span class="math">, let </span>a_j^{(l)} \\gets v_j^{(l)}(\\rho)<span class="math">, </span>b_j^{(l)} = p_j(a_j^{(l)})<span class="math">; otherwise, let </span>a_j^{(l)} \\gets v_j^{(l)}(0)<span class="math"> and </span>b_j^{(l)} = p_j(a_j^{(l)})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any <span class="math">l \\in [k]</span> let <span class="math">\\{a_{1,l}^<em>, \\ldots, a_{\\ell^</em>, l}^<em>\\} = \\{a_j^{(l)}\\}_{j \\in [\\ell]}</span> (repeated values are not counted), let <span class="math">P_1^{(l)}, \\ldots, P_{\\ell^</em>}^{(l)}</span> be a partition of the set <span class="math">[\\ell]</span> such that <span class="math">P_t^{(l)} = \\{j : a_j^{(l)} = a_{i,l}^*\\}</span>;</li>

      <li>Let <span class="math">S</span> be the minimal subset of <span class="math">[\\ell]</span> such that (1) exists an index <span class="math">i^<em></span> such that <span class="math">\\bar{S} = [\\ell] \\setminus S \\subseteq P_{i^</em>}</span>, (2) the polynomial <span class="math">G(x, X_1, \\ldots, X_\\ell)</span> has degree zero or one in the variables <span class="math">\\{X_j\\}_{j \\in S}</span>.</li>

      <li>Let <span class="math">\\sum_{j\\in \\bar{S}}l_jX_j + l_0</span> be equivalent to the polynomial <span class="math">G</span> with the variables <span class="math">(X_{j})_{j\\in S}</span> assigned to the values <span class="math">(b_{j})_{j\\in S}</span> and the variable <span class="math">X</span> assigned to the value <span class="math">\\rho</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">a^<em> = a_{i^</em>}^<em></span>, <span class="math">b^</em> = -l_0</span>, <span class="math">c^<em> = \\sum_{j \\in \\bar{S}} l_j \\cdot c_j</span>, <span class="math">p^</em> = \\sum_{j \\in \\bar{S}} l_j \\cdot p_j</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\hat{\\mathbf{x}}&#x27; = ((a_j, b_j, c_j)_{j \\in S}, (a^<em>, b^</em>, c^*)))</span>, namely <span class="math">\\hat{\\mathbf{x}}&#x27;</span> is a vector of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1<span class="math"> instances of </span>\\mathsf{R}_{\\mathrm{eval}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Compute <span class="math">\\pi_{\\mathrm{eval}} \\gets \\widehat{\\mathsf{Prove}}_{\\mathrm{eval}}(\\mathsf{ek}_{\\mathrm{eval}}, \\hat{\\mathbf{x}}&#x27;, ((p_j)_{j \\in S}, p^*, p_\\ell))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">(\\pi_{\\mathrm{opn}}, \\{b_j\\}_{j \\in S}, \\pi_{\\mathrm{eval}})</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Verify</strong>_{\\mathbf{eq}}(\\mathsf{vk}, \\hat{\\mathbf{x}}, \\pi)<span class="math">: Parse </span>\\pi = (\\pi_{\\mathrm{opn}}, \\{b_j\\}_{j \\in S}, \\pi_{\\mathrm{eval}})<span class="math">. Execute the steps 2, 3, 4 and 5 of the prover (but do not compute the values </span>(b_j)_{j \\in [\\ell]}<span class="math">, our rather take </span>(b_j)_{j \\in [S]}<span class="math"> from the proof). Also compute </span>W<span class="math"> as in step 1. Compute the commitment </span>c^<em><span class="math"> as in step 6 of the prover, set </span>a^</em> = a_i^<em><span class="math"> and </span>b^</em> = -l_0<span class="math">. We observe that </span>l_0<span class="math"> can be computed efficiently since it depends only on the linear terms of </span>G<span class="math"> involving the values </span>\\{b_j\\}_{j \\in S}<span class="math"> and the constant term of </span>G(\\rho, \\ldots)$.</p>

    <p class="text-gray-300">Return 1 iff:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Verify}_{\\mathsf{opn}}(\\mathsf{vk}_{\\mathsf{opn}},(c_j)_{j\\in [W]},\\pi_{\\mathsf{opn}}) = 1,</span></li>

      <li>Set <span class="math">\\hat{\\mathbf{x}}&#x27;</span> as in step 6 of the prover, <span class="math">\\widehat{\\mathsf{Verify}_{\\mathsf{eval}}}(\\mathsf{vk}_{\\mathsf{eval}}, \\hat{\\mathbf{x}}&#x27;, \\pi_{\\mathsf{eval}}) = 1</span> and,</li>

      <li><span class="math">\\forall j \\in [\\ell] : \\mathsf{C}(j, v_j(a_j)) = 1</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Efficiency.</strong> We give efficiency ignoring the costs of <span class="math">\\mathsf{CP}_{\\mathrm{opn}}</span>. Generating a proof requires generating a batched evaluation proof for $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1<span class="math"> committed polynomials (see previous section). Verification requires </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> </span>\\mathbb{F}<span class="math">-operations for the partial evaluation of </span>G<span class="math"> and to recover the </span>l_j$ coefficients, plus the cost of one batched evaluation verification (2 pairings).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Security.</strong> In the following theorem we state the security of <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span>.</p>

    <p class="text-gray-300"><strong>Theorem 11.</strong> Let <span class="math">\\mathsf{CP}_{\\mathrm{opn}}</span> and <span class="math">\\mathsf{CP}_{\\mathrm{eval}}</span> be CP-SNARKs over commitment scheme CS for relations <span class="math">\\mathcal{R}_{\\mathrm{opn}}</span> and <span class="math">\\mathsf{R}_{\\mathrm{eval}}</span> respectively. Then <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span> is a CP-SNARK over CS that is knowledge-sound (with partial opening of type-rel commitments), and <span class="math">\\mathsf{swh}</span>-typed <span class="math">(\\mathbf{1}, \\mathbf{C})</span>-leaky zero-knowledge. Moreover, if <span class="math">\\mathsf{CP}_{\\mathrm{opn}}</span> and <span class="math">\\mathsf{CP}_{\\mathrm{eval}}</span> have commitment-only SRSs then <span class="math">\\mathsf{CP}_{\\mathrm{eval}}</span> has a commitment-only SRS.</p>

    <p class="text-gray-300">Before proving the theorem we make the following observation.</p>

    <p class="text-gray-300"><strong>Remark 13 (On more fine-grained leakage).</strong> With a closer look, we observe that this scheme is actually <span class="math">(\\mathsf{b}, \\mathsf{C})</span>-leaky zero-knowledge, for a <span class="math">\\mathsf{b}</span> such that <span class="math">\\mathsf{b}_i = 1</span> if <span class="math">i \\in S</span> and <span class="math">\\mathsf{b}_i = 0</span> otherwise. This is because evaluations of polynomials are revealed only if the index <span class="math">j</span> is included in <span class="math">S</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Knowledge Soundness follows by the extractability of <span class="math">\\mathsf{CP}_{\\mathrm{opn}}</span>, the Schwartz-Zippel Lemma and the knowledge soundness of <span class="math">\\mathsf{CP}_{\\mathrm{eval}}</span>. In particular, it is enough to extract only from type-swh commitments as we only have to prove knowledge soundness with partial openings of type-rel commitments.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">More in detail, for any benign relation sampler <span class="math">\\mathcal{R}\\mathcal{G}_{\\mathrm{Com}}</span> and auxiliary input sampler <span class="math">\\mathcal{Z}</span> consider the adversary <span class="math">\\mathcal{A}</span> that outputs an instance <span class="math">\\hat{\\mathbf{x}} = (G, (v_j)_{j \\in [\\ell]}, (c_j)_{j \\in [\\ell]})</span> and a proof <span class="math">\\pi</span>, along with polynomials <span class="math">p_j</span> such that <span class="math">\\text{type}(c_j) = \\text{rel}</span>. By the knowledge soundness of <span class="math">\\mathsf{CP}_{\\mathrm{opn}}</span> we can extract polynomials <span class="math">(p_j)_{j \\in [\\ell]}</span>. Moreover, since $\\rho = \\mathcal{H}(\\hat{\\mathbf{x}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\mathrm{opn}})<span class="math"> the value </span>\\rho<span class="math"> is independent from the polynomials </span>G<span class="math">, </span>\\mathbf{v}<span class="math"> and </span>(p_j)_{j \\in [\\ell]}<span class="math"> and uniformly random over </span>\\mathbb{Z}_q<span class="math">. Thus applying the Schwartz-Zippel lemma, if the polynomial </span>G'(X) := G(X, (p_j(v_j(X)))_{j \\in [\\ell]})<span class="math"> evaluates to 0 on </span>\\rho<span class="math"> then </span>G'(X) \\equiv 0<span class="math">. We conclude noticing that, by the knowledge soundness of </span>\\mathsf{CP}_{\\mathrm{eval}}<span class="math"> it holds that </span>\\forall j \\in S : p_j(a_j) = b_j<span class="math"> and </span>\\sum_{j \\in \\bar{S}} l_j p_j(a^<em>) = b^</em><span class="math"> thus </span>G'(\\rho) = 0$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We show that <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span> is <span class="math">(\\mathbf{1}, \\mathbf{C})</span>-leaky zero-knowledge. Let <span class="math">\\hat{\\mathbf{x}}</span> a valid instance of <span class="math">\\mathsf{R}_{\\mathrm{eq}, \\mathbf{C}}^{\\mathrm{Com}}</span>. Consider the simulator <span class="math">\\mathcal{S}_{\\mathrm{leak}}(\\hat{\\mathbf{x}})</span> that computes $a_j \\gets v_j(\\mathcal{H}(\\hat{\\mathbf{x}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\mathrm{opn}}))<span class="math"> for </span>j \\in [\\ell]<span class="math"> and outputs the list </span>\\mathcal{L} = \\{(j, a_j)\\}_{j \\in [\\ell]}<span class="math">. By definition of </span>\\hat{\\mathbf{x}}<span class="math"> and by inspection of </span>\\mathcal{L}<span class="math">, the list </span>\\mathcal{L}<span class="math"> is </span>(\\mathbf{1}, \\mathbf{C})<span class="math">-bounded. The simulator </span>\\mathcal{S}_{\\mathrm{prv}}(\\mathsf{td}_k, \\hat{\\mathbf{x}}, \\text{leak})<span class="math"> simulates the proof </span>\\pi_{\\mathrm{opn}}<span class="math">, then parses </span>\\text{leak}<span class="math"> as </span>(b_j)_{j \\in [\\ell]}<span class="math"> where </span>b_j = p_j(a_j)<span class="math">, letting </span>\\mathcal{S}_{\\mathrm{prv}}'<span class="math"> be simulator of </span>\\mathsf{CP}_{\\mathrm{eval}}<span class="math"> and </span>\\hat{\\mathbf{x}}' = ((a_j, b_j, c_j)_{j \\in S}, (a^<em>, b^</em>, c^*))<span class="math">, computes </span>\\pi' \\gets \\mathcal{S}_{\\mathrm{prv}}'(\\mathsf{td}_k, \\hat{\\mathbf{x}}')<span class="math"> and outputs </span>(\\pi_{\\mathrm{opn}}, \\{b_j\\}_{j \\in S}, \\pi_{\\mathrm{poly}})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The indistinguishability easily follows by the zero-knowledge of the proofs of <span class="math">\\mathsf{CP}_{\\mathrm{eval}}</span> and of <span class="math">\\mathsf{CP}_{\\mathrm{opn}}</span>.</p>

    <p class="text-gray-300">52</p>

    <p class="text-gray-300">7.7 CP-SNARK for <span class="math">\\mathsf{CS}_2</span> for quadratic polynomial equations</p>

    <p class="text-gray-300">Let us consider the following relation in which <span class="math">G</span> is an <span class="math">\\ell</span>-variate polynomial of degree 2:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{R}_{\\mathrm{geq}}(G, (p_j)_{j \\in [\\ell]}) := G(p_1(X), \\dots, p_\\ell(X)) \\stackrel{?}{=} 0</span></div>

    <p class="text-gray-300"><span class="math">\\mathsf{R}_{\\mathrm{geq}}</span> is a simplification of <span class="math">\\mathsf{R}_{\\mathrm{eq}}</span> in which the degree of <span class="math">G</span> is restricted to 2, each <span class="math">v_j(X) = X</span>, and we removed the first variable <span class="math">X</span>.</p>

    <p class="text-gray-300">Here we show a simple CP-SNARK for the commitment scheme <span class="math">\\mathsf{CS}_2</span> and the above relation <span class="math">\\mathsf{R}_{\\mathrm{geq}}</span>. This scheme is novel and to the best of our knowledge it did not appear in previous work. The techniques are inspired by the linear interactive proof compiler of [15].</p>

    <p class="text-gray-300">The basic intuition is rather simple, when <span class="math">G</span> satisfies the restriction above it is possible to homomorphically compute <span class="math">G</span> over <span class="math">(p_1(s), \\ldots, p_\\ell(s))</span> in the target group using pairings and the linear property of the commitments. Like for the previous scheme, our approach is based on Schwartz-Zippel. Only, this time we exploit the random point <span class="math">s</span> hidden in the SRS of the commitment scheme for polynomial evaluation. Thus all the verifier needs to do is verify a pairing product for each of the monomials of the type <span class="math">a(X)b(X)</span>. For this to be possible, it needs to have each of the two polynomials <span class="math">a</span> and <span class="math">b</span> in two distinct groups. This is the case if they are committed through different types, i.e., one as type rel and the other as type swh. Otherwise, if they are both committed in the same group, we let the prover send one of the two polynomials committed in the "symmetric" group. Like in <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span> we abstract the most efficient approach to do this through a minimal set, in this case set <span class="math">\\mathcal{J}</span> as defined in the pseudocode.</p>

    <p class="text-gray-300"><strong>KeyGen<t><</strong> execute <span class="math">(\\mathsf{ek}_{\\mathsf{opn}}, \\mathsf{vk}_{\\mathsf{opn}}) \\gets \\mathsf{KeyGen}_{\\mathsf{opn}}(\\mathsf{ck})</span> and return <span class="math">\\mathsf{srs} := (\\mathsf{ek}_{\\mathsf{opn}}, \\mathsf{vk}_{\\mathsf{opn}})</span>.</p>

    <p class="text-gray-300"><strong>Prove<t><</strong> <span class="math">(\\mathsf{ek}, G, (c_j)_{j \\in [\\ell]}, (p_j)_{j \\in [\\ell]})</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>first, let <span class="math">W := \\{j \\in [\\ell] : \\mathsf{type}(c_j) = \\mathsf{swh}\\}</span> be the set of indices of type-swh commitments, and compute <span class="math">\\pi_{\\mathsf{opn}} \\gets \\mathsf{Prove}_{\\mathsf{opn}}(\\mathsf{ek}_{\\mathsf{opn}}, (c_j)_{j \\in W}, (p_j)_{j \\in W})</span>. Then proceed as follows:</li>

      <li>Consider the undirected graph where <span class="math">V = [\\ell]</span> and there is an edge <span class="math">\\{i, j\\}</span> if <span class="math">\\mathsf{type}(c_i) = \\mathsf{type}(c_j)</span> and the term <span class="math">(X_i \\cdot X_j)</span> is non-zero in <span class="math">G</span>.</li>

      <li>Let <span class="math">\\mathcal{J}</span> be the min-cut of such graph, namely the minimal set of nodes that cover all the edges of <span class="math">G</span>.</li>

      <li>For any <span class="math">j \\in \\mathcal{J}</span>:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">\\mathsf{type}(c_j) = \\mathsf{swh}</span>, compute <span class="math">c_j&#x27; = [p_j(s)]_2</span>;</li>

      <li>if <span class="math">\\mathsf{type}(c_j) = \\mathsf{rel}</span>, compute <span class="math">c_j&#x27; = [p_j(s)]_1</span>;</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathcal{C}&#x27; = \\{c_j&#x27;\\}_{j \\in \\mathcal{J}}</span> and output <span class="math">\\pi := (\\pi_{\\mathsf{opn}}, \\mathcal{C}&#x27;)</span>.</li>

    </ul>

    <p class="text-gray-300">Output <span class="math">\\pi := (\\pi_{\\mathsf{opn}}, \\mathcal{C}&#x27;)</span>.</p>

    <p class="text-gray-300"><strong>Verify<t><</strong> <span class="math">\\mathsf{reg}(\\mathsf{vk}, \\bar{\\mathsf{x}}, \\pi)</span>**: parse <span class="math">\\mathcal{C}&#x27; = \\{c_j&#x27;\\}_j</span>. Reconstruct the set <span class="math">\\mathcal{J}</span> as in the prover algorithm, and return 1 if and only if all the following checks pass:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Verify}_{\\mathsf{opn}}(\\mathsf{vk}_{\\mathsf{opn}}, (c_j)_{j \\in [W]}, \\pi_{\\mathsf{opn}}) = 1</span>, for <span class="math">W</span> computed as in step 1 of the prover;</li>

      <li>for all <span class="math">j \\in \\mathcal{J}</span>, check <span class="math">e(c_j, [1]_2) = e([1]_1, c_j&#x27;)</span> (if <span class="math">\\mathsf{type}(c_j) = \\mathsf{swh}</span>) or <span class="math">e(c_j&#x27;, [1]_2) = e([1]_1, c_j)</span> (if <span class="math">\\mathsf{type}(c_j) = \\mathsf{rel}</span>);</li>

      <li><span class="math">[\\hat{G}((c_j&#x27;)_{j \\in [\\ell]}, (c_j&#x27;)_{j \\in \\mathcal{J}})]_T \\stackrel{?}{=} [1]_T</span>, where <span class="math">\\hat{G}</span> is a modified version of <span class="math">G</span> where the computation of a quadratic term involving only <span class="math">c_j</span> is performed as <span class="math">e(c_j, c_j&#x27;)</span> (or <span class="math">e(c_j&#x27;, c_j)</span>).</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Efficiency.</strong> Generating a proof requires $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{J}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> operations of </span>\\mathbb{G}_1<span class="math"> or </span>\\mathbb{G}_2<span class="math"> to compute each </span>c_j'<span class="math">. Verification requires </span>2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{J}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> pairings in step 2 and </span>t + 1<span class="math"> pairings in step 3, where </span>t<span class="math"> is the number of quadratic terms in </span>G<span class="math">. Here we ignored the cost of </span>\\mathsf{CP}_{\\mathsf{opn}}<span class="math"> as well as that to compute the min-cut </span>\\mathcal{J}$; in our applications this is trivial and can be given as a parameter.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Security.</strong> In the following theorem we state the security of <span class="math">\\mathsf{CP}_{\\mathsf{geq}}</span>.</p>

    <p class="text-gray-300"><strong>Theorem 12.</strong> If <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> is a CP-SNARK for <span class="math">\\mathcal{R}_{\\mathsf{opn}}</span> over <span class="math">\\mathsf{CS}_2</span> then <span class="math">\\mathsf{CP}_{\\mathsf{geq}}</span> is a complete, knowledge-sound (with partial opening of type-rel commitments) zero-knowledge CP-SNARK for <span class="math">\\mathsf{R}_{\\mathsf{geq}}</span> over <span class="math">\\mathsf{CS}_2</span> under the d-DLOG assumption for <span class="math">\\mathsf{GenG}</span>. Moreover, if <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> has a commitment-only SRS then <span class="math">\\mathsf{CP}_{\\mathsf{geq}}</span> has a commitment-only SRS.</p>

    <p class="text-gray-300">53</t></t></p>

    <p class="text-gray-300">Proof (Proof Sketch). We define the extractor of  <span class="math">\\mathsf{CP}_{\\mathsf{geq}}</span>  to be the same as the  <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span>  extractor. By the knowledge soundness of  <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> , such extractor returns a tuple of polynomials  <span class="math">(p_j)_{j \\in [\\ell]}</span>  such that for every  <span class="math">j \\in [\\ell]</span>  it holds  <span class="math">c_j = [p_j(s)]_{g_j}</span>  for the appropriate group  <span class="math">g_j</span> .</p>

    <p class="text-gray-300">We want to bound the probability that for the extracted polynomials it holds  <span class="math">G(p_{1}(X), \\ldots, p_{\\ell}(X)) \\neq 0</span>  (while the proof accepts). Let us define  <span class="math">p^{<em>}(X) = G(p_{1}(X), \\ldots, p_{\\ell}(X))</span> . Since the proof accepts we have  <span class="math">p^{</em>}(s) = G(p_{1}(s), \\ldots, p_{\\ell}(s)) = 0</span> . Then we can factor  <span class="math">p^{*}(X)</span>  to recover the root  <span class="math">s</span> , and thus break  <span class="math">d</span> -DLOG assumption.</p>

    <p class="text-gray-300">In this section we show two CP-SNARKs,  <span class="math">\\mathsf{CP}_{\\mathsf{deg}}^{(\\star)}</span>  and  <span class="math">\\mathsf{CP}_{\\mathsf{deg}}^{(2)}</span> , for proving a bound on the degree of committed polynomials, namely they work for the universal relation  <span class="math">\\mathcal{R}_{\\mathsf{deg}}</span>  in which every  <span class="math">\\mathsf{R}_{\\mathsf{deg}} \\in \\mathcal{R}_{\\mathsf{deg}}</span>  consists of a vector  <span class="math">(d_j)_{j \\in [\\ell]}</span>  of degrees, such that every  <span class="math">d_j \\in [d]</span> , and the relation is satisfied if and only if  <span class="math">\\forall j: \\mathsf{deg}(p_j) \\leq d_j</span> .</p>

    <p class="text-gray-300">The basic idea of the schemes is the following. To prove that  <span class="math">\\deg(p) \\leq d^<em></span>  one commits to the shifted polynomial  <span class="math">p^</em>(X) = X^{d - d^<em>} p(X)</span>  and then proves that the polynomial equation  <span class="math">X^{d - d^</em>} \\cdot p(X) - p^*(X) = 0</span>  using a CP-SNARK for polynomial equations. This idea is extended in order to batch together these proofs for several polynomials.</p>

    <p class="text-gray-300">The two schemes  <span class="math">\\mathsf{CP}_{\\mathsf{deg}}^{(\\star)}</span>  and  <span class="math">\\mathsf{CP}_{\\mathsf{deg}}^{(2)}</span>  follow this approach with the only difference that  <span class="math">\\mathsf{CP}_{\\mathsf{deg}}^{(2)}</span>  makes use of the optimized scheme  <span class="math">\\mathsf{CP}_{\\mathsf{geq}}</span>  for quadratic equations. Indeed,  <span class="math">X^{d - d^{<em>}}\\cdot p(X) - p^{</em>}(X) = 0</span>  can be seen as a quadratic equation in which the polynomial  <span class="math">X^{d - d^{*}}</span>  can be committed in  <span class="math">\\mathbb{G}_2</span>  by the Derive algorithm.</p>

    <p class="text-gray-300">Therefore we have that  <span class="math">\\mathsf{CP}_{\\mathsf{deg}}^{(\\star)}</span>  can work with both commitment schemes  <span class="math">\\mathsf{CS}_1</span>  and  <span class="math">\\mathsf{CS}_2</span> , while  <span class="math">\\mathsf{CP}_{\\mathsf{deg}}^{(2)}</span>  works with  <span class="math">\\mathsf{CS}_2</span>  only. Both CP-SNARKs are  <span class="math">\\mathsf{svh}^{\\ell}</span> -restricted complete.</p>

    <p class="text-gray-300">Finally, we remark that in the CP-SNARKs below we assume that the degree bounds are always strictly less than the maximal degree  <span class="math">d</span>  supported by the commitment key  <span class="math">\\mathsf{ck}</span> . In fact, for such  <span class="math">d</span>  a proof for  <span class="math">\\deg(p) \\leq d</span>  is for free.</p>

    <p class="text-gray-300">Scheme  <span class="math">\\mathsf{CP}_{\\mathsf{deg}}^{(\\star)}</span>  We define the CP-SNARK  <span class="math">\\mathsf{CP}_{\\mathsf{deg}}^{(\\star)} = (\\mathsf{KeyGen}_{\\mathsf{deg}},\\mathsf{Prove}_{\\mathsf{deg}},\\mathsf{Verify}_{\\mathsf{deg}})</span>  as follows.</p>

    <p class="text-gray-300">KeyGen deg(ck): execute  <span class="math">(\\mathsf{ek}_{\\mathsf{opn}},\\mathsf{vk}_{\\mathsf{opn}})\\gets \\mathsf{KeyGen}_{\\mathsf{opn}}(\\mathsf{ck})</span>  , execute  <span class="math">(\\mathsf{ek}_{\\mathsf{eq}},\\mathsf{vk}_{\\mathsf{eq}})\\gets \\mathsf{KeyGen}_{\\mathsf{eq}}(\\mathsf{ck})</span>  , define ek := (ck, ekopn, ekeq) and vk := (vkopn, vkeq), and return srs := (ek, vk).</p>

    <p class="text-gray-300">Prove deg  <span class="math">(\\mathsf{ek},(d_j)_{j\\in [\\ell ]},(c_j)_{j\\in [\\ell ]},(p_j)_{j\\in [\\ell ]})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">\\pi_{\\mathrm{opn}}^{*} \\gets \\mathsf{Prove}_{\\mathrm{opn}}(\\mathsf{srs}, (c_j)_{j \\in [\\ell]}, (p_j)_{j \\in [\\ell]})</span> ;</li>

      <li>Let  <span class="math">\\rho_1, \\ldots, \\rho_\\ell \\gets \\mathcal{H}((d_j)_{j \\in [\\ell]}, (c_j)_{j \\in [\\ell]}, \\pi_{\\mathrm{opn}})</span> , let  <span class="math">\\{d_1^<em>, \\ldots, d_{\\ell^</em>}^<em>\\} = \\{d_j\\}_{j \\in [\\ell]}</span>  (repeated values are not counted), and let  <span class="math">P_1, \\ldots, P_{\\ell^</em>}</span>  be a partition of the set  <span class="math">[\\ell]</span>  such that  <span class="math">P_k = \\{j : d_j = d_k^*\\}</span> ;</li>

      <li>For all  <span class="math">i\\in [\\ell^{<em>}]</span>  let  <span class="math">c_{i}^{\\prime}\\gets [p^{\\prime}(s)]_{1}:= [\\sum_{j\\in P_{i}}\\rho_{j}\\cdot p_{j}(s)]_{1}</span>  and  <span class="math">c_{i}^{</em>}\\gets [p_{i}^{<em>}(s)]_{1}:=[s^{d - d_{i}^{</em>}}\\cdot \\sum_{j\\in P_{i}}\\rho_{j}\\cdot p_{j}(s)]_{1};</span></li>

      <li>Compute  <span class="math">\\pi_{\\mathrm{opn}}^{<em>} \\gets \\mathsf{Prove}_{\\mathrm{opn}}(\\mathsf{srs}, (c_{j}^{</em>})_{j \\in [\\ell^{<em>}]}, (p_{j}^{</em>})_{j \\in [\\ell^{*}]})</span> .</li>

      <li>For all  <span class="math">i\\in [\\ell^{<em>}]</span>  , define  <span class="math">G_{i}(X,X_{i}^{\\prime},X_{i}^{</em>}) = X^{d - d_{i}^{<em>}}\\cdot X_{i}^{\\prime} - X_{i}^{</em>}</span> <span class="math">v_{1}^{(i)}(X) = v_{2}^{(i)}(X) = X</span>  , and compute  <span class="math">\\pi_{\\mathrm{eq}}\\gets</span>  Proveeq(ekeq,  <span class="math">(G_{i},\\pmb{v}^{(i)})_{i\\in [\\ell^{<em>}]},(c_{i}^{\\prime},c_{i}^{</em>})_{i\\in [\\ell^{<em>}]},(p_{i}^{\\prime},p_{i}^{</em>})_{i\\in [\\ell^{*}]})</span></li>

      <li>Return  <span class="math">(\\pi_{\\mathrm{opn}},c_1^<em>,\\ldots ,c_{\\ell^</em>}^<em>,\\pi_{\\mathrm{opn}}^</em>,\\pi_{\\mathrm{eq}})</span></li>

    </ol>

    <p class="text-gray-300">Verify  <span class="math">\\mathsf{deg}(\\mathsf{vk},(d_j)_{j\\in [\\ell ]},(c_j)_{j\\in [\\ell ]},\\pi)</span>  : Parse  <span class="math">\\pi = (\\pi_{\\mathrm{opn}},c_1^<em>,\\ldots ,c_{\\ell^</em>}^<em>,\\pi_{\\mathrm{opn}}^</em>,\\pi_{\\mathrm{eq}})</span>  , and compute  <span class="math">\\rho_{1},\\dots,\\rho_{\\ell}</span>  and  <span class="math">G_{i},\\pmb{v}^{(i)}</span>  as the prover does. Return 1 iff :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifyopn(vkopn,  <span class="math">(c_{j})_{j\\in [\\ell ]},\\pi_{\\mathrm{opn}}) = 1</span>  and,</li>

      <li>Verifyopn(vkopn,  <span class="math">(c_j^<em>)_{j\\in [\\ell^</em> ]},\\pi_{\\mathrm{opn}}^*) = 1</span>  and,</li>

      <li>Verify <span class="math">_{\\mathbf{eq}}</span>  ( <span class="math">\\mathsf{vk}_{\\mathbf{eq}}</span> ,  <span class="math">(G_i, \\mathbf{v}^{(i)})_{i \\in [\\ell^<em>]}</span> ,  <span class="math">(c_i&#x27;, c_i^</em>)_{i \\in [\\ell^*]}</span> ,  <span class="math">\\pi_{\\mathbf{eq}}</span> ) = 1.</li>

    </ol>

    <p class="text-gray-300">Efficiency. Generating a proof requires  <span class="math">\\ell^{<em>} \\cdot d^{</em>}</span> <span class="math">\\mathbb{G}_1</span> -exponentiations and  <span class="math">O(\\ell \\cdot d^{<em>})</span> <span class="math">\\mathbb{F}</span> -operations, where  <span class="math">d^{</em>} = \\max_{j \\in [\\ell]} \\{\\deg(p_j)\\}</span> , the cost of generating two  <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span>  proofs and one  <span class="math">\\mathsf{CP}_{\\mathsf{eq}}</span>  proof. Verification requires verifying two  <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span>  proofs and one  <span class="math">\\mathsf{CP}_{\\mathsf{eq}}</span>  proof.</p>

    <p class="text-gray-300">Remark 14 (Optimization). When  <span class="math">\\mathsf{CP}_{\\mathsf{deg}}^{(\\star)}</span>  is used in a larger protocol that uses other invocations of  <span class="math">\\mathsf{CP}_{\\mathsf{eq}}</span> , we observe that these proofs can be batched together (which in turn implies for example the use of the same random point, and of the same  <span class="math">\\mathsf{CP}_{\\mathsf{eval}}</span>  proof).</p>

    <p class="text-gray-300">Security. In the following theorem we state the security of <span class="math">\\mathsf{CP}_{\\mathrm{deg}}^{(\\star)}</span>.</p>

    <p class="text-gray-300">Theorem 13. If <span class="math">\\mathsf{CP}_{\\mathrm{opn}}</span> is a CP-SNARK for <span class="math">\\mathcal{R}_{\\mathrm{opn}}</span> and <span class="math">\\mathsf{CS}_1</span> (resp. <span class="math">\\mathsf{CS}_2</span>), and <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span> is a CP-SNARK for <span class="math">\\mathcal{R}_{\\mathrm{eq}}</span>, then <span class="math">\\mathsf{CP}_{\\mathrm{deg}}^{(\\star)}</span> is a knowledge-sound and zero-knowledge CP-SNARK for <span class="math">\\mathsf{CS}_1</span> (resp. <span class="math">\\mathsf{CS}_2</span>).</p>

    <p class="text-gray-300">Proof. Let <span class="math">(p_j)_{j\\in [\\ell]}</span> and <span class="math">(p_j^<em>)_{j\\in [\\ell^</em>]}</span> be the polynomials extracted from <span class="math">\\pi_{\\mathrm{opn}}</span> and <span class="math">\\pi_{\\mathrm{opn}}^*</span> by the knowledge soundness of <span class="math">\\mathsf{CP}_{\\mathrm{opn}}</span>. We notice that <span class="math">\\rho_1, \\ldots, \\rho_\\ell</span> are uniformly random and independent of <span class="math">(p_j)_{j\\in [\\ell]}</span>, since we can extract the polynomials before answering the random oracle query <span class="math">((c_j)_{j\\in [\\ell]}, \\pi_{\\mathrm{opn}})</span>.</p>

    <p class="text-gray-300">Thus with overwhelming probability, for every <span class="math">i</span> the polynomial <span class="math">p_i&#x27;(X) = \\sum_{j \\in P_i} \\rho_j p_j(X)</span> has degree equal to <span class="math">\\max_{j \\in P_i} \\deg(p_j)</span>. Suppose exists <span class="math">i</span> such that <span class="math">p_i^<em></span> has degree bigger than <span class="math">d_i^</em></span>. Then for the same index <span class="math">i</span> we have that <span class="math">X^{d - d_i&#x27;} p_i&#x27;(X) - p_i^*(X) \\neq 0</span>. However, if this is the case, then we can build a reduction against the soundness of <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span>.</p>

    <p class="text-gray-300">Zero-knowledge is straightforward: the commitments <span class="math">c_1^<em>, \\ldots, c_{\\ell^</em>}^<em></span> are deterministic functions of the random oracle <span class="math">\\mathcal{H}</span>, the values <span class="math">(c_j)_{j \\in [\\ell]}</span> and the trapdoor <span class="math">s</span>, while the remaining proofs <span class="math">\\pi_{\\mathrm{opn}}^</em></span> and <span class="math">\\pi_{\\mathrm{eq}}</span> can be generated by using the simulators of <span class="math">\\mathsf{CP}_{\\mathrm{opn}}</span> and <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span> respectively.</p>

    <p class="text-gray-300">Scheme <span class="math">\\mathsf{CP}_{\\mathrm{deg}}^{(\\mathbf{2})}</span>. We define the CP-SNARK <span class="math">\\mathsf{CP}_{\\mathrm{deg}}^{(\\mathbf{2})} = (\\mathsf{KeyGen}_{\\mathrm{deg}}, \\mathsf{Derive}_{\\mathrm{deg}}, \\mathsf{Prove}_{\\mathrm{deg}}, \\mathsf{Verify}_{\\mathrm{deg}})</span> as follows.</p>

    <p class="text-gray-300">KeyGen deg (ck): execute <span class="math">(\\mathsf{ek}_{\\mathrm{opn}},\\mathsf{vk}_{\\mathrm{opn}})\\gets \\mathsf{KeyGen}_{\\mathrm{opn}}(\\mathsf{ck})</span>, execute <span class="math">(\\mathsf{ek}_{\\mathrm{neq}},\\mathsf{vk}_{\\mathrm{neq}})\\gets \\mathsf{KeyGen}_{\\mathrm{neq}}(\\mathsf{ck})</span>, parse ck as <span class="math">([s^{j}]_{1},[s^{j}]_{2})_{j\\in [0,d]}</span> define ek := (ck, ekopn, ekneq) and vk := (([s^j]_2)_{j\\in [0,d]}, vkopn, vkneq), and return srs := (ek, vk).</p>

    <p class="text-gray-300">Derive deg <span class="math">((d_j)_{j\\in [\\ell]})</span> generates a verification key for the vector of degrees <span class="math">(d_j)_{j\\in [\\ell]}</span> as follows. Let <span class="math">\\{d_j\\}_{j\\in [\\ell]} := \\{d_1^<em>,\\ldots ,d_{\\ell^</em>}^<em>\\}</span> (repeated values are not counted), and set <span class="math">\\mathsf{vk}_d := ([s^{d - d_j^</em>}]_2)_{i\\in [\\ell^*}]</span>.</p>

    <p class="text-gray-300">Prove deg (ek, (cj)j∈[ell], (pj)j∈[ell]):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\pi_{\\mathrm{opn}} \\gets \\mathsf{Prove}_{\\mathrm{opn}}(\\mathsf{srs}, (c_j)_{j \\in [\\ell]}, (p_j)_{j \\in [\\ell]})</span>;</li>

      <li>Let <span class="math">\\rho_1, \\ldots, \\rho_\\ell \\gets \\mathcal{H}((d_j)_{j \\in [\\ell]}, (c_j)_{j \\in [\\ell]}, \\pi_{\\mathrm{opn}})</span>, let <span class="math">\\{d_1^<em>, \\ldots, d_{\\ell^</em>}^<em>\\} = \\{d_j\\}_{j \\in [\\ell]}</span> (repeated values are not counted), and let <span class="math">P_1, \\ldots, P_{\\ell^</em>}</span> be a partition of the set <span class="math">[\\ell]</span> such that <span class="math">P_k = \\{j : a_j = a_k^*\\}</span>;</li>

      <li>For all <span class="math">i\\in [\\ell^{<em>}]</span> let <span class="math">c_i^\\prime \\gets [p^\\prime (s)]_1\\coloneqq [\\sum_{j\\in P_i}\\rho_j\\cdot p_j(s)]_1</span> and <span class="math">c_{i}^{</em>}\\gets [p^{<em>}(s)]_{1}\\coloneqq [s^{d - d_{i}^{</em>}}\\cdot \\sum_{j\\in P_{i}}\\rho_{j}\\cdot p_{j}(s)]_{1};</span></li>

      <li>Compute <span class="math">\\pi_{\\mathrm{opn}}^<em> \\gets \\mathsf{Prove}_{\\mathrm{opn}}(\\mathsf{srs}, (c_j^</em>)_{j \\in [\\ell^<em>]}, (p_j^</em>)_{j \\in [\\ell^*]})</span>.</li>

      <li>For all <span class="math">i\\in [\\ell^{<em>}]</span>, define <span class="math">G_{i}(\\hat{X}_{i},X_{i}^{\\prime},X_{i}^{</em>}) = \\hat{X}_{i}\\cdot X_{i}^{\\prime} - X_{i}^{*}</span>, and compute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\pi_ {\\mathrm {q e q}} \\leftarrow \\overline {{\\mathsf {P r o v e}}} _ {\\mathrm {q e q}} (\\mathsf {e k} _ {\\mathrm {e q}}, (G _ {i}, \\boldsymbol {v} ^ {(i)}) _ {i \\in [ \\ell^ {*} ]}, ([ s ^ {d - d _ {i} ^ {*}} ] _ {2}, c _ {i} ^ {\\prime}, c _ {i} ^ {*}) _ {i \\in [ \\ell^ {*} ]}, (X ^ {d - d _ {i} ^ {*}}, p _ {i} ^ {\\prime}, p _ {i} ^ {*}) _ {i \\in [ \\ell^ {*} ]})</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Return <span class="math">(\\pi_{\\mathrm{opn}},c_1^<em>,\\ldots ,c_{\\ell^</em>}^<em>,\\pi_{\\mathrm{opn}}^</em>,\\pi_{\\mathrm{neq}})</span></li>

    </ol>

    <p class="text-gray-300">Verify deg(vkd, (cj)j∈[ell], π): Parse π = (πopn, c1<em>, ..., ck</em>, πopn, πeq), and compute ρ1, ..., ρl and Gi, v(i) as the prover does. Return 1 iff:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifyopn(vkopn, (cj)j∈[ell], πopn) = 1 and,</li>

      <li>Verifyopn(vkopn, (cj*)j∈[ell], πopn) = 1 and,</li>

      <li>Verifyqeq(vkeq, (Gi)i∈[ell], ([s^d-d_i^<em>])_2, c_i', c_i^</em>)i∈[ell], πeq) = 1.</li>

    </ol>

    <p class="text-gray-300">The security proof of <span class="math">\\mathsf{CP}_{\\mathrm{deg}}^{(2)}</span> works essentially the same as that of <span class="math">\\mathsf{CP}_{\\mathrm{deg}}^{(\\star)}</span> and is therefore omitted.</p>

    <p class="text-gray-300">Theorem 14. If <span class="math">\\mathsf{CP}_{\\mathrm{opn}}</span> is a CP-SNARK for <span class="math">\\mathcal{R}_{\\mathrm{opn}}</span> over <span class="math">\\mathsf{CS}_2</span>, and <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span> is a CP-SNARK for <span class="math">\\mathcal{R}_{\\mathrm{eq}}</span> over <span class="math">\\mathsf{CS}_2</span>, then <span class="math">\\mathsf{CP}_{\\mathrm{deg}}^{(2)}</span> is a knowledge-sound and zero-knowledge CP-SNARK for <span class="math">\\mathsf{R}_{\\mathrm{deg}}</span> over <span class="math">\\mathsf{CS}_2</span>.</p>

    <p class="text-gray-300">Efficiency. From the shape of all the quadratic polynomials <span class="math">G_{i}</span> and the construction of <span class="math">\\mathsf{CP}_{\\mathsf{neq}}</span> in Section 7.7, we observe that the proof <span class="math">\\pi_{\\mathsf{neq}}</span> is empty and it can be verified by checking, for every <span class="math">i \\in [\\ell^{<em>}]</span>, <span class="math">e(\\sum_{j \\in P_i} \\rho_j c_j, [s^{d - d_i^</em>}]_2) = e(\\pi_i, [1]_2)</span>. The cost of generating the rest of the proof requires generating two <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> proofs, <span class="math">\\ell^{<em>} \\cdot d^{</em>} \\mathbb{G}_{1}</span>-exponentiations and <span class="math">O(\\ell \\cdot d^{<em>})</span> <span class="math">\\mathbb{F}</span>-operations, where <span class="math">d^{</em>} = \\max_{j \\in [\\ell]} \\{\\deg(p_j)\\}</span>. Verification additionally requires verification of two <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> proofs.</p>

    <p class="text-gray-300">55</p>

    <p class="text-gray-300">7.9 A general-purpose CP-SNARK for <span class="math">\\mathcal{R}_{\\mathsf{php}}</span></p>

    <p class="text-gray-300">Given the CP-SNARKs presented in the previous section, it is possible to construct CP-SNARKs for the commitment schemes <span class="math">\\mathsf{CS}_1</span>, <span class="math">\\mathsf{CS}_2</span> and for any PHP verifier checks, i.e., for the relation <span class="math">\\mathcal{R}_{\\mathsf{php}}</span> discussed in Section 3.1. Such a CP-SNARK <span class="math">\\mathsf{CP}_{\\mathsf{php}}</span> can be obtained with three main building block CP-SNARKs: one for <span class="math">\\mathcal{R}_{\\mathsf{opn}}</span> (see Section 7.3), one for proving a bound on the degree of committed polynomials, and one for polynomial equations.</p>

    <h2 id="sec-74" class="text-2xl font-bold">8 Our Compiler for Universal Commit-and-Prove zkSNARKs</h2>

    <p class="text-gray-300">In this section we show how to compile PHPs into CP-SNARKs. We present the compiler in Section 8.1. It can be instantiated with the same building blocks presented in the previous section, plus additional ones that we present in Section 8.2,</p>

    <h2 id="sec-75" class="text-2xl font-bold">8.1 Compiling to Commit-and-Prove Universal Interactive Arguments</h2>

    <p class="text-gray-300">We show how to adapt the compiler of Section 6.2 to produce a commit-and-prove succinct interactive argument in the SRS model.</p>

    <p class="text-gray-300">Let PHP be a PHP protocol for a universal relation <span class="math">\\mathcal{R}</span> such that for any triple <span class="math">(\\mathsf{R},\\mathsf{x},\\mathsf{w}) \\in \\mathcal{R}</span>, the witness splits into an <span class="math">\\ell + 1</span>-tuple <span class="math">\\mathsf{w} := ((\\mathsf{u}_j)_{j \\in [\\ell]}, \\omega) \\in \\mathcal{D}_1 \\times \\dots \\times \\mathcal{D}_\\ell \\times \\mathcal{D}_\\omega</span>.</p>

    <p class="text-gray-300">We show how to compile PHP to a commit-and-prove UIA for <span class="math">\\mathcal{R}</span> in which prover and verifier take as inputs commitments <span class="math">c_1, \\ldots, c_\\ell</span> to <span class="math">\\mathsf{u}_1, \\ldots, \\mathsf{u}_\\ell</span> respectively. More in detail, UIA is a universal commit-and-prove argument for <span class="math">\\mathcal{R}</span> and a type-based commitment scheme <span class="math">\\mathsf{CS}^<em></span> such that the commitments taken as input are of type lnk and satisfy full-fledged hiding. The reason to require these commitments to be hiding (instead of our weaker somewhat-hiding notion) is that these are supposed to be "regular" commitments that may be generated independently of this proof system and that, for a general application scenario, should hide messages even if they are re-used an unbounded number of times for different proofs.¹⁸ We summarize the requirements on <span class="math">\\mathsf{CS}^</em></span> in the following definition.</p>

    <p class="text-gray-300"><strong>Definition 22 (CP-Compiling Commitment Scheme).</strong> Let <span class="math">\\mathcal{R}</span> be a universal relation such that for any <span class="math">(\\mathsf{R},\\mathsf{x},\\mathsf{w}) \\in \\mathcal{R}</span>, <span class="math">\\mathsf{w} := ((\\mathsf{u}_j)_{j \\in [\\ell]}, \\omega) \\in \\mathcal{D}_1 \\times \\ldots \\mathcal{D}_\\ell \\times \\mathcal{D}_\\omega</span>. We say <span class="math">\\mathsf{CS}^* = (\\mathsf{Setup}, \\mathsf{Commit}, \\mathsf{VerCom})</span> is a CP-compiling commitment scheme if it is a type-based commitment scheme for a class of types <span class="math">\\mathcal{T} = \\{\\mathsf{rel}, \\mathsf{swh}, \\mathsf{lnk}\\}</span>, such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>commitments of type rel and swh are for messages that are polynomials <span class="math">\\mathbb{F}_{&amp;lt;d}[X]</span> for a given bound <span class="math">d \\in \\mathbb{N}</span>;</li>

      <li>commitments of type lnk are for messages in <span class="math">\\mathcal{D}</span> such that for all <span class="math">i \\in [\\ell]</span>, <span class="math">\\mathcal{D}_i \\subseteq \\mathcal{D}</span>;</li>

      <li>it is <span class="math">\\mathcal{T}</span>-binding;</li>

      <li>it is swh-somewhat-hiding and lnk-hiding.</li>

    </ul>

    <p class="text-gray-300"><strong>Additional building blocks.</strong> Besides the requirements of Section 6.2, we additionally require from the <span class="math">\\mathsf{CS}^*</span> and from PHP the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The PHP has a straight-line extractor (see Definition 3). Specifically, there exists an efficient extractor <span class="math">\\mathsf{WitExtract}</span> such that <span class="math">\\mathsf{WitExtract}((p_j)_{j\\in [\\mathsf{n}^*]}) = \\mathsf{w}</span>.</li>

      <li><span class="math">\\mathsf{CS}^<em></span> is equipped with a zero-knowledge CP-SNARK <span class="math">\\mathsf{CP}_{\\mathsf{link}} = (\\mathsf{KeyGen}_{\\mathsf{link}}, \\mathsf{Prove}_{\\mathsf{link}}, \\mathsf{VerProof}_{\\mathsf{link}})</span> that can "link" a tuple of lnk-typed commitments (opening to <span class="math">(\\mathsf{u}_j)_{j\\in [\\ell]})</span> with a tuple of <span class="math">\\mathsf{n}^</em></span> swh-typed commitments. The linking relation should also enforce that the latter commitments open to polynomials that somehow contain a witness for a universal relation. Specifically, <span class="math">\\mathsf{CP}_{\\mathsf{link}}</span> is a <span class="math">(\\{\\mathsf{lnk}\\}^{\\ell}\\times (\\mathsf{swh})^{\\mathsf{n}^*})</span>-restricted complete ZK CP-SNARK for the universal relation <span class="math">\\mathcal{R}_{\\mathsf{link}}</span> parametrized by the algorithm <span class="math">\\mathsf{WitExtract}</span> and by a PT decoding algorithm <span class="math">\\mathsf{Decode}</span>:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{R}_{\\mathsf{link}}((\\mathsf{u}_j)_{j\\in[\\ell]},(p_j)_{j\\in[\\mathsf{n}^*]},\\omega) := \\mathsf{WitExtract}((p_j)_{j\\in[\\mathsf{n}^*]}) \\stackrel{?}{=} (\\mathsf{Decode}((\\mathsf{u}_j)_{j\\in[\\ell]}),\\omega)</span></div>

    <p class="text-gray-300">¹⁸ Note this rules out the use of polynomial commitments with “bounded-use randomizers” such as the one in [45].</p>

    <p class="text-gray-300">56</p>

    <p class="text-gray-300">We additionally require the Decode algorithm for a rather technical reason. Namely, the commitment scheme CS could encode the witness blocks <span class="math">\\mathsf{u}_{i}</span> in different way, the decoding algorithm casts back to strings the encoding used by the commitment scheme CS.</p>

    <p class="text-gray-300">The commit-and-prove compiler. Let <span class="math">\\mathsf{UIA}=(\\mathsf{KeyGen},\\mathsf{Derive},\\mathbb{P},\\mathbb{V})</span> be the interactive protocol for <span class="math">\\mathcal{R}</span> from the Figure 3. We show how we can make it commit-and-prove with some simple modifications.</p>

    <p class="text-gray-300">In what follows, to distinguish the commitments (and the associated openings) taken as input by the protocol, from the commitments generated during the interaction, we denote the former ones with a hat.</p>

    <p class="text-gray-300">Consider the interactive protocol that is the same as UIA but with the following modifications:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The KeyGen algorithm does not sample a commitment key from CS.Setup but instead takes a commitment key ck of the <span class="math">\\mathsf{CS}^{*}</span> commitment scheme as input.</li>

      <li>The prover on input <span class="math">\\mathsf{ek}</span>, <span class="math">\\tilde{\\mathsf{x}}=(\\mathsf{x},(\\hat{c}_{j})_{j\\in[\\ell]})</span> and <span class="math">\\hat{\\mathsf{w}}=((\\mathsf{u}_{j})_{j\\in[\\ell]},(\\hat{o}_{j})_{j\\in[\\ell]},\\omega)</span>, executes the same as <span class="math">\\mathbb{P}(\\mathsf{vk},\\mathsf{x},((\\mathsf{u}_{j})_{j\\in[\\ell]},\\omega))</span>.</li>

      <li>At the last round the prover computes</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\pi_{\\mathsf{link}}\\leftarrow\\mathsf{Prove}_{\\mathsf{link}}(\\mathsf{ek}_{\\mathsf{link}},((\\hat{c}_{j})_{j\\in[\\ell]},(c_{j})_{j\\in[k]}),((\\mathsf{u}_{j})_{j\\in[\\ell]},(p_{j})_{j\\in[\\mathsf{n_{p}}]}),((\\hat{o}_{j})_{j\\in[\\ell]},(o_{j})_{j\\in[\\mathsf{n_{p}}]}),\\omega)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At the last round the verifier additionally checks <span class="math">b_{\\mathsf{link}}\\leftarrow\\mathsf{Verify}_{\\mathsf{link}}(\\mathsf{vk}_{\\mathsf{link}},((\\hat{c}_{j})_{j\\in[\\ell]},(c_{j})_{j\\in[\\mathsf{n_{p}}]}),\\pi_{\\mathsf{link}})</span>, and output 1 if all the CP-SNARK proofs verify.</li>

    </ul>

    <h6 id="sec-76" class="text-base font-medium mt-4">Theorem 15.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{PHP}=(\\mathsf{r},\\mathsf{n},\\mathsf{m},\\mathsf{d},\\mathsf{n_{e}},\\mathcal{R}\\mathcal{E},\\mathcal{P},\\mathcal{V})</span> be a non-adaptive public-coin PHP over <span class="math">\\mathcal{F}</span> and <span class="math">\\mathcal{R}</span>, let <span class="math">\\mathsf{CS}^{*}</span> be a compiling commitment scheme as in Definition 22 equipped with CP-SNARKs <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> for <span class="math">\\mathcal{R}_{\\mathsf{opn}}</span>, <span class="math">\\mathsf{CP}_{\\mathsf{php}}</span> for a relation <span class="math">\\mathcal{R}_{\\mathsf{php}}</span>, and <span class="math">\\mathsf{CP}_{\\mathsf{link}}</span> for <span class="math">\\mathsf{R}_{\\mathsf{link}}</span>. Then we have:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathsf{PHP}</span> has straight-line extractability, then the scheme UIA defined above is a universal commit and prove interactive argument in the SRS model for <span class="math">\\mathcal{R}^{\\prime}</span> such that:</li>

    </ul>

    <p class="text-gray-300"><span class="math">(\\mathsf{R},\\mathsf{x},(\\mathsf{u}_{j})_{j\\in[\\ell]},\\omega)\\in\\mathcal{R}^{\\prime}\\iff(\\mathsf{R},\\mathsf{x},\\mathsf{Decode}((\\mathsf{u}_{j})_{j\\in[\\ell]}),\\omega)\\in\\mathcal{R}.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If, for a checker <span class="math">\\mathsf{C}</span>, <span class="math">\\mathsf{PHP}</span> (resp. <span class="math">\\mathsf{CP}_{\\mathsf{php}}</span>) is <span class="math">(\\mathsf{b}+\\mathsf{1},\\mathsf{C})</span>-bounded honest-verifier zero knowledge (resp. trapdoor-commit <span class="math">(\\mathsf{b},\\mathsf{C})</span>-leaky zero-knowledge), and both <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> and <span class="math">\\mathsf{CP}_{\\mathsf{link}}</span> are trapdoor-commitment zero-knowledge, then UIA is trapdoor-commitment honest-verifier zero-knowledge.</li>

    </ul>

    <p class="text-gray-300">Note that the analogous of Remark 7 holds for this theorem as well.</p>

    <p class="text-gray-300">While a proof of Theorem 15 is in Appendix C, we provide an intuition for the case <span class="math">\\ell=1</span>. To prove knowledge soundness we should be able to extract <span class="math">(\\hat{o},\\mathsf{u},\\omega)</span>—valid CP-witnesses for the CP-version of <span class="math">\\mathsf{R}</span>—from <span class="math">\\hat{c},\\mathsf{x}</span>. Let us assume that the verifier accepts. We can run the <span class="math">\\mathsf{CP}_{\\mathsf{link}}</span> extractor and obtain <span class="math">\\mathsf{u},\\hat{o},\\omega</span> as well as a vector of polynomials <span class="math">\\bm{p}</span> with respective openings for the <span class="math">c_{j}</span>-s. By knowledge soundness of <span class="math">\\mathsf{CP}_{\\mathsf{link}}</span>, <span class="math">\\mathsf{u},\\omega</span> as defined above extracted from the polynomials in <span class="math">\\bm{p}</span>. In turn, we can claim these polynomials encode valid witnesses for relation <span class="math">\\mathsf{R}</span> because, if they didn’t, we could obtain “valid” polynomials <span class="math">\\bm{p}^{\\prime}</span> by running the extractor of <span class="math">\\mathsf{CP}_{\\mathsf{php}}</span>. These would also be valid openings to commitments <span class="math">\\bm{c}</span>. If the polynomials in <span class="math">\\bm{p}^{\\prime}</span> were distinct from the polynomials in <span class="math">\\bm{p}</span> then we would be able to break binding; therefore, polynomials in <span class="math">\\bm{p}</span> and <span class="math">\\bm{p}^{\\prime}</span> must be identical and encode witnesses for <span class="math">\\mathsf{R}</span>. To prove zero-knowledge we extend the simulator from Theorem 5 by appending to its output that of the simulator of <span class="math">\\mathsf{CP}_{\\mathsf{link}}</span> a zero-knowledge CP-SNARK.</p>

    <h3 id="sec-77" class="text-xl font-semibold mt-8">8.2 Pairing-Based Instantiations of our Building Blocks</h3>

    <p class="text-gray-300">Commitment Scheme We describe the polynomial commitment scheme <span class="math">\\mathsf{CS}^{<em>}</span> which supports types <span class="math">\\mathsf{lnk},\\mathsf{swh},\\mathsf{rel}</span>. The scheme is an extension of <span class="math">\\mathsf{CS}_{g}</span> for <span class="math">g\\in\\{1,2\\}</span>. The algorithms <span class="math">(\\mathsf{Setup},\\mathsf{Commit},\\mathsf{VerCom})</span> of <span class="math">\\mathsf{CS}_{g}^{</em>}</span> are defined as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Setup}(1^{\\lambda},d)</span>: run <span class="math">\\mathsf{ck}^{\\prime}\\leftarrow\\mathsf{Setup}_{g}(1^{\\lambda},d)</span>, sample random <span class="math">\\alpha\\leftrightarrows\\mathbb{F}</span> and output <span class="math">\\mathsf{ck}=\\mathsf{ck}^{\\prime},[\\alpha,\\alpha s,\\alpha s^{2}]_{1}</span>. <span class="math">\\mathsf{Commit}(\\mathsf{ck},\\mathsf{type},p)\\to(c,o)</span>: if <span class="math">\\mathsf{type}\\neq\\mathsf{lnk}</span> output the same as <span class="math">\\mathsf{Commit}_{g}</span>, else sample <span class="math">o\\leftrightarrows\\mathbb{F}</span> and output <span class="math">[p(s)+\\alpha\\cdot o]_{1}</span>. <span class="math">\\mathsf{VerCom}(\\mathsf{ck},\\mathsf{type},c,p,o)</span>: if <span class="math">\\mathsf{type}\\neq\\mathsf{lnk}</span> output the same as <span class="math">\\mathsf{VerCom}_{g}</span>, else check if <span class="math">c\\stackrel{{\\scriptstyle?}}{{=}}p([s]_{1})+o[\\alpha]_{1}</span>.</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Remark 15.</h6>

    <p class="text-gray-300">Notice that the values <span class="math">[\\alpha s,\\alpha s^{2}]_{1}</span> are not needed for hiding, however they are useful for the CP-SNARK for polynomial evaluation that we present next.</p>

    <p class="text-gray-300">CP-SNARK for  <span class="math">\\mathcal{R}_{\\mathrm{opn}}</span> . As described in Section 7.3 we can obtain trivially a CP-SNARK in the AGM. A trivial extension of the construction  <span class="math">\\mathsf{CP}_{\\mathrm{opn}}^{\\mathsf{PKE}}</span>  of Section 7.3 is also suitable for  <span class="math">\\mathsf{CS}^*</span> . The only difference is that for the security analysis we need to rely on the following assumption:</p>

    <p class="text-gray-300">Assumption 4 (mmPKE) The (multi-instance, multi-base) Power Knowledge of Exponent (mmPKE) assumption holds for a bilinear group generator GenG if for every efficient non-uniform adversary  <span class="math">\\mathcal{A}</span>  and degree bounds  <span class="math">d_1, d_2 \\in \\mathbb{N}</span>  there exists an efficient extractor  <span class="math">\\mathcal{E}</span>  such that for any benign distribution  <span class="math">\\mathcal{Z}</span>  the following probability is negligible in  <span class="math">\\lambda</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} \\mathsf {b g p} \\leftrightarrows \\mathsf {G e n G} (1 ^ {\\lambda}); \\\\ \\exists j: \\begin{array}{c} d _ {j} = \\gamma \\cdot c _ {j} \\wedge \\\\ c _ {j} \\neq \\sum_ {k = 0} ^ {d _ {1}} a _ {k} ^ {(j)} s ^ {j} + \\alpha \\sum_ {k = 0} ^ {d _ {2}} b _ {k} ^ {(j)} s ^ {j}: \\Sigma = \\left( \\begin{array}{c} ([ s ^ {j} ] _ {1}, [ s ^ {j} ] _ {2}, [ \\gamma s ^ {j} ] _ {1}, [ \\gamma ] _ {2}) _ {j \\in [ d _ {1} ]} \\\\ ([ \\alpha s ^ {j} ] _ {1}, [ \\alpha s ^ {j} ] _ {2}, [ \\alpha \\gamma s ^ {j} ] _ {1}, [ \\alpha \\gamma s ^ {j} ] _ {2}) _ {j \\in [ d _ {2} ]} \\end{array} \\right); \\\\ (c _ {j}) _ {j \\in [ \\ell^ {\\prime} ]}, (d _ {j}) _ {j \\in [ \\ell^ {\\prime} ]} \\leftarrow \\mathcal {A} (\\mathsf {b g p}, \\Sigma , \\mathsf {a u x} _ {Z}); \\\\ (\\boldsymbol {a} ^ {(j)}, \\boldsymbol {b} ^ {(j)}) _ {j \\in [ \\ell^ {\\prime} ]} \\leftarrow \\mathcal {E} (\\mathsf {b g p}, \\Sigma , \\mathsf {a u x} _ {Z}) \\end{array} \\right]. \\end{array} \\right]</span></div>

    <p class="text-gray-300">CP-SNARK for  <span class="math">\\mathsf{R}_{\\mathrm{eval},1}</span> . We define a zero-knowledge CP-SNARK  <span class="math">\\mathsf{CP}_{\\mathrm{eval},1}</span>  for  <span class="math">\\mathsf{CS}_p^*</span>  and the relation  <span class="math">\\mathsf{R}_{\\mathrm{eval},1}((a,b),p)\\coloneqq p(a)\\stackrel {\\circ}{=}b</span> , where  <span class="math">p</span>  is committed as  <span class="math">[p(s) + \\alpha \\cdot o]_1</span> .</p>

    <p class="text-gray-300">Kate et al. [45] describe a method to do evaluation proofs for hiding polynomial commitments. In a nutshell, in their case a commitment to  <span class="math">p</span>  is an element  <span class="math">[p(s) + \\alpha \\cdot o(s)]_1</span>  where  <span class="math">o</span>  is a random polynomial of degree  <span class="math">\\deg(p)</span>  (or degree  <span class="math">b</span> , if one aims to support at most  <span class="math">b</span>  evaluation proofs) and the evaluation proof for a point  <span class="math">a</span>  reveals  <span class="math">o(a)</span> . This technique, however, cannot be seen as a full-fledged commit-and-prove zero-knowledge proof as one should know a priori how many evaluation proofs are generated for a given commitment. More technically, in the commit-and-prove framework, a simulator would only take as input a commitment and must simulate a proof which must be indistinguishable from a real one, independently of how many other proofs have been already (or will be) generated. It is also interesting to note that for a polynomial  <span class="math">p</span>  of degree  <span class="math">d</span>  giving more than  <span class="math">d</span>  evaluations of  <span class="math">p</span>  on distinct points reveal the polynomial; thus one may think that zero-knowledge would no longer be needed. However, there are some applications in which one can use a commitment in more than  <span class="math">d</span>  evaluation proofs without necessarily revealing  <span class="math">d</span>  evaluations of the committed polynomial. This is for example the case if one shows evaluations of linear combinations of various committed polynomials to known constant, e.g., proving that  <span class="math">\\rho_1p_1(a) + \\rho_2p_2(a) = 0</span> . In this case, the technique from [45] would leak information on the random polynomials  <span class="math">o_1, o_2</span>  and would be usable a limited number of times.</p>

    <p class="text-gray-300">Motivated by this problem, we propose a different technique for proving an unbounded number of evaluations of committed polynomials in zero-knowledge.</p>

    <p class="text-gray-300">Let us provide a brief intuition of our technique. In our CP-SNARK the prover additionally computes a f1h-typed commitment  <span class="math">\\tilde{c}</span>  to the 0 polynomial using fresh randomness, and then proves that (1)  <span class="math">\\tilde{c}</span>  indeed commits to the 0 polynomial, and (2) that the polynomial  <span class="math">p</span>  committed in  <span class="math">c + \\tilde{c}</span>  evaluates to  <span class="math">b</span>  on the point  <span class="math">a</span> . The idea is that in the step (2) the prover masks the opening material of  <span class="math">c</span>  using the fresh opening material of  <span class="math">\\tilde{c}</span> . In particular, the prover picks a degree-2 polynomial for the opening of  <span class="math">\\tilde{c}</span>  because we want to assure that the mask in (2) is uniformly random even given the value  <span class="math">\\tilde{c}</span>  and the leakage (one evaluation point) in step (1).</p>

    <p class="text-gray-300">KeyGeneval1(ck): execute  <span class="math">(\\mathsf{ek}_{\\mathrm{opn}},\\mathsf{vk}_{\\mathrm{opn}})\\gets \\mathsf{KeyGen}_{\\mathrm{opn}}(\\mathsf{ck})</span>  , parse ck as  <span class="math">([s^j ]_1,[s^j ]_2)_{j\\in [0,d]}</span>  define ek := (ck, ekopn) and vk := ([1,s]2,vkopn), and return srs := (ek,vk).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proveeval1(ek,  <span class="math">(a,b),c,p)</span> : Sample random degree-2 polynomial  <span class="math">\\tilde{o} (X)</span>  and set  <span class="math">\\tilde{c} = [\\alpha \\tilde{o} (s)]_1</span> , compute a proof  <span class="math">\\pi_{\\mathrm{opn}}\\gets \\mathsf{Prove}_{\\mathrm{opn}}(\\mathsf{ek}_{\\mathrm{opn}},(c,\\tilde{c}),(p,0),(o,\\tilde{o}))</span> , and set  $(x)\\gets H(\\hat{\\mathbf{x}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\mathrm{opn}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{c})$  :</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">y_{1} \\gets \\tilde{o}(x)</span>  and let  <span class="math">w_{1}&#x27;(X)</span>  such that  <span class="math">w_{1}&#x27;(X) \\cdot (X - x) \\equiv \\tilde{o}(X) - y_{1}</span> ;</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">y_{2} \\gets o(a) + \\tilde{o}(a)</span> and let <span class="math">w(X), w_{2}&#x27;(X)</span> such that <span class="math">w(X) \\cdot (X - a) \\equiv p(X) - b</span> and <span class="math">w_{2}&#x27;(X) \\cdot (X - a) \\equiv o(X) + \\tilde{o}(X) - y</span>.</li>

    </ol>

    <p class="text-gray-300">set <span class="math">\\pi \\gets ([w_1&#x27;(s), w(s) + \\alpha w_2&#x27;(s)]_1, y_1, y_2)</span> and output <span class="math">(\\pi_{\\mathrm{opn}}, \\pi)</span>.</p>

    <p class="text-gray-300">Verify <span class="math">_{\\text{eval1}}(\\mathsf{vk}, (a, b), c, \\pi)</span>: Parse <span class="math">\\pi = (\\pi_{\\mathrm{opn}}, ([w&#x27;, w)]_1, y_1, y_2))</span>, and output 1 iff:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify <span class="math">_{\\text{opn}}(\\mathsf{vk}_{\\text{opn}}, c, \\pi_{\\text{opn}}) = 1</span>,</li>

      <li><span class="math">e([w&#x27;]_1, [s - x]_2) = e(\\tilde{c}, [1]_2) - [\\alpha y_1]_T</span>, and</li>

      <li><span class="math">e([w]_1, [s - a]_2) = e(c + \\tilde{c}, [1]_2) - [b]_T - [\\alpha y_2]_T</span>.</li>

    </ol>

    <p class="text-gray-300">Theorem 16. If <span class="math">\\mathsf{CP}_{\\mathrm{opn}}</span> is a f1h-restricted CP-SNARK for <span class="math">\\mathcal{R}_{\\mathrm{opn}}</span> and the <span class="math">d</span>-SDH assumption holds for <span class="math">\\mathsf{GenG}</span>, then <span class="math">\\mathsf{CP}_{\\mathrm{eval},1}</span> is a complete, knowledge sound, and trapdoor-commitment zero-knowledge CP-SNARK for <span class="math">\\mathsf{R}_{\\mathrm{eval},1}</span> for <span class="math">\\mathsf{CS}^*</span>. Moreover, if <span class="math">\\mathsf{CP}_{\\mathrm{opn}}</span> has commitment-only SRS then <span class="math">\\mathsf{CP}_{\\mathrm{eval},1}</span> has commitment-only SRS.</p>

    <p class="text-gray-300">Proof. The proof of knowledge soundness follows similar to [45, 24]. In particular, we notice that the second verification equation shows that <span class="math">\\tilde{c}</span> is indeed a polynomial commitment to 0, thus, by the homomorphic property of the commitment scheme we have that <span class="math">c + \\tilde{c}</span> is a commitment to <span class="math">p</span>. Then the third equation shows that <span class="math">p(a) = b</span>.</p>

    <p class="text-gray-300">For zero-knowledge notice that <span class="math">\\tilde{o}</span> is random degree-2 polynomial thus even given the evaluation points <span class="math">\\tilde{o}(x_1)</span> and <span class="math">\\tilde{o}(s)</span> the evaluation <span class="math">\\tilde{o}(a)</span> is still uniformly random over <span class="math">\\mathbb{F}</span> and it can be used to mask the value <span class="math">o(a)</span>. We can simulate by sampling <span class="math">\\tilde{c} \\leftrightarrows \\mathbb{G}_1</span> and <span class="math">y_1, y_2 \\leftrightarrows \\mathbb{Z}_q^2</span>, then set <span class="math">[w&#x27;]_1 = (\\tilde{c} - [\\alpha]y_1)/(s - x)</span> and <span class="math">[w]_1 = (c + \\tilde{c} - [b]_1 - [\\alpha]_1y_2)/(s - a)</span>.</p>

    <p class="text-gray-300">CP-SNARK for <span class="math">\\mathsf{R}_{\\mathrm{eval}}</span> and <span class="math">\\mathsf{R}_{\\mathrm{eq}}</span>. Similar to Section 7.5 and Section 7.6, we can define the CP-SNARKs <span class="math">\\mathsf{CP}_{\\mathrm{eval}}</span> and <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span> for <span class="math">\\mathsf{CS}^*</span>, indeed such constructions use <span class="math">\\mathsf{CP}_{\\mathrm{eval},1}</span> as a black-box thus we could easily instantiate 1nk-restricted complete version of them using the <span class="math">\\mathsf{CP}_{\\mathrm{eval},1}</span> presented in the previous paragraph.</p>

    <p class="text-gray-300">Efficiency. We give efficiency ignoring the costs of <span class="math">\\mathsf{CP}_{\\mathrm{opn}}</span>. For <span class="math">\\mathsf{CP}_{\\mathrm{eval},1}</span> generating a proof requires <span class="math">\\deg(p) + 6</span> <span class="math">\\mathbb{G}_1</span>-exponentiations to compute <span class="math">\\pi</span> and <span class="math">O(\\deg(p))</span> <span class="math">\\mathbb{F}</span>-operations to compute the polynomials <span class="math">w(X), w_1&#x27;(X), w_2&#x27;(X)</span>, verification requires 4 pairings. For <span class="math">\\mathsf{CP}_{\\mathrm{eval}}</span> generating a proof requires <span class="math">\\ell^<em> \\cdot (\\deg(p_k^</em>) + 1)</span> <span class="math">\\mathbb{G}_1</span>-exponentiations and <span class="math">O(\\ell^<em>\\deg(p_k^</em>))</span> <span class="math">\\mathbb{F}</span>-operations, verification requires <span class="math">4\\ell^<em></span> pairings, where we recall that <span class="math">\\ell^</em></span> is computed as the cardinality of the set of all the evaluation points (in particular <span class="math">\\ell^* \\leq \\ell</span>). For the counting for <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span> we refer to Section 7.6.</p>

    <p class="text-gray-300">CP-SNARK for Linking Commitments. Finally, we propose instantiations for the <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span> CP-SNARK that support our 1nk-typed commitments and the WitExtract straight-line extractors of our PHPs. We also remark that the techniques used in this section can be applied—with the appropriate care—to other zkSNARKs based on polynomial oracles/commitments, such as PLONK and Marlin [33, 24].</p>

    <p class="text-gray-300">The ideas in this section allow to obtain CP-SNARKs overcoming a limitation in our approach so far (which is also the basic approach in PLONK and Marlin): the commitments used to compile to the oracle polynomials cannot be reused. The reason for it is that, in order to reuse them in some other proofs, we would need to open additional evaluation points on them, but this would break zero-knowledge. We can go around that by linking the "throw-away" commitments used in the proof to the commitments we want to reuse. One of the challenges here is that the content of the reusable and throw-away polynomials, although related, does not match perfectly. For example, the latter is specific to the relation we are proving and to the rest of the input, while the former is not (it just represents "data" we are sharing among proofs).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The setting. Let us first consider the WitExtract algorithm of our PHPs for R1CS of Section 4.4; this simply uses one polynomial, <span class="math">\\hat{w}(X)</span>, and returns its evaluations on <span class="math">\\mathbb{H}&#x27; := \\mathbb{H} \\setminus \\mathbb{L}</span>, i.e., $\\boldsymbol{w} := (w(\\phi_{\\mathrm{lt}}^{-1}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1)), \\ldots, w(\\phi_{\\mathrm{lt}}^{-1}(n)))<span class="math">. Our goal is to support use cases in which one has commitments </span>\\hat{c}_j<span class="math"> to vectors </span>\\mathsf{u}_j<span class="math"> and wants to prove that </span>\\boldsymbol{w} = ((\\mathsf{u}_j)_{j \\in [\\ell]}, \\omega)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We consider the following algebraic setting. Let <span class="math">\\eta</span> be the generator of <span class="math">\\mathbb{H}</span> so that <span class="math">\\mathbb{H} = (\\eta, \\eta^2, \\ldots, \\eta^n)</span> and <span class="math">\\mathbb{H} \\setminus \\mathbb{L}</span> can be partitioned in ordered form as <span class="math">\\mathbb{H}&#x27; = (W_1, \\ldots, W_{\\ell+1})</span>, where the sets <span class="math">W_1, \\ldots, W_\\ell</span> have the same</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cardinality. We define <span class="math">V</span> as a “prefix” of <span class="math">\\mathbb{H}</span>, i.e., $V = \\{\\eta, \\dots, \\eta^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\}<span class="math">. Although </span>\\text{lnk}<span class="math">-typed commitments in </span>\\mathsf{CS}^*<span class="math"> are defined for polynomials, we assume a canonical encoding of a vector </span>\\mathfrak{u}<span class="math"> into a polynomial </span>\\hat{\\mathfrak{u}}(X)<span class="math"> via interpolation in </span>V<span class="math">. This means that the Decode algorithm corresponding to the linking relation is the one that outputs </span>\\hat{\\mathfrak{u}}_1(V), \\dots, \\hat{\\mathfrak{u}}_\\ell(V)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-80" class="text-2xl font-bold">Breaking the linking problem in two parts</h2>

    <p class="text-gray-300">Once fixed the setting above, proving the linking between commitments <span class="math">(\\hat{c}_j)_{j\\in [\\ell]}</span> to <span class="math">(\\hat{\\mathbf{u}}_j)_{j\\in [\\ell]}</span> and a commitment <span class="math">c</span> to <span class="math">\\hat{w}</span> requires to prove that there is a vector <span class="math">\\omega</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">(\\hat {\\mathbf {u}} _ {1} (V), \\dots , \\hat {\\mathbf {u}} _ {\\ell} (V), \\omega) = (\\hat {w} (W _ {1}), \\dots , \\hat {w} (W _ {\\ell}), \\hat {w} (W _ {\\ell + 1}))</span></div>

    <p class="text-gray-300">We create a CP-SNARK for this language in two steps. First we show a scheme <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(1)}</span> that proves</p>

    <div class="my-4 text-center"><span class="math-block">(\\hat {u} _ {1} ^ {\\prime} (W _ {1}), \\dots , \\hat {u} _ {\\ell} ^ {\\prime} (W _ {\\ell}), \\omega) = (\\hat {w} (W _ {1}), \\dots , \\hat {w} (W _ {\\ell}), \\hat {w} (W _ {\\ell + 1}))</span></div>

    <p class="text-gray-300">for some freshly committed <span class="math">(\\hat{\\mathbf{u}}_j^{\\prime})_{j\\in [\\ell ]}</span>, and then a scheme <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(2)}</span> that internally runs <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(1)}</span> and additionally proves that for all <span class="math">j\\in [\\ell ]</span>, it holds <span class="math">\\hat{\\mathbf{u}}_j^\\prime (W_j) = \\hat{\\mathbf{u}}_j(V)</span>. Thus, while <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(1)}</span> exclusively proves a correspondence among the polynomials on the same domains <span class="math">W_{j}</span>, <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(2)}</span> proves that (running <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(1)}</span>) plus a correspondence between the <span class="math">W_{j}</span>-s and <span class="math">V</span>.</p>

    <p class="text-gray-300">Finally, at the end of the section, we discuss how to extend these results to support the WitExtract algorithm of our PHPs for R1CS-lite, in which the extractor uses two polynomials <span class="math">\\hat{a}&#x27;(X), \\hat{b}&#x27;(X)</span> (instead of one) and computes the witness as <span class="math">\\pmb{w} := (\\hat{a}&#x27;(\\phi_{\\mathbb{H}}^{-1}(\\ell + 1)) \\cdot \\hat{b}(\\phi_{\\mathbb{H}}^{-1}(\\ell + 1)), \\dots, \\hat{a}&#x27;(\\phi_{\\mathbb{H}}^{-1}(n) \\cdot \\hat{b}(\\phi_{\\mathbb{H}}^{-1}(\\ell + 1)))</span>.</p>

    <h2 id="sec-81" class="text-2xl font-bold">Scheme <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(1)}</span></h2>

    <p class="text-gray-300">We first show a scheme for tuple Decode, WitExtract where <span class="math">W_{i} = V_{i}</span> for all <span class="math">i \\in [\\ell]</span> and the sets are disjoint. In particular, we can consider universal CP-SNARK for <span class="math">\\mathcal{R}_{\\mathrm{link}}</span> where each relation <span class="math">\\mathsf{R}_{\\mathrm{link}}</span> in the family is defined by a list of sets <span class="math">(W_{j})_{j \\in [\\ell]}</span>.</p>

    <p class="text-gray-300">We let <span class="math">\\mathcal{Z}_i(X)</span> be the vanishing polynomial on <span class="math">W_{i}</span>, let <span class="math">\\tilde{\\mathcal{Z}}_i(X) := \\prod_{1 &amp;lt; j &amp;lt; i} \\mathcal{Z}_j(X)</span> (we set <span class="math">\\tilde{\\mathcal{Z}}_1(X) \\equiv 1</span>). Below we assume that there exists an index <span class="math">i^<em> \\in [n^</em>]</span> such that the <span class="math">p_{i^<em>}(\\mathbb{H}) = \\text{WitExtract}((p_j)_{j \\in [n^</em>]})</span>. The intuition of our construction is to let the prover compute an (affine) decomposition of the polynomial <span class="math">p_{i^<em>}(X)</span> using the basis <span class="math">\\mathcal{Z}_1(X), \\ldots, \\mathcal{Z}_\\ell(X)</span>, and similarly compute an (affine) decomposition of the polynomial <span class="math">\\hat{p}_j(X)</span> using the base <span class="math">\\mathcal{Z}_j(X)</span>. If the statement holds then, for any <span class="math">i</span>, the <span class="math">\\mathcal{Z}_i(X)</span>-coefficient of the decomposition of <span class="math">p_{i^</em>}</span> and of the decomposition of <span class="math">\\hat{p}_j</span> are the same polynomials.</p>

    <p class="text-gray-300"><strong>KeyGen</strong><span class="math">_{\\text{link}}^{(1)}(\\text{ck})</span>: execute and output <span class="math">(\\mathsf{ek}_{\\mathsf{opn}}, \\mathsf{vk}_{\\mathsf{opn}}) \\gets \\mathsf{KeyGen}_{\\mathsf{opn}}(\\mathsf{ck})</span>.</p>

    <p class="text-gray-300"><strong>Derive</strong><span class="math">_{\\text{link}}^{(1)}(\\text{srs}, \\mathsf{R})</span>: Parse <span class="math">\\mathsf{R}</span> as <span class="math">(W_j)_{j \\in [\\ell]}</span> and output <span class="math">\\mathsf{vk}_{\\mathsf{R}} = ([\\mathcal{Z}_i(s)]_2, [\\tilde{\\mathcal{Z}}_i(s)]_2)_{j \\in [\\ell]}</span>.</p>

    <p class="text-gray-300"><strong>Prove</strong><span class="math">_{\\text{link}}^{(1)}(\\text{ek}, ((\\hat{c}_j)_{j \\in [\\ell]}, (c_j)_{j \\in [n^<em>]}), ((\\mathfrak{u}_j)_{j \\in [\\ell]}, (p_j)_{j \\in [n^</em>]}), ((\\hat{o}_j)_{j \\in [\\ell]}, (o_j)_{j \\in [n^*]}))</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i \\in [\\ell]</span> compute <span class="math">q_i(X), \\mathfrak{u}_i&#x27;(X)</span> such that <span class="math">\\mathfrak{u}_i(X) \\equiv q_i(X) \\mathcal{Z}_i(X) + \\mathfrak{u}_i&#x27;(X)</span>.</li>

    </ol>

    <p class="text-gray-300">Sample <span class="math">\\gamma_i \\leftrightarrows \\mathbb{F}</span>, set <span class="math">o_i&#x27; = \\mathcal{Z}_i(X)\\gamma_i + o_i</span> and</p>

    <div class="my-4 text-center"><span class="math-block">c _ {i} ^ {\\prime} = \\left[ u _ {i} ^ {\\prime} (s) + \\alpha o _ {i} ^ {\\prime} (s) \\right] _ {1}, \\quad \\left[ d _ {i} \\right] = \\left[ q _ {i} (s) - \\alpha \\gamma_ {i} \\right].</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">p \\coloneqq p_{i*}</span> and compute the polynomial <span class="math">q(X)</span> such that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">p (X) - \\sum_ {i \\in [ \\ell ]} \\tilde {\\mathcal {Z}} _ {i} (X) \\cdot \\mathfrak {u} _ {i} ^ {\\prime} (X) \\equiv \\hat {\\mathcal {Z}} _ {\\ell + 1} (X) \\cdot q (X)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">\\beta (X) = \\beta_0 + X\\beta_1</span> random polynomial of degree 1 and set</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">[ d ] _ {1} \\leftarrow [ q (s) + \\alpha \\beta (s)) ] _ {1}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">19 We parse the evaluation of a polynomial <span class="math">p(W)</span> on an ordered set <span class="math">W</span> as a vector in $\\mathbb{F}^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">60</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathfrak {R} _ {\\mathrm {o p n}} \\leftarrow \\operatorname {P r o v e} _ {\\mathrm {o p n}} \\left( \\begin{array}{c} \\hat {\\mathbf {x}} = \\left((\\hat {c} _ {j}) _ {j \\in [ \\ell ]}, c _ {i ^ {*}}, (c _ {j} ^ {\\prime}) _ {j \\in [ \\ell ]}, ([ d _ {j} ] _ {1}) _ {j \\in [ \\ell ]}, [ d ] _ {1}\\right), \\\\ \\mathbf {e k} _ {\\mathrm {o p n}}, \\hat {\\mathbf {w}} = \\left((\\mathfrak {u} _ {j}) _ {j \\in [ \\ell ]}, p, (\\mathfrak {u} _ {j} ^ {\\prime}) _ {j \\in [ \\ell ]}, (q _ {j}) _ {j \\in [ \\ell ]}, q\\right), \\\\ ((\\hat {o} _ {j}) _ {j \\in [ \\ell ]}, 0, (\\beta_ {j}) _ {j \\in [ \\ell ]}, (\\gamma_ {j}) _ {j \\in [ \\ell ]}, \\beta) \\end{array} \\right)</span></div>

    <p class="text-gray-300">(Namely, a proof for the opening for all the commitments to polynomials computed up to here and the all the commitments of the instance.)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prove that indeed <span class="math">p(X) - \\sum_{i\\in [\\ell ]}\\hat{\\mathcal{Z}}_i(X)\\cdot \\mathfrak{u}_i&#x27;(X)\\equiv \\hat{\\mathcal{Z}}_{\\ell +1}(X)\\cdot q(X)</span> using random point evaluation.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Specifically, let $\\tau = \\big((\\hat{c}_j)_{j\\in [\\ell ]}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(c_j)_{j\\in [n^* ]}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(c_j')_{j\\in [\\ell ]}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">([d_i]_1)_{i\\in [\\ell ]}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">[d]_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\mathrm{opn}}\\big)<span class="math">. Let </span>x\\gets H(\\tau)<span class="math"> and let </span>\\tilde{o} (X)\\coloneqq -\\beta (X)\\hat{\\mathcal{Z}}_{\\ell +1}(X) - \\sum_{j}o_{j}^{\\prime}\\hat{\\mathcal{Z}}_{j}(X)<span class="math">, compute </span>z = \\tilde{o} (x)<span class="math">, let </span>w(X)<span class="math"> be the polynomial such that </span>w(X)\\cdot (X - x)\\equiv \\tilde{o} (X) - z$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">(\\pi_{\\mathrm{opn}},(c_j^{\\prime})_{j\\in [\\ell ]},[(d_j)_{j\\in [\\ell ]},d,\\alpha w(s)]_1,z)</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{Verify}_{\\mathsf{link}}^{(1)}(\\mathsf{ck},c,(\\hat{c}_j)_{j\\in [\\ell ]},\\pi)</span>: Parse <span class="math">\\pi = (\\pi_{\\mathrm{opn}},(c_j^{\\prime})_{j\\in [\\ell ]},[(d_j)_{j\\in [\\ell ]},d,w]_1,z)</span>; then output 1 if all the following holds:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">j \\in [\\ell]</span> check <span class="math">e(\\hat{c}_j, [1]_2) = e([d_j]_1, [\\mathcal{Z}_i(s)]_2) + e(c_j&#x27;, [1]_2)</span>.</li>

      <li><span class="math">\\mathsf{Verify}_{\\mathsf{opn}}(\\mathsf{vk}_{\\mathsf{opn}},((\\hat{c}_j)_{j\\in [\\ell ]},c_{i^*},(c_j&#x27;)_{j\\in [\\ell ]},([d_j]_1)_{j\\in [\\ell ]},[d]_1),\\pi_{\\mathsf{opn}}) = 1,</span></li>

      <li><span class="math">e([w]_1,[s - x]) = e(c,[1]_2) - e([d]_1,[\\hat{\\mathcal{Z}}_{\\ell +1}(s)]_2) - \\sum_{i\\in [\\ell ]}e(c_i&#x27;,[\\hat{\\mathcal{Z}}_i(s)]_2) - [\\alpha z]_T.</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency of <span class="math">\\mathsf{CP}_{\\mathsf{link}}^{(1)}</span>. This analysis ignores the costs of <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span>. Generating a proof requires $O(\\ell</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> </span>\\mathbb{F}<span class="math">-operations, plus a total of </span>n + \\ell</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\ell<span class="math"> exponentiations in </span>\\mathbb{G}_1<span class="math">. Proof size is </span>2\\ell + 2<span class="math"> group elements </span>(\\mathbb{G}_1)<span class="math"> and one field element. Verification requires </span>3\\ell + 3$ pairings. A breakdown for the exponentiations of the prover follows:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\ell</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> to commit to the </span>c_j^{\\prime}$-s;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\ell O(1)</span> to commit to the <span class="math">d_{j}</span>-s;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $n - \\ell</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for </span>[d]<span class="math"> (we commit to </span>q<span class="math">, which is of maximum degree </span>n - \\ell</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme <span class="math">\\mathsf{CP}_{\\mathsf{link}}^{(2)}</span>. We show a scheme for tuple Decode, WitExtract where there exists a subset <span class="math">V</span> of a subgroup <span class="math">\\mathbb{H} = \\langle \\eta \\rangle</span> of <span class="math">\\mathbb{F}</span>, and let the values for <span class="math">j \\in [\\ell]</span> $\\theta_j = \\eta^{j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> (recall that in our PHPs for R1CS of Section 4.4, the polynomial </span>\\hat{w}<span class="math">, which &quot;encodes&quot; the witness, also contains the instance </span>\\mathbf{x}<span class="math">) and set </span>W_j = \\theta_j \\cdot V<span class="math">. (We can assume that </span>\\mathbb{H}<span class="math"> is big enough so that </span>W_j \\neq W_{j'}<span class="math"> for all </span>j, j'<span class="math"> where </span>j \\neq j'$.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The intuition is to first "shift" the polynomials <span class="math">\\mathfrak{u}_j</span> computing polynomials <span class="math">\\mathfrak{u}_j&#x27;</span> such that <span class="math">\\mathfrak{u}_j(V) = \\mathfrak{u}_j&#x27;(\\theta_j \\cdot V)</span> and secondly to apply the CP-SNARK <span class="math">\\mathsf{CP}_{\\mathsf{link}}^{(1)}</span>. To prove the soundness of the shifted polynomials we make black-box use of <span class="math">\\mathsf{CP}_{\\mathsf{eq}}</span> from the previous section, however the scheme is only leaky zero-knowledge, thus to obtain zero-knowledge we additionally need to randomize the polynomials <span class="math">\\mathfrak{u}_j&#x27;</span>.</p>

    <p class="text-gray-300">KeyGen(2) (ck): execute <span class="math">(\\mathsf{ek}_{\\mathsf{eval}},\\mathsf{vk}_{\\mathsf{eval}})\\gets \\mathsf{KeyGen}_{\\mathsf{eq}}(\\mathsf{ck})</span> execute <span class="math">(\\mathsf{ek}_{\\mathsf{link}}^{(1)},\\mathsf{vk}_{\\mathsf{link}}^{(1)})\\gets \\overline{\\mathsf{KeyGen}}_{\\mathsf{link}}^{(1)}(\\mathsf{ck})</span> and return <span class="math">\\mathsf{srs} := ((\\mathsf{ek}_{\\mathsf{eq}},\\mathsf{ek}_{\\mathsf{link}}^{(1)}),(\\mathsf{vk}_{\\mathsf{eq}},\\mathsf{vk}_{\\mathsf{link}}^{(1)}))</span>.</p>

    <p class="text-gray-300">Derive(2) (srs, R): Parse R as <span class="math">V, (W_j)_{j \\in [\\ell]}</span>, compute <span class="math">\\mathsf{vk}_{\\mathsf{R}}^{(1)} \\gets \\mathsf{CP}_{\\mathsf{link}}^{(1)}</span>. Derive(srs, R), and output specialized key <span class="math">\\mathsf{vk}_{\\mathsf{R}} = (\\mathsf{vk}_{\\mathsf{R}}^{(1)}, ([\\mathcal{Z}_i(s)]_1)_{j \\in [\\ell]})</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Prove}_{\\mathsf{link}}^{(2)}(\\mathsf{ek},\\hat{\\mathbf{x}} = ((\\hat{c}_j)_{j\\in [\\ell ]},(c_j)_{j\\in [n^<em> ]}),((\\mathfrak{u}_j)_{j\\in [\\ell ]},(p_j)_{j\\in [n^</em> ]}),((\\hat{o}_j)_{j\\in [\\ell ]},(o_j)_{j\\in [n^* ]}))</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any <span class="math">j \\in [\\ell]</span> let:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathfrak {u} _ {j} ^ {\\prime} (X) = \\mathfrak {u} _ {j} (X / \\theta_ {j}) + \\mathcal {Z} _ {V} (X / \\theta_ {j}) \\beta_ {j} (X / \\theta_ {j}),</span></div>

    <p class="text-gray-300">where <span class="math">\\beta_{j}(X)</span> is a uniformly random degree-2 polynomial in <span class="math">\\mathbb{F}[X]</span>. Set <span class="math">c_j&#x27; = [\\mathfrak{u}_j&#x27;(s)]_1</span> for <span class="math">j \\in [\\ell]</span>.</p>

    <p class="text-gray-300">61</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prove that for <span class="math">j \\in [\\ell]</span>, <span class="math">\\mathsf{u}_j(X)</span> and <span class="math">\\mathsf{u}_j&#x27;(\\theta_j \\cdot X)</span> agree on <span class="math">V</span>, namely, prove that <span class="math">\\mathsf{u}_j(X) - \\mathsf{u}_j&#x27;(\\theta_j X) \\equiv 0 \\mod \\mathcal{Z}_V(X)</span> using <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span>.</li>

    </ol>

    <p class="text-gray-300">Specifically, compute <span class="math">h_j(X)</span> such that <span class="math">h_j(X)\\mathcal{Z}_V(X) \\equiv \\mathsf{u}_j(X) - \\mathsf{u}_j&#x27;(X\\theta_j)</span> and set <span class="math">\\mathsf{h}_j = [h_j(s)]_1</span> for <span class="math">j \\in [\\ell]</span>; Let</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} G_j(X, (X_j)_{j \\in [3\\ell + 1]}) = X_i - X_{2i} - X_{3i} \\cdot X_{3\\ell + 1} \\quad j \\in [\\ell], \\\\ v_j(X) = \\left\\{ \\begin{array}{ll} X &amp;amp; j \\in [\\ell] \\cup [2\\ell + 1, 3\\ell] \\\\ \\theta_j X &amp;amp; j \\in [\\ell + 1, 2\\ell] \\end{array} \\right. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">and set <span class="math">\\pmb{v} = (v_j)_{j \\in [3\\ell]}</span>. Compute <span class="math">\\pi_{\\mathrm{eq}}</span> as the output of</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf{Prove}_{\\mathrm{eq}}((G_i, \\boldsymbol{v})_{i \\in [\\ell]}, (\\hat{c}_j)_{j \\in [\\ell]}, (c_j&#x27;)_{j \\in [\\ell]}, (\\mathsf{h}_j)_{j \\in [\\ell]}, \\\\ [\\mathcal{Z}_V(s)]_1, \\quad ((u_j)_{j \\in [\\ell]}, (u_j&#x27;)_{j \\in [\\ell]}, (h_j)_{j \\in [\\ell]}), \\quad ((o_j)_{j \\in [\\ell]}, \\mathbf{0}) \\\\ \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\pi \\gets \\mathsf{CP}_{\\mathrm{link}}^{(1)} \\cdot \\overline{\\mathsf{Prove}}(\\mathsf{ek}_{\\mathrm{link}}^{(1)}, (([\\mathsf{u}_j&#x27;(s)]_1)_{j \\in [\\ell]}, (c_j)_{j \\in [n^<em>]}), ((u_j&#x27;)_{j \\in [\\ell]}, (o_j)_{j \\in [n^</em>]}), 0).</span></li>

      <li>Output <span class="math">\\pi = ((c_j&#x27;)_{j \\in [\\ell]}, (\\mathsf{h}_j)_{j \\in [\\ell]}, \\pi_{\\mathrm{eq}}, \\pi_{\\mathrm{link}})</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{Verify}^{(2)}(\\mathsf{vk}_{\\mathrm{link}}, c, (\\hat{c}_j)_{j \\in [\\ell]}, \\pi)</span>: Parse <span class="math">\\pi = ((c_j&#x27;)_{j \\in [\\ell]}, (\\mathsf{h}_j)_{j \\in [\\ell]}, \\pi_{\\mathrm{eq}}, \\pi_{\\mathrm{link}})</span> output 1 iff:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Verify}_{\\mathrm{eq}}(\\mathsf{vk}_{\\mathrm{eq}},(G_i,\\pmb {v})_{i\\in [\\ell]},(\\hat{c}_j)_{j\\in [\\ell]},(c_j&#x27;)_{j\\in [\\ell]},(\\mathsf{h}_j)_{j\\in [\\ell]},[\\mathcal{Z}_V(s)]_1,\\pi_{\\mathrm{eq}}) = 1.</span></li>

      <li><span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(1)} \\cdot \\overline{\\mathsf{Verify}}(\\mathsf{vk}_{\\mathrm{link}}^{(1)}, ((c_j&#x27;)_{j \\in [\\ell]}, (c_j)_{j \\in [n^*]}), \\pi_{\\mathrm{link}}) = 1.</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficiency of <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(2)}</span>. We ignore the costs of <span class="math">\\mathsf{CP}_{\\mathrm{opn}}</span> in the efficiency analysis. For <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(2)}</span> generating a proof requires the computation of <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(1)}</span> and additionally <span class="math">2\\ell</span> multi-exponentiations with basis of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and a proof for </span>\\mathsf{CP}_{\\mathrm{eq}}<span class="math"> that costs approximately 2 multi-exponentiations with basis of size </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. In total the prover carries out </span>n + 3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\ell + 2) + \\ell<span class="math">. The total proof size is </span>4\\ell + 3<span class="math"> group elements </span>(\\mathbb{G}_1)<span class="math">, plus one field element. We observe that the proof size goes down to </span>4\\ell + 2<span class="math"> if we can batch the </span>\\mathsf{CP}_{\\mathrm{eq}}<span class="math"> proof with other </span>\\mathsf{CP}_{\\mathrm{eq}}<span class="math"> proofs used in the compiler, as we do in our resulting CP-SNARKs. The verifier complexity reduces to </span>\\ell + 4<span class="math"> pairings ( </span>\\ell + 3$ applying the batching techniques mentioned above).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Extension for the WitExtract of our PHPs for R1CS-lite. We discuss how to support the WitExtract algorithm of our PHPs for R1CS-lite. Let us recall that this algorithm uses the two polynomials <span class="math">\\hat{a}&#x27;(X), \\hat{b}&#x27;(X)</span> and computes the witness as <span class="math">\\pmb{w} := (\\hat{a}&#x27;(\\phi_{\\mathbb{H}}^{-1}(\\ell + 1)) \\cdot \\hat{b}(\\phi_{\\mathbb{H}}^{-1}(\\ell + 1)), \\dots, \\hat{a}&#x27;(\\phi_{\\mathbb{H}}^{-1}(n) \\cdot \\hat{b}(\\phi_{\\mathbb{H}}^{-1}(\\ell + 1)))</span>.</p>

    <p class="text-gray-300">Given the scheme <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(2)}</span> described above, which supports the WitExtract algorithm for a single polynomial, we can obtain a scheme that supports the WitExtract of our PHPs for R1CS-lite with the following simple extension. The prover computes a commitment to a polynomial <span class="math">\\hat{c}&#x27;(X)</span> such that <span class="math">\\forall \\eta \\in \\mathbb{H} : \\hat{c}&#x27;(\\eta) = \\hat{a}&#x27;(\\eta) \\cdot \\hat{b}&#x27;(\\eta)</span>, proves that this is the case, and then runs the proving algorithm of <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(2)}</span> for the single polynomial <span class="math">\\hat{c}&#x27;(X)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The proof for <span class="math">\\forall \\eta \\in \\mathbb{H} : \\hat{c}&#x27;(\\eta) = \\hat{a}&#x27;(\\eta) \\cdot \\hat{b}&#x27;(\\eta)</span> can be done by committing to the polynomial <span class="math">h(X) := (\\hat{a}&#x27;(X) \\cdot \\hat{b}&#x27;(X) - \\hat{c}&#x27;(X)) / \\mathcal{Z}_{\\mathbb{H}}(X)</span> and then showing that <span class="math">h(X) \\cdot \\mathcal{Z}_{\\mathbb{H}}(X) - \\hat{a}&#x27;(X) \\cdot \\hat{b}&#x27;(X) + \\hat{c}&#x27;(X) = 0</span>. The latter equation check can be added to the set of equations already proven in <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(2)}</span> using <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span>. The <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(2)}</span> CP-SNARK with this extension requires: <span class="math">2n</span> more exponentiations in <span class="math">\\mathbb{G}_1</span> to commit to <span class="math">\\hat{c}&#x27;(X)</span> and <span class="math">h(X)</span>, two more commitments, and finally the cost of the evaluation proof used in <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span> gets increased: instead of 2 multi-exponentiations with basis of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, it is one multi-exponentiation with basis of size </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and another multi-exponentiation with basis of size </span>n$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-82" class="text-2xl font-bold">Security of <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(1)}</span></h2>

    <p class="text-gray-300">Theorem 17. If <span class="math">\\mathsf{CP}_{\\mathrm{opn}}</span> is a CP-SNARK for <span class="math">\\mathcal{R}_{\\mathrm{opn}}</span>, and <span class="math">\\mathsf{CP}_{\\mathrm{deg}}</span> is a CP-SNARK for <span class="math">\\mathsf{R}_{\\mathrm{deg}}</span>, then <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(1)}</span> is <span class="math">\\{\\mathsf{swh},\\mathsf{lnk}\\}^{\\ell} \\times (\\mathsf{swh})^{n^*}</span>-restricted complete, knowledge-sound, and zero-knowledge. Moreover, if <span class="math">\\mathsf{CP}_{\\mathrm{opn}}</span> and <span class="math">\\mathsf{CP}_{\\mathrm{deg}}</span> have commitment-only SRS then <span class="math">\\mathsf{CP}_{\\mathrm{eval},1}</span> has a commitment-only SRS.</p>

    <p class="text-gray-300">Proof. We start with completeness. The check in step 1 holds in fact:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} e([d_j]_1, [\\mathcal{Z}_i(s)]_2) + e(c_j&#x27;, [1]_2) = \\\\ = [(q_i(s) + \\alpha\\beta_i)\\mathcal{Z}_i(s) + \\mathfrak{u}&#x27;(s) - \\alpha(\\mathcal{Z}_i(s)\\beta_i + o_i)]_T = \\\\ = [q_i(s)\\mathcal{Z}_i(s) + \\mathfrak{u}&#x27;(s) + \\alpha o_i]_T = e([\\hat{c}_i]_1, [1]_2) \\end{array}</span></div>

    <p class="text-gray-300">The check in step 2 of the verifier holds by the completeness of <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span>. For the last check, notice the relation <span class="math">\\mathsf{R}_{\\mathrm{link}}</span> can be expressed as <span class="math">\\forall i \\in [\\ell] : p_{i^*}(W_i) = \\mathfrak{u}_i(W_i)</span>. By the definition of the <span class="math">\\mathfrak{u}_i&#x27;(X)</span> we have <span class="math">\\mathfrak{u}_i(W_i) = \\mathfrak{u}_i&#x27;(W_i)</span> for <span class="math">i \\in [\\ell]</span>. Moreover:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} e(c_{i^*}, [1]_2) - e([d]_1, [\\hat{\\mathcal{Z}}_{\\ell+1}(s)]_2) - \\sum_{i \\in [\\ell]} e(c_i&#x27;, [\\hat{\\mathcal{Z}}_i(s)]_2) - [\\alpha z]_T \\\\ = \\underbrace{[p_{i^*}(s) - q(s)\\hat{\\mathcal{Z}}_{\\ell+1}(s) - \\sum_{i \\in [\\ell]} \\hat{\\mathcal{Z}}_i(s) \\cdot \\mathfrak{u}_i&#x27;(s)}_{=0} + \\alpha(o - \\beta(s)\\hat{\\mathcal{Z}}_{\\ell+1}(s) - \\sum_{j} o_j \\hat{\\mathcal{Z}}_j(s) - \\tilde{o}(x))]_T \\\\ = [\\alpha(\\tilde{o}(s) - \\tilde{o}(z))]_T = [\\alpha w(s) \\cdot (s - x)]_T = e([w]_1, [s - x]_2) \\end{array}</span></div>

    <p class="text-gray-300">Now we move to knowledge soundness.</p>

    <p class="text-gray-300">Let <span class="math">d(X), o_d(X), p(X), o_p(X), (\\mathfrak{u}_j)_{j \\in [\\ell]}, (\\hat{o}_j)_{j \\in [\\ell]}, (d_j, \\mathfrak{u}_j, \\mathfrak{u}_j&#x27;, o_{d_j}, o_{\\mathfrak{u}_j}, o_{\\mathfrak{u}_j&#x27;})_{j \\in [\\ell]}</span> be the output of the extractor of <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span>. First we show that for any <span class="math">j</span> and <span class="math">\\eta \\in W_i</span> it must be <span class="math">\\mathfrak{u}&#x27;(\\eta) = \\mathfrak{u}(\\eta)</span>. In fact, suppose not, if <span class="math">o_{\\mathfrak{u}_j}(s) - o_{\\mathfrak{u}_j&#x27;}(s) - o_{q_j}(X)v_j(s) = 0</span> then it must be that <span class="math">P_j(X) := \\mathfrak{u}_j(X) - \\mathfrak{u}_j&#x27;(X) - q_j(X)\\mathcal{Z}_j(X) \\not\\equiv 0</span>, since the third equation of the verifier holds then <span class="math">s</span> is a zero of the polynomial <span class="math">P_j</span>. Thus we can break the <span class="math">d</span>-DLOG assumption. The other case is when <span class="math">o_{\\mathfrak{u}_j}(s) - o_{\\mathfrak{u}_j&#x27;}(s) - o_{q_j}(s)v_j(s) \\neq 0</span>, in this we could sample <span class="math">s</span> and on challenge the value <span class="math">[\\alpha]_1</span>, since the third equation of the verifier holds, we can compute the value <span class="math">\\alpha</span> as <span class="math">(\\mathfrak{u}_j(s) - \\mathfrak{u}_j&#x27;(s) - q_j(s)\\mathcal{Z}_j(s)) / (o_{\\mathfrak{u}_j}(s) - o_{\\mathfrak{u}_j&#x27;}(s) - o_{q_j}(s)\\mathcal{Z}_j(s))</span>.</p>

    <p class="text-gray-300">Suppose <span class="math">\\exists i, \\eta : p_{i^*}(\\eta) \\neq \\mathfrak{u}_i(\\eta) = \\mathfrak{u}_i&#x27;(\\eta)</span> and <span class="math">\\eta \\in W_i</span>. We let:</p>

    <div class="my-4 text-center"><span class="math-block">P(X) := p(X) - \\hat{\\mathcal{Z}}_{\\ell+1}(X) d(X) - \\sum_j \\hat{\\mathcal{Z}}_j(X) \\hat{p}_j(X)</span></div>

    <p class="text-gray-300">Notice that the Eq. 3 of the verification algorithm implies that <span class="math">P(x) = 0</span> and <span class="math">x</span> is uniformly random and independent of <span class="math">P(X)</span> because <span class="math">x</span> is sampled after the proof <span class="math">\\pi_{\\mathrm{opn}}</span> is computed (and therefore the polynomial can be extracted before <span class="math">x</span> is sampled). By the Swartz-Zippel lemma we have that <span class="math">P(X) \\equiv 0</span>. The proof that <span class="math">P(x) = 0</span> follows the same line of the proof of knowledge soundness of <span class="math">\\mathsf{CP}_{\\mathrm{eval},1}</span>, therefore omitted. By our hypothesis, the polynomial <span class="math">P(X)</span> on point <span class="math">\\eta</span> evaluates to <span class="math">p(\\eta) - \\hat{p}_i(\\eta) \\neq 0</span>, which leads to a contradiction.</p>

    <p class="text-gray-300">We now prove zero-knowledge. We can simulate <span class="math">\\pi_{\\mathrm{opn}}</span> using the simulator of <span class="math">\\mathsf{CP}_{\\mathrm{opn}}</span>, moreover, given the trapdoor <span class="math">s</span> for any <span class="math">j \\in [\\ell]</span> we can sample a random value <span class="math">r_j</span> and set <span class="math">c_j&#x27; = [r_j]_1</span> and set <span class="math">[q_j] = (\\hat{c}_j - c_j&#x27;) / \\mathcal{Z}_i(s)</span> and we can sample <span class="math">d, z \\leftrightarrows \\mathbb{Z}_q</span> and define <span class="math">[w]_1 = [\\alpha \\tilde{o}(s) - \\tilde{o}(x)]_1 / (s - x)</span>.</p>

    <p class="text-gray-300">We show this is indistinguishable from the real distribution with an hybrid argument. In the first hybrid we are additionally given the witness <span class="math">p, (\\hat{p}_j)_{j \\in [\\ell]}, o, (\\hat{o}_j)_{j \\in [\\ell]}</span>. We compute the proofs <span class="math">\\pi_{\\mathrm{deg}}, \\pi_{\\mathrm{opn}}</span> as the real prover would do and we compute the value <span class="math">q(s)</span>, which is deterministically defined given the witness, we sample <span class="math">d, z</span> as in the simulator and then compute <span class="math">\\beta_0, \\beta_1</span> such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} q(s) + \\alpha(\\beta + s\\beta_1) = d \\\\ o - (\\beta_0 + x\\beta_1) - \\sum_j \\hat{\\mathcal{Z}}_j(s) o_j = z \\end{array} \\right.</span></div>

    <p class="text-gray-300">The group element <span class="math">[w]_1</span> is computed as the simulator does. Notice the marginal distribution of <span class="math">\\beta_0, \\beta_1</span> is the uniform distribution over <span class="math">\\mathbb{Z}_q^2</span>.</p>

    <p class="text-gray-300">In the next hybrid we sample <span class="math">d, z</span> at random, compute <span class="math">\\beta(X) \\coloneqq \\beta_0 + X\\beta_1</span> as described before, compute <span class="math">d&#x27; = q(s) + \\alpha\\beta(s)</span> and <span class="math">z&#x27; = \\tilde{o}(x)</span> Compute <span class="math">[w]_1</span> as in the simulator and output <span class="math">(\\pi_{\\mathrm{opn}}, \\pi_{\\mathrm{deg}}, [d&#x27;, w]_1, z&#x27;)</span>. This hybrid is equivalent to the previous one in fact <span class="math">d&#x27; = d</span> and <span class="math">z&#x27; = z</span>.</p>

    <p class="text-gray-300">In the last hybrid we compute the proof <span class="math">[w]_1</span> in the same way the prover does. Notice that once fixed the witness and <span class="math">d&#x27;, z&#x27;</span> the value <span class="math">w</span> is completely determined, thus the two hybrids are equivalent.</p>

    <p class="text-gray-300">Security of <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(2)}</span>. We will use the leaky-zero knowledge of <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span>. Before stating the theorem we describe the checker C that upon input an index and a value <span class="math">c \\in \\mathbb{F}</span> outputs 1 if and only if <span class="math">x \\notin \\mathbb{H}</span>. Moreover, we require from <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span> to be leaky zero-knowledge only for the input commitments <span class="math">(c_j&#x27;)_{j \\in [\\ell]}</span>. As noted in Remark 13 this is the case for our <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span>.</p>

    <p class="text-gray-300">Theorem 18. If <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span> is a CP-SNARK for <span class="math">\\mathsf{R}_{\\mathrm{eq}}</span>, and <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(1)}</span> is <span class="math">CP - SNARK</span> for <span class="math">\\mathsf{R}_{\\mathrm{link}}</span> then <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(2)}</span> is <span class="math">(\\ln k)^{\\ell} \\times (\\swh)^{n^{*}}</span>-restricted complete, knowledge-sound. Moreover if <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span> is <span class="math">((0^{\\ell}, 1^{\\ell}, 0^{\\ell}), \\mathsf{C})</span>-leaky zero-knowledge then <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(2)}</span> is zero-knowledge. Moreover, if <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(1)}</span> and <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span> have commitment-only SRSs then <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(2)}</span> has commitment-only SRS.</p>

    <p class="text-gray-300">Proof. We start with completeness. Notice that by definition of <span class="math">\\mathfrak{u}_j&#x27;(X)</span> for <span class="math">j \\in [\\ell]</span>, we have that <span class="math">\\mathfrak{u}_j(V) = \\mathfrak{u}_j&#x27;(\\theta_j \\cdot V)</span>. Thus, by definition of <span class="math">h_j(X)</span> and by the completeness of <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span> the first check of the verifier holds. By definition of WitExtract, for any <span class="math">j \\in [\\ell]</span> the value <span class="math">\\mathfrak{u}_j&#x27;(\\theta_j \\cdot V)</span> and <span class="math">p^*(\\theta_j \\cdot V)</span> agree thus by the completeness of <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(1)}</span> the third check of the verifier holds.</p>

    <p class="text-gray-300">We prove knowledge soundness. From the extractor of <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span> we can extract the polynomials <span class="math">(\\hat{\\mathbf{u}}_j)_{j\\in [\\ell]}</span> with the opening material <span class="math">(\\hat{o}_j)_{j\\in [\\ell]}</span> such that <span class="math">\\hat{\\mathbf{u}}_j(V) = \\mathbf{u}_j&#x27;(\\theta_jV)</span>. By the knowledge soundness of <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(1)}</span> we have for all <span class="math">j\\in [\\ell]</span>, <span class="math">\\mathbf{u}_j(V) = \\mathbf{u}_j&#x27;(\\theta_jV) = p^*(\\theta_jV)</span>.</p>

    <p class="text-gray-300">Finally, we prove zero-knowledge. Let <span class="math">S_{\\mathrm{eq}} = (S_{\\mathrm{leak}}, S)</span> be the simulator of <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span>. The simulator, for any <span class="math">j \\in [\\ell]</span>, sample <span class="math">c_j&#x27;, h_j</span> uniformly at random from <span class="math">\\mathbb{G}_1</span>. Then, let <span class="math">\\hat{\\mathbf{x}}_{\\mathrm{eq}} = (G_j, \\mathbf{v})_{j \\in [3\\ell]}, ((\\hat{c}_j)_{j \\in [\\ell]}, (c_j&#x27;)_{j \\in [\\ell]}, (h_j)_{j \\in [\\ell]})</span>, it runs <span class="math">S_{\\mathrm{leak}}(1^{\\lambda}, \\hat{\\mathbf{x}}_{\\mathrm{eq}})</span> of <span class="math">\\mathsf{CS}_{\\mathrm{eq}}</span> and obtains <span class="math">\\{(j, x_j)\\}_{j \\in [\\ell+1,2\\ell]}</span>. It samples uniformly random value <span class="math">Leak = (y_j)_{j \\in [\\ell+1,2\\ell]}</span> and runs <span class="math">S(\\mathrm{td}, \\hat{\\mathbf{x}}_{\\mathrm{eq}}, Leak)</span> obtaining <span class="math">\\pi_{\\mathrm{eq}}</span>. Then it simulates the proof <span class="math">\\pi_{\\mathrm{link}}^{(1)}</span> using the simulator of <span class="math">\\mathsf{CP}_{\\mathrm{link}}^{(1)}</span>.</p>

    <p class="text-gray-300">Through an hybrid argument we can show that the proof is statistically close to a proof where for any <span class="math">j \\in [\\ell]</span> the value <span class="math">c_j&#x27;, h_j</span> are computed as in the real proof and the value <span class="math">y_j</span> is computed as <span class="math">\\mathfrak{u}&#x27;(x_j)</span>. Indeed, for any fixed polynomial <span class="math">\\mathfrak{u}_j(X)</span>, the following system of equations hold:</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} \\mathfrak {u} _ {j} ^ {\\prime} (s) = \\mathfrak {u} _ {j} (s / \\theta_ {j}) + \\mathcal {Z} _ {V} (s / \\theta_ {j}) \\cdot \\beta_ {j} (s / \\theta_ {j}) \\\\ h _ {j} (s) = (\\mathfrak {u} (s) - \\mathfrak {u} ^ {\\prime} (\\theta_ {j} s)) / \\mathcal {Z} _ {V} (s) = \\beta_ {j} (s) \\\\ y _ {j} = \\mathfrak {u} _ {j} (x _ {j} / \\theta_ {j}) + \\mathcal {Z} _ {V} (x _ {j} / \\theta_ {j}) \\cdot \\beta_ {j} (x _ {j} / \\theta_ {j}) \\end{array} \\right.</span></div>

    <p class="text-gray-300">Recall that <span class="math">\\beta_{j}(X)</span> is an uniformly random degree-2 polynomial thus the tuple <span class="math">\\beta_{j}(s / \\theta_{j}),\\beta_{j}(s),\\beta_{j}(x_{j} / \\theta_{j})</span> is uniformly random over <span class="math">\\mathbb{F}^3</span> with overwhelming probability (it is not when <span class="math">x_{j} / \\theta_{j}\\in \\{s,s / \\theta_{j}\\}</span> or when <span class="math">s\\in V</span>). Therefore they are uniformly distributed as sampled by the simulator.</p>

    <p class="text-gray-300">We can conclude the proof of zero-knowledge through another hybrid step where we switch the simulated proofs <span class="math">\\pi_{\\mathrm{link}}^{(1)}</span> and <span class="math">\\pi_{\\mathrm{eq}}</span> with real proof.</p>

    <p class="text-gray-300">We describe different options to obtain universal zkSNARKs in the SRS model by applying our compiler from Section 6 to our PHP constructions of Sections 4.3-4.4 and our CP-SNARKs for pairing-based polynomial commitments of Section 7. The results are a collection of zkSNARKs that offer different tradeoffs in terms of (mainly) SRS size, proof size, and verification time. Some preliminary experimental evaluations of our zkSNARKs are gathered in Appendix D.</p>

    <p class="text-gray-300">We discuss how to combine the aforementioned CP-SNARKs for committed polynomials to obtain CP-SNARKs for the <span class="math">\\mathcal{R}_{\\mathrm{php}}</span> relations corresponding to our PHPs. All our PHPs have a similar structure in which the verifier checks consist of one vector <span class="math">\\pmb{d}</span> of degree checks, and two polynomial checks <span class="math">((G_1,\\pmb{v}_1),(G_2,\\pmb{v}_2))</span>. Hence, for each PHP the corresponding relation <span class="math">\\mathcal{R}_{\\mathrm{php}}</span> can be obtained via the product of</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {R} _ {\\mathrm {d e g}} ((d _ {j}) _ {j \\in [ n _ {e} ]}, (p _ {j}) _ {j \\in [ n (0) + 1, n ^ {*} ]}) \\wedge \\mathsf {R} _ {\\mathrm {e q}} ((G _ {1} ^ {\\prime}, \\boldsymbol {v} _ {1}), (p _ {j}) _ {j \\in [ n ^ {*} ]}) \\wedge \\mathsf {R} _ {\\mathrm {e q}} ((G _ {2} ^ {\\prime}, \\boldsymbol {v} _ {2}), (p _ {j}) _ {j \\in [ n ^ {*} ]})</span></div>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 4. Different options to compile our PHPs. We mark compatibility with commitment schemes  <span class="math">\\mathsf{CS}_1</span>  and  <span class="math">\\mathsf{CS}_2</span>  respectively by a circle and a square (both shapes mean full compatibility). Dotted lines mean either option is possible. An index 1 or 2 for an arrow to  <span class="math">\\mathsf{R}_{\\mathrm{eq}}</span>  denotes whether it refers to the first or second polynomial check.</p>

    <p class="text-gray-300">where  <span class="math">G_{i}^{\\prime}</span>  is the partial evaluation of  <span class="math">G_{i}</span>  on the prover message  <span class="math">\\sigma</span> .</p>

    <p class="text-gray-300">In all the PHPs, in the first polynomial check the  <span class="math">\\pmb{v}_{1,j}(X)</span>  are constant polynomials (in particular, they all encode the same point, i.e.,  <span class="math">\\forall j: \\pmb{v}_{1,j}(X) = y</span> ), while in the second check they are the identity, i.e.,  <span class="math">\\forall j: \\pmb{v}_{2,j}(X) = X</span> . Furthermore, in those PHPs where  <span class="math">\\deg_{X,\\{X_i\\}}(G_2) = 2</span> , the second  <span class="math">\\mathsf{R}_{\\mathrm{eq}}</span>  relation can be replaced by its specialization for quadratic equations.</p>

    <p class="text-gray-300">Given the above considerations, we consider two main options for applying our compiler to our PHPs:</p>

    <p class="text-gray-300">Commitment scheme  <span class="math">\\mathsf{CS}_1</span> : this is applied to  <span class="math">\\mathsf{PHP}_{\\mathrm{lite1x}}</span> ,  <span class="math">\\mathsf{PHP}_{\\mathrm{lite2x}}</span> ,  <span class="math">\\mathsf{PHP}_{\\mathrm{r1cs1x}}</span> , and  <span class="math">\\mathsf{PHP}_{\\mathrm{r1cs2x}}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span>  we can use either  <span class="math">\\mathsf{CP}_{\\mathsf{opn}}^{\\mathsf{AGM}}</span> , secure in the algebraic group model, or  <span class="math">\\mathsf{CP}_{\\mathsf{opn}}^{\\mathsf{PKE}}</span>  that relies on the mPKE assumption (see Section 7.3).</li>

      <li>To prove the first and second polynomial checks we use (twice)  <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span>  of Section 7.6.</li>

      <li>To prove  <span class="math">\\mathsf{R}_{\\mathrm{deg}}</span> , we use  <span class="math">\\mathsf{CP}_{\\mathrm{deg}}^{(*)}</span>  of Section 7.8, with the optimization of Remark 14.</li>

    </ul>

    <p class="text-gray-300">Commitment scheme  <span class="math">\\mathsf{CS}_2</span> : this is applied to  <span class="math">\\mathsf{PHP}_{\\mathrm{lite1}}</span> ,  <span class="math">\\mathsf{PHP}_{\\mathrm{lite2}}</span> ,  <span class="math">\\mathsf{PHP}_{\\mathrm{r1cs1}}</span> , and  <span class="math">\\mathsf{PHP}_{\\mathrm{r1cs2}}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span>  we can use either  <span class="math">\\mathsf{CP}_{\\mathsf{opn}}^{\\mathsf{AGM}}</span> , secure in the algebraic group model, or  <span class="math">\\mathsf{CP}_{\\mathsf{opn}}^{\\mathsf{PKE}}</span>  that relies on the mPKE assumption (see Section 7.3).</li>

      <li>To prove  <span class="math">\\mathsf{R}_{\\mathrm{deg}}</span> , we use  <span class="math">\\mathsf{CP}_{\\mathrm{deg}}^{(2)}</span>  of Section 7.8</li>

      <li>To prove the first polynomial check we use  <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span>  of Section 7.6.</li>

      <li>To prove the second polynomial check we use  <span class="math">\\mathsf{CP}_{\\mathrm{neq}}</span>  of Section 7.7.</li>

    </ul>

    <p class="text-gray-300">Our compiler accounts for using a CP-SNARK  <span class="math">\\mathsf{CP}_{\\mathsf{php}}</span>  that can be  <span class="math">(\\mathsf{b},\\mathsf{C})</span> -leaky-ZK, which in turn requires the PHP protocol to be  <span class="math">(1 + \\mathsf{b})</span> -bounded ZK (see Theorem 5), where the  <span class="math">+1</span>  essentially comes from the fact that the commitment reveals one evaluation of each oracle polynomial.</p>

    <p class="text-gray-300">Among the CP-SNARKs we propose to realize  <span class="math">\\mathsf{CP}_{\\mathsf{php}}</span> , the only one that is leaky-ZK is the  <span class="math">\\mathsf{CP}_{\\mathsf{eq}}</span>  scheme of Section 7.6. Its leaky-ZK is due to the fact that the proof includes evaluations of those polynomials that end up in the set  <span class="math">S</span>  used to optimize the proof size.</p>

    <p class="text-gray-300">Note that this concern arises only when using it to prove the first polynomial check. Indeed, in all our schemes the second polynomial check involves only oracle polynomials that are not related to the witness, and thus for those polynomials the amount of leakage does not matter.</p>

    <p class="text-gray-300">We discuss what is  <span class="math">\\mathsf{b}</span>  for the  <span class="math">\\mathsf{b}</span> -leaky-ZK of  <span class="math">\\mathsf{CP}_{\\mathrm{eq}}</span>  when it is used to prove the first polynomials checks in all our PHPs, and how such  <span class="math">\\mathsf{b}</span>  impacts the instantiation of these PHPs.</p>

    <p class="text-gray-300">.</p>

    <h5 id="sec-86" class="text-base font-semibold mt-4">PHPs for R1CS-lite</h5>

    <p class="text-gray-300">The first polynomial check is the same in both constructions, and for the sake of the relation <span class="math">\\mathsf{R_{eq}}</span> the polynomial <span class="math">G_{1}^{\\prime}</span> can be written as</p>

    <p class="text-gray-300"><span class="math">G_{1}^{\\prime}(X_{a},X_{b},X_{s},X_{q},X_{r}):=X_{a}\\cdot X_{b}\\cdot g_{a,b}+X_{a}\\cdot g_{a}+X_{b}\\cdot g_{b}+X_{q}\\cdot g_{q}+X_{r}\\cdot g_{r}+X_{s}+g_{0}</span></p>

    <p class="text-gray-300">and the goal is to prove that on a given <span class="math">y</span>, <span class="math">G_{1}^{\\prime}((p_{j}(y))_{j\\in[5]})=0</span>, i.e.,</p>

    <p class="text-gray-300"><span class="math">\\hat{a}^{\\prime}(y)\\hat{b}^{\\prime}(y)\\cdot g_{a,b}+\\hat{a}^{\\prime}(y)\\cdot g_{a}+\\hat{b}^{\\prime}(y)\\cdot g_{b}+s(y)+q(y)\\cdot g_{q}+r(y)\\cdot g_{r}+g_{0}\\stackrel{{\\scriptstyle?}}{{=}}0</span></p>

    <p class="text-gray-300">To this end, <span class="math">\\mathsf{CP_{eq}}</span> chooses a set <span class="math">S</span> of size <span class="math">1</span>; for instance it reveals <span class="math">\\hat{b}^{\\prime}(y)</span> and nothing more. Thus, <span class="math">\\mathsf{CP_{eq}}</span> for this polynomial check is <span class="math">\\mathsf{b}</span>-leaky-ZK with <span class="math">\\mathsf{b}=(\\mathsf{b}_{a},\\mathsf{b}_{b},\\mathsf{b}_{s},\\mathsf{b}_{q},\\mathsf{b}_{r})=(0,1,0,0,0)</span> (cf. Remark 13).</p>

    <p class="text-gray-300">From Theorem 5, <span class="math">\\mathsf{PHP_{lite1}}</span> and <span class="math">\\mathsf{PHP_{lite2}}</span> need to be <span class="math">(1,2,1,1,1)</span>-bounded ZK. Moreover, note that all the “<span class="math">+\\mathbf{1}</span>” evaluations due to the commitment are all in the same point (the secret exponent <span class="math">s</span>). This is relevant because, by Remark 1, we can optimize the degrees and instantiate <span class="math">\\mathsf{PHP_{lite1}}</span> and <span class="math">\\mathsf{PHP_{lite2}}</span> with <span class="math">\\hat{a}^{\\prime}\\in\\mathbb{F}_{\\leq n+1}[X]</span>, <span class="math">\\hat{b}^{\\prime}\\in\\mathbb{F}_{\\leq n+2}[X]</span>, <span class="math">q_{s}\\in\\mathbb{F}_{\\leq 1}[X]</span>, <span class="math">r_{s}\\in\\mathbb{F}_{\\leq 1}[X]</span>.</p>

    <h5 id="sec-87" class="text-base font-semibold mt-4">PHPs for R1CS</h5>

    <p class="text-gray-300">All constructions share the same first polynomial check, which can be written as</p>

    <p class="text-gray-300"><span class="math">G_{1}^{\\prime}(X_{a},X_{b},X_{w},X_{s},X_{q},X_{r}):=X_{a}\\cdot X_{b}\\cdot g_{a,b}+X_{a}\\cdot g_{a}+X_{b}\\cdot g_{b}+X_{s}+X_{q}\\cdot g_{q}+X_{r}\\cdot g_{r}+g_{0}</span></p>

    <p class="text-gray-300">and whose goal is to prove that on a given <span class="math">y</span>, <span class="math">G_{1}^{\\prime}((p_{j}(y))_{j\\in[6]})=0</span>, i.e.,</p>

    <p class="text-gray-300"><span class="math">\\hat{a}(y)\\hat{b}(y)\\cdot g_{a,b}+\\hat{a}(y)\\cdot g_{a}+\\hat{b}(y)\\cdot g_{b}+\\hat{w}(y)\\cdot g_{w}+s(y)+q(y)\\cdot g_{q}+r(y)\\cdot g_{r}+g_{0}\\stackrel{{\\scriptstyle?}}{{=}}0</span></p>

    <p class="text-gray-300">Similarly to the above, <span class="math">\\mathsf{CP_{eq}}</span> chooses a set <span class="math">S</span> of size <span class="math">1</span>, revealing only the evaluation of <span class="math">\\hat{b}(y)</span>. Thus, <span class="math">\\mathsf{CP_{eq}}</span> for <span class="math">G_{1}</span> is <span class="math">\\mathsf{b}-</span>leaky-ZK with <span class="math">\\mathsf{b}=(\\mathsf{b}_{a},\\mathsf{b}_{b},\\mathsf{b}_{w},\\mathsf{b}_{s},\\mathsf{b}_{q},\\mathsf{b}_{r})=(0,1,0,0,0,0)</span>. Due to Theorem 5, these constructions need to be <span class="math">(1,2,1,1,1,1)</span>-bounded ZK, where the <span class="math">+\\mathbf{1}</span> evaluations correspond to the evaluation of the secret exponent of the commitments. Similarly to the previous case, the optimizations of Remark 4 apply to these PHPs as well.</p>

    <h3 id="sec-88" class="text-xl font-semibold mt-8">9.3 Our zkSNARKs</h3>

    <p class="text-gray-300">In Table 4 we summarize the efficiency of the zkSNARKs schemes obtained through the different options to instantiate the compiler on all our PHPs (the table only shows the instantiation in the AGM model, see later for the differences when <span class="math">\\mathsf{CP_{opn}}=\\mathsf{CP_{opn}^{PKE}}</span>). We comment how these measures are computed. The final numbers are obtained after considering the efficiency of the single CP-SNARKs from Section 7.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>The universal SRS <span class="math">\\mathsf{srs}</span> is the commitment key instantiated using the maximal degree <span class="math">\\mathsf{D}</span> of the given PHP, and the <span class="math">\\mathsf{KeyGen}</span> cost is the cost of generating this commitment key. This follows from the fact that all the CP-SNARKs used in this instantiation are commitment-only.</li>

      <li>The verification key <span class="math">\\mathsf{vk_{R}}</span> of the specialized SRS <span class="math">\\mathsf{srs_{R}}</span> for an R1CS-lite (resp. R1CS) relation involving matrices of dimension <span class="math">n</span> and density at most <span class="math">m</span> includes <span class="math">\\mathsf{rel}</span>-type commitments to the relation polynomials and the specialized SRSs for the CP-SNARKs. In our case, the latter only includes <span class="math">[s]_{2}</span> used to verify a proof in <span class="math">\\mathsf{CP_{eval}}</span>, and <span class="math">[s,s^{\\mathsf{D}-n+2},s^{\\mathsf{D}-m+2}]_{2}</span> used in the verification of <span class="math">\\mathsf{CP^{(2)}_{\\deg}}</span> when using <span class="math">\\mathsf{CS_{2}}</span>. The <span class="math">\\mathsf{Derive}</span> complexity is the cost of generating these <span class="math">\\mathsf{rel}</span>-type commitments.</li>

      <li>The proof includes one commitment per polynomial sent by the PHP prover, one <span class="math">\\mathsf{CP_{opn}}</span> proof per PHP round, two <span class="math">\\mathsf{CP_{deg}}</span> proofs, one <span class="math">\\mathsf{CP_{eq}}</span> proof for the first polynomial check, and a proof for the second polynomial check, which is done using <span class="math">\\mathsf{CP_{eq}}</span> for <span class="math">\\mathsf{CS_{1}}</span> or using <span class="math">\\mathsf{CP_{qeq}}</span> for <span class="math">\\mathsf{CS_{2}}</span>. The cost of the prover is the sum of: the committing cost which corresponds to the PHP proof length (translated into <span class="math">\\mathbb{G}_{1}</span> exponentiations), the cost of generating the CP-SNARK proofs, and the PHP prover complexity (which are <span class="math">\\mathbb{F}</span> operations). Note that in the <span class="math">\\mathsf{CS_{2}}</span> instantiation, the <span class="math">\\mathsf{CP_{qeq}}</span> proof is empty since for every quadratic term of <span class="math">G_{2}^{\\prime}</span> we have exactly one commitment in <span class="math">\\mathbb{G}_{1}</span> and another in <span class="math">\\mathbb{G}_{2}</span>.</li>

    </ul>

    <p class="text-gray-300">##</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verification involves running the PHP verifier, <span class="math">D_{\\mathcal{V}}</span>, and to run verification of the CP-SNARK proofs for <span class="math">\\mathsf{CP_{opn}}</span>, <span class="math">\\mathsf{CP_{deg}}</span>, <span class="math">\\mathsf{CP_{eq}}</span> for the first polynomial check, and <span class="math">\\mathsf{CP_{eq}}</span> (resp. <span class="math">\\mathsf{CP_{qeq}}</span>) for the second check in the <span class="math">\\mathsf{CS}_{1}</span> (resp. <span class="math">\\mathsf{CS}_{2}</span>) instantiation. In our summary we only count the number of pairings, as this is the most expensive cost. Each proof of <span class="math">\\mathsf{CP_{opn}}</span>, <span class="math">\\mathsf{CP_{deg}}</span> and <span class="math">\\mathsf{CP_{eq}}</span> requires 2 pairings while a <span class="math">\\mathsf{CP_{qeq}}</span> proof (for the <span class="math">G</span> polynomial used in our case) needs 3 pairings. Several of these pairings have a common <span class="math">\\mathbb{G}_{2}</span> argument, and thus can be batched using standard techniques; the numbers in the table are the ones after batching.</li>

    </ul>

    <p class="text-gray-300">In Table 1 we present a comparison between a selection of our schemes and previous work.</p>

    <p class="text-gray-300">Instantiations under mPKE. For the versions of our zkSNARKs based on the mPKE assumption, i.e., instantiated with <span class="math">\\mathsf{CP_{opn}}=\\mathsf{CP_{opn}^{PKE}}</span>, the efficiency decreases as follows: SRS size is increased by <span class="math">\\mathsf{D}</span> elements of <span class="math">\\mathbb{G}_{1}</span> and 1 element of <span class="math">\\mathbb{G}_{2}</span> (while remaining updatable by remark 11), proof size is increased by 4 elements of <span class="math">\\mathbb{G}_{1}</span>, the verifier needs 1 more pairing (after batching), and the prover needs <span class="math">l</span> more exponentiations in <span class="math">\\mathbb{G}_{1}</span>, where <span class="math">l=3n+2m</span> for <span class="math">\\Pi^{(1)}_{\\mathsf{lite2x}},\\Pi^{(2)}_{\\mathsf{lite2}},\\Pi^{(1)}_{\\mathsf{r1cs2x}},\\Pi^{(2)}_{\\mathsf{r1cs2}}</span>, <span class="math">l=3n+4m</span> for <span class="math">\\Pi^{(1)}_{\\mathsf{lite1x}},\\Pi^{(2)}_{\\mathsf{lite1}},\\Pi^{(1)}_{\\mathsf{r1cs3}}</span>, and <span class="math">l=3n+6m</span> for <span class="math">\\Pi^{(1)}_{\\mathsf{r1cs1x}},\\Pi^{(2)}_{\\mathsf{r1cs1}}</span>.</p>

    <p class="text-gray-300">It is worth noting that all our instantiations under the mPKE assumption are significantly more efficient than the instantiation of Marlin <em>[24]</em> with the polynomial commitments based on mPKE. The latter would require 11 more elements of <span class="math">\\mathbb{G}_{1}</span> in the proof (1 per commitment), while the proving time requires <span class="math">11n+5m</span> more exponentiations in <span class="math">\\mathbb{G}_{1}</span>.</p>

    <h3 id="sec-89" class="text-xl font-semibold mt-8">9.4 Our CP-SNARKs</h3>

    <p class="text-gray-300">By using the commit-and-prove variant of our compiler described in Section 8.1, we obtain commit-and-prove variants of our zkSNARKs in Table 4. Below we discuss their efficiency.</p>

    <p class="text-gray-300">Let us consider proving R1CS or R1CS-lite relations in which a portion of the witness vector <span class="math">\\mathsf{w}</span> is committed. Assume there are <span class="math">l</span> commitments, <span class="math">(\\hat{c}_{j})_{j\\in[l]}</span>, such that each <span class="math">\\hat{c}_{i}</span> commits to a vector of dimension <span class="math">v</span> encoded in a low-degree extension <span class="math">\\mathsf{u}_{i}(X)</span> of degree <span class="math">v-1</span>. Also, we recall that according to our compiler, each CP-SNARK variant works the same as the corresponding zkSNARK except that it additionally runs the <span class="math">\\mathsf{CP^{(2)}_{\\text{link}}}</span> proof system.</p>

    <p class="text-gray-300">In the case of the PHPs for R1CS, adding the <span class="math">\\mathsf{CP^{(2)}_{\\text{link}}}</span> proof requires in addition: <span class="math">n+v(3l+2)+l</span> exponentiations in <span class="math">\\mathbb{G}_{1}</span> for the prover, <span class="math">(4l+2)</span> elements of <span class="math">\\mathbb{G}_{1}</span> and one element of <span class="math">\\mathbb{F}</span> in the proof, and <span class="math">l+3</span> pairings to the verifier.</p>

    <p class="text-gray-300">In the case of the PHPs for R1CS-lite, adding the <span class="math">\\mathsf{CP^{(2)}_{\\text{link}}}</span> proof (with the modification to deal with the two polynomials) requires in addition: <span class="math">4n+v(3l+1)+l</span> exponentiations in <span class="math">\\mathbb{G}_{1}</span> for the prover, <span class="math">(4l+4)</span> elements of <span class="math">\\mathbb{G}_{1}</span> and two elements of <span class="math">\\mathbb{F}</span> in the proof, and <span class="math">l+3</span> pairings to the verifier.</p>

    <h2 id="sec-90" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">This work has received funding in part from the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation program under project PICOCRYPT (grant agreement No. 101001283), by the Spanish Government under projects SCUM (ref. RTI2018-102043-B-I00), CRYPTOEPIC (ref. EUR2019-103816), and SECURITAS (ref. RED2018-102321-T), by the Madrid Regional Government under project BLOQUES (ref. S2018/TCS-4339), and by research grants from Protocol Labs, and by Nomadic Labs and the Tezos Foundation. The first and second authors were at the IMDEA Software Institute while developing part of this work. Additionally, the project that gave rise to these results received the support of a fellowship from “la Caixa” Foundation (ID 100010434). The fellowship code is LCF/BQ/ES18/11670018.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Table 4. Efficiency summary of our zkSNARKs with universal and updatable SRS in the AGM model (i.e., using  <span class="math">\\mathsf{CP}_{\\mathrm{opt}} = \\mathsf{CP}_{\\mathrm{opt}}^{\\mathrm{AGM}}</span> ) for R1CS-lite and R1CS relations with  <span class="math">n\\times n</span>  matrices, each of density  <span class="math">\\leq m</span> , and inputs of length  <span class="math">\\ell</span> . For field operations, we simplified using that  <span class="math">m = O(n)</span> .  <span class="math">M</span>  is the largest value of  <span class="math">m</span>  supported by the PHPs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PHP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CS</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">srs</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">vkR</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">π</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">KeyGen</td>

            <td class="px-3 py-2 border-b border-gray-700">Derive</td>

            <td class="px-3 py-2 border-b border-gray-700">Prove</td>

            <td class="px-3 py-2 border-b border-gray-700">Verify</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">R1CS-lite</td>

            <td class="px-3 py-2 border-b border-gray-700">PHPlite1x</td>

            <td class="px-3 py-2 border-b border-gray-700">CS1</td>

            <td class="px-3 py-2 border-b border-gray-700">Π(1)lite1x</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">2M</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">2M</td>

            <td class="px-3 py-2 border-b border-gray-700">10m</td>

            <td class="px-3 py-2 border-b border-gray-700">8n+8m-2l</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">PHPlite1</td>

            <td class="px-3 py-2 border-b border-gray-700">CS2</td>

            <td class="px-3 py-2 border-b border-gray-700">Π(2)lite1</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">2M</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">2M</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">8n+6m-2l</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">2M</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">2M</td>

            <td class="px-3 py-2 border-b border-gray-700">16m</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">PHPlite2x</td>

            <td class="px-3 py-2 border-b border-gray-700">CS1</td>

            <td class="px-3 py-2 border-b border-gray-700">Π(1)lite2x</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">16m</td>

            <td class="px-3 py-2 border-b border-gray-700">8n+4m-2l</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">PHPlite2</td>

            <td class="px-3 py-2 border-b border-gray-700">CS2</td>

            <td class="px-3 py-2 border-b border-gray-700">Π(2)lite2(aka LunarLite)</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">8n+3m-2l</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">24m</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">R1CS</td>

            <td class="px-3 py-2 border-b border-gray-700">PHPr1cs1x</td>

            <td class="px-3 py-2 border-b border-gray-700">CS1</td>

            <td class="px-3 py-2 border-b border-gray-700">Π(1)r1cs1x</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">3M</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">3M</td>

            <td class="px-3 py-2 border-b border-gray-700">18m</td>

            <td class="px-3 py-2 border-b border-gray-700">9n+12m-l</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">PHPr1cs1</td>

            <td class="px-3 py-2 border-b border-gray-700">CS2</td>

            <td class="px-3 py-2 border-b border-gray-700">Π(2)r1cs1</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">3M</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">3M</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">9n+9m-l</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">3M</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">3M</td>

            <td class="px-3 py-2 border-b border-gray-700">27m</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">PHPr1cs2</td>

            <td class="px-3 py-2 border-b border-gray-700">CS1</td>

            <td class="px-3 py-2 border-b border-gray-700">Π(1)r1cs2x</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">42m</td>

            <td class="px-3 py-2 border-b border-gray-700">9n+4m-l</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">PHPr1cs2</td>

            <td class="px-3 py-2 border-b border-gray-700">CS2</td>

            <td class="px-3 py-2 border-b border-gray-700">Π(2)r1cs2(aka Lunar1cs fast & short)</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">9n+3m-l</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">57m</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PHPr1cs3</td>

            <td class="px-3 py-2 border-b border-gray-700">CS1</td>

            <td class="px-3 py-2 border-b border-gray-700">Π(1)r1cs3(aka Lunar1cs short vk)</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">3M</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">3M</td>

            <td class="px-3 py-2 border-b border-gray-700">12m</td>

            <td class="px-3 py-2 border-b border-gray-700">9n+8m-l</td>

            <td class="px-3 py-2 border-b border-gray-700">2 pairings</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">—</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(ℓ+log m)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Abdolmaleki, B., Baghery, K., Lipmaa, H., Zajac, M.: A Subversion-Resistant SNARK. In: Takagi, T., Peyrin, T. (eds.) ASIACRYPT 2017, Part III. LNCS, vol. 10626, pp. 3–33. Springer, Heidelberg (Dec 2017). https://doi.org/10.1007/978-3-319-70700-6_1</li>

      <li>[2] Ames, S., Hazay, C., Ishai, Y., Venkitasubramaniam, M.: Ligero: Lightweight sublinear arguments without a trusted setup. In: Thuraisingham, B.M., Evans, D., Malkin, T., Xu, D. (eds.) ACM CCS 2017. pp. 2087–2104. ACM Press (Oct / Nov 2017). https://doi.org/10.1145/3133956.3134104</li>

      <li>[3] Aranha, D.F., Bennedsen, E.M., Campanelli, M., Ganesh, C., Orlandi, C., Takahashi, A.: Eclipse: Enhanced compiling method for pedersen-committed zksnark engines. Cryptology ePrint Archive, Report 2021/934 (2021), https://ia.cr/2021/934</li>

      <li>[4] Attema, T., Cramer, R.: Compressed <span class="math">\\Sigma</span>-protocol theory and practical application to plug <span class="math">k</span>: play secure algorithmics. In: Micciancio, D., Ristenpart, T. (eds.) CRYPTO 2020, Part III. LNCS, vol. 12172, pp. 513–543. Springer, Heidelberg (Aug 2020). https://doi.org/10.1007/978-3-030-56877-1_18</li>

      <li>[5] Baghery, K.: Subversion-Resistant Simulation (Knowledge) Sound NIZKs. In: Albrecht, M. (ed.) 17th IMA International Conference on Cryptography and Coding. LNCS, vol. 11929, pp. 42–63. Springer, Heidelberg (Dec 2019). https://doi.org/10.1007/978-3-030-35199-1_3</li>

      <li>[6] Ben-Sasson, E., Bentov, I., Chiesa, A., Gabizon, A., Genkin, D., Hamilis, M., Pergament, E., Riabzev, M., Silberstein, M., Tromer, E., Virza, M.: Computational integrity with a public random string from quasi-linear PCPs. In: Coron, J.S., Nielsen, J.B. (eds.) EUROCRYPT 2017, Part III. LNCS, vol. 10212, pp. 551–579. Springer, Heidelberg (Apr / May 2017). https://doi.org/10.1007/978-3-319-56617-7_19</li>

      <li>[7] Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.: Scalable zero knowledge with no trusted setup. In: Boldyreva, A., Micciancio, D. (eds.) CRYPTO 2019, Part III. LNCS, vol. 11694, pp. 701–732. Springer, Heidelberg (Aug 2019). https://doi.org/10.1007/978-3-030-26954-8_23</li>

      <li>[8] Ben-Sasson, E., Chiesa, A., Goldberg, L., Gur, T., Riabzev, M., Spooner, N.: Linear-size constant-query IOPs for delegating computation. In: Hofheinz, D., Rosen, A. (eds.) TCC 2019, Part II. LNCS, vol. 11892, pp. 494–521. Springer, Heidelberg (Dec 2019). https://doi.org/10.1007/978-3-030-36033-7_19</li>

      <li>[9] Ben-Sasson, E., Chiesa, A., Green, M., Tromer, E., Virza, M.: Secure sampling of public parameters for succinct zero knowledge proofs. In: 2015 IEEE Symposium on Security and Privacy. pp. 287–304. IEEE Computer Society Press (May 2015). https://doi.org/10.1109/SP.2015.25</li>

      <li>[10] Ben-Sasson, E., Chiesa, A., Riabzev, M., Spooner, N., Virza, M., Ward, N.P.: Aurora: Transparent succinct arguments for R1CS. In: Ishai, Y., Rijmen, V. (eds.) EUROCRYPT 2019, Part I. LNCS, vol. 11476, pp. 103–128. Springer, Heidelberg (May 2019). https://doi.org/10.1007/978-3-030-17653-2_4</li>

      <li>[11] Ben-Sasson, E., Chiesa, A., Spooner, N.: Interactive oracle proofs. In: Hirt, M., Smith, A.D. (eds.) TCC 2016-B, Part II. LNCS, vol. 9986, pp. 31–60. Springer, Heidelberg (Oct / Nov 2016). https://doi.org/10.1007/978-3-662-53644-5_2</li>

      <li>[12] Benarroch, D., Campanelli, M., Fiore, D.: Commit-and-Prove Zero-Knowledge Proof Systems. ZKProof.org (2020), https://docs.zkproof.org/standards/proposals</li>

      <li>[13] Benarroch, D., Campanelli, M., Fiore, D., Gurkan, K., Kolonelos, D.: Zero-Knowledge Proofs for Set Membership: Efficient, Succinct, Modular. In: Financial Cryptography and Data Security (2021)</li>

      <li>[14] Bitansky, N., Canetti, R., Chiesa, A., Tromer, E.: From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In: Goldwasser, S. (ed.) ITCS 2012. pp. 326–349. ACM (Jan 2012). https://doi.org/10.1145/2090236.2090263</li>

      <li>[15] Bitansky, N., Chiesa, A., Ishai, Y., Ostrovsky, R., Paneth, O.: Succinct non-interactive arguments via linear interactive proofs. In: Sahai, A. (ed.) TCC 2013. LNCS, vol. 7785, pp. 315–333. Springer, Heidelberg (Mar 2013). https://doi.org/10.1007/978-3-642-36594-2_18</li>

      <li>[16] Boneh, D., Boyen, X.: Short signatures without random oracles. In: Cachin, C., Camenisch, J. (eds.) EUROCRYPT 2004. LNCS, vol. 3027, pp. 56–73. Springer, Heidelberg (May 2004). https://doi.org/10.1007/978-3-540-24676-3_4</li>

      <li>[17] Boneh, D., Drake, J., Fisch, B., Gabizon, A.: Efficient polynomial commitment schemes for multiple points and polynomials. Cryptology ePrint Archive, Report 2020/081 (2020), https://eprint.iacr.org/2020/081</li>

      <li>[18] Bootle, J., Cerulli, A., Chaidos, P., Groth, J., Petit, C.: Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In: Fischlin, M., Coron, J.S. (eds.) EUROCRYPT 2016, Part II. LNCS, vol. 9666, pp. 327–357. Springer, Heidelberg (May 2016). https://doi.org/10.1007/978-3-662-49896-5_12</li>

      <li>[19] Bowe, S., Gabizon, A., Green, M.D.: A multi-party protocol for constructing the public parameters of the pinocchio zk-SNARK. In: Zohar, A., Eyal, I., Teague, V., Clark, J., Bracciali, A., Pintore, F., Sala, M. (eds.) FC 2018 Workshops. LNCS, vol. 10958, pp. 64–77. Springer, Heidelberg (Mar 2019). https://doi.org/10.1007/978-3-662-58820-8_5</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Bowe, S., Gabizon, A., Miers, I.: Scalable multi-party computation for zk-SNARK parameters in the random beacon model. Cryptology ePrint Archive, Report 2017/1050 (2017), http://eprint.iacr.org/2017/1050</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>21. Bünz, B., Bootle, J., Boneh, D., Poelstra, A., Wuille, P., Maxwell, G.: Bulletproofs: Short proofs for confidential transactions and more. In: 2018 IEEE Symposium on Security and Privacy. pp. 315–334. IEEE Computer Society Press (May 2018). https://doi.org/10.1109/SP.2018.00020</li>

      <li>22. Bünz, B., Fisch, B., Szepieniec, A.: Transparent SNARKs from DARK compilers. In: Canteaut, A., Ishai, Y. (eds.) EUROCRYPT 2020, Part I. LNCS, vol. 12105, pp. 677–706. Springer, Heidelberg (May 2020). https://doi.org/10.1007/978-3-030-45721-1_24</li>

      <li>23. Campanelli, M., Fiore, D., Querol, A.: LegoSNARK: Modular design and composition of succinct zero-knowledge proofs. In: Cavallaro, L., Kinder, J., Wang, X., Katz, J. (eds.) ACM CCS 2019. pp. 2075–2092. ACM Press (Nov 2019). https://doi.org/10.1145/3319535.3339820</li>

      <li>24. Chiesa, A., Hu, Y., Maller, M., Mishra, P., Vesely, N., Ward, N.P.: Marlin: Preprocessing zkSNARKs with universal and updatable SRS. In: Canteaut, A., Ishai, Y. (eds.) EUROCRYPT 2020, Part I. LNCS, vol. 12105, pp. 738–768. Springer, Heidelberg (May 2020). https://doi.org/10.1007/978-3-030-45721-1_26</li>

      <li>25. Chiesa, A., Ojha, D., Spooner, N.: Fractal: Post-quantum and transparent recursive proofs from holography. In: Canteaut, A., Ishai, Y. (eds.) EUROCRYPT 2020, Part I. LNCS, vol. 12105, pp. 769–793. Springer, Heidelberg (May 2020). https://doi.org/10.1007/978-3-030-45721-1_27</li>

      <li>26. Daza, V., Råfols, C., Zacharakis, A.: Updateable inner product argument with logarithmic verifier and applications. In: Kiayias, A., Kohlweiss, M., Wallden, P., Zikas, V. (eds.) PKC 2020, Part I. LNCS, vol. 12110, pp. 527–557. Springer, Heidelberg (May 2020). https://doi.org/10.1007/978-3-030-45374-9_18</li>

      <li>27. Dubhashi, D.P., Panconesi, A.: Concentration of Measure for the Analysis of Randomized Algorithms. Cambridge University Press (2009), http://www.cambridge.org/gb/knowledge/isbn/item2327542/</li>

      <li>28. Escala, A., Groth, J.: Fine-tuning Groth-Sahai proofs. In: Krawczyk, H. (ed.) PKC 2014. LNCS, vol. 8383, pp. 630–649. Springer, Heidelberg (Mar 2014). https://doi.org/10.1007/978-3-642-54631-0_36</li>

      <li>29. Escala, A., Herold, G., Kiltz, E., Råfols, C., Villar, J.: An algebraic framework for Diffie-Hellman assumptions. In: Canetti, R., Garay, J.A. (eds.) CRYPTO 2013, Part II. LNCS, vol. 8043, pp. 129–147. Springer, Heidelberg (Aug 2013). https://doi.org/10.1007/978-3-642-40084-1_8</li>

      <li>30. Fuchsbauer, G.: Subversion-Zero-Knowledge SNARKs. In: Abdalla, M., Dahab, R. (eds.) PKC 2018, Part I. LNCS, vol. 10769, pp. 315–347. Springer, Heidelberg (Mar 2018). https://doi.org/10.1007/978-3-319-76578-5_11</li>

      <li>31. Fuchsbauer, G., Kiltz, E., Loss, J.: The algebraic group model and its applications. In: Shacham, H., Boldyreva, A. (eds.) CRYPTO 2018, Part II. LNCS, vol. 10992, pp. 33–62. Springer, Heidelberg (Aug 2018). https://doi.org/10.1007/978-3-319-96881-0_2</li>

      <li>32. Gabizon, A.: AuroraLight: Improved prover efficiency and SRS size in a sonic-like system. Cryptology ePrint Archive, Report 2019/601 (2019), https://eprint.iacr.org/2019/601</li>

      <li>33. Gabizon, A., Williamson, Z.J., Ciobotaru, O.: PLONK: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Report 2019/953 (2019), https://eprint.iacr.org/2019/953</li>

      <li>34. Gennaro, R., Gentry, C., Parno, B., Raykova, M.: Quadratic span programs and succinct NIZKs without PCPs. In: Johansson, T., Nguyen, P.Q. (eds.) EUROCRYPT 2013. LNCS, vol. 7881, pp. 626–645. Springer, Heidelberg (May 2013). https://doi.org/10.1007/978-3-642-38348-9_37</li>

      <li>35. Gentry, C., Wichs, D.: Separating succinct non-interactive arguments from all falsifiable assumptions. In: Fortnow, L., Vadhan, S.P. (eds.) 43rd ACM STOC. pp. 99–108. ACM Press (Jun 2011). https://doi.org/10.1145/1993636.1993651</li>

      <li>36. Goldreich, O., Oren, Y.: Definitions and properties of zero-knowledge proof systems. Journal of Cryptology 7(1), 1–32 (Dec 1994). https://doi.org/10.1007/BF00195207</li>

      <li>37. Goldwasser, S., Micali, S., Rackoff, C.: The knowledge complexity of interactive proof systems. SIAM Journal on Computing 18(1), 186–208 (1989)</li>

      <li>38. Groth, J.: Short pairing-based non-interactive zero-knowledge arguments. In: Abe, M. (ed.) ASIACRYPT 2010. LNCS, vol. 6477, pp. 321–340. Springer, Heidelberg (Dec 2010). https://doi.org/10.1007/978-3-642-17373-8_19</li>

      <li>39. Groth, J.: On the size of pairing-based non-interactive arguments. In: Fischlin, M., Coron, J.S. (eds.) EUROCRYPT 2016, Part II. LNCS, vol. 9666, pp. 305–326. Springer, Heidelberg (May 2016). https://doi.org/10.1007/978-3-662-49896-5_11</li>

      <li>40. Groth, J., Kohlweiss, M., Maller, M., Meiklejohn, S., Miers, I.: Updatable and universal common reference strings with applications to zk-SNARKs. In: Shacham, H., Boldyreva, A. (eds.) CRYPTO 2018, Part III. LNCS, vol. 10993, pp. 698–728. Springer, Heidelberg (Aug 2018). https://doi.org/10.1007/978-3-319-96878-0_24</li>

      <li>41. Hopwood, D., Bowe, S., Hornby, T., Wilcox, N.: Zcash Protocol Specification. Tech. rep. 2016–1.10. Zerocoin Electric Coin Company, Tech. Rep. (2016)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[42] Ishai, Y.: Efficient zero-knowledge proofs: A modular approach (2019), https://simons.berkeley.edu/talks/tbd-79. Also see https://zkproof.org/2020/08/12/information-theoretic-proof-systems/</li>

      <li>[43] Ishai, Y.: Zero-Knowledge Proofs from Information-Theoretic Proof Systems - Part I. ZKProof.org, Blog entry (2020)</li>

      <li>[44] Ivanov, K.G., Saff, E.B.: Behavior of the Lagrange Interpolants in the Roots of Unity, pp. 81–87. Springer Berlin Heidelberg, Berlin, Heidelberg (1990). https://doi.org/10.1007/BFb0087899, https://doi.org/10.1007/BFb0087899</li>

      <li>[45] Kate, A., Zaverucha, G.M., Goldberg, I.: Constant-size commitments to polynomials and their applications. In: Abe, M. (ed.) ASIACRYPT 2010. LNCS, vol. 6477, pp. 177–194. Springer, Heidelberg (Dec 2010). https://doi.org/10.1007/978-3-642-17373-8_11</li>

      <li>[46] Kilian, J.: A note on efficient zero-knowledge proofs and arguments (extended abstract). In: 24th ACM STOC. pp. 723–732. ACM Press (May 1992). https://doi.org/10.1145/129712.129782</li>

      <li>[47] Kosba, A.E., Papadopoulos, D., Papamanthou, C., Song, D.: MIRAGE: Succinct arguments for randomized algorithms with applications to universal zk-SNARKs. In: Capkun, S., Roesner, F. (eds.) USENIX Security 2020. pp. 2129–2146. USENIX Association (Aug 2020)</li>

      <li>[48] Kothapalli, A., Masserova, E., Parno, B.: A direct construction for asymptotically optimal zkSNARKs. Cryptology ePrint Archive, Report 2020/1318 (2020), https://eprint.iacr.org/2020/1318</li>

      <li>[49] Lee, J., Setty, S., Thaler, J., Wahby, R.: Linear-time zero-knowledge SNARKs for R1CS. Cryptology ePrint Archive, Report 2021/030 (2021)</li>

      <li>[50] Lipmaa, H.: Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In: Cramer, R. (ed.) TCC 2012. LNCS, vol. 7194, pp. 169–189. Springer, Heidelberg (Mar 2012). https://doi.org/10.1007/978-3-642-28914-9_10</li>

      <li>[51] Maller, M., Bowe, S., Kohlweiss, M., Meiklejohn, S.: Sonic: Zero-knowledge SNARKs from linear-size universal and updatable structured reference strings. In: Cavallaro, L., Kinder, J., Wang, X., Katz, J. (eds.) ACM CCS 2019. pp. 2111–2128. ACM Press (Nov 2019). https://doi.org/10.1145/3319535.3339817</li>

      <li>[52] Micali, S.: CS proofs (extended abstracts). In: 35th FOCS. pp. 436–453. IEEE Computer Society Press (Nov 1994). https://doi.org/10.1109/SFCS.1994.365746</li>

      <li>[53] Micali, S.: Computationally sound proofs. SIAM Journal on Computing 30(4), 1253–1298 (2000). https://doi.org/10.1137/S0097539795284959</li>

      <li>[54] Reingold, O., Rothblum, G.N., Rothblum, R.D.: Constant-round interactive proofs for delegating computation. In: Wichs, D., Mansour, Y. (eds.) 48th ACM STOC. pp. 49–62. ACM Press (Jun 2016). https://doi.org/10.1145/2897518.2897652</li>

      <li>[55] Råfols, C., Zapico, A.: An Algebraic Framework for Universal and Updatable SNARKs. Cryptology ePrint Archive, Report 2021/590 (2021), https://eprint.iacr.org/2021/590</li>

      <li>[56] Setty, S.: Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In: Micciancio, D., Ristenpart, T. (eds.) CRYPTO 2020, Part III. LNCS, vol. 12172, pp. 704–737. Springer, Heidelberg (Aug 2020). https://doi.org/10.1007/978-3-030-56877-1_25</li>

      <li>[57] Trefethen, L., Berrut, J.P.: Barycentric lagrange interpolation. SIAM Review 46(3), 501–517 (2004). https://doi.org/10.1137/S0036144502417715</li>

      <li>[58] Wahby, R.S., Tzialla, I., shelat, a., Thaler, J., Walfish, M.: Doubly-efficient zkSNARKs without trusted setup. In: 2018 IEEE Symposium on Security and Privacy. pp. 926–943. IEEE Computer Society Press (May 2018). https://doi.org/10.1109/SP.2018.00060</li>

      <li>[59] Wu, H., Zheng, W., Chiesa, A., Popa, R.A., Stoica, I.: DIZK: A distributed zero knowledge proof system. In: Enck, W., Felt, A.P. (eds.) USENIX Security 2018. pp. 675–692. USENIX Association (Aug 2018)</li>

      <li>[60] Xie, T., Zhang, J., Zhang, Y., Papamanthou, C., Song, D.: Libra: Succinct zero-knowledge proofs with optimal prover computation. In: Boldyreva, A., Micciancio, D. (eds.) CRYPTO 2019, Part III. LNCS, vol. 11694, pp. 733–764. Springer, Heidelberg (Aug 2019). https://doi.org/10.1007/978-3-030-26954-8_24</li>

      <li>[61] Yamashita, K., Tibouchi, M., Abe, M.: On The Impossibility of NIZKs for Disjunctive Languages from Commit-and-Prove NIZKs. IEEE Access (2021)</li>

      <li>[62] Zhang, J., Xie, T., Zhang, Y., Song, D.: Transparent polynomial delegation and its applications to zero knowledge proof. In: 2020 IEEE Symposium on Security and Privacy. pp. 859–876. IEEE Computer Society Press (May 2020). https://doi.org/10.1109/SP40000.2020.00052</li>

      <li>[63] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: vSQL: Verifying arbitrary SQL queries over dynamic outsourced databases. In: 2017 IEEE Symposium on Security and Privacy. pp. 863–880. IEEE Computer Society Press (May 2017). https://doi.org/10.1109/SP.2017.43</li>

      <li>[64] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: A Zero-Knowledge Version of vSQL. Cryptology ePrint Archive, Report 2017/1146 (2017), https://eprint.iacr.org/2017/1146</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: vRAM: Faster verifiable RAM with program-independent preprocessing. In: 2018 IEEE Symposium on Security and Privacy. pp. 908-925. IEEE Computer Society Press (May 2018). https://doi.org/10.1109/SP.2018.00013</li>

    </ol>

    <h2 id="sec-92" class="text-2xl font-bold">A Constraint Systems</h2>

    <p class="text-gray-300">Below we define a less compact version of R1CS-lite (Definition 8) in which satisfiability is expressed via three vectors and three checks. This form is sometimes more convenient to work with.</p>

    <p class="text-gray-300"><strong>Definition 23 (LongR1CS-lite).</strong> Let <span class="math">\\mathbb{F}</span> be a finite field and <span class="math">n, m \\in \\mathbb{N}</span> be positive integers. The universal relation <span class="math">\\mathcal{R}_{\\text{LongR1CS-lite}}</span> is the set of triples</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf{R}, \\mathsf{x}, \\mathsf{w}) := ((\\mathbb{F}, n, m, \\{\\boldsymbol{L}, \\boldsymbol{R}\\}, \\ell), \\boldsymbol{x}, (\\boldsymbol{a}^{\\prime}, \\boldsymbol{b}^{\\prime}, \\boldsymbol{c}^{\\prime}))</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\boldsymbol{L}, \\boldsymbol{R} \\in \\mathbb{F}^{n \\times n}</span>, $\\max \\{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\} \\leq m<span class="math">, </span>\\boldsymbol{x} \\in \\mathbb{F}^{\\ell - 1}<span class="math">, </span>\\boldsymbol{a}^{\\prime}, \\boldsymbol{b}^{\\prime}, \\boldsymbol{c}^{\\prime} \\in \\mathbb{F}^{n - \\ell}<span class="math">, and for </span>\\boldsymbol{a} := (1, \\boldsymbol{x}, \\boldsymbol{a}^{\\prime})<span class="math">, </span>\\boldsymbol{b} := (\\mathbf{1}, \\boldsymbol{b}^{\\prime})<span class="math">, </span>\\boldsymbol{c} := (1, \\boldsymbol{x}, \\boldsymbol{c}^{\\prime})$ it holds</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol{a} \\circ \\boldsymbol{b} - \\boldsymbol{c} = 0 \\quad \\wedge \\quad \\boldsymbol{a} + \\boldsymbol{L} \\cdot \\boldsymbol{c} = 0 \\quad \\wedge \\quad \\boldsymbol{b} + \\boldsymbol{R} \\cdot \\boldsymbol{c} = 0</span></div>

    <p class="text-gray-300"><strong>Lemma 8.</strong> Let <span class="math">\\mathsf{R}</span> (resp. <span class="math">\\hat{\\mathsf{R}}</span>) be a LongR1CS-lite (resp. R1CS-lite) relation with matrices <span class="math">\\{\\boldsymbol{L}, \\boldsymbol{R}\\}</span>. Then for any <span class="math">\\boldsymbol{x} \\in \\mathbb{F}^{\\ell - 1}</span>, it holds <span class="math">\\boldsymbol{x} \\in \\mathcal{L}(\\mathsf{R})</span> if and only if <span class="math">\\boldsymbol{x} \\in \\mathcal{L}(\\hat{\\mathsf{R}})</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> CASE I: <span class="math">\\boldsymbol{x} \\in \\mathcal{L}(\\mathsf{R}) \\Rightarrow \\boldsymbol{x} \\in \\mathcal{L}(\\hat{\\mathsf{R}})</span>. Let <span class="math">(\\boldsymbol{a}&#x27;, \\boldsymbol{b}&#x27;, \\boldsymbol{c}&#x27;)</span> be a witness for <span class="math">\\boldsymbol{x} \\in \\mathcal{L}(\\mathsf{R})</span>. Then <span class="math">\\hat{\\boldsymbol{c}}&#x27; := \\boldsymbol{a}&#x27; \\circ \\boldsymbol{b}&#x27;</span> is a witness for <span class="math">\\boldsymbol{x} \\in \\mathcal{L}(\\hat{\\mathsf{R}})</span>. To see this, note that by LongR1CS-lite definition, we have that <span class="math">\\boldsymbol{L} \\cdot (\\boldsymbol{a} \\circ \\boldsymbol{b}) \\circ \\boldsymbol{R} \\cdot (\\boldsymbol{a} \\circ \\boldsymbol{b}) = \\boldsymbol{a} \\circ \\boldsymbol{b}</span>, for <span class="math">\\boldsymbol{a} := (1, \\boldsymbol{x}, \\boldsymbol{a}&#x27;)</span> and <span class="math">\\boldsymbol{b} := (\\mathbf{1}, \\boldsymbol{b}&#x27;)</span>. Finally, noticing that <span class="math">(1, \\boldsymbol{x}, \\hat{\\boldsymbol{c}}&#x27;) = \\boldsymbol{a} \\circ \\boldsymbol{b}</span> concludes this part of the proof.</p>

    <p class="text-gray-300">CASE II: <span class="math">\\boldsymbol{x} \\in \\mathcal{L}(\\mathsf{R}) \\Leftarrow \\boldsymbol{x} \\in \\mathcal{L}(\\hat{\\mathsf{R}})</span>. Let <span class="math">\\hat{\\boldsymbol{c}}&#x27;</span> be a witness for <span class="math">\\boldsymbol{x} \\in \\mathcal{L}(\\hat{\\mathsf{R}})</span>, namely for <span class="math">\\hat{\\boldsymbol{c}} := (1, \\boldsymbol{x}, \\hat{\\boldsymbol{c}}&#x27;)</span> it holds <span class="math">\\hat{\\boldsymbol{c}} = \\boldsymbol{L} \\cdot \\hat{\\boldsymbol{c}} \\circ \\boldsymbol{R} \\cdot \\hat{\\boldsymbol{c}}</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\tilde{\\boldsymbol{a}} := -\\boldsymbol{L} \\cdot \\hat{\\boldsymbol{c}}</span>, <span class="math">\\tilde{\\boldsymbol{b}} := -\\boldsymbol{R} \\cdot \\hat{\\boldsymbol{c}}</span>, and <span class="math">\\boldsymbol{c}&#x27; := \\hat{\\boldsymbol{c}}&#x27;</span>, and let <span class="math">\\boldsymbol{a}&#x27;, \\boldsymbol{b}&#x27;</span> be the last <span class="math">n - \\ell</span> rows of <span class="math">\\tilde{\\boldsymbol{a}}</span> and <span class="math">\\tilde{\\boldsymbol{b}}</span> respectively.</p>

    <p class="text-gray-300">By the satisfiability of R1CS-lite we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c} 1 \\\\ \\boldsymbol{x} \\\\ \\boldsymbol{c}&#x27; \\end{array} \\right) = \\hat{\\boldsymbol{c}} = \\boldsymbol{L} \\cdot \\hat{\\boldsymbol{c}} \\circ \\boldsymbol{R} \\cdot \\hat{\\boldsymbol{c}} = \\tilde{\\boldsymbol{a}} \\circ \\tilde{\\boldsymbol{b}} = \\left( \\begin{array}{c} \\boldsymbol{a}&#x27;&#x27; \\\\ \\boldsymbol{a}&#x27; \\end{array} \\right) \\circ \\left( \\begin{array}{c} \\boldsymbol{b}&#x27;&#x27; \\\\ \\boldsymbol{b}&#x27; \\end{array} \\right)</span></div>

    <p class="text-gray-300">which implies that <span class="math">\\boldsymbol{c}&#x27; = \\boldsymbol{a}&#x27; \\circ \\boldsymbol{b}&#x27;</span>, and thus for <span class="math">\\boldsymbol{a} := (1, \\boldsymbol{x}, \\boldsymbol{a}&#x27;)</span>, <span class="math">\\boldsymbol{b} := (\\mathbf{1}, \\boldsymbol{b}&#x27;)</span>, and <span class="math">\\boldsymbol{c} := (1, \\boldsymbol{x}, \\boldsymbol{c}&#x27;)</span>, the Hadamard constraint of R1CS-lite must hold.</p>

    <p class="text-gray-300">Finally, note that from the definition of the first <span class="math">\\ell</span> rows of <span class="math">\\boldsymbol{R}</span> it holds <span class="math">\\tilde{\\boldsymbol{b}} = (\\mathbf{1}, \\boldsymbol{b}&#x27;)</span>, and thus <span class="math">\\tilde{\\boldsymbol{a}} = (1, \\boldsymbol{x}, \\boldsymbol{a}&#x27;)</span>. Therefore, for <span class="math">\\boldsymbol{a}, \\boldsymbol{b}</span> as above the linear constraints of R1CS-lite are also satisfied.</p>

    <p class="text-gray-300">This concludes the proof that <span class="math">(\\boldsymbol{a}&#x27;, \\boldsymbol{b}&#x27;, \\boldsymbol{c}&#x27;)</span> is a satisfying witness for <span class="math">\\boldsymbol{x} \\in \\mathcal{L}(\\mathsf{R})</span>.</p>

    <h2 id="sec-93" class="text-2xl font-bold">A.1 Proof of Lemma 5</h2>

    <p class="text-gray-300"><strong>Proof.</strong> We do the proof by showing equivalence with the LongR1CS-lite relation of definition 23; by lemma 8 one can then obtain the proof.</p>

    <p class="text-gray-300">First, we claim that equation (1) is equivalent to</p>

    <div class="my-4 text-center"><span class="math-block">\\forall \\eta \\in \\mathbb{H}: a(\\eta) + \\sum_{\\eta&#x27; \\in \\mathbb{H}} \\boldsymbol{L}_{\\eta, \\eta&#x27;} \\cdot a(\\eta&#x27;) \\cdot b(\\eta&#x27;) = 0 \\tag{17}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall \\eta \\in \\mathbb{H}: b(\\eta) + \\sum_{\\eta&#x27; \\in \\mathbb{H}} \\boldsymbol{R}_{\\eta, \\eta&#x27;} \\cdot a(\\eta&#x27;) \\cdot b(\\eta&#x27;) = 0 \\tag{18}</span></div>

    <p class="text-gray-300">To see this, we observe that we can group the checks inside equations (17) (resp. (18)) by doing a linear combination with linearly independent polynomials <span class="math">\\{\\mathcal{L}_{\\eta}^{\\mathbb{H}}(X)\\}_{\\eta \\in \\mathbb{H}}</span>; then, these two equations can be merged into a single one by introducing a new random variable <span class="math">Z</span>.</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\eta \\in \\mathbb{H}} a(\\eta) \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) + \\sum_{\\eta, \\eta&#x27; \\in \\mathbb{H}} \\boldsymbol{L}_{\\eta, \\eta&#x27;} \\cdot a(\\eta&#x27;) \\cdot b(\\eta&#x27;) \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) = 0 \\in \\mathbb{F}[X]</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\eta \\in \\mathbb{H}} b(\\eta) \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) + \\sum_{\\eta, \\eta&#x27; \\in \\mathbb{H}} \\boldsymbol{R}_{\\eta, \\eta&#x27;} \\cdot a(\\eta&#x27;) \\cdot b(\\eta&#x27;) \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) = 0 \\in \\mathbb{F}[X]</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Updownarrow</span></div>

    <p class="text-gray-300">$$ \\begin{array}{l} a(X) + Z \\cdot b(X) + \\sum_{\\eta, \\eta' \\in \\mathbb{H}} \\boldsymbol{L}_{\\eta, \\eta'} \\cdot a(\\eta') \\cdot b(\\eta') \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) + \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Z \\sum_{\\eta, \\eta' \\in \\mathbb{H}} \\boldsymbol{R}_{\\eta, \\eta'} \\cdot a(\\eta') \\cdot b(\\eta') \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) = 0 \\in \\mathbb{F}[X, Z]</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">In one direction, given a satisfying witness <span class="math">(\\boldsymbol{a}&#x27;,\\boldsymbol{b}&#x27;,\\boldsymbol{c}&#x27;)</span> for R1CS-lite, we can build polynomials <span class="math">a&#x27;(X), b&#x27;(X)</span> that satisfy equations (17)-(18) by defining: <span class="math">\\boldsymbol{a} := (1,\\boldsymbol{x},\\boldsymbol{a}&#x27;)</span>, <span class="math">a(X) = \\sum_{\\eta \\in \\mathbb{H}} \\boldsymbol{a}_{\\phi_{\\mathbb{H}}(\\eta)} \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) \\in \\mathbb{F}_{\\leq n-1}[X]</span> (and similarly for <span class="math">b(X)</span> from <span class="math">\\boldsymbol{b} = (\\mathbf{1},\\boldsymbol{b}&#x27;)</span>), <span class="math">a&#x27;(X) := (a(X) - \\sum_{\\eta \\in \\mathbb{L}} \\boldsymbol{x}&#x27;_{\\phi_{\\mathbb{H}}(\\eta)} \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X)) / \\mathcal{Z}_{\\mathbb{L}}(X)</span>, and <span class="math">b&#x27;(X) := (b(X) - 1) / \\mathcal{Z}_{\\mathbb{L}}(X)</span>.</p>

    <p class="text-gray-300">In the other direction, let <span class="math">a&#x27;(X), b&#x27;(X)</span> be polynomials such that their extensions with the public input satisfy equations (17)-(18). Then, we build a witness <span class="math">(\\boldsymbol{a}&#x27;,\\boldsymbol{b}&#x27;,\\boldsymbol{c}&#x27;)</span> for R1CS-lite by defining: <span class="math">\\boldsymbol{b}&#x27; := (b(\\phi_{\\mathbb{H}}^{-1}(\\ell + 1)), \\ldots, b(\\phi_{\\mathbb{H}}^{-1}(n))</span>, <span class="math">\\boldsymbol{a}&#x27; := (a&#x27;(\\phi_{\\mathbb{H}}^{-1}(\\ell + 1)), \\ldots, a&#x27;(\\phi_{\\mathbb{H}}^{-1}(n))</span>, and <span class="math">\\boldsymbol{c}&#x27; := (a&#x27;(\\phi_{\\mathbb{H}}^{-1}(\\ell + 1)) \\cdot b(\\phi_{\\mathbb{H}}^{-1}(\\ell + 1)), \\ldots, a&#x27;(\\phi_{\\mathbb{H}}^{-1}(n) \\cdot b(\\phi_{\\mathbb{H}}^{-1}(\\ell + 1)))</span>.</p>

    <h2 id="sec-94" class="text-2xl font-bold">A.2 Proof of Lemma 6</h2>

    <p class="text-gray-300">Proof. Similarly to the proof above, we claim that equation (11) is equivalent to</p>

    <div class="my-4 text-center"><span class="math-block">\\forall \\eta \\in \\mathbb{H}: a(\\eta) + \\sum_{\\eta&#x27; \\in \\mathbb{H}} \\boldsymbol{L}_{\\eta, \\eta&#x27;} \\cdot z(\\eta&#x27;) = 0 \\tag{19}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall \\eta \\in \\mathbb{H}: b(\\eta) + \\sum_{\\eta&#x27; \\in \\mathbb{H}} \\boldsymbol{R}_{\\eta, \\eta&#x27;} \\cdot z(\\eta&#x27;) = 0 \\tag{20}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\forall \\eta \\in \\mathbb{H}: -a(\\eta) \\cdot b(\\eta) + \\sum_{\\eta&#x27; \\in \\mathbb{H}} \\boldsymbol{O}_{\\eta, \\eta&#x27;} \\cdot z(\\eta&#x27;) = 0 \\tag{21}</span></div>

    <p class="text-gray-300">To see this, we observe that we can group the checks inside equations (19)-(21) by doing a linear combination with linearly independent polynomials <span class="math">\\{\\mathcal{L}_{\\eta}^{\\mathbb{H}}(X)\\}_{\\eta \\in \\mathbb{H}}</span>; then, these three equations can be merged into a single one by introducing new random variables <span class="math">Z_{L}, Z_{R}, Z_{O}</span>.</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\eta \\in \\mathbb{H}} a(\\eta) \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) + \\sum_{\\eta, \\eta&#x27; \\in \\mathbb{H}} \\boldsymbol{L}_{\\eta, \\eta&#x27;} \\cdot z(\\eta&#x27;) \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) = 0 \\in \\mathbb{F}[X]</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\eta \\in \\mathbb{H}} b(\\eta) \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) + \\sum_{\\eta, \\eta&#x27; \\in \\mathbb{H}} \\boldsymbol{R}_{\\eta, \\eta&#x27;} \\cdot z(\\eta&#x27;) \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) = 0 \\in \\mathbb{F}[X]</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\sum_{\\eta \\in \\mathbb{H}} a(\\eta) \\cdot b(\\eta) \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) + \\sum_{\\eta, \\eta' \\in \\mathbb{H}} \\boldsymbol{O}_{\\eta, \\eta'} \\cdot z(\\eta') \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) = 0 \\in \\mathbb{F}[X]</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\eta \\in \\mathbb{H}} \\big(Z_{L} a(\\eta) + Z_{R} b(\\eta) - Z_{O} a(\\eta) b(\\eta)\\big) \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) + \\sum_{\\substack{\\eta, \\eta&#x27; \\in \\mathbb{H} \\\\ M \\in \\{L, R, O\\}}} Z_{M} \\boldsymbol{M}_{\\eta, \\eta&#x27;} z(\\eta&#x27;) \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) = 0 \\in \\mathbb{F}[X, Z_{L}, Z_{R}, Z_{O}]</span></div>

    <p class="text-gray-300">In one direction, given a satisfying witness <span class="math">\\pmb{w}</span> for R1CS, we can build polynomials <span class="math">a(X), b(X), w(X)</span> that satisfy equations (19)-(21): first, let <span class="math">\\pmb{a} = -\\pmb{L} \\cdot \\pmb{z}</span> and <span class="math">\\pmb{b} = -\\pmb{R} \\cdot \\pmb{z}</span> with <span class="math">\\pmb{z} = (1, \\pmb{x}, \\pmb{w})</span>, second, define by interpolation <span class="math">a(X) = \\sum_{\\eta \\in \\mathbb{H}} \\pmb{a}_{\\phi_{\\mathbb{H}}(\\eta)} \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) \\in \\mathbb{F}_{\\leq n-1}[X]</span> and similarly <span class="math">b(X)</span>, and finally define <span class="math">z(X) := \\sum_{\\eta \\in \\mathbb{L}} \\pmb{x}&#x27;_{\\phi_{\\mathbb{H}}(\\eta)} \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) + \\sum_{\\eta \\in \\mathbb{H} \\setminus \\mathbb{L}} \\pmb{w}_{\\phi_{\\mathbb{H}}(\\eta)} \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) \\cdot \\mathcal{Z}_{\\mathbb{L}}(X)</span>.</p>

    <p class="text-gray-300">In the other direction, let <span class="math">a(X), b(X), w(X)</span> be such that they satisfy equations (19)-(21), for <span class="math">z(X) := \\sum_{\\eta \\in \\mathbb{L}} \\pmb{x}&#x27;_{\\phi_{\\mathbb{H}}(\\eta)} \\cdot \\mathcal{L}_{\\eta}^{\\mathbb{H}}(X) + w(X) \\cdot \\mathcal{Z}_{\\mathbb{L}}(X)</span>. Then, we build a witness <span class="math">\\pmb{w}</span> for R1CS by defining <span class="math">\\pmb{w} := (z(\\phi_{\\mathbb{H}}^{-1}(\\ell + 1)), \\ldots, z(\\phi_{\\mathbb{H}}^{-1}(n)))</span>.</p>

    <h2 id="sec-95" class="text-2xl font-bold">A.3 Reduction to Arithmetic Circuit Satisfiability</h2>

    <p class="text-gray-300">Let us recall the arithmetic circuit satisfiability problem.</p>

    <p class="text-gray-300"><strong>Definition 24 (Arithmetic Circuit Satisfiability).</strong> Let <span class="math">\\mathbb{F}</span> be a finite field. The universal arithmetic circuit satisfiability relation <span class="math">\\mathcal{R}_{\\mathcal{C}}</span> is the set of triples <span class="math">(C, (\\pmb{x}, \\pmb{y}), \\pmb{w})</span>, where <span class="math">C: \\mathbb{F}^{\\ell_{in}} \\times \\mathbb{F}^{\\ell_{wit}} \\to \\mathbb{F}^{\\ell_{out}}</span> is an arithmetic circuit with <span class="math">\\ell_{in}</span> public inputs, <span class="math">\\ell_{wit}</span> private inputs, and <span class="math">\\ell_{out}</span> public outputs, such that <span class="math">C(\\pmb{x}, \\pmb{w}) = \\pmb{y}</span>.</p>

    <p class="text-gray-300">Gennaro et al. [34] proved how to encode arithmetic circuit satisfiability with a quadratic arithmetic program (which is the polynomial version of R1CS). We summarize below their result.</p>

    <p class="text-gray-300"><strong>Theorem 19 ([34]).</strong> Let <span class="math">C: \\mathbb{F}^{\\ell_{in}} \\times \\mathbb{F}^{\\ell_{wit}} \\to \\mathbb{F}^{\\ell_{out}}</span> be an arithmetic circuit with <span class="math">N</span> multiplication gates. Then there exists an R1CS <span class="math">\\pmb{L}, \\pmb{R}, \\pmb{O} \\in \\mathbb{F}^{(N + \\ell_{out}) \\times n}</span> with <span class="math">n = \\ell_{in} + \\ell_{out} + N + 1</span> such that for any <span class="math">\\pmb{x}</span>, <span class="math">\\exists \\pmb{w}: C(\\pmb{x}, \\pmb{w}) = \\pmb{y}</span> if and only if <span class="math">\\exists \\pmb{c}&#x27;</span> that makes <span class="math">(1, \\pmb{x}, \\pmb{y})</span> accepted by <span class="math">(\\pmb{L}, \\pmb{R}, \\pmb{O})</span>.</p>

    <p class="text-gray-300">In the following theorem we show a similar method to encode arithmetic circuit satisfiability with R1CS-lite.</p>

    <p class="text-gray-300"><strong>Theorem 20.</strong> Let <span class="math">C: \\mathbb{F}^{\\ell_{in}} \\times \\mathbb{F}^{\\ell_{wit}} \\to \\mathbb{F}^{\\ell_{out}}</span> be an arithmetic circuit with <span class="math">N</span> multiplication gates. Then there exists an R1CS-lite <span class="math">\\{\\pmb{L}, \\pmb{R}\\} \\in \\mathbb{F}^{n \\times n}</span> with <span class="math">\\ell = \\ell_{in} + \\ell_{out} + 1</span>, <span class="math">n = \\ell + N</span>, such that for any <span class="math">\\pmb{x}</span>, <span class="math">\\exists \\pmb{w}: C(\\pmb{x}, \\pmb{w}) = \\pmb{y}</span> if and only if <span class="math">\\exists \\pmb{w}&#x27;</span> that makes <span class="math">(1, \\pmb{x}, \\pmb{y})</span> accepted by <span class="math">\\{\\pmb{L}, \\pmb{R}\\}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> We do the proof by building matrices for the LongR1CS-lite relation. By the equivalence of R1CS-lite LongR1CS-lite shown in lemma 8, this shows a reduction to R1CS-lite.</p>

    <p class="text-gray-300">Our goal is to define <span class="math">\\pmb{a}, \\pmb{b}, \\pmb{c}</span> and matrices <span class="math">\\pmb{L}, \\pmb{R}</span> such that the satisfiability of <span class="math">C</span> can be expressed as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{ \\begin{array}{l} \\boldsymbol {a} + \\boldsymbol {L} \\cdot \\boldsymbol {c} = 0 \\\\ \\boldsymbol {b} + \\boldsymbol {R} \\cdot \\boldsymbol {c} = 0 \\\\ \\boldsymbol {a} \\circ \\boldsymbol {b} = \\boldsymbol {c} \\end{array} \\right. \\tag {22}</span></div>

    <p class="text-gray-300">with <span class="math">\\pmb{a} = (1, \\pmb{x}, \\pmb{y}, \\pmb{a}&#x27;)</span>, <span class="math">\\pmb{b} = (\\pmb{1}, \\pmb{b}&#x27;)</span> and <span class="math">\\pmb{c} = (1, \\pmb{x}, \\pmb{y}, \\pmb{c}&#x27;)</span>.</p>

    <p class="text-gray-300">Let us partition <span class="math">[n]</span> into <span class="math">I_{\\mathrm{in}} = \\{2,\\dots ,\\ell_{\\mathrm{in}} + 1\\}</span>, <span class="math">I_{\\mathrm{out}} = \\{\\ell_{\\mathrm{in}} + 2,\\dots ,\\ell \\}</span>, <span class="math">I_{\\mathrm{mid}} = \\{\\ell +1,\\dots ,n\\}</span>.</p>

    <p class="text-gray-300">Let us label all the multiplication gates of <span class="math">C</span> with integers in <span class="math">I_{\\mathrm{mid}}</span>, and for every such multiplication gate <span class="math">j</span> let us denote by <span class="math">a_j, b_j</span> and <span class="math">c_j</span> its left input, right input and output respectively. Also recall that <span class="math">\\pmb{c}</span> contains the public input and output (including the constant 1) as a prefix. Then the consistency of every multiplication gate can be checked as:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall j \\in I _ {\\mathrm {m i d}}: \\left\\{ \\begin{array}{l} a _ {j} + \\boldsymbol {L} _ {j} \\cdot \\boldsymbol {c} = 0 \\\\ b _ {j} + \\boldsymbol {R} _ {j} \\cdot \\boldsymbol {c} = 0 \\\\ a _ {j} \\cdot b _ {j} - c _ {j} = 0 \\end{array} \\right.</span></div>

    <p class="text-gray-300">for appropriate row vectors <span class="math">\\pmb{L}_j, \\pmb{R}_j</span> which express the linear subcircuits for the left and input wires. More in detail, a multiplication gate is described by a list of coefficients <span class="math">l_0, \\ldots, l_k</span> (the left inputs) and a list</p>

    <p class="text-gray-300">74</p>

    <p class="text-gray-300">of coefficients <span class="math">r_0, \\ldots, r_{k&#x27;}</span> (the right inputs) for values <span class="math">k, k&#x27; \\in \\mathbb{N}</span> and computes the function that maps <span class="math">(x_1, \\ldots, x_k, y_1, \\ldots, y_{k&#x27;})</span> to <span class="math">(\\sum_i l_i x_i + l_0) \\cdot (\\sum_i r_i y_i + r_0)</span>. Moreover, in the circuit <span class="math">C</span> the inputs of the gate with label <span class="math">j</span> are connected to the outputs of <span class="math">k + k&#x27;</span> distinct gates with indexes <span class="math">j_1, \\ldots, j_{k+k&#x27;}</span>. The row vectors <span class="math">\\mathbf{L}_j</span> and <span class="math">\\mathbf{R}_j</span> are thus defined as:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{L}_{j,i} := \\left\\{ \\begin{array}{ll} -l_0 &amp;amp; \\text{if } i = 1 \\\\ -l_\\alpha &amp;amp; \\text{if } \\exists \\alpha : i = j_\\alpha, \\\\ 0 &amp;amp; \\text{else} \\end{array} \\right. \\quad \\mathbf{R}_{j,i} := \\left\\{ \\begin{array}{ll} -r_0 &amp;amp; \\text{if } i = 1 \\\\ -r_\\alpha &amp;amp; \\text{if } \\exists \\alpha : i = j_{k+\\alpha}, \\\\ 0 &amp;amp; \\text{else} \\end{array} \\right.</span></div>

    <p class="text-gray-300">Next, we add constraints for the public outputs:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall j \\in I_{\\text{out}} : \\left\\{ \\begin{array}{l} a_j + \\mathbf{L}_j \\cdot \\mathbf{c} = 0 \\\\ b_j - c_1 = 0 \\\\ a_j \\cdot b_j - c_j = 0 \\end{array} \\right.</span></div>

    <p class="text-gray-300">The first and second constraints check correctness of outputs that are obtained from possible linear subcircuits on multiplication gates outputs, namely gates of the form <span class="math">\\sum_i l_i x_i</span> for constants <span class="math">l_1, \\ldots, l_k</span> and input variables <span class="math">x_1, \\ldots, x_k</span>. The row vectors <span class="math">\\mathbf{L}_j</span> for <span class="math">j \\in I_{\\mathrm{out}}</span> are thus defined as:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{L}_{j,i} := \\left\\{ \\begin{array}{cc} -l_\\alpha &amp;amp; \\text{if } \\exists \\alpha : i = j_\\alpha, \\\\ 0 &amp;amp; \\text{else} \\end{array} \\right.</span></div>

    <p class="text-gray-300">Finally, recalling that <span class="math">\\mathbf{a} = (1, \\mathbf{x}, \\mathbf{y}, \\mathbf{a}&#x27;)</span>, <span class="math">\\mathbf{b} = (\\mathbf{1}, \\mathbf{b}&#x27;)</span> and <span class="math">\\mathbf{c} = (1, \\mathbf{x}, \\mathbf{y}, \\mathbf{c}&#x27;)</span>, we can add the following (dummy) constraints for the public inputs:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall j \\in \\{1\\} \\cup I_{\\text{in}} : \\left\\{ \\begin{array}{l} a_j - c_j = 0 \\\\ b_j - c_1 = 0 \\\\ a_j \\cdot b_j - c_j = 0 \\end{array} \\right.</span></div>

    <p class="text-gray-300">We conclude by showing how to define matrices <span class="math">\\mathbf{L}</span> and <span class="math">\\mathbf{R}</span> such that all the constraints above are compactly represented by the equations (22).</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{L} = \\left( \\begin{array}{cc} -\\mathbf{I}_{\\ell_{\\text{in}} + 1} \\mid \\mathbf{0} \\\\ \\mathbf{L}_{\\ell_{\\text{in}} + 2} \\\\ \\vdots \\\\ \\mathbf{L}_n \\end{array} \\right)</span></div>

    <p class="text-gray-300">In order to define <span class="math">\\mathbf{R}</span>, we define auxiliary matrix <span class="math">\\mathbf{E}</span> as the <span class="math">\\ell \\times n</span> matrix where each row is the unit vector <span class="math">\\mathbf{e}_1 \\in \\mathbb{F}^n</span>.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{E} = \\left( \\begin{array}{cc} 1 \\ldots 0 \\ldots 0 \\\\ \\vdots \\\\ 1 \\ldots 0 \\ldots 0 \\end{array} \\right), \\quad \\mathbf{R} = \\left( \\begin{array}{c} -\\mathbf{E} \\\\ \\mathbf{R}_{\\ell + 1} \\\\ \\vdots \\\\ \\mathbf{R}_n \\end{array} \\right)</span></div>

    <h2 id="sec-96" class="text-2xl font-bold">A.4 Comparing R1CS and R1CS-lite</h2>

    <p class="text-gray-300">We compare the efficiency of the R1CS and R1CS-lite constraint systems that result from applying the results of theorems 19 and 20 to the same circuit <span class="math">C</span>. Let <span class="math">\\tilde{\\mathbf{L}}, \\tilde{\\mathbf{R}}, \\tilde{\\mathbf{O}}</span> and <span class="math">\\mathbf{L}, \\mathbf{R}</span> be the resulting R1CS and R1CS-lite matrices respectively.</p>

    <p class="text-gray-300">From the theorems statements it's clear that R1CS matrices have <span class="math">\\ell_{\\mathrm{in}} + 1</span> less rows than R1CS-lite ones.</p>

    <p class="text-gray-300">Next, we analyze their densities. For ease of comparison, we show how the R1CS matrices are obtained. This works very similarly to the proof of our theorem 20 with a few differences at the end. For <span class="math">\\boldsymbol{c}=(1,\\boldsymbol{x},\\boldsymbol{y},\\boldsymbol{c}^{\\prime})</span>, the satisfiability can be expressed as the following constraints</p>

    <p class="text-gray-300">\\[ \\begin{cases}(\\boldsymbol{L}^{\\prime}\\cdot\\boldsymbol{c})\\circ(\\boldsymbol{R}^{\\prime}\\cdot\\boldsymbol{c})=[\\boldsymbol{0}_{N\\times\\ell}\\mid\\boldsymbol{I}]\\cdot\\boldsymbol{c}\\\\ \\boldsymbol{L}_{out}\\cdot\\boldsymbol{c}=\\boldsymbol{0}\\end{cases}\\quad\\text{with}\\ \\ \\boldsymbol{L}^{\\prime}=\\begin{pmatrix}\\boldsymbol{L}_{\\ell+1}\\\\ \\vdots\\\\ \\boldsymbol{L}_{n}\\end{pmatrix},\\quad\\boldsymbol{R}^{\\prime}=\\begin{pmatrix}\\boldsymbol{R}_{\\ell+1}\\\\ \\vdots\\\\ \\boldsymbol{R}_{n}\\end{pmatrix} \\]</p>

    <p class="text-gray-300">where the <span class="math">i</span>-th row of <span class="math">\\boldsymbol{L}_{out}</span> checks that the <span class="math">i</span>-th output <span class="math">\\boldsymbol{y}_{i}</span> is correctly obtained from a linear subcircuit with inputs from <span class="math">(1,\\boldsymbol{x},\\boldsymbol{c}^{\\prime})</span>.</p>

    <p class="text-gray-300">Then one can set</p>

    <p class="text-gray-300">\\[ \\tilde{\\boldsymbol{L}}=\\begin{pmatrix}\\boldsymbol{L}^{\\prime}\\\\ \\boldsymbol{L}_{out}\\end{pmatrix},\\quad\\tilde{\\boldsymbol{R}}=\\begin{pmatrix}\\boldsymbol{R}^{\\prime}\\\\ (1,0,\\ldots 0)\\\\ \\vdots\\\\ (1,0,\\ldots 0)\\end{pmatrix},\\quad\\tilde{\\boldsymbol{O}}=\\begin{pmatrix}\\boldsymbol{0}\\mid\\boldsymbol{I}\\\\ \\boldsymbol{0}_{\\ell_{\\text{out}}\\times n}\\end{pmatrix} \\]</p>

    <p class="text-gray-300">Let us now analyze their densities. For R1CS we have:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{\\boldsymbol{L}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{L}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{L}_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\quad</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{\\boldsymbol{R}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{R}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ell_{\\text{out}},\\quad</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{\\boldsymbol{O}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=N$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">whereas for R1CS-lite we have:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{L}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{L}_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_{\\text{in}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1,\\quad</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{R}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\ell,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Basically, the two R1CS-lite matrices have each <span class="math">\\ell_{\\text{in}}+1</span> more entries than their R1CS counterparts. If we consider the total size of the constraint system, we also have that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boldsymbol{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{\\boldsymbol{L}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{\\boldsymbol{R}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{\\boldsymbol{O}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">holds as long as <span class="math">N&gt;2(\\ell_{\\text{in}}+1)</span>, which is likely to be the case.</p>

    <h2 id="sec-97" class="text-2xl font-bold">Appendix B Our Protocol for Lincheck</h2>

    <p class="text-gray-300">In this section we describe a PHP for the following relation</p>

    <p class="text-gray-300"><span class="math">\\boldsymbol{f}=\\boldsymbol{M}\\boldsymbol{g}</span></p>

    <p class="text-gray-300">where <span class="math">f,g\\in\\mathbb{F}^{n}</span> and <span class="math">\\boldsymbol{M}\\in\\mathbb{F}^{n\\times n}</span> is a sparse matrix. This PHP is used as a building block for the constructions in Section 4.</p>

    <h3 id="sec-98" class="text-xl font-semibold mt-8">B.1 Preliminaries</h3>

    <p class="text-gray-300">The equation <span class="math">\\boldsymbol{f}=\\boldsymbol{M}\\boldsymbol{g}</span> can be rewritten as</p>

    <p class="text-gray-300"><span class="math">\\forall\\eta\\in\\mathbb{H}\\quad f(\\eta)-\\sum_{\\eta^{\\prime}}M_{\\eta,\\eta^{\\prime}}\\cdot g(\\eta^{\\prime})=0</span> (23)</p>

    <p class="text-gray-300">We can rewrite it equivalently as a linear combination through Lagrange polynomials:</p>

    <p class="text-gray-300"><span class="math">\\sum_{\\eta}\\mathcal{L}_{\\eta}^{\\mathbb{H}}(Y)\\big{(}f(\\eta)-\\sum_{\\eta^{\\prime}}M_{\\eta,\\eta^{\\prime}}\\cdot g(\\eta^{\\prime})\\big{)}=0</span> (24)</p>

    <p class="text-gray-300">that is</p>

    <p class="text-gray-300"><span class="math">F(Y)=\\sum_{\\eta,\\eta^{\\prime}}\\mathcal{L}_{\\eta}^{\\mathbb{H}}(Y)M_{\\eta,\\eta^{\\prime}}g(\\eta^{\\prime})</span> (25)</p>

    <p class="text-gray-300">From here (we mark substitutions in blue):</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} F(Y) = \\sum_{\\substack{\\eta, \\eta^{\\prime} \\\\ M_{\\eta, \\eta^{\\prime}} \\neq 0}} \\mathcal{L}_{\\eta}^{\\mathbb{H}}(Y) M_{\\eta, \\eta^{\\prime}} g(\\eta^{\\prime}) \\quad (26) \\\\ = \\sum_{\\kappa \\in \\mathbb{K}} \\operatorname{val}(\\kappa) g(\\operatorname{col}(\\kappa)) \\mathcal{L}_{\\operatorname{row}(\\kappa)}^{\\mathbb{H}}(Y) \\quad (27) \\\\ = \\sum_{\\kappa \\in \\mathbb{K}} \\operatorname{val}(\\kappa) \\left(\\sum_{\\eta^{\\prime}} g(\\eta^{\\prime}) \\mathcal{L}_{\\operatorname{col}(\\kappa)}^{\\mathbb{H}}(\\eta^{\\prime})\\right) \\mathcal{L}_{\\operatorname{row}(\\kappa)}^{\\mathbb{H}}(Y) \\quad (28) \\\\ = \\sum_{\\eta^{\\prime}} g(\\eta^{\\prime}) \\left(\\sum_{\\kappa \\in \\mathbb{K}} \\operatorname{val}(\\kappa) \\mathcal{L}_{\\operatorname{col}(\\kappa)}^{\\mathbb{H}}(\\eta^{\\prime}) \\mathcal{L}_{\\operatorname{row}(\\kappa)}^{\\mathbb{H}}(Y)\\right) \\quad (29) \\\\ = \\sum_{\\eta^{\\prime}} g(\\eta^{\\prime}) V(\\eta^{\\prime}, Y) \\quad (30) \\\\ = \\sum_{\\eta^{\\prime}} D(\\eta^{\\prime}, Y) \\quad (31) \\end{array}</span></div>

    <p class="text-gray-300">Thus we are defining:</p>

    <div class="my-4 text-center"><span class="math-block">F(Y) := \\sum_{\\eta} \\mathcal{L}_{\\eta}^{\\mathbb{H}}(Y) f(\\eta) \\quad (32)</span></div>

    <div class="my-4 text-center"><span class="math-block">D(X, Y) := g(X) V(X, Y) \\quad (33)</span></div>

    <div class="my-4 text-center"><span class="math-block">V(X, Y) := \\sum_{\\kappa \\in \\mathbb{K}} \\operatorname{val}(\\kappa) \\mathcal{L}_{\\operatorname{col}(\\kappa)}^{\\mathbb{H}}(X) \\mathcal{L}_{\\operatorname{row}(\\kappa)}^{\\mathbb{H}}(Y) \\quad (34)</span></div>

    <h2 id="sec-99" class="text-2xl font-bold">A high-level view of the lincheck protocol:</h2>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Sumcheck.</strong> After sampling a random <span class="math">y_0</span>, we carry out a sumcheck protocol on <span class="math">\\sigma := F(y_0)</span>. Specifically, we check the claim <span class="math">\\sigma = \\sum_{\\eta&#x27;} D&#x27;(\\eta&#x27;)</span> where <span class="math">D&#x27;(X) := g(X)V(X, y_0)</span>.</li>

      <li><strong>Check product of polynomials.</strong> As a step in the sumcheck protocol from the step before, we need to recursively check the structure of <span class="math">D&#x27;</span>. We want to check that <span class="math">D&#x27;</span> is of the form <span class="math">D&#x27;(X) = g(X)V(X, y_0)</span>. In order to do this, we sample a random point <span class="math">x</span> and recursively check a claim on <span class="math">g(x)</span> (to which the verifier has oracle access) and on <span class="math">V(x, y)</span> (for which we use the following step).</li>

      <li><strong>Check sparse matrix polynomial.</strong> The polynomial <span class="math">V</span> encodes a sparse matrix. We use a specialized protocol for this type of claim, described later on in the following subsection.</li>

    </ol>

    <h2 id="sec-100" class="text-2xl font-bold">B.2 An Holographic Protocol for Points of Sparse Matrices</h2>

    <p class="text-gray-300">The new protocol we describe here is, together with sumcheck, the main ingredient for our lincheck. The protocol allows to verify that a polynomial <span class="math">\\tilde{V}</span> in input correctly "encodes" the point with indices <span class="math">(x^{<em>}, y^{</em>})</span> for a matrix encoded as described in Definition 6. We point out that the indices <span class="math">(x^{<em>}, y^{</em>})</span> do not necessarily have to be valid row/column position of the matrix (they are arbitrary field elements).</p>

    <p class="text-gray-300"><strong>Remark 16.</strong> The approach below can be generalized to a different number of polynomial and different rational functions.</p>

    <p class="text-gray-300">See Section 4.1 for background on this section. Consider a sparse matrix <span class="math">\\mathbf{M}</span> and let <span class="math">(\\text{row}, \\text{col}, \\text{val})</span> be its encoding (as by Definition 6) to which we assume the verifier has oracle access. Let <span class="math">x^{<em>}, y^{</em>}</span> be any two points in the field <span class="math">\\mathbb{F}</span>. Let us define the polynomial <span class="math">\\tilde{V}</span> as</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde{V} := \\sum_{\\kappa \\in \\mathbb{K}} \\operatorname{val}(\\kappa) \\mathcal{L}_{\\operatorname{col}(\\kappa)}^{\\mathbb{H}}(x^{*}) \\mathcal{L}_{\\operatorname{row}(\\kappa)}^{\\mathbb{H}}(y^{*}) \\quad (35)</span></div>

    <p class="text-gray-300">We now define a protocol that, fixed a matrix and fixed <span class="math">x^{<em>}, y^{</em>}</span> allows a verifier to check that <span class="math">\\tilde{V}</span> is correctly defined as in (35). Its analysis (efficiency and soundness) are analogous to those in Section 4.</p>

    <p class="text-gray-300">77</p>

    <p class="text-gray-300">Intuition By definition of <span class="math">\\tilde{V}</span>, we know that</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde{V}(\\kappa) = \\mathsf{val}(\\kappa) \\mathcal{L}_{\\mathsf{col}(\\kappa)}^{\\mathbb{H}}(x^{*}) \\mathcal{L}_{\\mathsf{row}(\\kappa)}^{\\mathbb{H}}(y^{*}) \\text{ for every } \\kappa \\in \\mathbb{K}</span></div>

    <p class="text-gray-300">For every <span class="math">\\kappa \\in \\mathbb{K}</span> we can write this as:</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde{V}(\\kappa) = \\mathsf{val}(\\kappa) \\frac{\\mathsf{col}(\\kappa)}{n} \\cdot \\frac{\\mathcal{Z}_{\\mathbb{H}}(x^{*})}{x^{*} - \\mathsf{col}(\\kappa)} \\cdot \\frac{\\mathsf{row}(\\kappa)}{n} \\cdot \\frac{\\mathcal{Z}_{\\mathbb{H}}(y^{*})}{y^{*} - \\mathsf{row}(\\kappa)}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $n \\coloneqq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. The latter is equivalent to</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">n^{2} \\tilde{V}(\\kappa) (x^{*} - \\mathsf{col}(\\kappa)) (y^{*} - \\mathsf{row}(\\kappa)) = \\mathsf{val}(\\kappa) \\mathsf{col}(\\kappa) \\mathsf{row}(\\kappa) \\mathcal{Z}_{\\mathbb{H}}(x^{*}) \\mathcal{Z}_{\\mathbb{H}}(y^{*})</span></div>

    <p class="text-gray-300">Let us define polynomial <span class="math">B</span> as</p>

    <div class="my-4 text-center"><span class="math-block">B(X&#x27;) := n^{2} \\tilde{V}(X&#x27;) (x^{*} - \\mathsf{col}(X&#x27;)) (y^{*} - \\mathsf{row}(X&#x27;)) - \\mathsf{val}(X&#x27;) \\mathsf{col}(X&#x27;) \\mathsf{row}(X&#x27;) \\mathcal{Z}_{\\mathbb{H}}(x^{*}) \\mathcal{Z}_{\\mathbb{H}}(y^{*})</span></div>

    <p class="text-gray-300">and we observe that the above is equivalent to:</p>

    <div class="my-4 text-center"><span class="math-block">B(X&#x27;) \\equiv 0 \\pmod{\\mathcal{Z}_{\\mathbb{K}}(X&#x27;)}</span></div>

    <p class="text-gray-300">In order to check this relation in the protocol, the prover can send <span class="math">\\pi(X&#x27;) \\coloneqq \\frac{B(X&#x27;)}{\\mathcal{Z}_{\\mathbb{K}}(X&#x27;)}</span> and the verifier can check</p>

    <div class="my-4 text-center"><span class="math-block">\\pi(y) \\mathcal{Z}_{\\mathbb{K}}(y) = B(y)</span></div>

    <p class="text-gray-300">for a random point <span class="math">y</span>.</p>

    <p class="text-gray-300">78</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Fig. 5. Online phase of our lincheck PHP.</p>

    <p class="text-gray-300">Let  <span class="math">\\tilde{p}(X) := \\frac{\\sigma_V}{n} + X\\tilde{r}(X)</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">n^2\\tilde{p} (X)(x - \\mathsf{col}(X))(y_0 - \\mathsf{row}(X)) -</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {Z} _ {\\mathbb {H}} (x) \\mathcal {Z} _ {\\mathbb {H}} (y _ {0}) \\operatorname {v a l} (X) \\operatorname {c o l} (X) \\operatorname {r o w} (X) - \\pi (X) \\mathcal {Z} _ {\\mathbb {K}} (X) \\stackrel {?} {=} 0</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">G(X)\\sigma_{V} - F(y_{0}) / n - q^{\\prime}(x)\\mathcal{Z}_{\\mathbb{H}}(x) - x r^{\\prime}(x)\\stackrel {?}{=}0</span></li>

    </ol>

    <p class="text-gray-300">Fig. 6. Decision phase of our Lincheck PHP</p>

    <p class="text-gray-300">80</p>

    <p class="text-gray-300">Definition 25 (Universal (Commit and Prove) Interactive Argument in the SRS model). A Universal Commit and Prove Interactive Argument in the SRS model (Universal CP-UIA) is a tuple UIA = (KeyGen, Derive,  <span class="math">\\bar{\\mathcal{P}},\\bar{\\mathcal{V}}</span> ) of PT algorithms where all the algorithms work as in universal CP-SNARK (Definition 14) but where  <span class="math">\\bar{\\mathcal{P}}</span>  and  <span class="math">\\bar{\\mathcal{V}}</span>  form an interactive protocol. In particular:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\bar{\\mathcal{P}}(\\mathsf{ek}, \\hat{\\mathbf{x}} = (\\mathsf{ck}, \\mathbf{x}, (\\hat{c}_j)_{j \\in [\\ell]}), \\hat{\\mathbf{w}} = ((\\mathsf{u}_j)_{j \\in [\\ell]}, (o_j)_{j \\in [\\ell]}, \\omega)), \\bar{\\rho}_1, \\ldots, \\bar{\\rho}_i)</span> : the next-message function of  <span class="math">\\bar{\\mathcal{P}}</span>  takes as input the evaluation key  <span class="math">\\mathsf{ek}</span> , the instance  <span class="math">\\hat{\\mathbf{x}}</span> , the witness  <span class="math">\\hat{\\mathbf{w}}</span>  and the first  <span class="math">i</span> -th messages  <span class="math">\\bar{\\rho}_1, \\ldots, \\bar{\\rho}_i</span>  from  <span class="math">\\bar{\\mathcal{V}}</span> .</li>

      <li><span class="math">\\bar{\\mathcal{V}}(\\mathsf{srs}, \\mathsf{vk}, \\hat{\\mathbf{x}}, \\pi_1, \\ldots, \\pi_i)</span> : the next-message function of  <span class="math">\\bar{\\mathcal{V}}</span>  takes as input the verification key  <span class="math">\\mathsf{vk}</span> , the instance  <span class="math">\\hat{\\mathbf{x}}</span>  and the first  <span class="math">i</span> -th messages  <span class="math">\\pi_1, \\ldots, \\pi_i</span>  from the prover  <span class="math">\\bar{\\mathcal{P}}</span> .</li>

    </ul>

    <p class="text-gray-300">At the last round of interaction the verifier outputs a decision bit  <span class="math">b</span> .</p>

    <p class="text-gray-300">When  <span class="math">\\ell = 0</span>  we simply call it a Universal Interactive Argument in the SRS model (Universal UIA). Furthermore, we define the properties of knowledge-soundness as in Definition 14 and of trapdoor-commitment honest-verifier zero-knowledge similar to Definition 17. Specifically:</p>

    <p class="text-gray-300">Knowledge Soundness. Let  <span class="math">\\mathcal{RG}</span>  be a relation generator and  <span class="math">\\mathcal{Z}</span>  an auxiliary input distribution, and let  <span class="math">\\mathcal{RG}_{\\mathrm{Com}}</span>  as in Definition 14, UIA has knowledge soundness for  <span class="math">\\mathcal{RG}</span>  and  <span class="math">\\mathcal{Z}</span> , denoted  <span class="math">\\mathrm{KSND}(\\mathcal{RG},\\mathcal{Z})</span>  for brevity, if for every (non-uniform) efficient adversary  <span class="math">\\mathcal{A} = (\\mathcal{A}_0,\\mathcal{A}_1)</span>  there exists a (non-uniform) efficient extractor  <span class="math">\\mathcal{E}</span>  such that  <span class="math">\\operatorname*{Pr}\\left[\\mathrm{Game}_{\\mathcal{RG},\\mathcal{Z},\\mathcal{A},\\mathcal{E}}^{\\mathrm{KSND}}(\\lambda) = 1\\right] = \\mathrm{negl}</span> . We say that  <span class="math">\\Pi</span>  is knowledge sound if there exist benign  <span class="math">\\mathcal{RG}</span>  and  <span class="math">\\mathcal{Z}</span>  such that  <span class="math">\\Pi</span>  is  <span class="math">\\mathrm{KSND}(\\mathcal{RG},\\mathcal{Z})</span> .</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\operatorname {G a m e} _ {\\mathcal {R G}, \\mathcal {Z}, \\mathcal {A}, \\mathcal {E}} ^ {\\mathrm {K S N D}} (\\lambda) \\rightarrow b \\\\ \\left(\\left(\\operatorname {c k}, \\mathrm {R}\\right), \\operatorname {a u x} _ {R}\\right) \\leftarrow \\mathcal {R G} _ {\\text {C o m}} \\left(1 ^ {\\lambda}\\right); \\quad \\operatorname {s r s}: = (\\operatorname {e k}, \\operatorname {v k}) \\leftarrow \\text {K e y G e n} (\\operatorname {c k}, \\mathrm {R}); \\quad \\operatorname {a u x} _ {Z} \\leftarrow \\mathcal {Z} (\\mathrm {R}, \\operatorname {a u x} _ {R}, \\operatorname {s r s}) \\\\ \\left(\\mathrm {R}, \\hat {\\mathrm {x}} = (\\mathrm {x}, (c _ {j}) _ {j \\in [ \\ell ]}), s t\\right) \\leftarrow \\mathcal {A} _ {0} (\\mathrm {R}, \\mathrm {c k}, \\mathrm {s r s}, \\mathrm {a u x} _ {R}, \\mathrm {a u x} _ {Z}); (\\tau , b ^ {\\prime}) \\leftarrow \\langle \\mathcal {A} _ {1} (s t), \\bar {\\mathcal {V}} (\\text {D e r i v e} (\\mathrm {v k}, \\mathrm {R}), \\mathrm {x}, (c _ {j}) _ {j \\in [ \\ell ]}) \\rangle \\\\ \\hat {\\mathbf {w}} = \\left(\\left(\\mathbf {u} _ {j}\\right) _ {j \\in [ \\ell ]}, \\left(o _ {j}\\right) _ {j \\in [ \\ell ]}, \\omega\\right) \\leftarrow \\mathcal {E} (\\mathrm {R}, \\mathrm {s r s}, \\mathrm {a u x} _ {R}, \\mathrm {a u x} _ {Z}); \\text {r e t u r n} b = b ^ {\\prime} \\wedge \\neg \\mathrm {R} _ {\\mathrm {c k}, \\mathrm {R}} ^ {\\mathrm {C o m}} (\\hat {\\mathrm {x}}, \\hat {\\mathbf {w}}) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Trapdoor-commitment honest-verifier zero-knowledge. A CP-UIA scheme UIA is trapdoor-commit honest-verifier zero-knowledge in the SRS model for a family of universal relations  <span class="math">\\{\\mathcal{R}_{\\mathsf{N}}\\}_{\\mathsf{N}\\in \\mathbb{N}}</span>  if there exists a simulator  <span class="math">S</span>  such that for all adversaries  <span class="math">\\mathcal{A}</span> , for all  <span class="math">\\mathsf{N}\\in \\mathbb{N}</span> , for all  <span class="math">\\mathsf{R}\\in \\mathcal{R}_{\\mathsf{N}}</span> , for all  <span class="math">(\\mathsf{ck},\\mathsf{td})\\in S_{\\mathsf{ck}}(1^{\\lambda})</span> , and for all  <span class="math">(\\mathsf{x},\\mathsf{w})</span>  such that  <span class="math">\\mathsf{R}(\\mathsf{x},\\mathsf{w}) = 1</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\begin{array}{c} (\\mathsf {s r s}, \\mathsf {t d} _ {\\mathsf {k}}) \\leftarrow \\mathsf {K e y G e n} (\\mathsf {c k}, \\mathsf {N}) \\\\ \\mathsf {s r s} _ {\\mathsf {R}} \\leftarrow \\mathsf {D e r i v e} (\\mathsf {s r s}, \\mathsf {R}): \\mathcal {A} (\\mathsf {s r s}, \\mathsf {t d} _ {\\mathsf {k}}, \\mathsf {t d}, \\mathsf {R}, \\mathsf {x}, \\mathsf {w}, \\tau) = 1 \\\\ (\\tau , b) \\leftarrow \\langle \\mathbb {P} (\\mathsf {e k}, \\hat {\\mathsf {x}}, \\hat {\\mathsf {w}}), \\mathbb {V} (\\mathsf {v k}, \\hat {\\mathsf {x}}) \\rangle \\end{array} \\right] \\approx \\\\ \\Pr \\left[ \\begin{array}{c} (\\mathsf {s r s}, \\mathsf {t d} _ {\\mathsf {k}}) \\leftarrow \\mathsf {K e y G e n} (\\mathsf {c k}, \\mathsf {N}) \\\\ \\tau \\leftarrow \\mathcal {S} (\\mathsf {t d} _ {\\mathsf {k}}, \\mathsf {t d}, \\mathsf {R}, \\mathsf {x}) \\end{array} : \\mathcal {A} (\\mathsf {s r s}, \\mathsf {t d} _ {\\mathsf {k}}, \\mathsf {t d}, \\mathsf {R}, \\mathsf {x}, \\mathsf {w}, \\tau) = 1 \\right] \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where recall that  <span class="math">\\hat{\\mathbf{x}} = (\\mathbf{x},(c_j)_{j\\in [\\ell]})</span>  and  <span class="math">\\hat{\\mathbf{w}} = ((\\mathsf{u}_j)_{j\\in [\\ell]},(o_j)_{j\\in [\\ell]},\\omega)</span> .</p>

    <p class="text-gray-300">Succinctness. We say that a public-coin CP-UIA scheme UIA is succinct if, for any input  <span class="math">x \\in \\{0,1\\}^n</span> , both its total communication complexity (the sum of the length of all prover's messages) and the runtime of  <span class="math">\\bar{\\mathcal{V}}</span>  are at most poly-logarithmic in  <span class="math">n</span> .</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Fig. 7. Hybrid Experiments for Proof of Theorem 5</p>

    <p class="text-gray-300">C.2 Proof of Theorem 5</p>

    <p class="text-gray-300">Knowledge Soundness. Let <span class="math">\\mathcal{Z}</span> be a benign auxiliary input distribution and let <span class="math">\\mathcal{A} = (\\mathcal{A}_0, \\mathcal{A}_1)</span> be a non-uniform PT adversary for the knowledge soundness game described in Definition 25. In Figure 7 we describe a sequence of hybrid experiments, the experiments are parameterized by an algorithm <span class="math">\\mathcal{E}^*</span> that they run internally.</p>

    <p class="text-gray-300">Consider the hybrid <span class="math">\\mathbf{H}_0(1^\\lambda, \\mathcal{E}^<em>)</span>. Let <span class="math">b_W^j</span> (resp. <span class="math">b_E^j</span>) be the event of the flag <span class="math">b_W</span> (resp. <span class="math">b_E</span>) being true in the hybrid experiment <span class="math">\\mathbf{H}_j</span>. Formally the events should be parameterized by the extractor <span class="math">\\mathcal{E}^</em></span> that the hybrid is running. However, it is clear that the variable <span class="math">b_W^j</span> does not depend on the specific of <span class="math">\\mathcal{E}^<em></span>, thus for a cleaner presentation we omit it. On the other hand <span class="math">b_E^j</span> depends on <span class="math">\\mathcal{E}^</em></span>, thus when needed we will refer to <span class="math">b_E^j[\\mathcal{E}^<em>]</span> to specify that the event is parameterized by the extractor <span class="math">\\mathcal{E}^</em></span>. By a simple derivation:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\text{Game}_{\\mathcal{Z}, \\mathcal{A}, \\mathcal{E}^*}^{\\text{KSND}} \\right] \\leq \\Pr \\left[ b_W^0 \\right] - \\Pr \\left[ b_E^0 [\\mathcal{E}^*] \\right].</span></div>

    <p class="text-gray-300">Let <span class="math">\\mathbf{H}_1(1^\\lambda, \\mathcal{E}^*)</span> be the same as <span class="math">\\mathbf{H}_0</span> but where the variable <span class="math">b_W</span> is computed differently. Specifically, let <span class="math">\\mathcal{E}_{\\mathrm{php}}</span> be the extractor for the CP-SNARK <span class="math">\\mathsf{CP}_{\\mathsf{php}}</span> and the adversary <span class="math">\\mathcal{A}_{\\mathsf{php}}</span> that runs the same as the adversary <span class="math">\\mathcal{A}</span> but that simply outputs the proof <span class="math">\\pi_{\\mathsf{php}}</span>, the openings <span class="math">(p_j)_{j \\in [n(0)]}, (o_j)_{j \\in [n(0)]}</span> for the rel-typed commitments and the relative statement. Formally, the adversary <span class="math">\\mathcal{A}_{\\mathsf{php}}</span> receives in input <span class="math">\\mathcal{R}_{\\mathsf{php}}, \\mathsf{ck}, \\mathsf{vk}_{\\mathsf{php}}</span> and <span class="math">\\mathsf{aux}_Z^{\\mathsf{PHP}} := \\mathsf{aux}_Z, \\mathsf{vk}_{\\mathsf{opn}}</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\epsilon_{\\mathrm{php}}</span> be the knowledge soundness error (with partial opening) of the CP-SNARK <span class="math">\\mathsf{CP}_{\\mathsf{php}}</span></p>

    <p class="text-gray-300">Lemma 9. <span class="math">\\Pr[b_W^0] \\leq \\Pr[b_W^1] + \\epsilon_{\\mathsf{PHP}}</span></p>

    <p class="text-gray-300">Proof. Notice that <span class="math">\\Pr[b_W^0] - \\Pr[b_W^1] = \\Pr[b_V = 0]</span>. In particular, as described in the definition of the hybrid, the adversary <span class="math">\\mathcal{A}_{\\mathrm{php}}</span> on input the state <span class="math">st</span> runs an execution of the universal argument between <span class="math">\\mathcal{A}_1</span> and the honest verifier and then outputs <span class="math">\\big((i_j, d_j)_{j \\in [n_p]}, (G_j, \\pmb{v}_j)_{j \\in [n_a]}, (c_j)_{j \\in [n^*]}\\big)</span> and the proof <span class="math">\\pi_{\\mathrm{php}}</span>. Since <span class="math">b = 1</span> then it means that the proof <span class="math">\\pi_{\\mathrm{php}}</span> is valid, but <span class="math">b_V = 0</span>, i.e., the extractor does not output a valid witness.</p>

    <p class="text-gray-300">Let <span class="math">\\mathbf{H}_2(1^\\lambda, \\mathcal{E}^*)</span> be the same as <span class="math">\\mathbf{H}_1</span> but where the variable <span class="math">b_W</span> is computed differently. Specifically, let <span class="math">\\mathcal{E}_i&#x27;</span> be the extractor for the adversary <span class="math">\\mathcal{A}^i</span> that runs the same as the adversary <span class="math">\\mathcal{A}</span> but that simply outputs the <span class="math">(c_{i,j})_{j\\in [n(i)]} \\cdot \\pi_{\\mathrm{opn},i}</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\epsilon_{\\mathrm{opn}}</span> be the knowledge soundness error of the CP-SNARK <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span>.</p>

    <p class="text-gray-300">Lemma 10. <span class="math">\\Pr[b_W^1] \\leq \\Pr[b_W^2] + r \\cdot \\epsilon_{\\mathrm{opn}}</span></p>

    <p class="text-gray-300">Proof. Similarly to the previous lemma, <span class="math">\\Pr[b_W^1] - \\Pr[b_W^2] = \\Pr[b_W^1 \\wedge \\exists i: b_V^i = 0] \\leq r \\cdot \\max_i \\Pr[b_W^1 \\wedge b_V^i = 0] \\leq r \\cdot \\epsilon_{\\mathrm{opn}}</span>. Since <span class="math">b = 1</span> then it means that <span class="math">\\mathsf{Verify}_{\\mathsf{opn}}(\\mathsf{vk}_{\\mathsf{opn}}), (c_{i,j})_{j \\in n(i)}, \\pi_{\\mathsf{opn},i}) = 1</span>, but <span class="math">b_V^i = 0</span> thus the extractor does not extract valid openings the commitments.</p>

    <p class="text-gray-300">Let <span class="math">\\mathbf{H}_3(1^\\lambda, \\mathcal{E}^*)</span> be the same as <span class="math">\\mathbf{H}_2</span> but where the variable <span class="math">b_W</span> is computed differently. Specifically, we check that the extractions of the CP-SNARKs agree. Let <span class="math">\\epsilon_{\\mathsf{CS}}</span> be the advantage against the binding of CS.</p>

    <p class="text-gray-300">Lemma 11. <span class="math">\\Pr[b_W^2] \\leq \\Pr[b_W^3] + \\epsilon_{\\mathsf{CS}}</span></p>

    <p class="text-gray-300">Proof. Notice that <span class="math">\\operatorname<em>{Pr}[b_W^3] \\leq \\operatorname</em>{Pr}[b_W^3] + \\operatorname<em>{Pr}[b_{\\mathsf{CS}} = 0]</span>. We reduce to the binding of CS. In particular consider the adversary that runs <span class="math">\\mathbf{H}_3</span> and if <span class="math">b_{C} = 0</span> it outputs the values <span class="math">(p_j, o_j, p_j&#x27;, o_j&#x27;)</span> for the index <span class="math">j</span> that make <span class="math">b_{\\mathsf{CS}} = 0</span>. Thus <span class="math">\\operatorname</em>{Pr}[b_{\\mathsf{CS}} = 0] \\leq \\epsilon_{\\mathsf{CS}}</span>.</p>

    <p class="text-gray-300">Consider the following PPT sampler algorithm:</p>

    <p class="text-gray-300">Sampler <span class="math">\\mathcal{D}(1^{\\lambda})</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{pp} \\leftarrow \\operatorname{ParGen}(1^{\\lambda}) ; \\quad \\mathsf{srs} := (\\mathsf{ek}, \\mathsf{vk}) \\leftarrow \\operatorname{KeyGen}(\\mathsf{pp}, \\mathsf{N}) ; \\quad \\mathsf{aux}_Z \\leftarrow \\mathcal{Z}(\\mathsf{srs}) ;</span></div>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf{R}, \\mathsf{x}, \\mathsf{st}) \\leftarrow \\mathcal{A}_0(\\mathsf{srs}, \\mathsf{aux}_Z) ; \\quad \\mathsf{aux}_Z&#x27; := (\\mathsf{srs}, \\mathsf{aux}_Z) ; \\quad \\mathsf{return} (\\mathsf{R}, \\mathsf{x}, \\mathsf{aux}_Z&#x27;)</span></div>

    <p class="text-gray-300">Lemma 12. There exists a prover <span class="math">\\mathcal{P}^*</span> for the protocol PHP such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\langle \\mathcal {P} ^ {*} (\\mathbb {F}, \\mathsf {R}, \\mathrm {x}, z), \\mathcal {V} ^ {\\mathcal {R E} (\\mathbb {F}, \\mathsf {R})} (\\mathbb {F}, \\mathrm {x}) \\rangle = 1: (\\mathsf {R}, \\mathrm {x}, \\operatorname {a u x} _ {Z} ^ {\\prime}) \\leftarrow_ {\\#} \\mathcal {D} (1 ^ {\\lambda}) \\right] = \\Pr \\left[ b _ {W} ^ {3} \\right] \\tag {36}</span></div>

    <p class="text-gray-300">Proof. We define the prover <span class="math">\\mathcal{P}^<em></span>. For any <span class="math">i, j</span>, let <span class="math">ind(i, j) \\coloneqq \\sum_{i&#x27; &amp;lt; i} \\mathfrak{n}^</em>(i&#x27;) + j</span> and let <span class="math">ind^{-1}</span> its inverse in the domain <span class="math">[\\mathfrak{n}^*]</span>. Namely, the function <span class="math">ind</span> re-indexes the <span class="math">j</span>-th polynomial sent at the <span class="math">i</span>-th round as the <span class="math">ind(i, j)</span>-th polynomial sent by the prover.</p>

    <p class="text-gray-300">Prover <span class="math">\\mathcal{P}^* (\\mathsf{R},\\mathsf{x},\\mathsf{aux}_Z&#x27;,\\rho_1,\\ldots ,\\rho_i))</span>:</p>

    <p class="text-gray-300"><span class="math">(R,x,st)\\gets \\mathcal{A}_0(\\mathsf{aux}_Z^{\\prime})</span>  ；</p>

    <p class="text-gray-300">if <span class="math">i = r + 1</span> then :</p>

    <p class="text-gray-300"><span class="math">(c_{i,j})_{j\\in [\\mathfrak{n}(i)]},\\{\\pi_{i,j}\\}_{j\\in [\\mathfrak{r}(i)]},\\pi_{\\mathsf{php}}\\gets \\mathcal{A}_1(st,\\rho_1,\\ldots ,\\rho_{\\mathfrak{r}})</span>  ；</p>

    <p class="text-gray-300"><span class="math">\\hat{\\mathbf{x}}_{\\mathsf{PHP}} := \\big((i_j, d_j)_{j \\in [n_{\\mathfrak{p}}]}, (G_j&#x27;, \\mathbf{v}_j)_{j \\in [n_{\\mathfrak{v}}]}, (c_j)_{j \\in [n^*]}\\big)</span>  ；</p>

    <p class="text-gray-300">if Verifyphp(vkphp, <span class="math">\\hat{\\mathbf{x}}_{\\mathsf{PHP}}, \\pi) = 0</span> then return <span class="math">\\perp</span> ；</p>

    <p class="text-gray-300"><span class="math">(p_k&#x27;, o_k&#x27;)_{k \\in [n^*]} \\gets \\mathcal{E}_{\\mathsf{php}}(\\mathcal{R}_{\\mathsf{php}}, \\mathsf{ck}, \\mathsf{srs}, \\mathsf{aux}_Z)</span> ；</p>

    <p class="text-gray-300">for <span class="math">k\\in [\\mathfrak{n}^* ]</span> let <span class="math">p_{i,j}\\coloneqq p_{ind^{-1}(k)}^{\\prime}</span> ；</p>

    <p class="text-gray-300">if <span class="math">\\exists i,j:p_{i,j}^{\\prime}\\neq p_{i,j}</span> then return <span class="math">\\perp</span> ；</p>

    <p class="text-gray-300">else :</p>

    <p class="text-gray-300"><span class="math">(c_{i,j})_{j\\in [\\mathfrak{n}(i)]},\\{\\pi_{i,j}\\}_{j\\in [\\mathfrak{r}(i)]},\\pi_j\\gets \\mathcal{A}_1(st,\\rho_1,\\ldots ,\\rho_i))</span> ；</p>

    <p class="text-gray-300">if Verifyopn(vkphp, <span class="math">\\pi_j</span>) = 0 then return <span class="math">\\perp</span> ；</p>

    <p class="text-gray-300"><span class="math">(p_{i,j},o_{i,j})_{j\\in [\\mathfrak{n}(i)]} \\gets \\mathcal{E}_j&#x27;(\\mathsf{ek}_{\\mathsf{opn}},\\mathsf{aux}_Z)</span></p>

    <p class="text-gray-300">if <span class="math">\\exists j: \\operatorname{VerCom}(\\mathsf{ck}, c_{i,j}, p_{i,j}, o_{i,j}) = 0</span> then return <span class="math">\\perp</span> ；</p>

    <p class="text-gray-300">return <span class="math">(p_{i,j})_{j\\in [\\mathfrak{n}(i)]},\\{\\pi_{i,j}\\}_{j\\in [\\mathfrak{r}(i)]};</span></p>

    <p class="text-gray-300">By inspection, if <span class="math">\\mathcal{P}^<em></span> does not output <span class="math">\\perp</span> then the output of <span class="math">\\mathcal{P}^</em></span> is computed exactly the same as <span class="math">\\mathcal{A}</span> does. Moreover, the prover <span class="math">\\mathcal{P}^*</span> outputs <span class="math">\\perp</span> only when either the verification of the <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span> fails (if round <span class="math">i \\leq r</span>) or the verification of the <span class="math">\\mathsf{CP}_{\\mathsf{php}}</span> fails (if last round) or exists index <span class="math">j</span> s.t. <span class="math">\\mathsf{VerCom}(\\mathsf{ck}, c_{i,j}, p_{i,j}, o_{i,j}) = 0</span> or the binding property of CS is violated. Notice that if <span class="math">b_W^3</span> holds then none of the previous events can happen.</p>

    <p class="text-gray-300">Notice that we can rewrite the Eq. (36) as:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {E} _ {\\left(\\mathrm {R}, \\mathrm {x}, \\mathrm {a u x} _ {Z} ^ {\\prime}\\right) \\leftarrow \\#} \\mathcal {D} \\left(1 ^ {\\lambda}\\right) \\left[ \\Pr \\left[ \\langle \\mathcal {P} ^ {*} (\\mathbb {F}, \\mathrm {R}, \\mathrm {x}, z), \\mathcal {V} ^ {\\mathcal {R E} (\\mathbb {F}, \\mathrm {R})} (\\mathbb {F}, \\mathrm {x}) \\rangle = 1 \\right] \\right] = \\Pr \\left[ b _ {W} ^ {3} \\right]</span></div>

    <p class="text-gray-300">Thus by applying the knowledge soundness of PHP there exists an extractor <span class="math">\\mathcal{E}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {E} _ {\\left(\\mathrm {R}, \\mathrm {x}, \\mathrm {a u x} _ {Z} ^ {\\prime}\\right) \\leftarrow \\#} \\mathcal {D} \\left(1 ^ {\\lambda}\\right) \\left[ \\Pr \\left[ \\mathcal {E} ^ {\\mathcal {P} ^ {*}} \\left(\\mathrm {R}, \\mathrm {x}, \\mathrm {a u x} _ {Z} ^ {\\prime}\\right) \\right] + \\epsilon_ {\\mathrm {P H P}} \\right] \\geq \\Pr \\left[ b _ {W} ^ {3} \\right]</span></div>

    <p class="text-gray-300">Equivalently we can rewrite the equation above:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathcal {E} ^ {\\mathcal {P} ^ {*}} \\left(\\mathrm {R}, \\mathrm {x}, \\mathrm {a u x} _ {Z} ^ {\\prime}\\right): \\left(\\mathrm {R}, \\mathrm {x}, \\mathrm {a u x} _ {Z} ^ {\\prime}\\right) \\leftarrow_ {\\#} \\mathcal {D} \\left(1 ^ {\\lambda}\\right) \\right] + \\epsilon_ {\\mathrm {P H P}} \\geq \\Pr \\left[ b _ {W} ^ {3} \\right].</span></div>

    <p class="text-gray-300">Finally, we define the extractor <span class="math">\\mathsf{Ext}^<em> \\coloneqq \\mathsf{Ext}^{\\mathcal{P}^</em>}</span>. It is easy to see that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\operatorname {E x t} ^ {\\mathcal {P} ^ {*}} \\left(\\mathrm {R}, \\mathrm {x}, \\operatorname {a u x} _ {Z} ^ {\\prime}\\right): \\left(\\mathrm {R}, \\mathrm {x}, \\operatorname {a u x} _ {Z} ^ {\\prime}\\right) \\leftarrow_ {\\#} \\mathcal {D} \\left(1 ^ {\\lambda}\\right) \\right] = \\Pr \\left[ b _ {E} ^ {0} \\left[ \\mathcal {E} ^ {*} \\right] \\right]</span></div>

    <p class="text-gray-300">The equation above holds by definition of <span class="math">\\mathcal{D}</span> and <span class="math">\\mathcal{E}^*</span>. Thus we can conclude:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left[ \\operatorname {G a m e} _ {Z, \\mathcal {A}, \\mathcal {E} ^ {*}} ^ {\\mathrm {K S N D}} \\right] \\leq \\Pr \\left[ b _ {W} ^ {0} \\right] - \\Pr \\left[ b _ {E} ^ {0} \\right] \\leq \\Pr \\left[ b _ {W} ^ {3} \\right] - \\Pr \\left[ b _ {E} ^ {0} \\right] + N \\cdot \\epsilon_ {\\text {s n a r k}} + (\\mathrm {n} ^ {*} + 1) \\epsilon_ {\\mathrm {C S}} \\\\ \\leq \\epsilon_ {\\mathrm {P H P}} + N \\cdot \\epsilon_ {\\mathrm {s n a r k}} + (\\mathsf {n} ^ {*} + 1) \\epsilon_ {\\mathsf {C S}}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Zero Knowledge. We now prove that under the condition of the statement of the theorem the UIA is trapdoor commitment honest-verifier zero-knowledge.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{C}</span> and <span class="math">\\mathcal{S}_{\\mathsf{PHP}}</span> be the checker and the simulator for the claimed <span class="math">(\\mathsf{C},\\mathsf{b}_{\\mathsf{PHP}})</span>-bounded zero-knowledge of <span class="math">\\mathsf{PHP}</span>. Let <span class="math">\\mathcal{S} = (\\mathcal{S}_{\\mathsf{leak}}^{\\prime},\\mathcal{S}_{\\mathsf{prv}}^{\\prime})</span> be the simulator of <span class="math">\\mathsf{CP}_{\\mathsf{php}}</span>. Let <span class="math">\\mathcal{S}&#x27;&#x27;</span> be the simulator of <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span>. Consider the simulator <span class="math">\\mathcal{S}_{\\mathsf{UIA}} = (\\mathcal{S}_{\\mathsf{kg}},\\mathcal{S}_{\\mathsf{prv}})</span>:</p>

    <p class="text-gray-300">Simulator <span class="math">\\mathcal{S}_{\\mathrm{kg}}(\\mathrm{ck},\\mathrm{td}_{\\mathrm{ck}},\\mathsf{N})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample <span class="math">\\mathsf{ek}_{\\mathrm{opn}},\\mathsf{vk}_{\\mathrm{opn}},\\mathsf{td}_{\\mathsf{k}}^{\\mathrm{opn}}\\gets \\mathsf{S}_{\\mathrm{kg}}^{\\prime \\prime}(\\mathrm{ck},\\mathrm{td}_{\\mathrm{ck}})</span> and output <span class="math">\\mathsf{ek}_{\\mathrm{php}},\\mathsf{vk}_{\\mathrm{php}},\\mathsf{td}_{\\mathsf{k}}^{\\mathrm{php}}</span> and output <span class="math">\\mathsf{vk} = \\mathsf{ck},\\mathsf{ek}_{\\mathrm{opn}},\\mathsf{ek}_{\\mathrm{php}}</span> and <span class="math">\\mathsf{vk} = \\mathsf{ck},\\mathsf{vk}_{\\mathrm{opn}},\\mathsf{vk}_{\\mathrm{php}}</span> and <span class="math">\\mathsf{td}_{\\mathsf{k}} := \\mathsf{td}_{\\mathsf{k}}^{\\mathrm{opn}},\\mathsf{td}_{\\mathsf{k}}^{\\mathrm{php}},\\mathsf{td}_{\\mathrm{ck}}</span>.</li>

    </ol>

    <p class="text-gray-300">Simulator <span class="math">\\mathcal{S}_{\\mathrm{prv}}(\\mathrm{td}_k,\\mathsf{R},\\mathsf{x})</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Init Phase. Let $\\mathsf{r} := \\mathsf{r}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Run the honest verifier on input </span>\\mathsf{vk}_{\\mathsf{R}}<span class="math"> and </span>\\mathsf{x}<span class="math">, obtain a sequence of messages </span>\\rho_1, \\ldots, \\rho_{r+1}<span class="math"> and the constraints </span>((G_j, \\boldsymbol{v}_j))_{j \\in [n_r]}, (i_j, d_j)_{j \\in [n_r]}<span class="math">. Set </span>\\bar{\\rho} := (\\rho_j)_{j \\in [r+1]}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Parse the trapdoor <span class="math">\\mathsf{td}_{\\mathsf{k}}</span> as <span class="math">(\\mathsf{td}_{\\mathsf{k}}^{\\mathsf{opn}}, \\mathsf{td}_{\\mathsf{k}}^{\\mathsf{php}}, \\mathsf{td}, s)</span> where <span class="math">s \\in \\mathbb{F}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define Leakage. Let <span class="math">\\mathcal{L}&#x27; \\gets \\mathcal{S}_{\\text{leak}}&#x27;(\\bar{\\mathbf{x}}_{\\mathsf{PHP}})</span>. Let <span class="math">\\mathcal{L} := \\mathcal{L}&#x27; \\cup \\{(i, s) : i \\in [\\mathfrak{n}^*] \\}</span>. Assert that <span class="math">\\mathsf{C}(i, x)</span> for all <span class="math">(i, x) \\in \\mathcal{L}</span>;</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Create Transcript. Compute the following:</li>

    </ol>

    <p class="text-gray-300">(a) Run the simulator <span class="math">\\mathcal{S}_{\\mathsf{PHP}}(\\mathbb{F},\\mathsf{R},\\mathsf{x},\\mathcal{L})</span> and obtain a simulated transcript <span class="math">\\tilde{\\tau} = (\\pi_1,\\rho_1,\\dots ,\\pi_r,\\rho_r)</span>, and a set of simulated evaluated points <span class="math">\\{\\tilde{p}_i(y):(i,y)\\in \\mathcal{L}\\}</span>;</p>

    <p class="text-gray-300">(b) For <span class="math">j \\in [\\mathfrak{n}^*]</span> compute the simulated commitment: set <span class="math">\\tilde{c}_j, st_j \\gets \\mathsf{TdCom}(\\mathsf{td}_k, \\tilde{p}_j(s))</span>;</p>

    <p class="text-gray-300">(c) Let <span class="math">leak&#x27; := (\\tilde{p}_i(y))_{(i,y) \\in \\mathcal{L}}</span> and let <span class="math">\\bar{\\mathbf{x}}_{\\mathsf{PHP}} := \\big((i_j, d_j)_{j \\in [\\mathfrak{n}_r]}, (G&#x27;_j, \\mathbf{v}_j)_{j \\in [\\mathfrak{n}_r]}, (c_j)_{j \\in [\\mathfrak{n}^*}]\\big)</span>, compute the simulated proof <span class="math">\\widetilde{\\pi_{\\mathsf{php}}} \\gets S_{\\mathsf{prv}}&#x27;(\\mathsf{td}_{\\mathsf{k}}^{\\mathsf{php}}, \\bar{\\mathbf{x}}_{\\mathsf{PHP}}, leak&#x27;)</span>;</p>

    <p class="text-gray-300">(d) For <span class="math">i \\in [r]</span> compute the simulated proof <span class="math">\\widetilde{\\pi_{\\mathrm{opn},i}} \\gets S&#x27;&#x27;(\\mathrm{td}_k^{\\mathrm{opn}},(c_{i,j})_{j \\in r(i)})</span>;</p>

    <p class="text-gray-300">Output the full transcript re-ordered according to the specification of the protocol.</p>

    <p class="text-gray-300">We consider a sequence of hybrid experiments. The first hybrid <span class="math">\\mathbf{H}_0</span> receives in input the trapdoor <span class="math">\\mathsf{td}_{\\mathsf{k}}</span>, the specific relation <span class="math">\\mathsf{R}</span>, the input <span class="math">\\mathsf{x}</span> and the witness <span class="math">\\mathsf{w}</span>, runs the same steps of simulator <span class="math">\\mathcal{S}_{\\mathsf{prv}}</span> defined above, and outputs the full view including the evaluation points.</p>

    <p class="text-gray-300">The next hybrid <span class="math">\\mathbf{H}_1</span> runs the same as <span class="math">\\mathbf{H}_0</span> but instead of running <span class="math">\\mathcal{S}_{\\mathsf{PHP}}</span> at step 3, it runs the real protocol between <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> and computes the evaluation points using the polynomial oracles output by <span class="math">\\mathcal{P}</span>.</p>

    <p class="text-gray-300"><strong>Lemma 13.</strong> For all <span class="math">\\mathsf{ck},\\mathsf{R},\\mathsf{x},\\mathsf{w}</span> and for any adversary <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathcal {A} (\\operatorname {s r s}, \\mathbf {H} _ {0} \\left(\\mathrm {t d} _ {\\mathrm {k}}, \\mathrm {R}, \\mathrm {x}, \\mathrm {w}\\right)\\right) = 1 \\right] - \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathcal {A} (\\operatorname {s r s}, \\mathbf {H} _ {1} \\left(\\mathrm {t d} _ {\\mathrm {k}}, \\mathrm {R}, \\mathrm {x}, \\mathrm {w}\\right)\\right) = 1 \\right] \\in \\operatorname {n e g l} (\\lambda)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Proof.</strong> Notice that if the assertion in step 2 does not hold the two hybrids are equivalent. Thus we can assume the assertion holds, in this case the list <span class="math">\\mathcal{L}</span> is <span class="math">(\\mathsf{C},\\mathsf{b} + \\mu (\\pmb {t}))</span>-bounded. The proof of the lemma follows straightforwardly from the <span class="math">(\\mathsf{C},\\mathsf{b} + \\mu (\\pmb {t}))</span>-bounded zero-knowledge of PHP.</p>

    <p class="text-gray-300">The next hybrid <span class="math">\\mathbf{H}_2</span> is the same as <span class="math">\\mathbf{H}_1</span> but the assertion in step 2 is not executed.</p>

    <p class="text-gray-300"><strong>Lemma 14.</strong> For all <span class="math">\\mathsf{ck},\\mathsf{R},\\mathsf{x},\\mathsf{w}</span> and for any adversary <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathcal {A} (\\operatorname {s r s}, \\mathbf {H} _ {1} \\left(\\mathrm {t d} _ {\\mathrm {k}}, \\mathrm {R}, \\mathrm {x}, \\mathrm {w}\\right)\\right) = 1 \\right] - \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathcal {A} (\\operatorname {s r s}, \\mathbf {H} _ {2} \\left(\\mathrm {t d} _ {\\mathrm {k}}, \\mathrm {R}, \\mathrm {x}, \\mathrm {w}\\right)\\right) = 1 \\right] \\in \\operatorname {n e g l} (\\lambda)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Proof.</strong> The two hybrids diverge if there is tuple <span class="math">(i,x)\\in \\mathcal{L}</span> such that <span class="math">\\mathsf{C}(i,x) = 0</span>. Notice that, by our assumption on <span class="math">\\mathsf{C}</span> (Definition 2), a tuple <span class="math">(i,s)</span> does not pass the checker with negligible probability (since the trapdoor element <span class="math">s</span> is chosen uniformly at random). Moreover, by the bounded leakage property of the <span class="math">(\\mathsf{b},\\mathsf{C})</span>-leaky zero knowledge of <span class="math">\\mathsf{CP}_{\\mathsf{php}}</span>, a tuple in <span class="math">\\mathcal{L}</span> does not pass the check with negligible probability. We can conclude applying union bound.</p>

    <p class="text-gray-300">The next hybrid <span class="math">\\mathbf{H}_3</span> is the same as <span class="math">\\mathbf{H}_2</span> but the commitments are computed as in the real protocol, specifically for any <span class="math">i,j</span> where <span class="math">i &amp;gt; 1</span> we compute <span class="math">c_{i,j}, o_{i,j} \\gets \\text{Commit}(\\text{ck}, \\text{swh}, p_{i,j})</span>.</p>

    <p class="text-gray-300"><strong>Lemma 15.</strong> For all <span class="math">\\mathsf{ck},\\mathsf{R},\\mathsf{x},\\mathsf{w}</span> and for any adversary <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathcal{A}(\\text{srs}, \\mathbf{H}_2(\\text{td}_k, \\mathsf{R}, \\mathsf{x}, \\mathsf{w})) = 1 \\right] - \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathcal{A}(\\text{srs}, \\mathbf{H}_3(\\text{td}_k, \\mathsf{R}, \\mathsf{x}, \\mathsf{w})) = 1 \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in \\operatorname{negl}(\\lambda) \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The lemma easily follows by the swh-typed somewhat-hiding property of CS.</p>

    <p class="text-gray-300">The next hybrid <span class="math">\\mathbf{H}_4</span> is the same as <span class="math">\\mathbf{H}_3</span> but at step (c), the proof is computed with the algorithm <span class="math">\\text{Prove}_{\\text{php}}</span> and the polynomial oracles <span class="math">p_1, \\ldots, p_{n^*}</span>.</p>

    <p class="text-gray-300"><strong>Lemma 16.</strong> For all <span class="math">\\mathsf{ck},\\mathsf{td}_k,\\mathsf{R},\\mathsf{x},\\mathsf{w}</span> and for any adversary <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathcal{A}(\\text{srs}, \\mathbf{H}_3(\\text{td}_k, \\mathsf{R}, \\mathsf{x}, \\mathsf{w})) = 1 \\right] - \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathcal{A}(\\text{srs}, \\mathbf{H}_4(\\text{td}_k, \\mathsf{R}, \\mathsf{x}, \\mathsf{w})) = 1 \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in \\operatorname{negl}(\\lambda) \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The lemma easily follows by the leaky zero-knowledge of the CP-SNARK <span class="math">\\mathsf{CP}_{\\mathsf{php}}</span>.</p>

    <p class="text-gray-300">The next hybrid <span class="math">\\mathbf{H}_5</span> is the same as <span class="math">\\mathbf{H}_4</span> but at step (d), for any round <span class="math">i \\in [\\mathsf{r}]</span>, the proofs are computed with the algorithm <span class="math">\\text{Prove}_{\\text{opn}}</span> and the polynomial oracles <span class="math">p_{i,j}</span>.</p>

    <p class="text-gray-300"><strong>Lemma 17.</strong> For all <span class="math">\\mathsf{ck},\\mathsf{td}_k,\\mathsf{R},\\mathsf{x},\\mathsf{w}</span> and for any adversary <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathcal{A}(\\text{srs}, \\mathbf{H}_4(\\text{td}_k, \\mathsf{R}, \\mathsf{x}, \\mathsf{w})) = 1 \\right] - \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathcal{A}(\\text{srs}, \\mathbf{H}_5(\\text{td}_k, \\mathsf{R}, \\mathsf{x}, \\mathsf{w})) = 1 \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in \\operatorname{negl}(\\lambda) \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The lemma easily follows by the zero-knowledge of the CP-SNARK <span class="math">\\mathsf{CP}_{\\mathsf{opn}}</span>.</p>

    <h2 id="sec-104" class="text-2xl font-bold">C.3 Proof of Theorem 15</h2>

    <p class="text-gray-300">The proof of zero-knowledge is almost the same as in the proof of Thm. 5, for knowledge soundness there are some differences that we highlight next.</p>

    <p class="text-gray-300">Consider the hybrid <span class="math">\\mathbf{H}_3</span> as in the proof of Thm. 5 and the event <span class="math">b_W</span>. For clarity we rewrite the hybrid below. The only difference with the hybrid from Thm. 5 is that they hybrid below does not run the extractor <span class="math">\\mathcal{E}^*</span> since we are interested only in the event <span class="math">b_W</span>.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{H}_3(1^\\lambda)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf{pp} \\leftarrow \\operatorname{ParGen}(1^\\lambda); \\quad \\mathsf{ck} \\leftarrow \\mathsf{CS}^*. \\text{Setup}(\\mathsf{pp}); \\quad \\mathsf{srs} := (\\mathsf{ek}, \\mathsf{vk}) \\leftarrow \\text{KeyGen}(\\mathsf{pp}, \\mathsf{ck}, \\mathsf{N}); \\quad \\mathsf{aux}_Z \\leftarrow \\mathcal{Z}(\\mathsf{srs}); \\\\ \\big(R, \\hat{\\mathbf{x}} = (\\mathbf{x}, (c_j)_{j \\in [\\ell]}), st\\big) \\leftarrow \\mathcal{A}_0(\\mathsf{srs}, \\mathsf{aux}_Z); \\quad (\\tau, b) \\leftarrow \\langle \\mathcal{A}_1(\\mathsf{st}), \\mathbb{V}(\\text{Derive}(\\mathsf{vk}, \\mathsf{R}), \\mathbf{x}, (c_j)_{j \\in [\\ell]}) \\rangle; \\\\ (p_j&#x27;, o_j&#x27;)_{j \\in [n^*]} \\leftarrow \\mathcal{E}(\\mathcal{R}_{\\mathsf{php}}, \\mathsf{srs}, \\mathsf{aux}_Z); \\\\ b_V \\leftarrow \\bigwedge_k \\left(G_k(X, \\{p_j&#x27;(v_{k,j}(X))\\}_{j \\in [n^*]}, \\{\\pi_j\\}_{j \\in [m^*]}) \\equiv 0\\right) \\wedge \\bigwedge_k \\left(\\deg(p_{i_k}&#x27;) \\leq d_k\\right) \\wedge \\bigwedge_k \\text{VerCom}(\\mathsf{ck}, c_k, p_k&#x27;, o_k&#x27;); \\\\ \\text{for } j \\in [\\mathsf{r}] : (p_{i,j}, o_{i,j})_{j \\in [\\mathsf{n}(i)]} \\leftarrow \\mathcal{E}_j&#x27;(\\mathsf{vk}_{\\mathsf{opn}}, \\mathsf{aux}_Z); \\quad b_V^j \\leftarrow \\bigwedge_{j \\in [\\mathsf{n}(i)]} \\text{VerCom}(\\mathsf{ck}, c_{i,j}, p_{i,j}, o_{i,j}) \\\\ \\text{let } (p_j)_{j \\in [n^*]} := (p_{i,j})_{i \\in [\\mathsf{r}], j \\in [\\mathsf{n}(i)]}; \\quad b_{\\mathsf{CS}} \\leftarrow \\forall j: p_j&#x27; = p_j; \\\\ b_W \\leftarrow b \\wedge b_V \\wedge (\\wedge_j b_V^j) \\wedge b_{\\mathsf{CS}}; \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Consider the hybrid <span class="math">\\mathbf{H}_4</span> which is the same as <span class="math">\\mathbf{H}_3</span> but additionally check that the linking relation holds. Recall that for a PHP has a straight-line extractor WitExtract.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{E}_{\\mathrm{link}}</span> be the extractor for the CP-SNARK for the adversary <span class="math">\\mathcal{A}_{\\mathrm{link}}</span> that runs the same as the adversary <span class="math">\\mathcal{A}</span> but that simply outputs the proof <span class="math">\\pi_{\\mathrm{link}}</span> and the statement <span class="math">((\\hat{c}_j)_{j \\in [\\ell]}, (c_j)_{j \\in [n^*]})</span>. Formally, the adversary <span class="math">\\mathcal{A}_{\\mathrm{link}}</span> receives in input <span class="math">\\mathsf{R}_{\\mathrm{link}}, \\mathsf{ck}, \\mathsf{srs}_{\\mathrm{link}}</span> and <span class="math">\\mathsf{aux}_Z^{\\mathrm{link}}</span> where <span class="math">\\mathsf{aux}_Z^{\\mathrm{link}}</span> contains all the other values, namely the elements of <span class="math">\\mathsf{srs}</span> different than <span class="math">\\mathsf{srs}_{\\mathrm{link}}</span>, and <span class="math">\\mathsf{n_e}</span> and <span class="math">\\mathsf{R}</span>. In particular:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{H}_4(1^\\lambda)</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf{pp} \\leftarrow \\operatorname{ParGen}(1^{\\lambda}) ; \\mathsf{ck} \\leftarrow \\operatorname{Setup}(\\mathsf{pp}) ; \\mathsf{srs} := (\\mathsf{ek}, \\mathsf{vk}) \\leftarrow \\operatorname{KeyGen}(\\mathsf{pp}, \\mathsf{ck}, \\mathsf{N}) ; \\mathsf{aux}_Z \\leftarrow \\mathcal{Z}(\\mathsf{srs}) ; \\\\ \\big(R, \\tilde{\\mathbf{x}} = (\\mathbf{x}, (c_j)_{j \\in [\\ell]}), st\\big) \\leftarrow \\mathcal{A}_0(\\mathsf{srs}, \\mathsf{aux}_Z) ; (\\tau, b) \\leftarrow \\langle \\mathcal{A}_1(st), \\mathbb{V}(\\text{Derive}(\\mathsf{vk}, \\mathsf{R}), \\mathbf{x}, (c_j)_{j \\in [\\ell]}) \\rangle ; \\\\ \\boxed{((\\mathsf{u}_j)_{j \\in [\\ell]}, (\\tilde{o}_j)_{j \\in [\\ell]}, (p_j&#x27;&#x27;)_{j \\in [n^*]}, (o_j&#x27;&#x27;)_{j \\in [n^*]}) \\leftarrow \\mathcal{E}_{\\text{link}}(\\mathsf{R}_{\\text{link}}, \\mathsf{ck}, \\mathsf{srs}_{\\text{link}}, \\mathsf{aux}_Z^{\\text{link}})} ; \\\\ \\boxed{\\mathsf{w} = \\bar{\\mathsf{u}}, \\omega \\leftarrow \\operatorname{WitExtract}((p_j&#x27;&#x27;)_{j \\in [n^*}])} ; \\\\ \\boxed{b_V^{\\text{link}} \\leftarrow \\wedge_{j \\in [\\ell]} (\\operatorname{VerCom}(\\mathsf{ck}, \\hat{c}_j, \\tilde{o}_j, \\mathsf{u}_j) = 1) \\wedge_{l \\in [n]} (\\operatorname{VerCom}(\\mathsf{ck}, c_{i_l, j_l}, o_l, p_l) = 1) \\wedge \\operatorname{Decode}((\\mathsf{u}_j)_{j \\in [\\ell]}) = \\bar{\\mathsf{u}}} ; \\\\ (p_j&#x27;, o_j&#x27;)_{j \\in [n^*]} \\leftarrow \\mathcal{E}(\\mathcal{R}_{\\mathsf{php}}, \\mathsf{ck}, \\mathsf{srs}, \\mathsf{aux}_Z) ; \\\\ b_V \\leftarrow \\bigwedge_k \\left(G_k(X, \\{p_j&#x27;(v_{k,j}(X))\\}_{j \\in [n^*]}, \\{\\pi_j\\}_{j \\in [m^*]}) \\equiv 0\\right) \\wedge \\bigwedge_k \\left(\\deg(p_{i_k}&#x27;) \\leq d_k\\right) \\wedge \\bigwedge_k \\operatorname{VerCom}(\\mathsf{ck}, c_k, p_k&#x27;, o_k&#x27;) ; \\\\ \\text{for } j \\in [\\mathsf{r}] : (p_{i,j}, o_{i,j})_{j \\in [n(i)]} \\leftarrow \\mathcal{E}_j&#x27;(\\mathsf{vk}_{\\mathsf{opn}}, \\mathsf{ck}, \\mathsf{aux}_Z) ; \\quad b_V^j \\leftarrow \\bigwedge_{j \\in [n(i)]} \\operatorname{VerCom}(\\mathsf{ck}, c_{i,j}, p_{i,j}, o_{i,j}) \\\\ \\text{let } (p_j)_{j \\in [n^*]} := (p_{i,j})_{i \\in [\\mathsf{r}], j \\in [n(i)]} ; \\quad b_{\\mathsf{CS}} \\leftarrow \\forall j : p_j&#x27; = p_j = p_j&#x27;&#x27; ; \\\\ b_W \\leftarrow b \\wedge b_V \\wedge (\\wedge_j b_V^j) \\wedge b_{\\mathsf{CS}} \\boxed{\\wedge b_V^{\\text{link}}} ; \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Let <span class="math">\\epsilon_{\\mathsf{snark}}^{\\mathrm{link}}</span> be the knowledge soundness error of <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span>.</p>

    <p class="text-gray-300"><strong>Lemma 18.</strong> <span class="math">\\operatorname{Pr}[b_W^4] \\leq \\operatorname{Pr}[b_W^8] + \\epsilon_{\\mathsf{snark}}^{\\mathrm{link}} + \\epsilon_{\\mathsf{CS}}</span>.</p>

    <p class="text-gray-300">The proof follows almost identically to Lemma 9 and Lemma 11, specifically we can reduce to the knowledge soundness of <span class="math">\\mathsf{CP}_{\\mathrm{link}}</span> or the binding property of CS, the proof of the lemma is therefore omitted. Consider the following PPT sampler algorithm:</p>

    <p class="text-gray-300"><strong>Sampler <span class="math">\\mathcal{D}(1^\\lambda)</span>:</strong></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf{pp} \\leftarrow \\operatorname{ParGen}(1^{\\lambda}) ; \\mathsf{ck} \\leftarrow \\operatorname{Setup}(\\mathsf{pp}) ; \\mathsf{srs} := (\\mathsf{ek}, \\mathsf{vk}) \\leftarrow \\operatorname{KeyGen}(\\mathsf{pp}, \\mathsf{ck}, \\mathsf{N}) ; \\mathsf{aux}_Z \\leftarrow \\mathcal{Z}(\\mathsf{srs}) ; \\\\ \\big(R, \\mathbf{x}, st\\big) \\leftarrow \\mathcal{A}_0(\\mathsf{R}, \\mathsf{ck}, \\mathsf{srs}, \\mathsf{aux}_R, \\mathsf{aux}_Z) ; \\quad \\mathsf{aux}_Z&#x27; := (\\mathsf{R}, \\mathsf{ck}, \\mathsf{srs}, \\mathsf{aux}_R, \\mathsf{aux}_Z) ; \\quad \\text{return } (\\mathsf{R}, \\mathbf{x}, \\mathsf{aux}_Z&#x27;) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Similarly to the proof of Thm. 5.</p>

    <p class="text-gray-300"><strong>Lemma 19.</strong> There exists a prover <span class="math">\\mathcal{P}^*</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr\\left[\\langle \\mathcal{P}^*(\\mathbb{F}, \\mathsf{R}, \\mathbf{x}, z), \\mathcal{V}^{\\mathcal{RE}(\\mathbb{F}, \\mathsf{R})}(\\mathbb{F}, \\mathbf{x}) \\rangle = 1 : (\\mathsf{R}, \\mathbf{x}, \\mathsf{aux}_Z&#x27;) \\leftarrow \\mathcal{D}(1^\\lambda) \\right] = \\Pr[b_W^4] \\tag{37}</span></div>

    <p class="text-gray-300">We define <span class="math">\\mathcal{P}^*</span> to be the prover that emulates <span class="math">\\mathbf{H}_4</span> almost identically as done in Thm. 5, the proof follows similarly thus is omitted. By the knowledge soundness of the PHP with straight-line extractor we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr\\left[(\\mathsf{R}, \\mathbf{x}, \\operatorname{WitExtract}((p_j)_{j \\in [n^*}])) \\in \\mathsf{R} : (\\mathsf{R}, \\mathbf{x}, \\mathsf{aux}_Z&#x27;) \\leftarrow \\mathcal{D}(1^\\lambda) \\right] + \\epsilon_{\\mathsf{PHP}} \\geq \\Pr[b_W^4].</span></div>

    <p class="text-gray-300">We are ready to define the extractor <span class="math">\\mathcal{E}^<em></span>. Let <span class="math">\\mathcal{E}^</em>(\\mathsf{R}, \\mathsf{srs}, \\mathsf{aux}_R, \\mathsf{aux}_Z)</span> be the algorithm that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>computes <span class="math">((\\hat{p}_j)_{j\\in [\\ell]},(\\hat{o}_j)_{j\\in [\\ell]},(p_j)_{j\\in [n^<em>}],(o_j)_{j\\in [n^</em>]}) \\leftarrow \\mathcal{E}_{\\mathrm{link}}(\\mathsf{R}_{\\mathrm{link}},\\mathsf{ck},\\mathsf{srs}_{\\mathrm{link}},\\mathsf{aux}_R,\\mathsf{aux}_Z^{\\mathrm{link}})</span>;</li>

      <li>outputs <span class="math">((\\hat{p}_j)_{j\\in [\\ell]},(\\hat{o}_j)_{j\\in [\\ell]},\\operatorname{WitExtract}((p_j)_{j\\in [n^*}]))</span>.</li>

    </ol>

    <p class="text-gray-300">Assuming that <span class="math">b_W^4</span> is true then we have <span class="math">(p_j)_{j\\in [n^<em>]} = (p_j&#x27;&#x27;)_{j\\in [n^</em>]}</span> in <span class="math">\\mathbf{H}_4</span> (thus by definition of the extractor the polynomial extracted by <span class="math">\\mathcal{E}_{\\mathrm{link}}</span> are the same as the one sent by <span class="math">\\mathcal{P}^<em></span>) and that for any <span class="math">j</span> the opening <span class="math">\\hat{o}_j</span> is a valid opening for the polynomial <span class="math">\\hat{p}_j</span>, moreover by straight-line extractability we have that <span class="math">\\operatorname{WitExtract}((p_j)_{j\\in [n^</em>]})</span> is a valid witness.</p>

    <p class="text-gray-300">87</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(BN128)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(BLS12-381)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Marlin</td>

            <td class="px-3 py-2 border-b border-gray-700">672</td>

            <td class="px-3 py-2 border-b border-gray-700">880</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PLONK (small proof)</td>

            <td class="px-3 py-2 border-b border-gray-700">448</td>

            <td class="px-3 py-2 border-b border-gray-700">560</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PLONK (fast prover)</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">656</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LunarLite</td>

            <td class="px-3 py-2 border-b border-gray-700">384</td>

            <td class="px-3 py-2 border-b border-gray-700">544</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Lunar1cs (fast & short)</td>

            <td class="px-3 py-2 border-b border-gray-700">416</td>

            <td class="px-3 py-2 border-b border-gray-700">592</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Lunar1cs (short vk)</td>

            <td class="px-3 py-2 border-b border-gray-700">544</td>

            <td class="px-3 py-2 border-b border-gray-700">736</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 8. Comparison of proof sizes, in bytes, among our schemes (last three rows) and previous work.</p>

    <p class="text-gray-300">PROOF SIZE. Figure 8 compares concrete proof sizes of our schemes with those in previous work. LunarLite shows a gain in proof size of approximately  <span class="math">15\\%</span>  (over curve BN128) when compared to the smallest argument in PLONK.</p>

    <p class="text-gray-300">PROVING TIME. Our experimental evaluation for proving running times is summarized in Figure 9. We have implemented both our commitment schemes and compiler's building blocks in a Rust library. We plan to release our code, which we are currently extending to include a domain-specific language (embedded in Rust) to define algebraically-flavored information-theoretic protocols and automatically compile them into zkSNARKs with universal SRS.</p>

    <p class="text-gray-300">We evaluate our systems on relations with different constraints size  <span class="math">n</span> . Results are summarized in Figure 9. We assume each matrix in the system of constraints (of type R1CS-lite for LunarLite, R1CS for the other schemes) to have a number of non-zero elements approximately equal to  <span class="math">3n</span> . This ratio is representative, for example, of the relation for Merkle Tree opening with SHA256.</p>

    <p class="text-gray-300">We choose to compare only to Marlin and not to PLONK—currently one of the most efficient argument systems with universal SRS—because, as also observed in [33], PLONK uses different basic measures than Marlin and Lunar, due to the different constraint systems. This makes a concrete comparison less straightforward.</p>

    <p class="text-gray-300">Although still preliminary, these experimental results confirm that some of our schemes can provide concrete practical benefits, in particular constructions LunarLite and Lunarlcs (fast &amp; short). Although Lunarlcs (short vk) has better constants than Marlin on paper, it runs with virtually the same performance. This may be due to our preliminary implementation, still not as optimized as the one in Marlin's codebase. We plan to investigate this as future work.</p>

    <p class="text-gray-300">We ran all benchmarks on CPU i7-5500U with 7.5GiB of RAM, running at 2.40 GHz. We do not implement our Lunar* schemes as full systems, although we plan to. The cryptographic components (committing and CP-SNARKs) work as described and on the parameter sizes reported in our compiler; we skip the inner workings of the information-theoretic components by simulating its polynomials from appropriate distributions. For a fair comparison we modify the code for Marlin in an analogous way, measuring only the sum of the cryptographic components and skipping field operations.</p>

    <p class="text-gray-300">This evaluation is likely to be faithful as our PHPs and Marlin's AHP have field operations of very similar nature. Because our PHPs perform fewer of them compared to Marlin, we expect the overhead of field operations in the Lunar* scheme to be even lower.</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Number of Constraints (log)</p>`;
---

<BaseLayout title="Lunar: a Toolbox for More Efficient Universal and Updatable ... (2020/1069)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/1069
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
