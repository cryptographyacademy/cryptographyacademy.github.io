---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2008/199';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Simultaneous field divisions: an extension of Montgomery&#x27;s trick';
const AUTHORS_HTML = 'David G.  Harris';

const CONTENT = `    <p class="text-gray-300">TITLE:</p>

    <p class="text-gray-300">Simultaneous field divisions: an extension of Montgomery’s trick</p>

    <p class="text-gray-300">AUTHOR: David G. Harris</p>

    <p class="text-gray-300">Department of Defense</p>

    <p class="text-gray-300">9206 Daleview Court</p>

    <p class="text-gray-300">Silver Spring, MD USA 20901</p>

    <p class="text-gray-300">davidgharris29@hotmail.com</p>

    <p class="text-gray-300">ABSTRACT:</p>

    <p class="text-gray-300">Montgomery’s trick is a technique which can be used to quickly compute multiple field inversions simultaneously. We extend this technique to simultaneous field divisions (that is, combinations of field multiplications and field inversion). This generalized Montgomery’s trick is faster in some fields than a simple inversion with Montgomery’s trick followed by a simple field multiplication.</p>

    <p class="text-gray-300">KEYWORDS: Montgomery’s trick, simultaneous inversion, simultaneous division</p>

    <p class="text-gray-300">Field inversions are typically expensive to compute, requiring far more operations than simpler computations such as addition and multiplication. For example, inversion in a prime field requires computing an Extended GCD. If we have many independent inversions to compute, i.e. we want to compute</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {1}{y _ {i}} \\qquad i = 1, \\ldots , N</span></div>

    <p class="text-gray-300">then the algorithm known as Montgomery's trick can be used to produce all  <span class="math">N</span>  inverses simultaneously, at the cost of just one field inversion and  <span class="math">3N - 2</span>  field multiplications. In Section 2, we will review this algorithm.</p>

    <p class="text-gray-300">Often, however, the field inversion is part of a larger arithmetic computation. Suppose we wish to compute</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {c}{y _ {i}} \\qquad \\mathrm {o r} \\qquad \\frac {c x _ {i}}{y _ {i}}</span></div>

    <p class="text-gray-300">Here,  <span class="math">c</span>  is some constant multiplier applied to all of the  <span class="math">N</span>  computations, and  <span class="math">x_{i}</span>  (optional) is some numerator that varies among the  <span class="math">N</span>  separate computations. For example, to double an elliptic curve point  <span class="math">(X,Y)</span>  in affine coordinates, one needs to compute</p>

    <div class="my-4 text-center"><span class="math-block">\\lambda = \\frac {3 X ^ {2} + a}{2 Y}</span></div>

    <p class="text-gray-300">where  <span class="math">a</span>  is a constant parameter of the elliptic curve.</p>

    <p class="text-gray-300">In this case, the simplest approach would be to use the numerator  <span class="math">x_{i} = 3X^{2} + a</span> , the denominator  <span class="math">y_{i} = Y</span> , and the constant multiplier  <span class="math">c = 1/2</span> . As we will see, a better approach is to set  <span class="math">x_{i} = X^{2} + (a/3)</span> ,  <span class="math">y_{i} = Y</span> , and the constant multiplier  <span class="math">c = 3/2</span> .</p>

    <p class="text-gray-300">Of course, we could use Montgomery’s trick to compute all the denominators <span class="math">1/y_{i}</span>, and then multiply by the numerators <span class="math">c</span> and <span class="math">x_{i}</span>, at the cost of additional field multiplications. There have been many applications of Montgomery’s trick to elliptic curve arithmetic, such as <em>[1]</em> and <em>[2]</em>, and they apparently have all followed this plan.</p>

    <p class="text-gray-300">However, there is an alternative, which is to modify Montgomery’s trick to incorporate the multiplication of <span class="math">x_{i}</span> and <span class="math">c</span> with the field inversion. In Section 4, we will describe how to do this. Because our algorithm incorporates a numerator as well as a denominator, we refer to this as a field <em>division</em> algorithm, as opposed to merely field <em>inversion</em>.</p>

    <h2 id="sec-2" class="text-2xl font-bold">2 Montgomery’s trick for multiple field inversions</h2>

    <p class="text-gray-300">We will first review Montgomery’s trick for simultaneous field inversions as described in <em>[1]</em>. We are given <span class="math">N</span> field elements <span class="math">y_{i}\\in F</span>, and wish to compute <span class="math">1/y_{i}</span> for <span class="math">i=1,\\ldots,N</span>. We will do this by performing two separate “passes” through the data. In the forward pass, we initialize <span class="math">r_{1}=y_{i}</span> and compute the forward products</p>

    <p class="text-gray-300"><span class="math">r_{i}=r_{i-1}\\times y_{i},\\qquad i=2,\\ldots,N</span></p>

    <p class="text-gray-300">When this is done, we have <span class="math">r_{N}=\\prod_{i=1}^{N}y_{i}</span>. We compute a single field inversion</p>

    <p class="text-gray-300"><span class="math">I=r_{N}^{-1}</span></p>

    <p class="text-gray-300">Next, we enter the backward pass. To begin, we set <span class="math">t_{N}=I</span> and then for</p>

    <p class="text-gray-300"><span class="math">i=N,\\ldots,2</span>, we compute the two products</p>

    <p class="text-gray-300"><span class="math">1/y_{i}=t_{i}\\times r_{i-1}</span> <span class="math">t_{i-1}=t_{i}\\times y_{i}</span></p>

    <p class="text-gray-300">To finish, we set</p>

    <p class="text-gray-300"><span class="math">1/y_{1}=t_{1}</span></p>

    <p class="text-gray-300">In total, this algorithm requires a single field inverse; in the forward pass, it requires <span class="math">N-1</span> field multiplications; and in the backward pass, it requires <span class="math">2N-2</span> field multiplications.</p>

    <p class="text-gray-300">One observation has been apparently overlooked or at least underestimated: the backward pass’s two multiplications share a common factor. That is, instead of performing two unrelated multiplications</p>

    <p class="text-gray-300"><span class="math">a\\times b\\qquad c\\times d</span></p>

    <p class="text-gray-300">we are performing two related multiplications</p>

    <p class="text-gray-300"><span class="math">a\\times b\\qquad a\\times c</span></p>

    <p class="text-gray-300">For some fields, it may be faster to compute these two related multiplications as compared to unrelated multiplications. We will discuss this more in Section 3. For the moment, let us simply summarize the cost of this algorithm as</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Cost}=(N-1)\\times M_{1}+(2N-2)\\times M_{2}+\\mathrm{Inversion}</span></p>

    <p class="text-gray-300">where <span class="math">M_{1}</span> is the cost of an ordinary field multiplication; <span class="math">M_{2}</span> is half the cost of a pair of “double multiplications”, i.e. multiplications involving a shared multiplicand; and Inversion is the cost of a field inversion.</p>

    <p class="text-gray-300">To simplify the costing, Cost/<span class="math">N</span> as <span class="math">N\\rightarrow\\infty</span> goes to</p>

    <p class="text-gray-300"><span class="math">\\mbox{Cost}/N\\rightarrow M_{1}+2M_{2}</span></p>

    <h2 id="sec-3" class="text-2xl font-bold">3 Double multiplication</h2>

    <p class="text-gray-300">Depending on the specific field, computing a double multiplication</p>

    <p class="text-gray-300"><span class="math">a\\times b\\qquad a\\times c</span></p>

    <p class="text-gray-300">may be less expensive than computing two unrelated multiplications. In costing field arithmetic, it is well-known that squaring may be cheaper than a general multiplication. By the same token, these double multiplications may be cheaper too and should be accounted separately. The reason is that many methods of multiplication are based on “transforming” one or both multiplicands. In a double multiplication, we need only transform <span class="math">a</span> once.</p>

    <p class="text-gray-300">For example, in very large prime fields, (e.g. 2000+ bits), field multiplication is generally structured as first an ordinary integer multiplication followed by a modular reduction. For the integer multiplication one views the multiplicands as integer polynomials, which one Fourier transforms, multiplies pointwise, and then inverse transforms the product. A double multiplication saves a transform compared to two ordinary multiplications.</p>

    <p class="text-gray-300">As another example, in small prime fields <span class="math">{\\bf F}_{p}</span> (e.g. 100—400 bits) one typically represents the multiplicands in “Montgomery form.” In this case, if the radix size of the computer is <span class="math">W</span>, we represent <span class="math">a</span> by <span class="math">a_{0},\\ldots,a_{k-1}</span> such that</p>

    <p class="text-gray-300"><span class="math">a=W^{k}(a_{0}+a_{1}W+a_{2}W^{2}+\\cdots+a_{k-1}W^{k-1})\\mod p</span></p>

    <p class="text-gray-300">o double-multiply <span class="math">a</span> by <span class="math">b</span> and <span class="math">c</span>, we can use the Montgomery multiplication formula</p>

    <p class="text-gray-300"><span class="math">ab</span> <span class="math">=\\sum_{i=0}^{k-1}((aW^{-i})\\bmod p)\\times b_{k-1-i}</span> <span class="math">ac</span> <span class="math">=\\sum_{i=0}^{k-1}((aW^{-i})\\bmod p)\\times c_{k-1-i}</span></p>

    <p class="text-gray-300">Again, we are “transforming” <span class="math">a</span> by successively dividing it by powers of <span class="math">W</span>; and this transformation can be shared between the two products.</p>

    <p class="text-gray-300">In some fields, a double multiplication is not noticeably faster than two ordinary multiplications. For example, in medium prime fields <span class="math">\\mathbf{F}_{p}</span>, multiplication is most efficiently computed by Karatsuba multiplication followed by modular reduction or Montgomery reduction. The Karatsuba algorithm does not take advantage of the common factor.</p>

    <p class="text-gray-300">In general, then, we can say that double multiplication can sometimes be faster, for some fields, than ordinary multiplication.</p>

    <h2 id="sec-4" class="text-2xl font-bold">4 Simultaneous field divisions: constant numerator</h2>

    <p class="text-gray-300">To return to the problem at hand, suppose we wish to compute something more complicated than a simple field inversion. At first, let us analyze the computation</p>

    <p class="text-gray-300"><span class="math">c/y_{i}\\qquad i=1,\\ldots,N</span></p>

    <p class="text-gray-300">Using the inversion algorithm, we could compute the denominators <span class="math">1/y_{i}</span> at a per-unit cost <span class="math">M_{1}+2M_{2}</span>. We could then multiply by the constant numerator</p>

    <p class="text-gray-300"><span class="math">c</span> to get a total cost of</p>

    <p class="text-gray-300"><span class="math">\\mbox{Cost}=N\\times M_{1}+(2N-2)\\times M_{2}+\\mbox{Inversion}+NM_{c}</span></p>

    <p class="text-gray-300">As <span class="math">N\\rightarrow\\infty</span>, the per-unit cost is</p>

    <p class="text-gray-300"><span class="math">\\mbox{Cost}/N\\rightarrow M_{1}+2M_{2}+M_{c}</span></p>

    <p class="text-gray-300">Note that we are treating multiplication by <span class="math">c</span> differently than an ordinary multiplication. In many applications, <span class="math">c</span> is small or has special structure making multiplication by <span class="math">c</span> significantly cheaper than a general field multiplication. For example, in the case of elliptic curve affine point doubling, <span class="math">c=3/2</span>. We can multiply by <span class="math">3/2</span> with just a few bit-shifts and field additions, so the cost to multiply by <span class="math">c</span> will be small, although not totally negligible.</p>

    <p class="text-gray-300">We will now show how to combine the multiplications by <span class="math">c</span> with the multiple inversion algorithm, resulting in a lower cost. As before, we have a forward pass, a field inversion, and a backward pass.</p>

    <p class="text-gray-300">To begin, we initialize the forward pass with <span class="math">r_{1}=y_{1}</span>, and then for <span class="math">i=2,\\ldots,N</span> compute</p>

    <p class="text-gray-300"><span class="math">r_{i}=r_{i-1}\\times y_{i}</span></p>

    <p class="text-gray-300">When this is done, we have <span class="math">r_{N}=\\prod y_{i}</span>. We next compute</p>

    <p class="text-gray-300"><span class="math">I=c\\times r_{N}^{-1}</span></p>

    <p class="text-gray-300">Next, we enter the backward pass. To begin, we set <span class="math">t_{N}=I</span> and then for</p>

    <p class="text-gray-300"><span class="math">i=N,\\ldots,2</span> we compute the two products</p>

    <p class="text-gray-300"><span class="math">c/y_{i}=t_{i}\\times r_{i-1}</span> <span class="math">t_{i-1}=t_{i}\\times y_{i}</span></p>

    <p class="text-gray-300">and finish by</p>

    <p class="text-gray-300"><span class="math">c/y_{1}=t_{1}</span></p>

    <p class="text-gray-300">In total, the cost of the foward pass is <span class="math">(N-1)\\times M_{1}</span>; we then perform a modular inversion and a single multiplication by <span class="math">c</span>; finally, the backward pass costs <span class="math">(N-1)\\times 2M_{2}</span>. In total, the cost is</p>

    <p class="text-gray-300"><span class="math">\\mbox{Cost}=(N-1)M_{1}+(2N-2)M_{2}+M_{c}+\\mbox{Inversion}</span></p>

    <p class="text-gray-300">As <span class="math">N\\to\\infty</span>, the per-unit cost tends to</p>

    <p class="text-gray-300"><span class="math">\\mbox{Cost}/N\\to M_{1}+2M_{2}</span></p>

    <p class="text-gray-300">Note that the multiplication by <span class="math">c</span> has been completely amortized away, just like the field inversion. Although the cost of multiplying by <span class="math">c</span> may be small, it is not negligible. A side benefit is that, even if <span class="math">c</span> has a special form, there is no need for specialized computer code to multiply by it since it is no longer a time-critical step.</p>

    <h2 id="sec-5" class="text-2xl font-bold">5 Simultaneous field divisions: variable numerator</h2>

    <p class="text-gray-300">Now let us consider the case of a variable numerator as well as variable denominator. We now wish to compute</p>

    <p class="text-gray-300"><span class="math">c\\ x_{i}/y_{i}\\qquad i=1,\\ldots,N</span></p>

    <p class="text-gray-300">Using the algorithm of Section 3, we could compute the fractions <span class="math">c/y_{i}</span> at a per-unit cost <span class="math">M_{1}+2M_{2}</span>. We could then multiply by the numerators <span class="math">x_{i}</span> to get a total cost of</p>

    <p class="text-gray-300"><span class="math">\\text{Cost}=2NM_{1}+(2N-2)M_{2}+\\text{Inversion}</span></p>

    <p class="text-gray-300">As <span class="math">N\\to\\infty</span>, the per-unit cost is</p>

    <p class="text-gray-300"><span class="math">\\text{Cost}/N\\to 2M_{1}+2M_{2}</span></p>

    <p class="text-gray-300">We will now show how to interleave the multiplications by <span class="math">x_{i}</span> and <span class="math">c</span> with the multiple inversion algorithm, resulting in a lower cost. As before, we have a forward pass, a field inversion, and a backward pass. All these stages are changed however.</p>

    <p class="text-gray-300">To begin, we start the forward pass by setting</p>

    <p class="text-gray-300"><span class="math">r_{1}=y_{1}</span></p>

    <p class="text-gray-300">and then for <span class="math">i=2,\\ldots,N</span> we compute</p>

    <p class="text-gray-300"><span class="math">r_{i}=r_{i-1}\\times y_{i}</span> <span class="math">s_{i}=r_{i-1}\\times x_{i}</span></p>

    <p class="text-gray-300">Note that the two multiplications share a common factor, and thus this is a double multiplication.</p>

    <p class="text-gray-300">When this is done, we have <span class="math">r_{N}=\\prod y_{i}</span>. We next compute</p>

    <p class="text-gray-300"><span class="math">I=c\\times r_{N}^{-1}</span></p>

    <p class="text-gray-300">Next, we enter the backward pass. To begin, we set <span class="math">t_{N}=I</span> and then for <span class="math">i=N,\\ldots,2</span> we compute the two products</p>

    <p class="text-gray-300"><span class="math">c\\ x_{i}/y_{i}=t_{i}\\times s_{i}</span> <span class="math">t_{i-1}=t_{i}\\times y_{i}</span></p>

    <p class="text-gray-300">and finally finish with</p>

    <p class="text-gray-300"><span class="math">c\\ x_{1}/y_{1}=t_{1}\\times x_{1}</span></p>

    <p class="text-gray-300">In total, the cost of the foward pass is <span class="math">(N-1)\\times 2M_{2}</span>; we then perform a modular inversion and a single multiplication by <span class="math">c</span>; finally, the backward pass costs <span class="math">M_{1}+(N-1)\\times 2M_{2}</span>. In total, the cost is</p>

    <p class="text-gray-300"><span class="math">\\mbox{Cost}=M_{1}+(4N-4)M_{2}+M_{c}+\\mbox{Inversion}</span></p>

    <p class="text-gray-300">As <span class="math">N\\to\\infty</span>, the per-unit cost tends to</p>

    <p class="text-gray-300"><span class="math">\\mbox{Cost}/N\\to 4M_{2}</span></p>

    <p class="text-gray-300">As compared to our previous cost, we have replaced the two unrelated multiplications by a double multiplication.</p>

    <h2 id="sec-6" class="text-2xl font-bold">6 Conclusion</h2>

    <p class="text-gray-300">Inversion in a field can be quite costly. For this reason, if many field inversions need to be computed, Montgomery’s trick is a useful technique for replacing them all with a single field inversion and many multiplications.</p>

    <p class="text-gray-300">In many cases, such as elliptic curve affine point doubling, these field inversions go along with field multiplications, a combination we define as a</p>

    <p class="text-gray-300">field division. We have described an algorithm which incorporates this numerator into the Montgomery’s trick, resulting in a computation which is faster than the simple Montgomery’s trick in two cases: 1) If the numerator involves a constant term; or 2) If double multiplication (a pair of multiplications with common factor) can be computed more quickly than two unrelated multiplications.</p>

    <p class="text-gray-300">Thanks to Joana Silva for helping edit this paper, and for helping me with the publication process.</p>

    <h2 id="sec-7" class="text-2xl font-bold">8 Reference</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1 ] H. Cohen, “A Course in Computational Algebraic Number Theory.” Graduate Texts in Math. 138, Springer-Verlage, 1993.</li>

      <li>[2 ] P. Mishra, S. Palash, “Application of Montgomery’s trick to scalar multiplication for elliptic and hyperelliptic curves using a fixed base point.” PKC 2004, March 2004, pp. 41-54.</li>

    </ul>`;
---

<BaseLayout title="Simultaneous field divisions: an extension of Montgomery&#x27;s t... (2008/199)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2008 &middot; eprint 2008/199
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
