---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/1609';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Blaze: Fast SNARKs from Interleaved RAA Codes';
const AUTHORS_HTML = 'Martijn Brehm, Binyi Chen, Ben Fisch, Nicolas Resch, Ron D. Rothblum, Hadas Zeilberger';

const CONTENT = `    <p class="text-gray-300">Martijn Brehm<sup>1</sup> Binyi Chen<sup>2</sup> Ben Fisch<sup>3</sup> Nicolas Resch<sup>1</sup> Ron D. Rothblum<sup>4</sup> Hadas Zeilberger<sup>3</sup></p>

    <p class="text-gray-300">University of Amsterdam. Emails: {m.a.brehm,n.a.resch}@uva.nl Stanford University. Email: binyi@cs.stanford.edu Yale University. Emails:{ben.fisch,hadas.zeilberger}@yale.edu Succinct. Email: rothblum@gmail.com</p>

    <p class="text-gray-300">October 9, 2024</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">In this work we construct a new and highly efficient multilinear polynomial commitment scheme (MLPCS) over binary fields, which we call Blaze. Polynomial commitment schemes allow a server to commit to a large polynomial and later decommit to its evaluations. Such schemes have emerged as a key component in recent efficient SNARK constructions.</p>

    <p class="text-gray-300">Blaze has an extremely efficient prover, both asymptotically and concretely. The commitment is dominated by 8n field additions (i.e., XORs) and one Merkle tree computation. The evaluation proof generation is dominated by 6n additions and 5n multiplications over the field. The verifier runs in time Oλ(log<sup>2</sup> (n)). Concretely, for sufficiently large message sizes, the prover is faster than all prior schemes except for Brakedown (Golovnev et al., Crypto 2023), but offers significantly smaller proofs than the latter.</p>

    <p class="text-gray-300">The scheme is obtained by combining two ingredients:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Building on the code-switching technique (Ron-Zewi and Rothblum, JACM 2024), we show how to compose any error-correcting code together with an interactive oracle proof of proximity (IOPP) underlying existing MLPCS constructions, into a new MLPCS. The new MLPCS inherits its proving time from the code's encoding time, and its verification complexity from the underlying MLPCS. The composition is distinctive in that it is done purely on the information-theoretic side.</li>

      <li>We apply the above methodology using an extremely efficient error-correcting code known as the Repeat-Accumulate-Accumulate (RAA) code. We give new asymptotic and concrete bounds, which demonstrate that (for sufficiently large message sizes) this code has a better encoding time vs. distance tradeoff than previous linear-time encodable codes that were considered in the literature.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Introduction<br>1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.1<br>Our Results<br></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.2<br>Technical Overview<br></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.3<br>Comparison with Prior Work<br></td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">Preliminaries</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2.1<br>Multilinear Extension<br></td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2.2<br>Interactive Proofs and IOPs<br></td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2.3<br>Coding Background<br></td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">The RAA Code</td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3.1<br>Adding Tests<br></td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3.2<br>Puncturing<br></td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3.3<br>Concrete Numbers<br></td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |                                                                             |    |  |  |  |  |  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">IOPs for Multilinear Evaluation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">19</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">Multilinear Evaluation for the (Packed)<br>RAA<br>Code</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.1<br>Checking Simple Linear Operations<br></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.2<br>Checking Permutations<br></td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.3<br>MLIOP for<br>RMLE[PRAA]<br></td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.4<br>Puncturing<br></td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">IOPs for Interleaved Codes</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">Multilinear Evaluation for Interleaved<br>RAA</td>

            <td class="px-3 py-2 border-b border-gray-700">35</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">Experiments and Results</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8.1<br>Prover and Verifier Runtimes<br></td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8.2<br>Communication Complexity<br></td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">Distance Analysis of RAA code</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">9.1<br>Setup of RAA Analysis<br></td>

            <td class="px-3 py-2 border-b border-gray-700">41</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">9.2<br>Probability First Stage Fails<br></td>

            <td class="px-3 py-2 border-b border-gray-700">43</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">9.3<br>Given Successful First Stage, Probability Code has Good Distance<br></td>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">9.4<br>Conditioning on Low Weight Messages Having Good First Stage<br></td>

            <td class="px-3 py-2 border-b border-gray-700">63</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">9.5<br>Puncturing<br></td>

            <td class="px-3 py-2 border-b border-gray-700">70</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |                                                                             |    |  |  |  |  |  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Round-by-Round Soundness of the Protocols</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">82</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A.2<br>RBR Soundness of the MLIOP-to-IOPP Transformation<br></td>

            <td class="px-3 py-2 border-b border-gray-700">84</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A.3<br>RBR Soundness of the Interleaving IOPP<br></td>

            <td class="px-3 py-2 border-b border-gray-700">85</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Recent years have seen an incredible progress in the development and deployment of cryptographic proof-systems. These proof-systems enable a prover to prove correctness of extremely complex computations to a highly efficient verifier that runs in much faster time.</p>

    <p class="text-gray-300">One of the main approaches to constructing such proof-systems is by combining an informationtheoretic proof-system called a polynomial interactive oracle proof (polynomial IOP) with a cryptographic object called a polynomial commitment scheme (PCS). A polynomial IOP is a proof-system in which the prover can send truth tables of large polynomials to the verifier. A PCS in turn allows a prover to commit to a large polynomial P, using a short commitment, such that later it can prove evaluation claims of the form "P(x) = y". An efficient proof-system can then be derived by combining the two: run the IOP prover but instead of sending the large polynomials in the clear, commit to the them using the PCS, and then provide the desired values to the verifier and prove their correctness.</p>

    <p class="text-gray-300">Due to the above, PCS's have emerged as a cornerstone of modern proof-system design. For example, the famous FRI protocol <a href="#page-76-0">\\[BBHR18a,</a>[BGKS20\\]](#page-78-0) which underlies STARKs [\\[BBHR18b\\]](#page-76-1) can be viewed as a univariate PCS.<a href="#page-2-2">1</a> Circle STARKs [\\[HLP24\\]](#page-80-0), STIR [\\[ACFY24\\]](#page-75-0), and Basefold [\\[ZCF24\\]](#page-83-1) are recent improvements and generalizations of this PCS. We discuss other recent exciting developments on the PCS front shortly.</p>

    <p class="text-gray-300">In this work we focus on polynomial commitment schemes for multilinear polynomials P : F <sup>m</sup> → F (i.e., m-variate polynomials that have degree 1 in each variable) over binary extension fields (i.e., fields of characteristic 2). Multilinear Polynomial Commitments Schemes (MLPCS) have recently drawn significant attention and are at the heart of some of the most efficient proof-systems that have been developed. These include systems based on the GKR [\\[GKR15\\]](#page-80-1) protocol, Spartan [\\[Set20\\]](#page-82-0), Hyperplonk [\\[CBBZ23\\]](#page-79-0) and most recently Lasso/Jolt <a href="#page-82-1">\\[STW24,</a>[AST24\\]](#page-76-2).</p>

    <p class="text-gray-300">Highly efficient proof-systems based on binary extension fields have recently been proposed by Diamond and Posen <a href="#page-80-2">\\[DP23,</a> [DP24a\\]](#page-80-3). Such schemes are exceptionally attractive due to the field's high level of compatibility with modern computer architectures. In particular, such fields avoid altogether the notorious problem of embedding overhead which prime fields suffer from. Additionally, some common CPU operations are natively supported by binary extension fields (e.g., XOR corresponds to field addition and Intel processors natively support field multiplication for some binary fields). On the downside, some issues in arithmetization (such as handling integer arithmetic) are somewhat more complicated in the case of binary fields, see [\\[DP23\\]](#page-80-2) for details.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.1 Our Results</h3>

    <p class="text-gray-300">In this work we construct a new MLPCS over binary extension fields, which we call Blaze. Our scheme has an extremely efficient prover, both asymptotically and concretely. The scheme builds on the code-switching paradigm introduced by Ron-Zewi and Rothblum [\\[RR24\\]](#page-82-2) in combination with a particularly efficient family of error-correcting codes called Repeat-Accumulate-Accumulate (RAA) codes. The RAA family of codes has been studied in the coding literature due to its extremely fast encoding, which directly translates into our scheme's efficiency.</p>

    <p class="text-gray-300"><span id="page-2-2"></span><sup>1</sup> In a bit more detail, FRI is an interactive oracle proof of proximity (IOPP) for membership in the Reed-Solomon code. Deep-FRI [\\[BGKS20\\]](#page-78-0) shows how to additionally check an evaluation query. A PCS can be derived form these IOPPs by combining them with a vector commitment (e.g., Merkle hashing) and the Fiat-Shamir [\\[FS86\\]](#page-80-4) transform.</p>

    <p class="text-gray-300">Similarly to Spielman's code [Spi96] and Expand Accumulate codes [BCG<sup>+</sup>22] (which were used, respectively, in [BCG20, GLS<sup>+</sup>23, XZS22] and [BFK<sup>+</sup>24] to construct efficient proof-systems), the RAA code requires a (public) parameterization, that is generated by a randomized setup algorithm. This means that the code is constructed by a randomized procedure, that, if successful, outputs public parameters of the RAA code that guarantee good distance. An important contribution of our work is providing new asymptotic and concrete bounds on the failure probability of RAA codes.</p>

    <p class="text-gray-300">For example, for messages of size  <span class="math">k=2^{22}</span> , we produce an RAA code with rate 1/4 and relative distance 0.19 except with an error probability of  <span class="math">2^{-27.4}</span> , using a parameter generation procedure that takes about a second on a laptop. Using a procedure that takes a few days, the error probability decreases to  <span class="math">2^{-41.5}</span> . More generally, for messages of size k and using rate 1/4, for any constant  <span class="math">w \\in \\mathbb{N}</span> , we give a  <span class="math">\\tilde{O}(k^w)</span>  time generation procedure for the code that fails to have distance 0.19 with probability roughly  <span class="math">O(k^{-w-0.5})</span> . (This algorithm is fully parallelizable and runs in  <span class="math">O(\\log k)</span>  time given  <span class="math">k^w</span>  processors.)</p>

    <p class="text-gray-300">We emphasize that this error probability comes from a <em>one time setup</em>. As long as the setup, which is <em>performed only once</em>, is successful, the distance holds for <em>all</em> codewords and so soundness is guaranteed in <em>all</em> invocations of the proof-systems.</p>

    <p class="text-gray-300">For comparison, when attacking a SNARK with "100-bits of security", an adversary running in time  <span class="math">2^{70}</span> , which seems a feasible runtime, can break security with probability  <span class="math">2^{-30}</span> . We reiterate that in our case the bad event can happen only once, when the public parameters of the system are decided. As such, and in contrast to typical notions of security in cryptography, this error cannot be leveraged by attackers that run in more time – the error either happens during the parameter generation or, far more likely, it does not.</p>

    <p class="text-gray-300">Still, it would be interesting to have an efficient procedure for certifying that the public parameters for the RAA codeword are "good" (analogously to a test developed by Xie <em>et al.</em> [XZS22] for Spielman's code) and we leave this as an interesting open question.</p>

    <p class="text-gray-300"><strong>Blaze:</strong> a Fast Multilinear PCS over Binary Fields. Our main contribution is a new multilinear PCS, which we call Blaze, over binary extension fields. Blaze's asymptotic behavior is described in the following theorem:</p>

    <p class="text-gray-300"><span id="page-3-1"></span><strong>Theorem 1</strong> (Informally Stated, see Theorem 7.1). Let  <span class="math">\\mathbb{F}</span>  be a binary extension field. There exists an MLPCS in the random oracle model with O(n) prover time, and  <span class="math">O_{\\lambda}(\\log^2 n)</span>  proof size and verifier time. The committing complexity is dominated by 8n field additions and a Merkle tree computation, and the evaluation proving is dominated by 6n field multiplications and 5n additions.</p>

    <p class="text-gray-300">We remark that the operations in the evaluation proof account also for evaluating the polynomial at the desired point. The number of steps in the evaluation proof generation can be further reduced, but at the cost of constant overhead to the proof size that we rather avoid.</p>

    <p class="text-gray-300">While there are previous linear-time PCS constructions, our work is the first to present one that measures the exact constant overhead. We hope that having these constants as a clean comparison point will also enable and direct a cleaner comparison to future work (as has happened in other areas of cryptography, see, e.g., [BCG<sup>+</sup>23]).</p>

    <p class="text-gray-300">Similarly to other hash based proof-systems, our PCS can be shown secure in the <em>random oracle model</em>. As in the prior work, the random oracle is used for two reasons: (1) as a collision-resistant</p>

    <p class="text-gray-300"><span id="page-3-0"></span><sup>&</sup>lt;sup>2</sup>For sake of comparison, the probability for an individual to win the US Powerball Lottery is 2<sup>-28.1</sup>, see https://www.powerball.com/powerball-prize-chart.</p>

    <p class="text-gray-300"><span id="page-4-2"></span>hash function, and (2) to implement the Fiat-Shamir transform. Indeed, the above transformation (due to <a href="#page-81-0">\\[Kil92,</a> <a href="#page-80-4">FS86,</a> <a href="#page-82-4">Mic00,</a> [BCS16\\]](#page-77-4)) is entirely standard in the literature (see the recent related textbook [\\[CY24\\]](#page-79-1)) and our focus is on the information-theoretic core that underlies the PCS and is described in the technical overview in <a href="#page-5-0">Section 1.2</a> below.</p>

    <p class="text-gray-300">The protocol establishing <a href="#page-3-1">Theorem 1</a> is not only asymptotically efficient. Our benchmarks demonstrate that for sufficiently large multilinear polynomials (i.e., of size ≥ 2 <sup>25</sup> or in other words polynomials on 25 or more variables) Blaze's prover is faster than prior work. The only exception is Brakedown <a href="#page-80-5">\\[GLS</a>+23] which is faster (up to size about 230) but has much larger proofs, see <a href="#page-37-0">Section 8</a> for detailed benchmarks. We emphasize that Blaze is particularly well-suited to large message sizes and unlocks the possibility of encoding larger polynomials than what was previously possible.</p>

    <p class="text-gray-300">Remark 2. Similarly to Brakedown <a href="#page-80-5">\\[GLS</a>+23], our PCS does not guarantee any hiding properties. Therefore, when using it to construct a zero-knowledge proof-system some care should be taken. For example, following Ben Or et al. <a href="#page-77-5">\\[BGG</a>+88], the resulting succinct argument can be compiled into a zero-knowledge one using an additional proof-composition step. See, e.g., [\\[XZS22\\]](#page-83-2) for a practical system that does this.</p>

    <p class="text-gray-300">New Bounds for RAA Codes. As previously mentioned, Blaze relies on a particular efficient family of codes known as repeat-accumulate-accumulate (RAA) codes. We provide additional details on the codes in <a href="#page-16-0">Section 3</a> (see also <a href="#page-5-0">Section 1.2\\)</a>, but for now we briefly say that the encoding procedure first repeat each message symbol r = O(1) times, permutes the coordinates, does a prefix-sum modulo-2, then again permutes and computes a prefix-sum.</p>

    <p class="text-gray-300">The parameters of the code are descriptions of the two permutations that are used in the encoding procedure, and are sampled at random. Prior work <a href="#page-78-1">\\[BMS08,</a> [KZCJ07\\]](#page-81-1) showed that if the permutations are chosen at random then the RAA codes offer a good rate/distance tradeoff; however, the failure bounds implicit in these works can be seen to be quite poor, and therefore insufficient for our purposes. A contribution of this work is a new analysis of RAA codes, showing they can achieve very good rate-distance tradeoffs with a small failure probability (both asymptotically and concretely).</p>

    <p class="text-gray-300"><span id="page-4-1"></span>Theorem 3 (Informally Stated, see <a href="#page-17-0">Theorem 3.1\\)</a>. Let k ∈ N be a growing parameter, let r ∈ N be even and at least 4, and set γ = 1 − 2.01 r . With all but O(k 1+γ−r/2 ) = O(k 2− <sup>2</sup>.<sup>01</sup> <sup>r</sup> −r/2 ) probability, a random RAA code with rate 1/r and message length k has distance δ<sup>r</sup> > 0, where δ<sup>r</sup> is close to the GV bound.</p>

    <p class="text-gray-300">For context, the Gilbert-Varshamov (GV) bound states that there exist binary codes of minimum distance δ with rate 1 − H(δ), where H is the binary entropy function. Moreover, this is the best known tradeoff for any binary code.<a href="#page-4-0">3</a> We get quite close to the GV bound: e.g., for rate 1/4 we can get distance about 0.19 whereas the GV bound is about 0.215. The general tradeoff is quite hard to state explicitly; see <a href="#page-17-0">Theorem 3.1</a> for additional details.</p>

    <p class="text-gray-300">The error probability achieved by <a href="#page-4-1">Theorem 3</a> goes to 0 as k grows, but unfortunately not fast enough for the message sizes that we consider. Thus, to improve the failure probability, we observe that after sampling the permutations we can test whether or not all messages of weight at most ≤ w = O(1) (where w is a parameter we can choose) have encodings of weight at least δn.</p>

    <p class="text-gray-300"><span id="page-4-0"></span><sup>3</sup>The reason that the codes guaranteed by the GV bound are not used is that their encoding time is quadratic, whereas the RAA code that we use has a roughly similar rate/distance tradeoff but with linear-time encoding.</p>

    <p class="text-gray-300"><span id="page-5-3"></span>Conditioned on this test passing, the failure probability decreases to about  <span class="math">O(k^{-(w+1)(r/2-1)+\\gamma})</span> . Given that this runtime is very large even for small values of w, we propose a simplified test (which, roughly speaking, does half of the encoding procedure) that runs in  <span class="math">O(k^w \\log k)</span>  time, and still drastically decreases the error probability. Still, given the exponential dependence of both tests on w, we cannot choose it to be too large (e.g., for  <span class="math">k=2^{20}</span> , testing for w=3 is about the best we could hope to do).</p>

    <p class="text-gray-300">We remark that a similar test was suggested by Boyle  <span class="math">et\\ al.\\ [BCG^+22, Section\\ 3.5]</span>  in the context of the related  <span class="math">expand\\ accumulate\\ codes</span> . In their case the test was suggested as a heuristic whereas we give a full analysis.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">1.2 Technical Overview</h4>

    <p class="text-gray-300">Our starting point is the <em>code switching</em> technique [RR24] as further developed and articulated in [BCG20, GLS<sup>+</sup>23] (and also related to the work of Bootle <em>et al.</em> [BCG<sup>+</sup>17]). At a high-level, code-switching is the idea that one can convert claims about the multilinear extension code, into claims about simple combinatorial extensions of an <em>arbitrary</em><sup>4</sup> error-correcting code. The key benefit of this approach is that we can utilize the rich literature on efficient codes, and in particular it demonstrates that the distance property of codes is essentially <em>all that is needed</em> to construct efficient SNARKs.</p>

    <p class="text-gray-300">In particular, [RR24] (implicitly, see [RR24, Lemma 3.6]) construct an MLPCS by tensoring any error-correcting code and utilizing the sumcheck protocol for tensor codes [LFKN92, Mei13], and a similar approach is taken in [BCG20, RR22, HR22]. Brakedown [GLS+23] relies instead on code interleaving (this is also implicit in [BCG+17] and explicit in Ligero [AHIV23] for the Reed-Solomon code).</p>

    <p class="text-gray-300">We first describe our code-switching based approach which shows that the prover's complexity can essentially only depend on the complexity of the encoding time of the code, and still obtain polylogarithmic proof-size and verification complexity. This is described in Section 1.2.1. Afterwards, in Section 1.2.2 we describe our new analysis of RAA codes and show how to combine code-switching with RAA codes.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">1.2.1 IOPP for Multilinear Evaluation</h4>

    <p class="text-gray-300">Before proceeding, let us briefly recall the definition of the multilinear extension. Fix a finite field  <span class="math">\\mathbb{F}</span> , that, for the moment, can be arbitrary but should be thought of as "cryptographically large". The multilinear extension of a vector  <span class="math">m \\in \\mathbb{F}^k</span> , where  <span class="math">k \\in \\mathbb{N}</span>  is a power of 2, is the multilinear polynomial  <span class="math">\\widehat{m} : \\mathbb{F}^{\\log(k)} \\to \\mathbb{F}</span>  defined as  <span class="math">\\widehat{m}(z) = \\sum_{b \\in \\{0,1\\}^{\\log(k)}} eq(z,b) \\cdot m_b</span> , where  <span class="math">eq(z,b) = \\prod_{i=1}^{\\log(k)} eq_1(z_i,b_i)</span>  and  <span class="math">eq_1(\\alpha,\\beta) = \\alpha \\cdot \\beta + (1-\\alpha) \\cdot (1-\\beta)</span>  (see Section 2 for a more thorough exposition and additional details).</p>

    <p class="text-gray-300">Our MLPCS is best described from the perspective of Interactive Oracle Proofs of Proximity (IOPP) for Multilinear Evaluation – an information-theoretic abstraction that we put forth (but is implicit in prior "hash based" MLPCS constructions). An IOPP for Multilinear Evaluation relative to a code  <span class="math">C: \\mathbb{F}^k \\to \\mathbb{F}^n</span>  is a protocol in which the verifier is given as explicit input  <span class="math">z \\in \\mathbb{F}^{\\log(k)}</span>  and  <span class="math">v \\in \\mathbb{F}</span> . The verifier additionally has oracle access to a string  <span class="math">y \\in \\mathbb{F}^n</span> . The verifier's goal is to check that y is close to some codeword C(m) such that  <span class="math">\\widehat{m}(z) = v</span> . The verifier should do so while reading</p>

    <p class="text-gray-300"><span id="page-5-1"></span><sup>&</sup>lt;sup>4</sup>Here and throughout this work we assume that all error-correcting codes are <em>linear</em>, meaning that the set of codewords is a linear space.</p>

    <p class="text-gray-300"><span id="page-6-0"></span>only a few symbols from y but is allowed to interact with an untrusted prover in the <em>interactive</em> oracle proof model [BCS16,RRR16], which basically means that the prover can send long messages from which the verifier reads only a few symbols.</p>

    <p class="text-gray-300">A code C that has good relative distance and an efficient IOPP for Multilinear Evaluation can be used to derive an MLPCS as follows: given a description  <span class="math">f:\\{0,1\\}^m \\to \\mathbb{F}</span>  of a multilinear polynomial, the prover views f as a message of length  <span class="math">2^m</span> , encodes it using C and sends a Merkle hash of C(f) to the verifier. To prove an evaluation claim of the form  <span class="math">\\widehat{f}(z) = v</span> , the prover and verifier engage in the above IOPP, which is compiled into a succinct non-interactive argument using Merkle hashing and the Fiat-Shamir transform.</p>

    <p class="text-gray-300">The core of Brakedown [GLS<sup>+</sup>23], Basefold [ZCF24], FRI/Binius/Basefold [DP24a] and Red-Shift [KPV22] can all be framed as IOPPs for Multlilinear Evaluation (for different codes) that are then compiled into an MLPCS using cryptographic hashing as above.</p>

    <p class="text-gray-300"><strong>Lifting MLPCS via Interleaving.</strong> Our first main observation, which builds on the codeswitching approach, is a procedure that "lifts" a code C that already has an IOPP for Multilinear Evaluation, with an inefficient prover, into a new code C' that also has such an IOPP, but this time with an efficient prover. The drawback is that the new code is defined over a larger alphabet, which accordingly increases the proof's size.</p>

    <p class="text-gray-300">Following Ligero and Brakedown, this lifting is achieved by using code interleaving. In a nutshell, this procedure takes an arbitrary code  <span class="math">C: \\mathbb{F}^k \\to \\mathbb{F}^n</span>  and an integer  <span class="math">t \\in \\mathbb{N}</span>  (which should be thought of as poly-logarithmic and likewise a power of two), and produces the interleaved code  <span class="math">C^t: \\mathbb{F}^{t \\times k} \\to \\mathbb{F}^{t \\times n}</span>  as follows: the message m is interpreted as a  <span class="math">t \\times k</span>  matrix and each row is encoded separately using C. The output  <span class="math">C^t(m)</span>  is simply the resulting  <span class="math">t \\times n</span>  matrix.</p>

    <p class="text-gray-300">Observe that, assuming C is linear-time encodable, the encoding time of  <span class="math">C^t</span>  is similar to that of C. If we view  <span class="math">C^t</span>  as operating over the alphabet  <span class="math">\\mathbb{F}^t</span>  (i.e. each column is a single alphabet symbol) then the relative distance is also preserved, albeit over the larger alphabet.</p>

    <p class="text-gray-300">It remains therefore to show how to transform an IOPP for Multilinear Evaluation for C into one for  <span class="math">C^t</span> , but with a more efficient prover. In this IOPP we need, given as input a matrix  <span class="math">y \\in \\mathbb{F}^{t \\times n}</span> , to prove that y is close to some  <span class="math">C^t(m)</span>  such that  <span class="math">\\widehat{m}(z) = v</span> , for  <span class="math">z \\in \\mathbb{F}^{\\log(tk)}</span>  and  <span class="math">v \\in \\mathbb{F}</span> .</p>

    <p class="text-gray-300">The idea, building on [AHIV23, GLS<sup>+</sup>23] is as follows. The prover first decomposes the claim  <span class="math">\\widehat{m}(z) = v</span>  into separate claims about the rows of m. Denoting the rows of m by  <span class="math">m_1, \\ldots, m_t</span>  and decomposing  <span class="math">z = (z_1, z_2) \\in \\mathbb{F}^{\\log(t)} \\times \\mathbb{F}^{\\log(k)}</span> , the prover sends a full description of the function  <span class="math">u: \\{0, 1\\}^{\\log(t)} \\to \\mathbb{F}</span>  defined as  <span class="math">u(i) = \\widehat{m}_i(z_2)</span> .</p>

    <p class="text-gray-300">The verifier then checks that this decomposition is consistent with the prover's claim. To do so it simply checks that  <span class="math">\\widehat{u}(z_1) = v</span> . To see why this test should pass (when the prover behaves honestly) observe that:</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat{u}(z_1) = \\sum_{b_1 \\in \\{0,1\\}^{\\log(t)}} eq(b_1, z_1) \\cdot \\widehat{m_i}(z_2)</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\sum_{b_1 \\in \\{0,1\\}^{\\log(t)}} eq(b_1, z_1) \\sum_{b_2 \\in \\{0,1\\}^{\\log(k)}} eq(b_2, z_2) \\cdot m(b_1, b_2)</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\sum_{b \\in \\{0,1\\}^{\\log(t) + \\log(k))}} eq(b, z) \\cdot m(b)</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\widehat{m}(z).</span></div>

    <p class="text-gray-300"><span id="page-7-2"></span>For soundness, we should consider the behavior for a NO input – i.e., an input y that is either far from the code  <span class="math">C^t</span> , or one that is close to some codeword  <span class="math">C^t(m)</span>  for which the claim about the multilinear evaluation is false (i.e.,  <span class="math">\\hat{m}(z) \\neq v</span> ). Suppose first that we are in the latter case. Denoting the correct function that the prover should send by u, observe that in this case the prover must send as its first message a different function  <span class="math">\\tilde{u} \\neq u</span> , since otherwise the verifier will reject in the above consistency test.</p>

    <p class="text-gray-300">To catch the prover, the verifier now chooses a random linear combination  <span class="math">r \\in \\mathbb{F}^t</span>  of the rows of m and sends r to the prover. Since C is a linear code, the vector r defines a new codeword  <span class="math">y_{combo} = r^T y \\in C</span> . Moreover, by linearity, the message  <span class="math">m_{combo} = r^T m</span>  encoded within  <span class="math">y_{combo}</span>  is such that  <span class="math">\\widehat{m}_{combo}(z_2) = \\sum_i r_i \\cdot \\widehat{m}_i(z_2) = \\langle u, r \\rangle</span> , where  <span class="math">\\langle u, r \\rangle</span>  is a shorthand for  <span class="math">\\langle u, r \\rangle = \\sum_{i \\in \\{0,1\\}^{\\log(t)}} u(i) \\cdot r_i</span> .</p>

    <p class="text-gray-300">Since  <span class="math">u \\neq \\tilde{u}</span> , with high probability<sup>5</sup> over r, it holds that  <span class="math">\\langle u, r \\rangle \\neq \\langle \\tilde{u}, r \\rangle</span> . Thus, to catch the prover, the verifier simply runs the underlying IOPP for multilinear evaluation on the codeword  <span class="math">y_{combo} = r^T y</span>  relative to the – in this case false – claim  <span class="math">\\widehat{m}_{combo}(z_2) = \\langle \\tilde{u}, r \\rangle</span> . Each query to the input  <span class="math">y_{combo}</span>  is emulated by the verifier by making a query to the corresponding column of y (i.e., a single query over the alphabet  <span class="math">\\mathbb{F}^t</span> ).</p>

    <p class="text-gray-300">Thus, we are left with the case that y is altogether far from the code  <span class="math">C^t</span> . In this case, we use elegant results on <em>proximity gaps</em> of codes [RVW13, AHIV23, BSCI<sup>+</sup>20] to argue that, with high probability over r, the resulting vector  <span class="math">r^T \\cdot y</span>  is far from the code C.</p>

    <p class="text-gray-300">We conclude that in any case, for a NO input, the resulting vector  <span class="math">r^T y</span>  is, with high probability over r, far from any codeword C(x) such that  <span class="math">\\hat{x}(z_2) = \\langle \\tilde{u}, r \\rangle</span>  and so, by the soundness of the underlying Multilinear Evaluation IOPP of C, the verifier rejects.</p>

    <p class="text-gray-300">Observe that when lifting a code, the encoding time for a message of size  <span class="math">t \\cdot k</span>  is just t times the encoding time of C for a length k message – i.e., the encoding time of C is (at least) retained. As for the evaluation proof, all the prover needs to do is to compute  <span class="math">r^Ty</span>  and then run the underlying IOPP of C. The point is that the latter IOPP is run on a significantly shorter instance (i.e., smaller than the input by a multiplicative t factor). Thus, by setting t to be sufficiently large, the running time of the prover is dominated by the encoding time of  <span class="math">C^t</span> .</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">1.2.2 Choosing the Right Code</h4>

    <p class="text-gray-300">To instantiate the above framework we therefore need to choose a base linear code C such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. The code has an <em>extremely fast</em> encoding procedure this is important since by the above analysis, the encoding procedure dominates the prover's complexity.</li>

      <li>2. The code has good relative distance the distance of the code translates into the number of queries that the IOPP verifier needs to make, which in turn directly affects the proof-size and verification complexity when further compiled into an argument via Merkle Hashing.</li>

      <li>3. The code has an IOPP for Multilinear Evaluation actually, at least from a theoretical perspective, this part can be taken "off-the-shelf", since there exist general results for the existence of IOPPs for arbitrary computations, in particular there exists an IOPP for Multilinear Evaluation for any code. From an asymptotic perspective, by setting t to be sufficiently large, the prover overhead incurred by these generic results becomes a small order term.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-7-1"></span><sup>&</sup>lt;sup>5</sup>Specifically the error probability is  $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , and recall that  </span>\\mathbb{F}$  is cryptographically large, meaning that its size is exponential in the security parameter.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-8-2"></span>Still, from a concrete perspective, the generic approach does introduce an (additive) overhead that is important to minimize in practice. Thus, we would like to find a base code that has a concretely efficient IOPP for Multilinear Evaluation.</p>

    <p class="text-gray-300">RAA Codes. We implement the above framework using the Repeat-Accumulate-Accumulate (RAA) family of codes [\\[DJM98\\]](#page-80-6), mainly due to their extremely efficient encoding and good relative distance (points 1 and 2) above, but we additionally show an efficient direct IOPP for Multilinear Evaluation for these codes (point 3 above).</p>

    <p class="text-gray-300">The RAA code is a binary code meaning that the underlying field is GF(2) – both messages and codewords are just sequences of bits (for the PCS we will actually need a code over a larger alphabet, but we defer a discussion on this till later). The code RAA : {0, 1} <sup>k</sup> → {0, 1} n is parameterized by a small integer r ∈ N (e.g., r = 4 is a good choice) such that r = n/k, and descriptions of two permutations π1, π<sup>2</sup> : [n] → [n]. The encoding of a message m ∈ {0, 1} <sup>k</sup> proceeds through the five following step process:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. (Repeat:) Each bit of m is repeated r times.</li>

      <li>2. (Permute:) The order of the n bits is then permuted using π1.</li>

      <li>3. (Accumulate:) Then, an accumulation (i.e., prefix-sum modulo 2) is performed on the vector.<a href="#page-8-0">6</a></li>

      <li>4. (Permute:) Another permutation step is applied, this time using π2.</li>

      <li>5. (Accumulate) Lastly, one more accumulation step is applied.</li>

    </ul>

    <p class="text-gray-300">The result of the last step is the encoded RAA codeword (for more details, see <a href="#page-16-0">Section 3\\)</a>.</p>

    <p class="text-gray-300">RAA codes are known in the coding literature for their extremely fast and simple encoding and are thus perfectly suited for the first requirement above. Indeed, observe that encoding can be done using a circuit with exactly 2(kr − 1) XOR gates.<a href="#page-8-1">7</a></p>

    <p class="text-gray-300">Distance Analysis of RAA Codes. As with prior works, we analyze the expected number of low-weight codewords appearing in an RAA code (where the randomness is over a uniform choice of π<sup>1</sup> and π2): if this expectation is proved small enough, Markov's inequality immediately translates this into a bound on the probability the code fails to have good minimum distance.</p>

    <p class="text-gray-300">Prior works <a href="#page-78-1">\\[BMS08,</a> [KZCJ07\\]](#page-81-1) already analyzed this expected value and derived promising results. In particular, [\\[BMS08\\]](#page-78-1) showed that asymptotically good RAA codes exist; however, the tradeoff between rate and distance is not made explicit (and indeed, the proof is not optimized to obtain meaningful minimum distance). One benefit is that it is fairly easy to follow the argument and thereby obtain a concrete bound on the expectation. On the other hand, [\\[KZCJ07\\]](#page-81-1) provide an "asymptotic" statement which shows that for sufficiently large n, very impressive rate-distance tradeoffs are achievable (in particular, one can get quite close to the GV bound). However, the analysis does not naturally give concrete failure probabilities (and an inspection of the proof shows that they are quite poor).</p>

    <p class="text-gray-300"><span id="page-8-0"></span><sup>6</sup> In more detail, the accumulation of a vector a ∈ {0, 1} n is the vector b ∈ {0, 1} <sup>n</sup> defined as b<sup>i</sup> = L 1≤j≤i ai.</p>

    <p class="text-gray-300"><span id="page-8-1"></span><sup>7</sup>The accumulation step can be done either by a straightforward sequential scan with n − 1 XOR operations, or using an O(log n) depth circuit with O(n) XOR gates and excellent constants, by the classical work of Fischer and Ladner [\\[LF80\\]](#page-81-6).</p>

    <p class="text-gray-300"><span id="page-9-3"></span>We built off the two approaches in order to obtain the rate-distance tradeoffs of [\\[KZCJ07\\]](#page-81-1) while still obtaining meaningful bounds on the expectation. Our crucial idea is to break the expectation into two parts: the expectation over message vectors where after the first accumulation the weight is still small (say, ≪ k <sup>1</sup>−2/r) vs. the case that it is quite large. (For context, <a href="#page-78-1">\\[BMS08,</a> [KZCJ07\\]](#page-81-1) establish that k <sup>−</sup>2/r is roughly the expected minimum distance of an RA code, i.e., a code with only one round of accumulation.) We provide two separate analyses for each of these expectations: for the first term with small middle weight, our bound is quite combinatorial and follows by reasoning about binomial coefficients; for the latter term with large middle weight, we use ideas from [\\[KZCJ07\\]](#page-81-1) with an extended analysis to derive concrete bounds.</p>

    <p class="text-gray-300">While the bounds are meaningful, they are not always satisfactory; i.e., for k = 2<sup>15</sup> and r = 4, achieving distance δ = 0.19 the failure probability is about 2−<sup>5</sup> . Fortunately, we observe that one can decrease this failure probability by additionally testing the RAA code after sampling: if the RAA code passes the test then we can argue that it will have good distance with improved probability.<a href="#page-9-0">8</a> We consider the following simple test: for messages of weight at most w (where w = O(1) is a parameter), we verify that they all have encodings of weight at least δn (here and throughout, n = rk is the blocklength). The motivation stems from the observation that the dominant terms in the expectation that we bound come from the case of low weight message vectors, so if we can remove them from the expectation (which conditioning on a successful test essentially allows us to do) we then obtain a decreased failure probability. Informally, we observe that with a O˜(n <sup>w</sup>) time test, whereas the original failure probability is something like 1/n<sup>c</sup> for a constant c, the new failure probability will be roughly 1/nc(w+1) .</p>

    <p class="text-gray-300">Improved Rate via Puncturing. RAA codes are inherently limited to rates of the form 1/r for r ∈ N: in particular, rates > 1/2 are unachievable. Furthermore, as [\\[KZCJ07\\]](#page-81-1) point out, at rate 1/2 the expectation is necessarily Ω(1).<a href="#page-9-1">9</a> To remedy this, we follow the lead of [\\[KZCJ07\\]](#page-81-1) and consider puncturing RAA codes.</p>

    <p class="text-gray-300">By puncturing we mean that a subset of the coordinates is selected and removed from the codewords. We show that if the punctured set is chosen at random then the resulting punctured RAA code can obtain even higher rates and obtain minimal distance close to the GV bound, with similar failure probabilities (in particular, the above test is still applicable). We note that puncturing does not improve the encoding time of the code, but can be useful in our PCS context in case the Merkle hashing becomes the dominant term. However, for our benchmarks, in the parameter regime that we consider, Merkle hashing does not dominate and so we do not implement puncturing but merely suggest it as a possibility. We provide some analysis of punctured RAA codes and, assuming a conjecture,<a href="#page-9-2">10</a> we can show that they achieve good tradeoffs between rate and distance (e.g., rate 1/2 with distance 0.1, which is nearly the GV bound).</p>

    <p class="text-gray-300">Handling Larger Fields by Bit Packing and Slicing. As mentioned above, the RAA code is defined over the binary field GF(2), whereas we need our code to work over a larger finite field</p>

    <p class="text-gray-300"><span id="page-9-0"></span><sup>8</sup>Such an idea was also suggested in <a href="#page-77-0">\\[BCG</a><sup>+</sup>22], but only as a heuristic, whereas we formally prove the test is effective. Our argument justifies equally well the heuristic considered in <a href="#page-77-0">\\[BCG</a><sup>+</sup>22].</p>

    <p class="text-gray-300"><span id="page-9-1"></span><sup>9</sup>Also for technical reasons we prefer working with even r, meaning that the largest rate we directly analyze is 1/4.</p>

    <p class="text-gray-300"><span id="page-9-2"></span><sup>10</sup>The conjecture concerns the maximizer of a certain function which arises. For the unpunctured case, we provide a complete analysis of the analogous function. We believe the analysis could be extended to the case of punctured RAA codes, but we leave it for future work.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-10-0"></span>(essentially this is a requirement from the proof-system that uses the polynomial commitment scheme – the scheme has soundness error at least 1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, so the field should be rather large).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In <a href="#page-77-2">\\[BFK</a>+24] this was handled in the context of expand accumulate codes, by extending the construction and analysis of the code to arbitrary fields. Inspired by recent advances in SNARKs over binary fields <a href="#page-80-2">\\[DP23,</a>[DP24a\\]](#page-80-3) we take a different route, by focusing on binary extension fields. Recall that the elements of the field GF(2<sup>f</sup> ), for an integer f ∈ F can be viewed as f-dimensional bit vectors. In this representation field addition is simply an f-bit exclusive-Or (XOR). To extend the RAA code to GF(2<sup>f</sup> ) we simply "pack" f codewords that live in {0, 1} n into one packed codeword in (GF(2<sup>f</sup> ) n ) as follows. We place the codewords as rows of an f × n dimensional matrix and then interpret each column as a field element. We remark that this operation is essentially the same as interleaving described above, but we use the term packing since it will be useful to distinguish the two stages.</p>

    <p class="text-gray-300">Observe that this method of packing, which is also sometimes referred to as bit slicing, is particular efficient to implement: to encode a single packed RAA message m ∈ (GF(2<sup>f</sup> ))<sup>k</sup> we just apply the original RAA operations but on f bit words at a time. Thus, all we need to do in order to encode is apply f-bit XORs (for accumulation), or move around f-bit words (for the permutation).</p>

    <p class="text-gray-300">Thus, using, e.g., rate 1/4 the packed RAA codes can be encoded by an arithmetic circuit over GF(2<sup>f</sup> ) using 8k additions. On a RAM, one additionally needs to implement the two permutations (that were "for free" in the circuit model), which can be done in O(n) time (the exact constant depending on the specific architecture).</p>

    <p class="text-gray-300">We remark that the above is the reason that in this work we focus on binary extension fields. We believe that a different generalization of RAA codes to prime order fields (possibly following <a href="#page-77-2">\\[BFK</a>+24]) may be possible and leave exploring this to future work.</p>

    <p class="text-gray-300">Multilinear Evaluation for Packed RAA Codes. Addressing point 3 above, we also develop a special purpose multilinear evaluation IOPP for packed RAA codes. In a nutshell we observe that the (packed) RAA encoding is done by alternating between accumulations and permutations and handle each of these 4 steps using a simple protocol.</p>

    <p class="text-gray-300">In more detail, the IOPP prover sends Reed-Solomon encodings of the 4 intermediate stages in the computation. We use the BaseFold-FRI IOPP <a href="#page-83-1">\\[ZCF24,</a> [DP24a\\]](#page-80-3) to "pretend" that we have access to the multilinear extension of these intermediate computations. Finally, we use sumcheck to check the accumulations steps and an argument from [\\[CBBZ23\\]](#page-79-0) (that is derived from the grand product argument from [\\[SL20\\]](#page-82-8)) to check the permutation steps.</p>

    <p class="text-gray-300">Remark 4. We emphasize that we use BaseFold-FRI as a generic IOPP for checking multilinear evaluations. As such, any progress on more efficient IOPPs for multilinear evaluation (especially on the verifier's side) can be used as a drop-in replacement for BaseFold in our scheme.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">1.2.3 Summary and Open Problems</h4>

    <p class="text-gray-300">To summarize, in this work we make two main technical contributions:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We introduce the IOPP for Multilinear Evaluation as a convenient abstraction from prior work, and show how to use code interleaving to lift an efficiently computable code into a new code, that is still efficiently computable, but now also has a highly efficient IOPP for Multilinear Evaluation.</li>

    </ol>

    <p class="text-gray-300"><span id="page-11-1"></span>2. We give new asymptotic and concrete bounds for the distance of RAA codes, as well as their packed analogs.</p>

    <p class="text-gray-300">While these two contributions are somewhat orthogonal, they go very well together. Still, it may be useful to utilize them separately. For example, one might want to apply the lifting procedure to other codes (possibly over a prime field). Alternatively, it may be useful to use our improved analysis of RAA codes in other contexts (e.g., a "vanilla" code interleaving as in Ligero and Brakedown, which can be viewed as lifting a trivial IOPP for Multilinear evaluation in which the verifier reads everything).</p>

    <p class="text-gray-300">Open Problems. While Blaze is not the first system to achieve linear-time proving, it is the first to specify the concrete constant overhead (at least in the circuit model, which serves as a clean comparison point). We believe that an important challenge for the community is to further improve this constant prover overhead. We mentions some additional concrete directions for improvement:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Construct codes that match the efficiency of our packed RAA codes over large prime fields.</li>

      <li>2. While the binary RAA codes that we construct are close to optimal (in the sense of almost matching the GV bound), the packed RAA codes are still somewhat far from optimal (for this larger alphabet, optimal would mean meeting the Singleton bound).</li>

      <li>3. RAA codes for shorter messages our distance guarantee scales with the message-size and as such only gives weak guarantees for short messages. Providing some mechanism for certifying the parameterization of RAA codes, even specifically for short messages, would therefore be quite useful.</li>

      <li>4. The proximity gap lemma that we use from [\\[BKS18\\]](#page-78-2) is for arbitrary codes and still lags behind the results that are known for the Reed-Solomon code <a href="#page-77-0">\\[BCG</a>+22]. Improving these bounds (ideally for arbitrary codes, but even specifically for the RAA variants) is an interesting and important open problem.</li>

    </ul>

    <h2 id="sec-10" class="text-2xl font-bold">1.3 Comparison with Prior Work</h2>

    <p class="text-gray-300">As already mentioned, our PCS is heavily inspired by prior works. We compare to some of these works next:</p>

    <p class="text-gray-300">Ligero [\\[AHIV23\\]](#page-75-1), Brakedown <a href="#page-80-5">\\[GLS</a>+23], Block et al. <a href="#page-77-2">\\[BFK</a>+24] and Binius [\\[DP23\\]](#page-80-2). The commitment phase of our PCS is identical to that in these works, except that we use RAA codes instead of the Reed-Solomon code, Spielman's code, EA codes and binary Reed-Solomon, respectively. The evaluation proof in our case is more complex, but offers better parameters, both asymptotically (i.e., Oλ(log<sup>2</sup> (n)) vs. Oλ( √ n)) and concretely for large instances (see <a href="#page-37-0">Section 8\\)</a>. The two main differences from these works is that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We use RAA codes which have a better rate/distance tradeoff than Spielman's code and the EA code. Additionally the codes have a much faster encoding time than Reed-Solmonon and EA codes (the encoding time of both is O(n log n)).</li>

    </ol>

    <p class="text-gray-300"><span id="page-12-0"></span>2. We utilize an additional proof composition step to reduce the proof length and verification time to be poly-logarithmic. In contrast <a href="#page-75-1">\\[AHIV23,</a><a href="#page-77-2">BFK</a>+24[,DP23\\]](#page-80-2) achieve only O( √ n) proofsize and verification time. Still, it seems that for small message sizes their approach is preferable, see <a href="#page-37-0">Section 8.</a></p>

    <p class="text-gray-300">BaseFold [\\[ZCF24\\]](#page-83-1) and FRI-Binius [\\[DP24a\\]](#page-80-3). BaseFold achieves Oλ(log<sup>2</sup> (n)) proof-size and verification time by combining sumcheck with FRI. FRI-Binius adapts Basefold to binary extension fields. However, compared to our approach, both schemes have slower prover times due to their reliance on the FFT algorithm (or additive NTT in the case of FRI-Binius), which incurs an O(n log(n)) encoding overhead. We eliminate this overhead by interleaving and running BaseFold over a smaller instance of size n/t. However, RAA codes have worse distances (than Reed-Solomon), and thus this optimization comes at the cost of a concretely larger proof size, see <a href="#page-37-0">Section 8.</a></p>

    <p class="text-gray-300">Orion [\\[XZS22\\]](#page-83-2). Orion, builds on <a href="#page-80-5">\\[GLS</a>+23] but achieves a poly-logarithmic proof size and verification time. At a very high level their proof composition approach is similar to ours but looking in more detail, the approaches are quite different. Similarly to Blaze, in Orion, a "Brakedown"-like system is constructed but is then composed with another proof-system to reduce the proof size.</p>

    <p class="text-gray-300">The key difference is in where this composition happens. Orion constructs a full cryptographic argument-system (i.e. after Merkle hashing) and then composes with another succinct argument to prove correctness. In contrast, our composition happens within the information-theoretic proofsystem (as in classical PCP composition <a href="#page-75-2">\\[AS92,</a> <a href="#page-78-3">BGH</a>+06]). We believe that the latter approach is preferable and in particular it avoids altogether the need for the inner proof-system to prove correctness of complex cryptographic operations. We note that the original version of Orion had a soundness issue, which was recently fixed by [\\[dHS24\\]](#page-79-3). Additionally, there is a variant called Orion+ [\\[CBBZ23\\]](#page-79-0), which achieves constant proof sizes by composing with a KZG-based proofsystem. However, both the fixes and variants still need an inner proof-system for verifying complex cryptographic operations.</p>

    <p class="text-gray-300">Batch FRI <a href="#page-79-2">\\[BSCI</a>+20]. Our composition approach is also similar to "batch-FRI" – a method proposed by Ben Sasson et al. <a href="#page-79-2">\\[BSCI</a>+20] to check that t given functions are all close to being low degree polynomials. Their approach (much like ours) can be described as interleaving these t polynomials and then applying a proximity test (in their case FRI) to a random linear combination of the rows. To the best of our knowledge this approach has not been suggested in the context of obtaining a (multilinear) PCS for a single polynomial.</p>

    <p class="text-gray-300">Additional Related Work. We also mention some other exciting developments. STIR [\\[ACFY24\\]](#page-75-0) suggests an improvement to the FRI PCS by leveraging the fact that due to its recursive nature, as the FRI protocol advances, the instance size shrinks, which enables them to slow down the prover a bit in the interest of smaller proofs and faster verification. Circle STARKs [\\[HLP24\\]](#page-80-0) are a different extension of FRI which enables the use of certain non-smooth prime fields, which is extremely important and useful in practice.</p>

    <p class="text-gray-300">So far we have focused exclusively on hashed-based PCS constructions. We briefly mention that there are other approaches for PCS constructions, based on more structured cryptographic assumptions such as discrete log. Notable examples include KZG [\\[KZG10\\]](#page-81-7), Bulletproofs <a href="#page-76-4">\\[BCC</a>+16, <a href="#page-76-5">BBB</a>+18], Hyrax <a href="#page-83-3">\\[WTS</a>+18], and Dory [\\[Lee20\\]](#page-81-8). Such systems typically have <span id="page-13-4"></span>much shorter proofs, but involve expensive "public-key" operations, are typically quantum-insecure and sometimes require an expensive trusted setup. On the other hand, in contrast to their hash-based counterparts, this line of work can produce sublinear-space commitments [BHR<sup>+</sup>20, BHR<sup>+</sup>21, BCHO22], which in turn can be used to construct time and space efficient proof-systems (but see [BBHV22, FPP24] for some exceptions to the general rule). Additionally, many efficient lattice-based PCS constructions have emerged recently, demonstrating promising performance [CMNW24, NS24, AFLN24, BC24, HSS24, BS23].</p>

    <h2 id="sec-11" class="text-2xl font-bold">2 Preliminaries</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Throughout this work for equal length strings  <span class="math">x, y \\in \\Sigma^n</span>  over an alphabet  <span class="math">\\Sigma</span> , we denote their relative Hamming distance by  $\\Delta(x,y) := \\frac{1}{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{i \\in [n] : x_i \\neq y_i\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . For a non-empty set  </span>S \\subseteq \\Sigma^n<span class="math">  and  </span>x \\in \\Sigma^n<span class="math"> , we define  </span>\\Delta(u,S) := \\min\\{\\Delta(u,s) : s \\in S\\}$ . The Hamming weight of a string is the number of non-zero coordinates.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">2.1 Multilinear Extension</h4>

    <p class="text-gray-300">Let  <span class="math">\\mathbb{F}</span>  be a finite field and  <span class="math">m \\in \\mathbb{N}</span>  be an integer. For every function  <span class="math">f : \\{0,1\\}^m \\to \\mathbb{F}</span>  there exists a unique multilinear polynomial  <span class="math">\\widehat{f} : \\mathbb{F}^m \\to \\mathbb{F}</span>  that agrees with f on  <span class="math">\\{0,1\\}^m</span> . We refer to  <span class="math">\\widehat{f}</span>  as the multilinear extension (MLE) of f.</p>

    <p class="text-gray-300">The polynomial  <span class="math">\\widehat{f}</span>  can be expressed explicitly as:</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat{f}(x) = \\sum_{b \\in \\{0,1\\}^m} eq(x,b) \\cdot f(b), \\tag{1}</span></div>

    <p class="text-gray-300">where  <span class="math">eq(x, b) = \\prod_{i \\in [m]} eq_1(x_i, b_i)</span>  and  <span class="math">eq_1(x_i, b_i) = x_i \\cdot b_i + (1 - x_i) \\cdot (1 - b_i)</span> .</p>

    <p class="text-gray-300">For a given  <span class="math">x \\in \\mathbb{F}^m</span> , the sequence of values  <span class="math">(eq(x,b))_{b \\in \\{0,1\\}^m}</span>  can be generated very efficiently, as demonstrated by the following proposition (see also [VSBW13, CFFZ24] and [Tha22, Section 3.5]).</p>

    <p class="text-gray-300"><span id="page-13-3"></span><strong>Proposition 2.1</strong> ([Rot24, Proposition 1 and Section 2.1]). Let  <span class="math">\\mathbb{F}</span>  be a binary extension field. Given as input  <span class="math">z \\in \\mathbb{F}^m</span> , the sequence of values  <span class="math">(eq(z,b))_{b \\in \\{0,1\\}^m}</span>  can be generated in lexicographic order in time  <span class="math">O(2^m)</span>  and space O(m). In more detail, the algorithm performs exactly  <span class="math">2^m</span>  field multiplications and an additional O(m) additions, multiplications and inversions over the field.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">2.2 Interactive Proofs and IOPs</h4>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{R}</span>  be an NP relation and denote the corresponding language by  <span class="math">\\mathcal{L}(\\mathcal{R}) = \\{x : \\exists w, (x, w) \\in \\mathcal{R}\\}</span> . Throughout, we will think of the language  <span class="math">\\mathcal{L}(\\mathcal{R})</span>  itself as a pair language - that is, the inputs are a pair (x, y) where x (which will typically be short) is called the <em>explicit input</em> and y (which is long) is called the <em>implicit input</em>. In certain cases, we may work with an <em>indexed relation</em>, where the input additionally includes an index i, such as the description of a circuit or a linear code.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">2.2.1 Interactive Proofs and Sumcheck</h4>

    <p class="text-gray-300">Interactive proofs [GMR89] are protocols enabling a prover to convince a verifier of the correctness of a statement  <span class="math">x \\in L</span>  by back and forth interaction. We do not formally define interactive proofs since</p>

    <p class="text-gray-300"><span id="page-14-2"></span>this work focuses on a different form of proof, called an <em>interactive oracle proof</em> [BCS16, RRR16], which we define below. Still, we will make use of the celebrated sumcheck protocol [LFKN92], with a linear-time prover [Tha13], as described next:</p>

    <p class="text-gray-300"><strong>Lemma 2.2</strong> (The Sumcheck Protocol). Let  <span class="math">\\mathbb{F}</span>  be a finite field and  <span class="math">m, d \\in \\mathbb{N}</span> . There exists a protocol between a prover, who is given as input a description of an m-variate polynomial  <span class="math">Q : \\mathbb{F}^m \\to \\mathbb{F}</span>  of individual degree d, and a verifier who gets as input  <span class="math">\\alpha \\in \\mathbb{F}</span>  and either rejects or outputs  <span class="math">(z, v) \\in \\mathbb{F}^m \\times \\mathbb{F}</span> . The protocol satisfies the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Complexity: the protocol has m rounds. In each round the prover sends d+1 field elements and the verifier responds with a single field element. The verifier performs  <span class="math">O(d \\cdot m)</span>  field operations. The prover runs in time  <span class="math">O((d+1)^m)</span> .</li>

      <li>Completeness: if  <span class="math">\\alpha = \\sum_{x \\in \\{0,1\\}^m} Q(x)</span>  then when interacting with the honest prover, the verifier always outputs (z,v) such that Q(z) = v.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Soundness: if  <span class="math">\\alpha \\neq \\sum_{x \\in \\{0,1\\}^m} Q(x)</span>  then, when interacting with any prover, with probability at least  $1 \\frac{dm}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> , the verifier either rejects or outputs (z, v) such that  </span>Q(z) \\neq v$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-14-1"></span>Remark 2.3 (Batch Sumcheck). Suppose we wish to simultaneously check k sumcheck statements  <span class="math">\\alpha_1 = \\sum_x f_1(x), \\ldots, \\alpha_k = \\sum_x f_k(x)</span> , where each  <span class="math">f_i : \\mathbb{F}^m \\to \\mathbb{F}</span>  is an individual degree d polynomial. Rather than running k separate sumcheck protocols, we can batch them by having the verifier select a random  <span class="math">\\lambda \\in \\mathbb{F}</span>  and running a single sumcheck on the statement  <span class="math">\\sum_{x \\in \\{0,1\\}^m} Q(x) = \\sum_{i=0}^{k-1} \\lambda^i \\cdot \\alpha_i</span> , where Q is the individual degree d polynomial defined as  <span class="math">Q(x) = \\sum_{i=0}^{k-1} \\lambda^i \\cdot f_i(x)</span> . This batching incurs an additional  $k/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  soundness error.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Interactive Proofs for Batching Polynomial Evaluations. We recall an interactive protocol that reduce multiple multilinear evaluation claims into a single one [RR24, CBBZ23]. We state the result from [CBBZ23] due to its optimal prover complexity.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-14-0"></span><strong>Theorem 2.4</strong> ( [CBBZ23, Algorithm 4]). Let  <span class="math">f: \\{0,1\\}^{\\ell} \\to \\mathbb{F}</span>  be a function and denote by  <span class="math">\\widehat{f}</span>  its multilinear extension. There exists an interactive protocol that reduces t > 1 evaluation claims for  <span class="math">\\widehat{f}</span>  to a single evaluation claim for  <span class="math">\\widehat{f}</span> . The protocol has soundness error  $\\frac{2\\ell+3\\log_2(t)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> , prover time  </span>O(t \\cdot 2^{\\ell})<span class="math"> , verifier time  </span>O(t\\ell)<span class="math"> , communication complexity  </span>O(\\ell+\\log(t))<span class="math">  and  </span>\\ell+\\log_2(t)+O(1)$  rounds.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">2.2.2 Interactive Oracle Proofs</h4>

    <p class="text-gray-300">Interactive Oracle Proofs (IOP) [BCS16, RRR16] are a hybrid between interactive proofs, and probabilistically checkable proofs. In a nutshell, an IOP is an interactive protocol in which the prover can send long messages from which the verifier only reads very few symbols. In this work we focus on variants of IOPs which are introduced next.</p>

    <p class="text-gray-300"><strong>Holographic IOP.</strong> Holographic IOPs [COS20] combine features of IOPs and holographic interactive proofs [GR17]. Let  <span class="math">\\mathcal{R}</span>  be an indexed relation. A holographic IOP for  <span class="math">\\mathcal{R}</span>  is specified by an indexer I, a prover P and a verifier V. The IOP consists of an offline phase and an online phase.</p>

    <p class="text-gray-300">In the offline phase, the indexer I outputs an oracle  <span class="math">\\mathsf{idx}(i)</span>  given index i. In the online phase, the prover receives the input  <span class="math">(i, x, y, w) \\in \\mathcal{R}</span> , while the verifier receives x along with oracle access</p>

    <p class="text-gray-300"><span id="page-15-2"></span>to idx(i) and y. The prover and verifier then engage in multiple rounds of interaction, where the prover sends an oracle proof string in each round, and the verifier responds with a message. At the end of the interaction, the verifier accepts or rejects.</p>

    <p class="text-gray-300">The protocol satisfies completeness if for every (i, x, y, w) ∈ R, the prover convinces the verifier with probability 1. The protocol has soundness error ϵ if for every (i, x, y) ∈ L / (R) and every malicious prover P ∗ in the IOP model, the probability that the verifier accepts is at most ϵ.</p>

    <p class="text-gray-300">Multilinear polynomial IOPs (MLIOP). Next, we define the notion of a multilinear polynomial IOP (MLIOP)<a href="#page-15-1">11</a>. Let R be an indexed relation as described earlier, where the online inputs are pairs of an explicit and implicit input. An MLIOP for R is a public coin interactive protocol between a prover, a verifier, and optionally a trusted indexer. The indexer is omitted when the relation has no index component. The protocol consists of following phases:</p>

    <p class="text-gray-300">Offline phase: The trusted indexer provides the verifier with a multilinear polynomial oracle idx, which encodes the index of the relation R.</p>

    <p class="text-gray-300">Interaction phase: The verifier receives the explicit input x ∈ X and has access to the multilinear extension of the implicit input y ∈ Y and multilinear access to idx. The prover receives (x, y) and the witness w ∈ W. The prover and verifier engage in multiple rounds of communication, where in each round the prover sends a set of multilinear polynomial oracles and possibly an additional string. The verifier responds with a list of random challenges.</p>

    <p class="text-gray-300">Query phase: The verifier evaluates the multilinear polynomial oracles at specific points and queries certain entries of y. Finally, the verifier accepts or rejects.</p>

    <p class="text-gray-300">The protocol satisfies completeness if for all (i, x, y, w) ∈ R, the verifier accepts with probability 1 in an honest execution. The protocol has soundness error ε if for every malicious prover P ∗ in the MLIOP model (i.e., P ∗ can only send multilinear polynomials as oracles), and every input (i, x, y) ∈ L/ (R), the probability that the verifier accepts is at most ϵ(δ).</p>

    <p class="text-gray-300">Complexity metrics. When measuring proof communication complexity for MLIOPs and IOPs, we count both the oracle communication (i.e., the total length of the prover oracles being sent) and the non-oracle communication (i.e., the length of the additional strings being sent). We define the total proof communication complexity as the sum of the oracle and non-oracle communications. In MLIOPs, the prover's time for generating the MLE oracle is the size of the polynomial (i.e., O(2m) for an m-variate multilinear polynomial).</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">2.3 Coding Background</h3>

    <p class="text-gray-300">A code C over a finite field F is an injective function C : F <sup>k</sup> → F n . We refer to k as the message length and n as the block length. We will sometimes overload this notation and also use C to denote the image of the function (i.e., {C(x) : x ∈ F <sup>k</sup>}). The rate of a code C is R = k n and its minimum distance is min{∆(x, y) : x, y ∈ C, x ̸= y}. Intuitively, thinking of a codeword as a robust</p>

    <p class="text-gray-300"><span id="page-15-1"></span><sup>11</sup>This notion was originally called "probabilistically checkable interactive proof wrt encoded provers" by Reingold et al. [\\[RRR16\\]](#page-82-6) and also called "polynomial IOP" by Bunz et al. [\\[BFS20\\]](#page-77-7) and Chiesa et al. <a href="#page-79-7">\\[CHM</a><sup>+</sup>20]. We use the term multilinear IOP (MLIOP) to emphasize that the polynomials are multilinear. Multilinear IOPs are also a special case of Tensor IOPs [\\[BCG20\\]](#page-77-1).</p>

    <p class="text-gray-300"><span id="page-16-4"></span>representation for some data, the rate quantifies the efficiency of the encoding, while the minimum distance quantifies its noise-resilience.</p>

    <p class="text-gray-300">If C is a linear function over F then we say that it is a linear code; henceforth all codes in this work are linear. Note that for a linear code, the minimum distance is the equal to the minimal Hamming weight of a non-zero codeword – i.e., min{∆(x, 0) : x ∈ C \\ {0}}. A code is systematic if the the first k codeword symbols are always equal to the message.</p>

    <p class="text-gray-300">A linear code C ⊆ F <sup>n</sup> of dimension k can be conveniently presented in terms of a generator matrix, which is a matrix G ∈ F n×k for which</p>

    <div class="my-4 text-center"><span class="math-block">C = \\{Gx : x \\in \\mathbb{F}^k\\} \\ .</span></div>

    <p class="text-gray-300">Note that in general a linear code has many generator matrices; however, it will be convenient for us to design codes with accompanying generator matrices allowing for very efficient encoding, i.e., the computation of Gx from x will be very fast.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proximity Gaps. We will make use of the following lemma from [\\[BKS18\\]](#page-78-2) (see also <a href="#page-82-7">\\[RVW13,</a> [AHIV23\\]](#page-75-1)), which informally states that any linear code V ⊆ F <sup>n</sup> with sufficiently good distance satisfies a "proximity gap".<a href="#page-16-1">12</a> That is, if U is any other linear space that has at least one vector that is far from all elements of V , then in fact most vectors in U are far from V (at least, assuming</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is sufficiently large). That is, there is a "gap" in terms of proximity: either all elements of U are close to V , or almost all are far.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-16-2"></span>Theorem 2.5 ( <a href="#page-78-2">\\[BKS18,</a> Theorem 4.1]). Let V ⊆ F n be a linear space over a finite field F with distance λ. Let U be an affine space and suppose ∃u ∈ U for which ∆(u, V ) > δ. Then, for any ε > 0 such that δ − ε < λ/3,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr_{u \\in U}[\\Delta(u, V) < \\delta - \\varepsilon] \\le \\frac{1}{\\varepsilon</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For our purposes it will be convenient to reformulate <a href="#page-16-2">Theorem 2.5</a> in the language of matrices and codes. If C ⊆ F n is a code, we denote by C t the t-fold interleaving of C – namely, the space of all t × n dimensional matrices whose rows belong to C.</p>

    <p class="text-gray-300"><span id="page-16-3"></span>Corollary 2.6. Let C ⊆ F n be a linear code with distance λ, let t ∈ N and let M ∈ F t×n be a matrix such that ∆(M, C<sup>t</sup> ) > δ. For any ε > 0 such that δ − ε < λ/3,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr_{r \\in \\mathbb{F}^t} [\\Delta(r^T M, C) < \\delta - \\varepsilon] \\le \\frac{1}{\\varepsilon</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. If M is δ-far from C t then at least one of its rows is δ-far from C. Thus, there exists a vector in the row span of M that is δ-far from C. <a href="#page-16-2">Theorem 2.5</a> now implies that a random vector in the row span is (δ − ε)-far from C with all but <sup>1</sup> ε</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">probability.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our proof system makes use of repeat-accumulate-accumulate (RAA) codes over the binary field F<sup>2</sup> = {0, 1}. For an integer n ∈ N, which we assume to be divisible by a constant r ∈ N, we shall need the following three ingredients to specify a generator matrix for the RAA code as a composition of linear operators.</p>

    <p class="text-gray-300"><span id="page-16-1"></span><sup>12</sup>Actually, a weaker statement is true even for general linear spaces (i.e., with poor distance), see [\\[RVW13\\]](#page-82-7).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For a constant  <span class="math">r \\in \\mathbb{N}</span>  dividing n, let  <span class="math">F_r \\in \\{0,1\\}^{n \\times n/r}</span>  denote the matrix corresponding to the linear operator that repeats each entry in the vector r times. That is,  <span class="math">F_r[i,j] = 1</span>  if and only if  <span class="math">\\lfloor j/r \\rfloor + 1 = i</span> .</li>

      <li>Let  <span class="math">A \\in \\{0,1\\}^{n \\times n}</span>  be the accumulator matrix, A[i,j] = 1 if and only if  <span class="math">i \\ge j</span> .</li>

      <li>For a permutation  <span class="math">\\pi:[n] \\to [n]</span> , let  <span class="math">M_{\\pi} \\in \\{0,1\\}^{n \\times n}</span>  be the permutation matrix corresponding to  <span class="math">\\pi</span> . That is, M[i,j] = 1 if and only if  <span class="math">\\pi(i) = j</span> .</li>

    </ul>

    <p class="text-gray-300">Using these ingredients, the generator matrix for the rate 1/r RAA code  <span class="math">\\mathsf{RAA}_{\\pi_1,\\pi_2}:\\{0,1\\}^{n/r}\\to\\{0,1\\}^n</span>  code is defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{RAA}_{\\pi_1,\\pi_2}(x) = A \\cdot M_{\\pi_2} \\cdot A \\cdot M_{\\pi_1} \\cdot F_r \\cdot x.</span></div>

    <p class="text-gray-300"><img src="_page_17_Figure_5.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Figure 1: A pictorial representation of (a generator matrix for) an RAA code with rate R = 1/3 and block-length n = 9.</p>

    <p class="text-gray-300">Our main result the following theorem, which is a more formal version of Theorem 3 from the introduction. The following function will play an important role: for fixed even  <span class="math">r \\in \\mathbb{N}</span> ,  <span class="math">r \\geq 4</span> , we define</p>

    <div class="my-4 text-center"><span class="math-block">f(\\alpha,\\beta,\\rho) := \\frac{H(\\alpha)}{r} - H(\\beta) - H(\\rho) + \\alpha + (1-\\alpha)H\\left(\\frac{\\beta - \\alpha/2}{1-\\alpha}\\right) + \\beta + (1-\\beta)H\\left(\\frac{\\rho - \\beta/2}{1-\\beta}\\right)</span></div>

    <p class="text-gray-300">where  <span class="math">H(p) := -p \\log p - (1-p) \\log (1-p)</span>  is the binary entropy function (and log's here, and elsewhere, are base-2 unless otherwise specified). We also use  <span class="math">\\mathbb{I}</span>  to denote the indicator for a given condition, i.e.,  <span class="math">\\mathbb{I}\\{\\mathcal{E}\\}</span>  is 1 if the condition  <span class="math">\\mathcal{E}</span>  holds and is 0 otherwise.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-17-0"></span><strong>Theorem 3.1.</strong> Let  <span class="math">r, n \\in \\mathbb{N}</span>  be integers,  <span class="math">r \\geq 4</span>  with r even and r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n. Let  <span class="math">\\delta \\in (0, 1/3)</span>  and, if r = 4, assume  <span class="math">\\delta &lt; 1/4</span> . Let  <span class="math">\\varepsilon &gt; 0</span> . Assume n is sufficiently large compared to  <span class="math">r, \\delta</span>  and  <span class="math">\\varepsilon</span> . Then, there exists a near-linear time generation algorithm that outputs a representation for a rate 1/r RAA code with block-length n which has minimum distance  <span class="math">\\geq \\delta</span>  with probability  <span class="math">\\geq 1 - p</span> , where</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-17-1"></span> <span class="math-block">p \\leq \\mathbb{I}\\{r = 4\\} \\cdot \\frac{3}{n-2} + \\mathbb{I}\\{r = 6, \\delta \\geq 1/4\\} \\cdot \\frac{180\\delta^{2}(1-\\delta)}{(n-2)^{2}} + n^{1-r/2} \\cdot \\lceil \\frac{n^{\\gamma}}{2} \\rceil \\cdot \\frac{0.43603}{r} \\cdot \\binom{r}{\\frac{r}{2}} \\cdot \\varphi_{n} \\left(2 \\cdot \\lceil \\frac{m}{2} \\rceil\\right) \\cdot \\varphi_{n}(r) \\cdot (2v_{2}^{<em>})^{\\frac{r+1}{2}} \\cdot \\eta^{v_{2}^{</em>}} + \\frac{0.80192 \\cdot \\delta}{r^{3/2}} \\cdot n^{7/2} \\cdot 2^{Bn} .</span></p>

    <div class="my-4 text-center"><span class="math-block">(2)</span></div>

    <p class="text-gray-300"><span id="page-18-3"></span>In the above,  <span class="math">d := \\delta n \\in \\mathbb{N}</span> ,  <span class="math">m := \\lfloor n^{\\gamma} \\rfloor</span> ,  <span class="math">\\gamma := 1 - \\frac{2}{r}(1 + \\varepsilon)</span> ,  <span class="math">\\eta := 4(\\delta(1 - \\delta))</span> ,  <span class="math">v_2^* = \\frac{1+r}{2\\ln(1/\\eta)} = O(1)</span> ,  <span class="math">\\varphi_n(x) := \\exp\\left(\\frac{x(x-1)}{2n}\\right)</span> , and</p>

    <div class="my-4 text-center"><span class="math-block">B = \\max\\{f(\\alpha_0, \\beta_0, \\delta), \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in CP(r, \\delta)\\}\\}\\</span></div>

    <p class="text-gray-300">where  <span class="math">\\alpha_0 := r/n</span> ,  <span class="math">\\beta_0 := n^{\\gamma-1}</span>  and  <span class="math">CP(r, \\delta)</span>  is the set of critical points of f for fixed r and  <span class="math">\\delta</span>  (defined by equations (19) and (20), and further we only consider critical points lying in a certain region  <span class="math">\\mathcal{R}&#x27;</span>  introduced in Section 9.3).</p>

    <p class="text-gray-300">Additionally, assuming  <span class="math">\\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in \\mathrm{CP}(r, \\delta)\\} &lt; 0</span> , for sufficiently large n we have  <span class="math">B = f(\\alpha_0, \\beta_0, \\delta) = -\\Omega(n^{\\gamma})</span> , so we find</p>

    <p class="text-gray-300"><span class="math-block">(2) \\le O(n^{1+\\gamma-r/2}) + 2^{-\\Omega(n^{\\gamma})} = O(n^{1+\\gamma-r/2})</span> .</p>

    <p class="text-gray-300">In the above theorem, we have taken great efforts to obtain the tightest bound possible (even up to constants), as we wish to obtain good guarantees for concrete values of n. We now provide some interpretation. Firstly, imagine requiring  <span class="math">B&#x27; := \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in \\operatorname{CP}(r, \\delta)\\} &lt; 0</span> , which is a certain set of equations depending on r and  <span class="math">\\delta</span> ; while the exact expression is quite messy to state formally, they are easy to evaluate on a computer. Requiring B' < 0 is what constrains the minimum distance  <span class="math">\\delta</span>  in terms of the rate R = 1/r: this can be compared to something like the GV bound that states we need  <span class="math">R \\leq 1 - H(\\delta)</span> . Nonetheless, we emphasize that the bound (2) is completely explicit, and can be computed easily for concrete values of n (and we provide some calculations in Figure 2 below). An even more detailed version of this theorem is provided as Theorem 9.1, which provides the explicit requirements on n beyond the above "sufficiently large compared to r,  <span class="math">\\varepsilon</span>  and  <span class="math">\\delta</span> ."</p>

    <p class="text-gray-300">The condition of r even is largely for convenience, and a natural adaptation of our techniques handle odd  <span class="math">r \\geq 3</span> .<sup>13</sup> As our target applications of this theorem choose r as a power of 2, we do not bother with supporting odd r. Furthermore for rate 1/4 the GV bound only guarantees codes with minimum distance  <span class="math">\\approx 0.21</span> , so assuming  <span class="math">\\delta &lt; 1/4</span>  in this case is not meaningfully constraining.</p>

    <p class="text-gray-300">Briefly, our approach is the following: we look at the expected number of RAA codewords of weight at most  <span class="math">d^{14}</span>  and split up the terms based on whether the "middle weight" – i.e., weight after one round of accumulating and permuting – is small or large. When it is small, we give a novel combinatorial argument and provide a  <span class="math">O(n^{1+\\gamma-\\frac{r}{2}})</span>  bound on this portion. For large middle weight, we repurpose the approach of [KZCJ07] which, along with some additional care to obtain concrete bounds, yields the  <span class="math">2^{-\\Omega(n^{\\gamma})}</span>  portion of the bound (assuming B < 0).</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">3.1 Adding Tests</h4>

    <p class="text-gray-300">The above gives us meaningful bounds on the failure probability: for message length  <span class="math">k=2^{22}</span> , a rate 1/4 RAA code has minimum distance  <span class="math">\\delta=0.19</span>  except with probability  <span class="math">2^{-13}</span> . While this error probability is perhaps sufficient in some cases (recall this is a one-time set-up procedure), we would like to do better. In this section, we argue that with more sophisticated generation algorithms we can decrease the failure probability significantly. For example, a still near-linear time generation procedure has failure probability  <span class="math">2^{-27}</span> , and a near-quadratic time procedure has failure probability  <span class="math">2^{-42}</span> .</p>

    <p class="text-gray-300"><span id="page-18-1"></span><sup>&</sup>lt;sup>13</sup>However, as [KZKJ08, page 14] indicates, for r=2 the failure probability would be  <span class="math">\\Omega(1)</span> .</p>

    <p class="text-gray-300"><span id="page-18-2"></span> <span class="math">&lt;sup&gt;^{14}&lt;/sup&gt;</span> By Markov's inequality, this suffices for bounding the probability the minimum distance is at most d.</p>

    <p class="text-gray-300">Consider the following generation procedure: after sampling the permutations π<sup>1</sup> and π2, we check to see if low weight messages are problematic. That is, we run the following test: for all O(n <sup>w</sup>) nonzero messages of weight ≤ w (where w = O(1) is a parameter of choice), we check to see if any of them have encoding of weight at most d.</p>

    <p class="text-gray-300">The bulk of the cost of this test is of course in encoding all O(k <sup>w</sup>) messages of weight w: even with the linear-time encoding of RAA codes, this still costs O(k <sup>w</sup>+1) time. Thus, for weight exactly w we in fact to a simplified test: we just check that after the first round the permuting and accumulating, the weight of all these codewords is at least n <sup>κ</sup> where κ ∈ (0, 1 − 2/r) is a tunable parameter (e.g., κ = 0.4 is a reasonable choice). Note that for a weight rw vector (obtained after repeating and permuting a weight w message), given its support {i<sup>1</sup> < i<sup>2</sup> < · · · < irw} we can quickly compute its weight after the accumulation step as (i<sup>2</sup> − i1) + (i<sup>4</sup> − i3) + · · · + (irw − irw−1).</p>

    <p class="text-gray-300">We thereby obtain the following informally stated theorem. Due to space constraints, a formal version (analogous to <a href="#page-17-0">Theorem 3.1\\)</a> only appears in the appendix as <a href="#page-70-0">Theorem 9.16.</a></p>

    <p class="text-gray-300">Theorem 3.2. Let r, n, δ, γ and B be as in <a href="#page-17-0">Theorem 3.1,</a> and assume B < 0. Let also w ∈ N. Then there exists a O(n <sup>w</sup> log(n)) generation algorithm that outputs a representation for a rate 1/r RAA code with block-length n which has minimum distance ≥ δ with probability ≥ 1 − p, where p = O(n (w+1)(1−r/2)+γ ).</p>

    <p class="text-gray-300">Morally speaking, <a href="#page-17-0">Theorem 3.1</a> is the "w = 0" case of the above theorem. Ignoring the γ portion, the moral is that the exponent of the inverse polynomial decay is multiplied by w+ 1 when we use an O˜(n <sup>w</sup>) time test.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As a final contribution, we also consider and analyze punctured RAA codes. By puncturing, we mean that a subset of the coordinates is chosen at random and discarded from all the codewords, which increases the rate of the code but will also decreases the distance. Formally, for a code C ⊆ F n 2 and a subset S ⊆ [n], C punctured to S is the code C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><sup>S</sup> = {c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><sup>S</sup> : c ∈ C}, where for x ∈ F n <sup>2</sup> x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><sup>S</sup> = (xi)i∈<sup>S</sup> is the subvector consisting only of coordinates in S. Note that to encode a punctured RAA codeword one typically would encode the entire RAA codeword and then remove the unnecessary coordinates: i.e., this puncturing operation adds some inefficiency to the encoding.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We provide a formal analysis of the parameters achievable by puncturing RAA codes along with concrete failure probabilities. As we do not eventually use this result in our proposed proof system we defer a more formal discussion – including precise theorem statements – to <a href="#page-19-0">Section 3.2.</a> Informally, we again find that we can achieve codes very close to the GV bound, and now for higher rates; e.g., rate 1/2 is now achievable. In settings of interest, the probability of failure is dominated by the probability that the original "unpunctured" RAA code had much smaller distance than expected: in particular, using our O˜(n <sup>w</sup>) time generation procedure, the failure probability will still be asymptotically O(n (w+1)(1−r/2)+γ ).</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">3.3 Concrete Numbers</h3>

    <p class="text-gray-300">To conclude, we provide in <a href="#page-20-1">Fig. 2</a> achievable parameters for (generation procedures of) RAA codes, along with provable failure bounds.</p>

    <p class="text-gray-300"><span id="page-20-2"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Message Length<br>k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rate 1/r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Distance<br>δ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Generation Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Failure Probability</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">21<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.19</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">−25.4<br>2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">22<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.19</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">−27.4<br>2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">21<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.19</td>

            <td class="px-3 py-2 border-b border-gray-700">2<br>k</td>

            <td class="px-3 py-2 border-b border-gray-700">−38.5<br>2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">22<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">1/4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.19</td>

            <td class="px-3 py-2 border-b border-gray-700">2<br>k</td>

            <td class="px-3 py-2 border-b border-gray-700">−41.5<br>2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">21<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">1/8</td>

            <td class="px-3 py-2 border-b border-gray-700">0.29</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">−86.2<br>2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">22<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">1/8</td>

            <td class="px-3 py-2 border-b border-gray-700">0.29</td>

            <td class="px-3 py-2 border-b border-gray-700">k</td>

            <td class="px-3 py-2 border-b border-gray-700">−92.2<br>2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-20-1"></span>Figure 2: We list parameters achievable by RAA codes along with the running time of the generation procedure (the run-times have the O˜(· · ·)'s removed). We used the following Mathematica script to compute the relatively complicated expressions for the failure probabilities <a href="https://github.com/raa-code-analysis/raa-code-analysis">https://github.</a> <a href="https://github.com/raa-code-analysis/raa-code-analysis">com/raa-code-analysis/raa-code-analysis</a>.</p>

    <p class="text-gray-300">In this section we introduce the notion of a holographic IOP for Multilinear Evaluation. Loosely speaking this is the information-theoretic primitive underlying "hash-based" constructions of (multilinear) polynomial commitment schemes (more on this below). In addition to defining the notion, we also give an overview and systemization of existing tools from the literature, which will be used in our eventual construction.</p>

    <p class="text-gray-300">Let I be an index set, and let C = {C<sup>i</sup> : F <sup>k</sup> → F <sup>n</sup>}i∈I be a family of linear codes, indexed by i ∈ I, where k is a power of 2. We define the indexed relation RMLE[C] as</p>

    <div class="my-4 text-center"><span class="math-block">R_{\\mathsf{MLE}}[\\mathcal{C}] := \\left\\{ (i \\in \\mathcal{I}; \\, (z, v) \\in \\mathbb{F}^{\\log k} \\times \\mathbb{F}; \\, y \\in \\mathbb{F}^n; \\, m \\in \\mathbb{F}^k) \\, : \\, \\widehat{m}(z) = v \\, \\, \\text{and} \\, \\, y = C_i(m) \\right\\}.</span></div>

    <p class="text-gray-300">Here i is an index, (z, v) ∈ F log <sup>k</sup> × F is the explicit input, y ∈ F n is an implicit input and m ∈ F k is the witness. Intuitively, (i, z, v, y, m) is in RMLE[C] if and only if y is the encoding of m (wrt code <sup>C</sup>i) and the multilinear evaluation <sup>m</sup><sup>b</sup> (z) equals <sup>v</sup>. In the following, if the code family <sup>C</sup> has only one code C, we simply write RMLE[C] and omit the index i. Recall that in an IOP for (i, z, v, y, m) ∈ RMLE[C], the verifier has oracle access to the encoding idx(i) of index i.</p>

    <p class="text-gray-300">We will sometimes be interested in IOPs for Multilinear Evaluation in which the code C is defined over a field extension of the field F. Let K = F t , for t ∈ N be a field extension, and {C<sup>i</sup> : K<sup>k</sup> → Kn}i∈I be a family of linear codes over K, indexed by i ∈ I. where k is a power of 2. We define the indexed relation RMLE[C] as</p>

    <div class="my-4 text-center"><span class="math-block">R_{\\mathsf{MLE}}[\\mathcal{C}] := \\left\\{ (i \\in \\mathcal{I}; \\, (z, v) \\in \\mathbb{F}^{\\log(tk)} \\times \\mathbb{F}; \\, y \\in \\mathbb{K}^n; \\, m \\in \\mathbb{K}^k) \\, : \\, \\widehat{m}(z) = v \\, \\, \\text{and} \\, \\, y = C_i(m) \\right\\},</span></div>

    <p class="text-gray-300">where m ∈ K<sup>k</sup> is interpreted as a vector in m ∈ F t·k in the natural way and then we require that the multilinear extension ˆm over F at the point z is equal to v.</p>

    <p class="text-gray-300">Polynomial commitments from IOPPs. For a linear code C with good distance d, an IOPP for RMLE[C] naturally leads to a multilinear polynomial commitment via Merkle hashing (or more generally via composition with a vector commitment) <a href="#page-77-4">\\[BCS16,</a> <a href="#page-79-8">CMS19,</a> [COS20\\]](#page-79-6): the polynomial commitment to m is the Merkle commitment to y = C(m); each proof oracle string is replaced with the corresponding Merkle commitment, and each IOP query is replaced with a Merkle path <span id="page-21-4"></span>opening. IOPP verifier challenges are generated via the Fiat-Shamir transformation. The scheme is a PCS, or equivalently a SNARG (or SNARK) for the polynomial evaluation relation, so long as the IOPP satisfies round-by-round (knowledge) soundness <a href="#page-79-9">\\[CCH</a>+19, [CMS19\\]](#page-79-8). We defer the detailed discussion of the RBR soundness of our IOPP constructions to <a href="#page-83-0">Appendix A.</a></p>

    <p class="text-gray-300">The binding property of the commitment follows from the fact that the IOPP has proximity error δ less than the unique decoding radius: if the prover commits to a string that is δ-far from any codeword, it will be caught with high probability given the IOPP soundness. Otherwise, the committed string is δ-close to a unique codeword and the binding property naturally holds.</p>

    <p class="text-gray-300">The above construction generalizes for any code family C whereas only a negligble fraction of codes C ∈ C have a poor distance. The idea is to randomly pick a code C from C (which has good distance with high probability), the parties then run the same protocol as above wrt code C.</p>

    <p class="text-gray-300">A building block: IOPPs for RMLE[RS]. BaseFold [\\[ZCF24\\]](#page-83-1) constructed an IOPP for RMLE[C] with polylogarithmic verifiers, where C can be any foldable codes. For simplicity, we consider the case where C = RS is a Reed-Solomon code (which is indeed foldable). FRI-Binius [\\[DP24a\\]](#page-80-3) further extended BaseFold to support committing polynomials with small coefficients over binary fields.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-21-2"></span>Theorem 4.1 ( <a href="#page-83-1">\\[ZCF24,</a>[DP24a\\]](#page-80-3)). Let λ ∈ N be the security parameter. Let k ∈ N be a power of 2 and let RS := RS[F, k, n] be a Reed-Solomon code with message length k, blocklength n = O(k) and relative distance d ∈ (0, 1) over the field F (where</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> 2 λ ). Moreover, F is either a binary extension field or a smooth field.<a href="#page-21-1">15</a> There exists an IOPP for RMLE[RS] (with alphabet F) which, for proximity parameter δ < d/3, has the following parameters:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <pre><code class="language-text">input query complexity O (λ/δ),
proof query complexity O (λ log k/δ),
rounds complexity O(log k),
oracle proof communication O(n),
non-oracle proof communication O(log k),
soundness error 2
                        −λ + O(
                              log n
                              |F|
                                ),
prover time O(n),
verifier time O (λ log k/δ).</code></pre>

    <p class="text-gray-300">We note that in BaseFold, generating the implicit input encoding y takes O(n log n) time, but the IOPP prover's complexity is linear in n given access to y.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">4.1 From MLIOP to IOPP</h3>

    <p class="text-gray-300">In this section, we describe an efficient transformation from a holographic MLIOP for a relation R to a holographic IOPP for R. Recall that in an MLIOP the prover is restricted to sending multilinear polynomials, whereas in an IOP, the prover can send arbitrary messages. Looking ahead, this transformation will be used to compile the MLIOP for the multilinear evaluation relation wrt RAA codes (in <a href="#page-25-0">Section 5\\)</a> to an IOPP for the same relation.</p>

    <p class="text-gray-300">The transformation is summarized in the following lemma:</p>

    <p class="text-gray-300"><span id="page-21-3"></span><span id="page-21-1"></span><sup>15</sup>A field is smooth if the domain L ⊂ F of the code is a multiplicative group whose order is a power of 2.</p>

    <p class="text-gray-300"><strong>Lemma 4.2.</strong> Let  <span class="math">\\lambda</span>  be the security parameter and let  <span class="math">\\Pi</span>  be an MLIOP protocol for a relation  <span class="math">\\mathcal{R}</span>  with parameters</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathbb{F}, q_{\\mathsf{inp}}, q_{idx}, q_{\\mathsf{pf}}, \\mathsf{rnd}, cc_{\\mathsf{oracle}}, cc, \\epsilon, T_P, T_V, n_{\\mathsf{oracle}}),</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> 2^{\\lambda}<span class="math">  and the largest polynomial being sent has  </span>\\ell<span class="math">  variables. Set  </span>Q := q_{\\mathsf{inp}} + q_{\\mathsf{idx}} + q_{\\mathsf{pf}}<span class="math">  as the total number of evaluation queries. Let  </span>\\mathsf{RS} := \\mathsf{RS}[\\mathbb{F}, 2^{\\ell}, n]<span class="math">  be the Reed-Solomon code defined in Theorem 4.1 with relative distance d and let  </span>\\delta < d/3<span class="math">  denote the proximity parameter. There exists an IOPP for relation  </span>\\mathcal{R}<span class="math">  with alphabet  </span>\\mathbb{F}$  and has the following complexity parameters:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <pre><code class="language-text">\\begin{array}{lll} input \\ and \\ index \\ query \\ complexity \\\\ proof \\ query \\ complexity \\\\ rounds \\\\ oracle \\ proof \\ communication \\\\ non-oracle \\ proof \\ communication \\\\ soundness \\ error \\\\ prover \\ time \\\\ verifier \\ time \\\\ \\end{array} \\begin{array}{ll} O(\\lambda/\\delta), \\\\ O((n_{\\mathsf{oracle}} + \\ell)\\lambda/\\delta), \\\\ \\mathsf{rnd} + \\log_2(Q) + O(\\ell), \\\\ \\mathsf{noracle} \\cdot n + O(n) \\\\ \\mathsf{cc} + O(\\ell + \\log Q), \\\\ \\epsilon + 2^{-\\lambda} + O\\left(\\frac{\\ell + \\log Q}{|\\mathbb{F}|}\\right), \\\\ T_P + O(n_{\\mathsf{oracle}} \\cdot n \\log n + Q \\cdot 2^\\ell), \\\\ \\mathsf{verifier} \\ time \\\\ \\end{array}</code></pre>

    <p class="text-gray-300">Before describing the scheme, let us recall a nice feature of multilinear polynomials. A multilinear polynomial  <span class="math">f(x_1, \\ldots, x_k)</span>  can be written as</p>

    <div class="my-4 text-center"><span class="math-block">f(x_1,...,x_k) = x_1 \\cdot f(1,x_2,...,x_k) + (1-x_1) \\cdot f(0,x_2,...,x_k).</span></div>

    <p class="text-gray-300">Thus we can split f into two multilinear polynomials  <span class="math">f_0(\\cdot) = f(0, \\cdot)</span>  and  <span class="math">f_1(\\cdot) = f(1, \\cdot)</span>  of k-1 variables without losing information. Similarly, we can merge two polynomials of k variables into one with k+1 variables. This approach extends to splitting a single polynomial to more than 2 polynomials or merging more than 2 polynomials into one.</p>

    <p class="text-gray-300">Let (I, P, V) be an MLIOP for an indexed relation  <span class="math">\\mathcal{R}</span> . We assume wlog that the prover P sends at most one multilinear oracle per round, as multiple polynomials can be merged into one using the previous technique. Let  <span class="math">(P_{\\mathsf{mle}}, V_{\\mathsf{mle}})</span>  be an IOPP for the multilinear evaluation relation  <span class="math">R_{\\mathsf{MLE}}[C]</span> , where C is a systematic linear code. A straightforward IOPP for  <span class="math">\\mathcal{R}</span>  works by simulating the MLIOP execution, but replacing each multilinear oracle  <span class="math">\\widehat{m}</span>  with the oracle string C(m). For each multilinear evaluation query  <span class="math">\\widehat{m}(z) = v</span>  made by the MLIOP verifier, the protocol runs an IOPP protocol for the claim  <span class="math">(z, v, m, C(m)) \\in R_{\\mathsf{MLE}}[C]</span> . However, this protocol is inefficient, as it requires running a separate IOPP for each evaluation query.</p>

    <p class="text-gray-300">To improve efficiency, we leverage the batching protocols from Theorem 2.4 that reduces multiple multilinear evaluation claims into one. Let  <span class="math">\\Pi_{\\mathsf{batch}}</span>  denote the batching protocol. Let (I, P, V) be the MLIOP for  <span class="math">\\mathcal{R}</span>  where every multilinear oracle has  <span class="math">\\ell</span>  variables. Let  <span class="math">\\Sigma_C := (P_{\\mathsf{mle}}, V_{\\mathsf{mle}})</span>  be the building block IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span>  wrt a systematic code C with message length  <span class="math">2^{\\ell}</span> . We now describe the holographic IOPP  <span class="math">(\\mathcal{I}_{\\mathsf{iop}}, \\mathcal{P}_{\\mathsf{iop}}, \\mathcal{V}_{\\mathsf{iop}})</span>  for  <span class="math">\\mathcal{R}</span> .</p>

    <p class="text-gray-300">Offline phase: Given the multilinear polynomial idx sent by the MLIOP indexer I, the indexer  <span class="math">\\mathcal{I}_{iop}</span>  encodes idx and outputs the index oracle  <span class="math">\\mathbb{I} = C(idx)</span> .</p>

    <p class="text-gray-300"><span id="page-22-0"></span><sup>&</sup>lt;sup>16</sup>In our instantiation, C is a Reed-Solomon code and we omit the indexer. One can extend to a family of codes by picking C uniformly random from the family C and let  <span class="math">(P_{\\mathsf{mle}}, V_{\\mathsf{mle}})</span>  denote the corresponding IOPP wrt a code C.</p>

    <p class="text-gray-300"><span id="page-23-4"></span>Online phase: The prover  <span class="math">\\mathcal{P}_{\\mathsf{iop}}</span>  and the verifier  <span class="math">\\mathcal{V}_{\\mathsf{iop}}</span>  simulate the interaction phase of the MLIOP between the prover P and the verifier V. Wlog we denote by  <span class="math">y \\in \\mathbb{F}^{2^{\\ell}}</span>  the implicit input of  <span class="math">\\mathcal{R}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1. The prover  <span class="math">\\mathcal{P}_{\\mathsf{iop}}</span>  provides the verifier with an oracle  <span class="math">\\tilde{y}</span>  containing the non-systematic part of C(y). Together, the oracles to y and  <span class="math">\\tilde{y}</span>  simulate oracle access to  $C(y) = (y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{y})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>2. For every MLE oracle  <span class="math">\\widehat{m}</span>  sent by P, the prover  <span class="math">\\mathcal{P}_{iop}</span>  sends the oracle string C(m) instead.</li>

      <li>3. Let  <span class="math">\\mathcal{O}</span>  denote the set of multilinear oracles sent by P. For every oracle  <span class="math">\\widehat{m} \\in \\mathcal{O} \\cup \\{\\widehat{y}, \\mathsf{idx}\\}</span> , let  <span class="math">S_m</span>  denote the set of V's evaluation queries to  <span class="math">\\widehat{m}</span> .</li>

      <li>(a)  <span class="math">\\mathcal{P}_{\\mathsf{iop}}</span>  and  <span class="math">\\mathcal{V}_{\\mathsf{iop}}</span>  run the batching protocol  <span class="math">\\Pi_{\\mathsf{batch}}</span>  to reduce the evaluation claims to a single claim  <span class="math">\\widehat{m}(z_m) = v_m</span> .</li>

      <li>(b) Run the IOPP  <span class="math">(P_{\\mathsf{mle}}, V_{\\mathsf{mle}})</span>  for  <span class="math">R_{\\mathsf{MLE}}[C]</span>  on instance  <span class="math">(z_m, v_m, C(m), m)</span> .</li>

    </ul>

    <p class="text-gray-300">Note that the batch protocols and IOPPs for different multilinear oracles run in parallel.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">V_{\\text{iop}}</span>  accepts if V accepts in the simulated MLIOP, and  <span class="math">V_{\\text{mle}}</span>  accepts in all IOPP executions.</li>

    </ol>

    <p class="text-gray-300">We can further reduce the number of IOPP executions via the optimization below.</p>

    <p class="text-gray-300"><span id="page-23-3"></span><strong>Remark 4.3.</strong> The batching technique from Theorem 2.4 [CBBZ23] extends to batch evaluations over different polynomials. By combining this with the FRI batching techniques from [BSCI <span class="math">^+</span> 20], we can reduce evaluation claims across different multilinear polynomials to a single evaluation claim over a (virtual) multilinear polynomial. A single query to the encoding of this virtual multilinear polynomial is simulated by corresponding queries to the encodings of the original polynomials—one per polynomial. As a result, the number of IOPP executions for  <span class="math">R_{\\text{MLE}}[C]</span>  is reduced to one, albeit with a slightly worse proximity parameter depening on the batched FRI.</p>

    <p class="text-gray-300"><span id="page-23-2"></span><strong>Proposition 4.4.</strong>  <span class="math">\\Pi_{\\mathsf{IOPP}}^{\\mathcal{R}}[\\Sigma_C]</span>  is an IOPP for the relation  <span class="math">\\mathcal{R}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Completeness follows from the completeness property of the MLIOP, the batching protocol and the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span> . We next prove soundness.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{P}_{\\mathsf{iop}}^<em></span>  be any IOPP adversary for  <span class="math">\\Pi_{\\mathsf{IOPP}}^{\\mathcal{R}}[\\Sigma_C]</span> , wlog we assume that  <span class="math">\\mathcal{P}_{\\mathsf{iop}}^</em></span>  is deterministic.<sup>17</sup> Now, consider an unbounded multilinear IOP adversary  <span class="math">\\tilde{P}</span>  that simulates the execution of  <span class="math">\\mathcal{P}_{\\mathsf{iop}}^*</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">\\tilde{y}</span>  be the first oracle string sent by  <span class="math">\\mathcal{P}^*_{\\text{iop}}</span>  that is alleged to be the non-systematic part of a codeword. For ease of exposition, we instead set the first oracle as  $\\pi_y := (y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{y})<span class="math">  where y is the implicit input. Fix any  </span>\\delta < d/3<span class="math"> . For every oracle string  </span>\\pi<span class="math">  sent by  </span>\\mathcal{P}^<em>_{\\text{iop}}<span class="math"> , the prover  </span>\\tilde{P}<span class="math">  checks whether  </span>\\pi<span class="math">  is within  </span>\\delta<span class="math"> -distance to C, and decodes  </span>\\pi<span class="math">  to m if it is. (Note that  </span>\\tilde{P}<span class="math">  can be computationally unbounded.) If  </span>\\pi<span class="math">  is  </span>\\delta<span class="math"> -far from any codeword,  </span>\\tilde{P}<span class="math">  aborts; otherwise it sends the corresponding oracle  </span>\\hat{m}<span class="math"> . In particular, the decoding of  </span>\\pi_y<span class="math">  is set as the implicit input of the MLIOP execution. Finally,  </span>\\tilde{P}<span class="math">  forwards  </span>\\mathcal{P}^</em>_{\\text{iop}}$ 's responses to the evaluation queries.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Denote  <span class="math">\\epsilon_1</span> ,  <span class="math">\\epsilon_2</span>  and  <span class="math">\\epsilon_3</span>  as the soundness error of the MLIOP, the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span>  and the batching protocol, respectively. Fix  <span class="math">\\delta&#x27; := \\delta/c</span>  where  <span class="math">c \\in (0,1)</span>  is the rate<sup>18</sup> of code C. Consider an indexed input (i,x,y) such that y is  <span class="math">\\delta&#x27;</span> -far from the set  <span class="math">\\{y^<em> : (i,x,y^</em>) \\in \\mathcal{L}(\\mathcal{R})\\}</span> . We argue that the success probability of  <span class="math">\\mathcal{P}^*_{\\mathsf{lop}}</span>  is at most  <span class="math">\\epsilon_1 + \\epsilon_2(\\delta) + \\epsilon_3</span> .</p>

    <p class="text-gray-300"><span id="page-23-0"></span><sup>&</sup>lt;sup>17</sup>For a randomized adversary  <span class="math">\\mathcal{P}_{iop}^<em></span> , we can choose its internal randomness that maximizes its success probability, which leads to a deterministic adversary with success probability no less than that of  <span class="math">\\mathcal{P}_{iop}^</em></span> .</p>

    <p class="text-gray-300"><span id="page-23-1"></span> <span class="math">&lt;sup&gt;^{18}&lt;/sup&gt;C</span>  is instantiated with Reed-Solomon codes in our solutions, so the rate can be large (e.g. 1/2).</p>

    <p class="text-gray-300">Fix  <span class="math">\\vec{\\alpha}</span>  as any public coin challenges in the MLIOP protocol and consider the execution  <span class="math">\\mathcal{P}^<em>_{\\text{iop}}(\\vec{\\alpha})</span> . Denote by  <span class="math">O_{\\vec{\\alpha}} := \\{\\pi_j\\}</span>  the proof strings sent by  <span class="math">\\mathcal{P}^</em>_{\\text{iop}}</span>  and let  <span class="math">S_{\\vec{\\alpha}} := \\{(j, z, v)\\}</span>  be the set of evaluation claims, where j refers to the j-th oracle, z is the evaluation point and v is the evaluation result. Since  <span class="math">\\vec{\\alpha}</span>  is fixed,  <span class="math">O_{\\vec{\\alpha}}</span>  and  <span class="math">S_{\\vec{\\alpha}}</span>  are fixed and well-defined. We now consider two cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. There exists  <span class="math">\\pi_j \\in O_{\\vec{\\alpha}}</span>  that is  <span class="math">\\delta</span> -far from code C. By the soundness of the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span> , the probability that the verifier  <span class="math">\\mathcal{V}_{\\mathsf{iop}}</span>  accepts is at most  <span class="math">\\epsilon_2(\\delta)</span> , where the randomness is over the public coins of the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span> .</li>

      <li>2. All oracles in  <span class="math">O_{\\vec{\\alpha}}</span>  are  <span class="math">\\delta</span> -close to C, but there exists  <span class="math">(j, z, v) \\in S_{\\vec{\\alpha}}</span>  such that for the unique codeword  <span class="math">C(m_j)</span>  that is  <span class="math">\\delta</span> -close to  <span class="math">\\pi_j</span> , it holds that  <span class="math">\\widehat{m_j}(z) \\neq v</span> . Then by the soundness of the batching protocol and the soundness of the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span> , the probability that the verifier  <span class="math">\\mathcal{V}_{\\mathsf{iop}}</span>  accepts is at most  <span class="math">\\epsilon_2(\\delta) + \\epsilon_3</span> .</li>

    </ul>

    <p class="text-gray-300">If neither of the two cases above occurs, then  <span class="math">\\tilde{P}(\\vec{\\alpha})</span>  passes the verification with at least the same probability as  <span class="math">\\mathcal{P}^<em>_{\\text{iop}}(\\vec{\\alpha})</span> . Therefore, the probability that  <span class="math">\\mathcal{P}^</em>_{\\text{iop}}</span>  passes the verification is no more than that of  <span class="math">\\tilde{P}</span>  plus  <span class="math">\\epsilon_2(\\delta) + \\epsilon_3</span> , where the randomness is over the choice of  <span class="math">\\vec{\\alpha}</span>  and the randomness of the batching protocol and the IOPP for  <span class="math">R_{\\text{MLE}}[C]</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, we upper-bound the success probability of  <span class="math">\\tilde{P}</span> . Wlog we assume that  <span class="math">\\pi_y</span>  is  <span class="math">\\delta</span> -close to C (as otherwise  <span class="math">\\tilde{P}</span>  immediately aborts). Let y' be the decoding<sup>19</sup> of  $\\pi_y = (y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{y})<span class="math"> . Therefore,  </span>\\pi_y<span class="math">  is  </span>\\delta<span class="math"> -close to C(y&#x27;), which implies that y is  </span>\\delta'<span class="math"> -close to y&#x27;. On the other hand, y is  </span>\\delta'<span class="math"> -far from the set  </span>\\{y^<em>: (i, x, y^</em>) \\in \\mathcal{L}(\\mathcal{R})\\}<span class="math"> , thus  </span>(i, x, y') \\notin \\mathcal{L}(\\mathcal{R})<span class="math"> . By the soundness of the MLIOP, the success probability of  </span>\\tilde{P}<span class="math">  is at most  </span>\\epsilon_1$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In sum, the success probability of  <span class="math">\\mathcal{P}_{\\text{iop}}^*</span>  is at most  <span class="math">\\epsilon_1 + \\epsilon_2(\\delta) + \\epsilon_3</span> , which finishes the proof.  <span class="math">\\square</span></p>

    <p class="text-gray-300">Combining Proposition 4.4 and Remark 4.3, we get the following proposition.</p>

    <p class="text-gray-300"><strong>Proposition 4.5.</strong> Let  <span class="math">\\lambda \\in \\mathbb{N}</span>  be the security parameter. Let  <span class="math">\\Pi = (I, P, V)</span>  be an MLIOP protocol for a relation  <span class="math">\\mathcal{R}</span>  with parameters</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathbb{F}, q_{\\mathsf{inp}}, q_{idx}, q_{\\mathsf{pf}}, \\mathsf{rnd}, cc_{\\mathsf{oracle}}, cc, \\epsilon, T_P, T_V, n_{\\mathsf{oracle}})</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> 2^{\\lambda}<span class="math">  and  </span>n_{\\mathsf{oracle}}<span class="math">  is the total number of oracles sent by the prover with the largest oracle being an  </span>\\ell<span class="math"> -variate multilinear polynomial. Wlog we assume that there is only one index oracle. Set  </span>Q := q_{\\mathsf{inp}} + q_{\\mathsf{idx}} + q_{\\mathsf{pf}}<span class="math">  as total number of evaluation queries. Let C be a systematic code with message length  </span>2^{\\ell}<span class="math"> , blocklength n, and encoding complexity  </span>T_C<span class="math"> . Let  </span>\\Sigma_C := (P_{\\mathsf{mle}}, V_{\\mathsf{mle}})<span class="math">  be an IOPP for  </span>R_{\\mathsf{MLE}}[C]$  with parameters</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">(q_{\\mathsf{inp}}&#x27;, q_{\\mathsf{pf}}&#x27;, \\mathsf{rnd}&#x27;, cc_{\\mathsf{oracle}}&#x27;, cc&#x27;, \\epsilon&#x27;, T_P&#x27;, T_V&#x27;) \\,.</span></div>

    <p class="text-gray-300">There is an IOPP  <span class="math">\\Pi_{\\mathsf{IOPP}}^{\\mathcal{R}}[\\Sigma_C]</span>  for relation  <span class="math">\\mathcal{R}</span>  with alphabet  <span class="math">\\mathbb{F}</span>  and following complexity parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{array}{lll} \\textit{input and index query complexity} & q'_{\\mathsf{inp}}, \\\\ \\textit{proof query complexity} & n_{\\mathsf{oracle}} \\cdot q'_{\\mathsf{inp}} + q'_{\\mathsf{pf}}, \\\\ \\textit{rounds} & \\mathsf{rnd} + \\mathsf{rnd}' + \\ell + \\log_2(Q) + O(1), \\\\ \\textit{oracle proof communication} & n_{\\mathsf{oracle}} \\cdot n + cc'_{\\mathsf{oracle}}, \\\\ \\textit{non-oracle proof communication} & cc + cc' + O(\\ell + \\log Q), \\\\ \\textit{soundness error} & \\epsilon + \\epsilon' + \\frac{2\\ell + 3\\log_2(Q)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}, \\\\ \\textit{prover time} & T_P + n_{\\mathsf{oracle}} \\cdot T_C + T'_P + O(Q \\cdot 2^\\ell), \\\\ \\textit{verifier time} & T_V + T'_V + O(Q\\ell)). \\end{array}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-24-0"></span><sup>&</sup>lt;sup>19</sup>Note that y' is fixed because  <span class="math">\\mathcal{P}_{\\mathsf{iop}}^*</span>  is deterministic and  <span class="math">\\tilde{y}</span>  is sent before receiving any challenges.</p>

    <p class="text-gray-300">Using the IOPP for RMLE[RS] from <a href="#page-21-2">Theorem 4.1,</a> and setting C as the Reed-Solomon code, the compiler described above establishes <a href="#page-21-3">Lemma 4.2.</a></p>

    <p class="text-gray-300">Remark 4.6. While the IOPP in <a href="#page-21-2">Theorem 4.1</a> has a linear-time prover, the prover complexity in <a href="#page-21-3">Lemma 4.2</a> has a term noracle · n log n. This is because the IOPP prover for R needs to compute the RS encoding of the polynomials provided by the MLIOP prover, which requires quasilinear time.</p>

    <p class="text-gray-300">Recall that the RAA code is parameterized by a repetition parameter r ∈ N and two permutations π1, π<sup>2</sup> : [n] → [n] (see <a href="#page-16-0">Section 3</a> for details). We view the repetition parameter as fixed, but the permutations are thought of as "indexing" the code, as described in <a href="#page-20-0">Section 4.</a> For convenience, throughout this section we sometimes omit the parameterization and simply refer to the code as RAA.</p>

    <p class="text-gray-300">Packed RAA Codes. In this section we will consider a simple extension of the RAA code over a larger alphabet F which is a binary extension field (i.e., a field of characteristic 2), which we call packed RAA. There are different ways to view this extension:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1. We consider a list of log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) RAA codewords over the base field GF(2) and view these as a single codeword over F, where the i-th symbol is constructed by taking the i-th bits of the RAA codewords, viewing them as a log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)-dimensional bit vector, and interpreting the latter as an elemenf in F in the natural way.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>2. If we consider the encoding process of the RAA code, an equivalent view to the above is that given a message in F <sup>k</sup> we repeat each field element, and then permute and accumulate twice, where the accumulation is using field's addition operation (which can be viewed as a bitwise XOR) and the permutation is also at level of field elements (i.e., we still use two permutations π1, π<sup>2</sup> : [n] → [n]).</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that the packed RAA code has the same minimal distance as the standard RAA code, and that it is a linear code over F. We further remark that the packed RAA code is entirely analogous to interleaving, except that here we use a fixed interleaving parameter which is log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) and we view the interleaved symbols as elements of our field F in the natural way. We use PRAA to denote the packed RAA code.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">MLIOP for PRAA. The goal of this section is to construct an efficient MLIOP for the relation RMLE[PRAA]. As discussed in <a href="#page-20-0">Section 4,</a> such an MLIOP can then be converted into an IOP which can be further compiled into a multilinear commitment scheme although this will not be the path that we follow - rather in the subsequent sections we will consider an interleaving of the PRAA code, for better efficiency.</p>

    <p class="text-gray-300">We proceed to present the MLIOP for PRAA. Recall that in such an MLIOP, the explicit input is a point z ∈ F <sup>m</sup> and a scalar v ∈ F. The implicit input is a string y ∈ F n , and the verifier has access to the multilinear extension ˆy of y. The goal is to check whether there exists m ∈ F k such that <sup>y</sup> <sup>=</sup> PRAA(m) such that <sup>m</sup><sup>b</sup> (z) = <sup>v</sup>. In addition, the verifier is gives access to the multilinear extension of the index – namely, to a description of the two permutations  <span class="math">\\pi_1, \\pi_2</span> .<sup>20</sup> The MLIOP that we construct is captured by the following lemma.</p>

    <p class="text-gray-300"><span id="page-26-2"></span><strong>Lemma 5.1.</strong> The relation  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{PRAA}]</span>  has an MLIOP with the following parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{array}{ll} \\textit{input, index and proof query complexity} & O(1), \\\\ \\textit{rounds} & \\log_2(n) + O(1), \\\\ \\textit{soundness error} & \\frac{n+13\\log(n)+7}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}, \\\\ \\textit{prover time} & O(n), \\\\ \\textit{verifier time} & O(\\log n). \\end{array}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The communication consists of 2 multilinear oracles each on  <span class="math">\\log_2(n) + O(1)</span>  variables and an additional O(m) field elements.</p>

    <p class="text-gray-300">The focus of this section is proving Lemma 5.1. In a nutshell, this will be done by decomposing the RAA computation into the distinct accumulation and permutation steps and handling each of these separately.</p>

    <p class="text-gray-300"><strong>Notation.</strong> Throughout this section we identify a vector  <span class="math">x \\in \\mathbb{F}^n</span>  with a function  <span class="math">x : \\{0,1\\}^m \\to \\mathbb{F}</span> , where  <span class="math">m = \\log_2(n)</span> , in the natural way (i.e., the vector is viewed as the truth table of the function). Likewise, we will identify a function  <span class="math">M : \\{0,1\\}^m \\times \\{0,1\\}^m \\to \\mathbb{F}</span>  with the  <span class="math">n \\times n</span>  dimensional matrix  <span class="math">M_{i,j} = M(i,j)</span> . Thus, for  <span class="math">x : \\{0,1\\}^m \\to \\mathbb{F}</span>  and  <span class="math">M : \\{0,1\\}^m \\times \\{0,1\\}^m \\to \\mathbb{F}</span> , the vector Mx can be viewed as the function  <span class="math">Mx : \\{0,1\\}^m \\to \\mathbb{F}</span>  defined as  <span class="math">Mx(i) = \\sum_{j \\in \\{0,1\\}^m} M(i,j) \\cdot x(i)</span> , for every  <span class="math">i \\in \\{0,1\\}^m</span> , and  <span class="math">\\widehat{Mx} : \\mathbb{F}^m \\to \\mathbb{F}</span>  denotes the multilinear extension of this function.</p>

    <p class="text-gray-300"><strong>Section Organization.</strong> In Section 5.1 we show how to reduce checking "simple" linear relations between multilinear polynomials to sumcheck, and show that the accumulation step is indeed simple in the above sense. In Section 5.2 we show how to handle permutations. Finally, we combine these steps and prove Lemma 5.1 in Section 5.3.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">5.1 Checking Simple Linear Operations</h4>

    <p class="text-gray-300">The next proposition shows that, given oracle access to the multilinear polynomials  <span class="math">\\widehat{x}, \\widehat{y} : \\mathbb{F}^m \\to \\mathbb{F}</span>  and  <span class="math">\\widehat{M} : \\mathbb{F}^m \\times \\mathbb{F}^m \\to \\mathbb{F}</span>  it is possible to reduce checking that y = Mx to an instance of sumcheck. Here M should be thought of as a simple function whose low degree extension can be efficiently computed by anyone, whereas  <span class="math">\\widehat{x}</span>  and  <span class="math">\\widehat{y}</span>  are the (implicit) input.</p>

    <p class="text-gray-300"><span id="page-26-3"></span><strong>Proposition 5.2.</strong> Let  <span class="math">M: \\{0,1\\}^m \\times \\{0,1\\}^m \\to \\mathbb{F}</span>  and  <span class="math">x,y: \\{0,1\\}^m \\to \\mathbb{F}</span> , and let  <span class="math">\\widehat{M}, \\widehat{x}, \\widehat{y}</span>  be their corresponding multilinear extensions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If y = Mx then for every  <span class="math">r \\in \\mathbb{F}^m</span>  it holds that  <span class="math">\\widehat{y}(r) = \\sum_{j \\in \\{0,1\\}^m} x(j) \\cdot \\widehat{M}(r,j)</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If  <span class="math">y \\neq Mx</span>  then, with probability  $1 \\frac{m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  over  </span>r \\in \\mathbb{F}^m<span class="math"> , it holds that  </span>\\widehat{y}(r) \\neq \\sum_{j \\in \\{0,1\\}^m} x(j) \\cdot \\widehat{M}(r,j)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-26-1"></span><sup>&</sup>lt;sup>20</sup>Formally, the verifier is given oracle access to the multilinear extension of the concatenation of  <span class="math">\\pi_1</span>  and  <span class="math">\\pi_2</span> . This is merely a technicality and in particular access to the above can be used to emulate access to the individual multilinear extensions.</p>

    <p class="text-gray-300"><span id="page-27-1"></span>Before proving Proposition 5.2, we note that it can be directly used to reduce checking whether y = Mx to a sumcheck instance, by having the verifier select at random  <span class="math">r \\in \\mathbb{F}</span> , reading  <span class="math">\\widehat{y}(r)</span>  and checking, via sumcheck, that it is equal to  <span class="math">\\sum_{j} \\widehat{x}(j) \\cdot \\widehat{M}(r,j)</span>  (the sumcheck involves a single query to  <span class="math">\\widehat{x}</span>  and to  <span class="math">\\widehat{M}</span> ).</p>

    <p class="text-gray-300">Proof of Proposition 5.2. For the first item, if Mx = y then, simply by definition of matrix-vector multiplication, for  <span class="math">r \\in \\{0,1\\}^m</span>  it clearly holds that  <span class="math">\\widehat{y}(r) = \\sum_{j \\in \\{0,1\\}^m} x(j) \\cdot \\widehat{M}(r,j)</span> . However, as both sides of the equation are multilinear polynomials (in r), this means that the equation holds for all  <span class="math">r \\in \\mathbb{F}^m</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the second item, if  <span class="math">y \\neq Mx</span>  then the two sides of the equation are distinct multilinear polynomials in r, and so, by the Schwartz-Zippel Lemma, they can agree on at most an  $m/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  fraction of the domain.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Accumulations are Simple.</strong> The following proposition shows that the accumulation operation, which is central in the RAA construction, is compatible with Proposition 5.2.</p>

    <p class="text-gray-300"><span id="page-27-0"></span><strong>Proposition 5.3</strong> (Efficient Computation of MLE of Accumulation). Let  <span class="math">A: \\{0,1\\}^m \\times \\{0,1\\}^m \\to \\{0,1\\}</span>  be such that A(i,j)=1 if and only if  <span class="math">i \\geq j</span> , where the inequality interprets i and j as integers (in  <span class="math">\\{0,\\ldots,2^m-1\\}</span> ) in the natural way. Then,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Given  <span class="math">r \\in \\mathbb{F}^m</span> , the vector  <span class="math">(\\widehat{A}(r,b))_{b \\in \\{0,1\\}^m}</span>  can be generated in time  <span class="math">O(2^m)</span> .</li>

      <li>2. The polynomial  <span class="math">\\widehat{A}: \\mathbb{F}^m \\times \\mathbb{F}^m \\to \\mathbb{F}</span>  can be evaluated (on a single point) using O(m) arithmetic operations over  <span class="math">\\mathbb{F}</span> .</li>

    </ul>

    <p class="text-gray-300"><em>Proof.</em> For the first item, note that by definition of the multilinear extension, it holds that  <span class="math">\\widehat{A}(r,b) = \\sum_{x \\in \\{0,1\\}^m} eq(x,r) \\cdot A(x,b) = \\sum_{x \\geq b} eq(x,r)</span> . Using Proposition 2.1 we can generate all values eq(x,r) and aggregate them in the correct order.</p>

    <p class="text-gray-300">For the second item, observe that, up to reordering of the input bits, A(i,j) can be computed by a width 3 read-once branching program. Thus, by [HR18, Theorem 5.2], the multi-linear extension  <span class="math">\\widehat{A}</span>  can be computed using O(m) arithmetic operations. For sake of self-containment, we also provide an explicit multilinear formula for computing A(i,j), as follows.</p>

    <p class="text-gray-300">For every m > 0, letting  <span class="math">(i_1, i_2), (j_1, j_2) \\in \\{0, 1\\} \\times \\{0, 1\\}^{m-1}</span>  be such that  <span class="math">i = (i_1, i_2)</span>  and  <span class="math">j = (j_1, j_2)</span>  (i.e.,  <span class="math">i_1</span>  and  <span class="math">j_1</span>  are MSBs, respectively of i and j). Then, we can express  <span class="math">A_m</span>  recursively as</p>

    <div class="my-4 text-center"><span class="math-block">A_m(i,j) = ((i_1 = 1) \\land (j_1 = 0)) \\lor ((i_1 = j_1) \\land A_{m-1}(i_2, j_2)),</span></div>

    <p class="text-gray-300">where  <span class="math">A_m</span>  denotes the accumulation function for inputs of size m (and  <span class="math">A_0 \\equiv 1</span> ). The foregoing equation can be easily used to express  <span class="math">\\widehat{A}_m</span>  as the following multilinear polynomial:</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat{A}_m(i,j) = i_1 \\cdot (j_1 - 1) + (i_1 \\cdot j_1 + (1 - i_1) \\cdot (1 - j_1)) \\cdot \\widehat{A}_{m-1}(i_2, j_2),</span></div>

    <p class="text-gray-300">which can be computed recursively for  <span class="math">i, j \\in \\mathbb{F}^m</span> , using exactly m multiplications and O(m) additions over the field.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">5.2 Checking Permutations</h4>

    <p class="text-gray-300">We use a method for checking permutations from [CBBZ23, Section 3.5] (which relies on a grand product argument from [SL20, Section 5]). The argument goes through several steps (permutation  <span class="math">\\rightarrow</span>  grand product  <span class="math">\\rightarrow</span>  zero-check  <span class="math">\\rightarrow</span>  sum-check), for sake of convenience for our eventual protocol we simply combine all of these steps and describe the eventual reduction to sumcheck claims in the following proposition:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-28-2"></span><strong>Proposition 5.4</strong> ( [CBBZ23, Section 3.5]). Assume that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2^m<span class="math"> . Let  </span>\\pi : \\{0,1\\}^m \\to \\{0,1\\}^m<span class="math">  be a permutation. We view  </span>\\pi<span class="math">  also as a function  </span>\\pi : \\{0,1\\}^m \\to \\mathbb{F}<span class="math">  by associate the range of  </span>\\pi<span class="math">  with some subset of  </span>2^m<span class="math">  elements in  </span>\\mathbb{F}<span class="math"> . We use  </span>\\widehat{\\pi} : \\mathbb{F}^m \\to \\mathbb{F}$  to denote the multilinear extension in the latter view.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let  <span class="math">x, y: \\{0,1\\}^m \\to \\mathbb{F}</span> , and let  <span class="math">\\widehat{x}, \\widehat{y}: \\mathbb{F}^m \\to \\mathbb{F}</span>  be their corresponding multilinear extensions. Then:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. If  <span class="math">y(b) = x(\\pi(b))</span>  for every  <span class="math">b \\in \\{0,1\\}^m</span> , then for every  <span class="math">\\alpha, \\beta \\in \\mathbb{F}</span>  there exist multilinear polynomials  <span class="math">f, g : \\mathbb{F}^{m+1} \\to \\mathbb{F}</span>  such that for every  <span class="math">r \\in \\mathbb{F}^m</span> :</li>

      <li><span class="math">f(1^m, 0) = g(1^m, 0)</span> .</li>

      <li><span class="math">f(0,r) = \\alpha (\\widehat{x}(r) + \\beta \\cdot \\pi(r)).</span></li>

      <li><span class="math">g(0,r) = \\alpha (\\widehat{y}(r) + \\beta \\cdot r)</span> .</li>

      <li><span class="math">0 = \\sum_{x \\in \\{0,1\\}^m} eq(x,r) \\cdot (f(1,x) f(x,0) \\cdot f(x,1)).</span></li>

      <li><span class="math">0 = \\sum_{x \\in \\{0,1\\}^m} eq(x,r) \\cdot (g(1,x) g(x,0) \\cdot g(x,1)).</span></li>

    </ul>

    <p class="text-gray-300">Moreover, given  <span class="math">(x, y, \\alpha, \\beta)</span> , the polynomials f and g can be found in time  <span class="math">O(2^m)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2. If  <span class="math">y(b) \\neq x(\\pi(b))</span>  for some  <span class="math">b \\in \\{0,1\\}^m</span> , then with all but probability  $\\frac{2^m+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  over  </span>\\alpha, \\beta \\in \\mathbb{F}<span class="math"> , for every multilinear polynomials  </span>f, g : \\mathbb{F}^{m+1} \\to \\mathbb{F}<span class="math">  it holds that for all but  </span>\\frac{10m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  fraction of  </span>r \\in \\mathbb{F}^m$  at least one of the following is false.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f(1^m, 0) = g(1^m, 0)</span> .</li>

      <li><span class="math">f(0,r) = \\alpha (\\widehat{x}(r) + \\beta \\cdot \\pi(r)).</span></li>

      <li><span class="math">g(0,r) = \\alpha (\\widehat{y}(r) + \\beta \\cdot r)</span> .</li>

      <li><span class="math">0 = \\sum_{x \\in \\{0,1\\}^m} eq(x,r) \\cdot (f(1,x) f(x,0) \\cdot f(x,1)).</span></li>

      <li><span class="math">0 = \\sum_{x \\in \\{0,1\\}^m} eq(x,r) \\cdot (g(1,x) g(x,0) \\cdot g(x,1)).</span></li>

    </ul>

    <p class="text-gray-300">Let  <span class="math">\\pi_1, \\pi_2 : [n] \\to [n]</span>  be permutations and  <span class="math">r \\in \\mathbb{N}</span>  be a repetition parameter for the RAA code. Observe that the packed RAA code PRAA with these parameters can be viewed as the linear operator  <span class="math">\\mathsf{RAA}(m) = A \\cdot M_{\\pi_2} \\cdot A \\cdot M_{\\pi_1} \\cdot F_r \\cdot m</span> , where A denotes the accumulation matrix,  <span class="math">M_{\\pi}</span>  denotes the permutation matrix associated with  <span class="math">\\pi</span> , and  <span class="math">F_r</span>  is the "repetition operator" (observe that all operations are over the field  <span class="math">\\mathbb{F}</span> ).</p>

    <p class="text-gray-300">Using the results from the previous subsections, we proceed to construct an MLIOP for  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{PRAA}]</span> , thereby proving Lemma 5.1.</p>

    <p class="text-gray-300">An MLIOP for  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{PRAA}]</span> . Recall that the explicit input for the verifier is a point  <span class="math">z \\in \\mathbb{F}^{\\log(k)}</span>  and value  <span class="math">v \\in \\mathbb{F}</span>  and the implicit input is an alleged codeword  <span class="math">y \\in \\mathbb{F}^n</span>  of PRAA. Recall that the verifier in an MLIOP has access to the multilinear extension of y. In addition, the verifier has access to the multilinear extensions  <span class="math">\\hat{\\pi}_1, \\hat{\\pi}_2 : \\mathbb{F}^m \\to \\mathbb{F}</span>  of the permutations describing the RAA code. The claim is that there exists  <span class="math">m \\in \\mathbb{F}^k</span>  such that  <span class="math">y = \\mathsf{PRAA}(m)</span>  and  <span class="math">\\hat{m}(z) = v</span> . The prover is given as input  <span class="math">m, \\pi_1, \\pi_2, \\mathsf{PRAA}(m), z</span>  and v.</p>

    <p class="text-gray-300">For a message  <span class="math">m \\in \\mathbb{F}^k</span>  we denote the results of the main intermediate steps of the PRAA encoding as follows:</p>

    <div class="my-4 text-center"><span class="math-block">u_1 = F_r \\cdot m</span></div>

    <p class="text-gray-300"> <span class="math">u_2 = M_{\\pi_1} \\cdot u_1</span>  <span class="math">u_3 = A \\cdot u_2</span>  <span class="math">u_4 = M_{\\pi_2} \\cdot u_3</span>  <span class="math">u_5 = A \\cdot u_4</span> .</p>

    <p class="text-gray-300">Note that in a correct computation it holds that  <span class="math">u_5 = y</span> . The MLIOP for  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{PRAA}]</span>  proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-29-1"></span>1. The prover sends to the verifier (as oracles) the multilinear polynomials  <span class="math">\\widehat{m}: \\mathbb{F}^{\\log(k)} \\to \\mathbb{F}</span>  and  <span class="math">\\widehat{u}_2, \\widehat{u}_3, \\widehat{u}_4: \\mathbb{F}^{\\log(n)} \\to \\mathbb{F}</span> . We use  <span class="math">\\widehat{u}_1: \\mathbb{F}^{\\log(n)} \\to \\mathbb{F}</span>  to denote the multilinear function  <span class="math">\\widehat{u}_1(x,\\cdot) = \\widehat{m}(x)</span>  (and notice that the verifier can emulate each query to  <span class="math">\\widehat{u}_1</span>  via a single query to  <span class="math">\\widehat{m}</span> ). We also use  <span class="math">\\widehat{u}_5</span>  to denote  <span class="math">\\widehat{y}</span>  and observe that the verifier has query access to  <span class="math">\\widehat{u}_5</span>  since in the MLIOP model it has access to  <span class="math">\\widehat{y}</span> .</li>

      <li><span id="page-29-2"></span>2. The verifier checks that  <span class="math">\\widehat{m}(z) = v</span> .</li>

      <li><span id="page-29-3"></span>3. The verifier chooses at random  <span class="math">\\alpha, \\beta \\in \\mathbb{F}</span>  and sends them to the prover.</li>

      <li><span id="page-29-4"></span>4. Using Proposition 5.4, wrt the claims  <span class="math">(u_2 = M_{\\pi_1} \\cdot u_1)</span>  and wrt  <span class="math">(u_4 = M_{\\pi_2} \\cdot u_3)</span> , the prover finds the corresponding pairs  <span class="math">(f_1, g_1)</span>  and  <span class="math">(f_2, g_2)</span> . The prover sends these 4 oracles to the verifier.</li>

      <li><span id="page-29-7"></span>5. The verifier checks that  <span class="math">f_1(1^{\\log(n)}, 0) = g_1(1^{\\log(n)}, 0)</span>  and  <span class="math">f_2(1^{\\log(n)}, 0) = g_2(1^{\\log(n)}, 0)</span> .</li>

      <li><span id="page-29-5"></span>6. The verifier samples at random  <span class="math">r \\in \\mathbb{F}^{\\log(n)}</span>  and checks the following equations (arising from Proposition 5.4) hold:</li>

      <li>(a)  <span class="math">f_1(0,r) = \\alpha (\\widehat{u_1}(r) + \\beta \\cdot \\pi_1(r)).</span></li>

      <li>(b)  <span class="math">g_1(0,r) = \\alpha (\\widehat{u_2}(r) + \\beta \\cdot r).</span></li>

      <li>(c)  <span class="math">f_2(0,r) = \\alpha (\\widehat{u_3}(r) + \\beta \\cdot \\pi_2(r)).</span></li>

      <li>(d)  <span class="math">g_2(0,r) = \\alpha (\\widehat{u_4}(r) + \\beta \\cdot r).</span></li>

    </ul>

    <p class="text-gray-300">The verifier also sends r to the prover.</p>

    <p class="text-gray-300"><span id="page-29-6"></span>7. The prover and verifier engage in a batch sumcheck (see Remark 2.3) protocol to check that the following sums all hold:</p>

    <p class="text-gray-300"><span id="page-29-0"></span>(a) <span class="math-block">\\widehat{u_3}(r) = \\sum_{j \\in \\{0,1\\}^{\\log(n)}} \\widehat{u_2}(j) \\cdot \\widehat{A}(r,j)</span> .</p>

    <p class="text-gray-300"><span id="page-30-0"></span>(b) <span class="math-block">\\widehat{u_5}(r) = \\sum_{j \\in \\{0,1\\}^{\\log(n)}} \\widehat{u_4}(j) \\cdot \\widehat{A}(r,j).</span></p>

    <p class="text-gray-300"><span id="page-30-1"></span>(c) <span class="math-block">0 = \\sum_{x \\in \\{0,1\\}^{\\log(n)}} eq(x,r) \\cdot (f_1(1,x) - f_1(x,0) \\cdot f_1(x,1)).</span></p>

    <p class="text-gray-300">(d) <span class="math-block">0 = \\sum_{x \\in \\{0,1\\}^{\\log(n)}} eq(x,r) \\cdot (g_1(1,x) - g_1(x,0) \\cdot g_1(x,1)).</span></p>

    <p class="text-gray-300">(e) <span class="math-block">0 = \\sum_{x \\in \\{0,1\\}^{\\log(n)}} eq(x,r) \\cdot (f_2(1,x) - f_2(x,0)) \\cdot f_2(x,1)</span></p>

    <p class="text-gray-300"><span id="page-30-2"></span>(f) <span class="math-block">0 = \\sum_{x \\in \\{0,1\\}^{\\log(n)}} eq(x,r) \\cdot (g_2(1,x) - g_2(x,0) \\cdot g_2(x,1)).</span></p>

    <p class="text-gray-300">(Checks 7a and 7b arise from the accumulation test of Proposition 5.3 and 7c-7f arise from the permutation test of Proposition 5.4)</p>

    <p class="text-gray-300">To run the sumcheck, the prover first generates the vector  <span class="math">(A(r,b))_{b\\in\\{0,1\\}^k}</span>  using Proposition 5.3. At the conclusion of the batch sumcheck, the verifier needs to make a single query to  <span class="math">\\widehat{A}</span>  (which can be computed using Proposition 5.3), one query to each of  <span class="math">\\widehat{u_2}, \\widehat{u_3}, \\widehat{u_4}, \\widehat{u_5}</span>  and two queries each to  <span class="math">f_1, g_1, f_2, g_2</span> .</p>

    <p class="text-gray-300"><strong>Completeness.</strong> Let  <span class="math">z \\in \\mathbb{F}^{\\log(k)}</span> ,  <span class="math">v \\in \\mathbb{F}</span>  and  <span class="math">c = \\mathsf{PRAA}(m)</span> , such that  <span class="math">\\widehat{m}(z) = v</span> . Let  <span class="math">\\widehat{m}, \\widehat{u_1}, \\dots, \\widehat{u_5}</span>  be the messages sent by the prover as in Step 1. Note that  <span class="math">\\widehat{m}(z) = v</span>  and so the verifier does not reject in Step 2.</p>

    <p class="text-gray-300">Fix a choice of  <span class="math">\\alpha, \\beta \\in \\mathbb{F}</span>  for the verifier in Step 3 and the prover's responses in Step 4 (according to Proposition 5.4) by  <span class="math">(f_1, g_1)</span>  and  <span class="math">(f_2, g_2)</span> . Since  <span class="math">u_2(\\cdot) = u_1(\\pi_1(\\cdot))</span>  and  <span class="math">u_4(\\cdot) = u_3(\\pi_3(\\cdot))</span> , for the value  <span class="math">r \\in \\mathbb{F}^k</span>  sampled in Step 6 it holds that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f_1(1^{\\log(n)}, 0) = g_1(1^{\\log(n)}, 0).</span></li>

      <li><span class="math">f_1(0,r) = \\alpha (\\widehat{u_2}(r) + \\beta \\cdot \\pi_1(r)).</span></li>

      <li><span class="math">g_1(0,r) = \\alpha (\\widehat{u_1}(r) + \\beta \\cdot r).</span></li>

      <li><span class="math">0 = \\sum_{x \\in \\{0,1\\}^{\\log(n)}} eq(x,r) \\cdot (f_1(1,x) f_1(x,0) \\cdot f_1(x,1)).</span></li>

      <li><span class="math">0 = \\sum_{x \\in \\{0,1\\}^{\\log(n)}} eq(x,r) \\cdot (g_1(1,x) g_1(x,0) \\cdot g_1(x,1)).</span></li>

      <li><span class="math">f_2(1^{\\log(n)}, 0) = g_2(1^{\\log(n)}, 0).</span></li>

      <li><span class="math">f_2(0,r) = \\alpha (\\widehat{u_3}(r) + \\beta \\cdot \\pi_2(r)).</span></li>

      <li><span class="math">g_2(0,r) = \\alpha (\\widehat{u_4}(r) + \\beta \\cdot r).</span></li>

      <li><span class="math">0 = \\sum_{x \\in \\{0,1\\}^{\\log(n)}} eq(x,r) \\cdot (f_2(1,x) f_2(x,0) \\cdot f_2(x,1)).</span></li>

      <li><span class="math">0 = \\sum_{x \\in \\{0,1\\}^{\\log(n)}} eq(x,r) \\cdot (g_2(1,x) g_2(x,0) \\cdot g_2(x,1)).</span></li>

    </ul>

    <p class="text-gray-300">and so the tests in Step 6 pass and the bottom four sumcheck claims in Step 7 also pass. Since  <span class="math">u_3 = A \\cdot u_2</span>  and  <span class="math">u_5 = A \\cdot u_4</span> , by Proposition 5.2, it holds that:</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat{u_3}(r) = \\sum_{j \\in \\{0,1\\}^{\\log(n)}} \\widehat{u_2}(j) \\cdot \\widehat{A}(r,j), \\text{ and}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widehat{u_5}(r) = \\sum_{j \\in \\{0,1\\}^{\\log(n)}} \\widehat{u_4}(j) \\cdot \\widehat{A}(r,j).</span></div>

    <p class="text-gray-300">Thus, the top two sumcheck claims are also true. From the completeness of the (batched) sumcheck, we get that the verifier always accepts.</p>

    <p class="text-gray-300"><strong>Soundness.</strong> Let  <span class="math">z \\in \\mathbb{F}^{\\log(k)}</span>  and  <span class="math">v \\in \\mathbb{F}</span> . Let  <span class="math">y \\notin \\{\\mathsf{PRAA}(m) : \\widehat{m}(z) = v\\}</span> . Fix a (wlog determinstic) cheating prover strategy. As in the protocol, denote the multilinear oracles<sup>21</sup> that the prover sends in its first message by  <span class="math">\\widehat{m} : \\mathbb{F}^{\\log(k)} \\to \\mathbb{F}</span>  and  <span class="math">\\widehat{u}_2, \\widehat{u}_3, \\widehat{u}_4 : \\mathbb{F}^{\\log(n)} \\to \\mathbb{F}</span> . Also, similarly to the protocol, use  <span class="math">\\widehat{u}_1 : \\mathbb{F}^{\\log(n)} \\to \\mathbb{F}</span>  to denote  <span class="math">\\widehat{u}_1(x, \\cdot) = \\widehat{m}(x)</span>  and  <span class="math">\\widehat{u}_5 \\equiv \\widehat{y}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-31-1"></span><strong>Proposition 5.5.</strong> If  <span class="math">u_5 \\neq \\mathsf{PRAA}_{\\pi_1,\\pi_2}(m)</span>  then the verifier rejects with probability at least  $1 - \\frac{n+13\\log(n)+7}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>Proof.</em> The proof proceeds by a somewhat tedious case analysis, that the individual components in the RAA computation were computed correctly:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case 1: Suppose  <span class="math">u_2 \\neq M_{\\pi_1}u_1</span> . After the verifier sends  <span class="math">\\alpha, \\beta</span> , the prover responds with  <span class="math">f_1, g_1</span> . By Proposition 5.4 with probability at least  $1 - \\frac{n+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  over  </span>\\alpha, \\beta<span class="math">  it holds that for the  </span>f_1, g_1<span class="math">  that the prover selected, with probability at least  </span>1 - \\frac{10 \\log(n)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  over  </span>r \\in \\mathbb{F}^{\\log(n)}$ , one of the following is false then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1.  <span class="math">f_1(1^{\\log(n)}, 0) = g_1(1^{\\log(n)}, 0)</span> . In this case the verifier rejects in Step 5.</li>

      <li>2.  <span class="math">f_1(0,r) = \\alpha (\\widehat{u_1}(r) + \\beta \\cdot \\pi_1(r))</span> . In this case the verifier rejects in Step 6.</li>

      <li>3.  <span class="math">g_1(0,r) = \\alpha (\\widehat{u_2}(r) + \\beta \\cdot r)</span> . Similar to the previous case.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 4.  <span class="math">0 = \\sum_{x \\in \\{0,1\\}^{\\log(n)}} eq(x,r) \\cdot (f_1(1,x) f_1(x,0) \\cdot f_1(x,1))</span> . In this case, one of the sums in Step 7 is false, and so with probability at least  $1 \\frac{3\\log(n) + 6}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$  (see Remark 2.3) the verifier rejects.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>5.  <span class="math">0 = \\sum_{x \\in \\{0,1\\}^{\\log(n)}} eq(x,r) \\cdot (g_1(1,x) g_1(x,0) \\cdot g_1(x,1))</span> . Similar to the previous case.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case 2: Suppose  <span class="math">u_3 \\neq A \\cdot u_2</span> . Then, by Proposition 5.2 we have that with probability  $1 - \\frac{\\log(n)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  over r it holds that  </span>\\widehat{u_3}(r) \\neq \\sum_{j \\in \\{0,1\\}^{\\log(n)}} \\widehat{u_2}(j) \\cdot \\widehat{A}(r,j)<span class="math"> . In this case, one of the sums in Step 7 is false, and so with probability at least  </span>1 - \\frac{3\\log(n)+6}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$  the verifier rejects.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Case 3: Suppose  <span class="math">u_4 \\neq M_{\\pi_2} \\cdot u_3</span> . This case is analyzed similarly to Case 1.</p>

    <p class="text-gray-300">Case 4: Suppose  <span class="math">u_5 \\neq A \\cdot u_4</span> . This case is analyzed similarly to Case 2.</p>

    <p class="text-gray-300">(Note that the soundness error is the maximum between these different cases rather than the sum.)</p>

    <p class="text-gray-300">Thus, by Proposition 5.5, we may assume that  <span class="math">u_5 = \\mathsf{PRAA}_{\\pi_1,\\pi_2}(m)</span> .</p>

    <p class="text-gray-300">Notice that we may also assume that  <span class="math">\\widehat{m}(z) = v</span>  since otherwise the verifier immediately rejects (in Step 2). Thus,  <span class="math">y \\in \\{\\mathsf{PRAA}(m) : \\widehat{m}(z) = v\\}</span>  in contradiction to our assumption.</p>

    <p class="text-gray-300"><span id="page-31-0"></span> <span class="math">&lt;sup&gt;\\&lt;/sup&gt;overline{^{21}}</span> Recall that in an MLIOP, when instructed to, the prover <em>must</em> send multilinear polynomials of the right size.</p>

    <p class="text-gray-300"><span id="page-32-2"></span>Optimizations. We remark that some aspects of our MLIOP for RMLE[PRAA] can be further optimized:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. In particular, rather than sending u2, u3, u<sup>4</sup> we can take a "GKR-like" approach to gradually reduce claims about them until we get to a claim about the input ˆm.</li>

      <li>In this approach, the verifier starts by sampling a random point from the input ˆu5. Then, as in GKR [\\[GKR15\\]](#page-80-1), in sequence it reduces this claim to a claim about ˆu<sup>4</sup> and then ˆu<sup>3</sup> and so on it until it derives a claim about ˆm which it can check (since ˆm is sent by the prover). We emphasize that in this variant ˆu2, ....uˆ<sup>4</sup> are not sent by the prover, but rather claims about them are derived in a gradual process. We remark that in this approach the f and g polynomials for the permutation argument are still sent.</li>

      <li>2. An orthogonal optimization is to batch the two permutation checks that are done (i.e., to check u<sup>4</sup> and u2). This can be done via "fingerprinting", see <a href="#page-83-5">\\[Tha22,</a> Section 6.6.2].</li>

    </ul>

    <h2 id="sec-28" class="text-2xl font-bold">5.4 Puncturing</h2>

    <p class="text-gray-300">Since we do not end up using it our system, we give only a brief explanation of how puncturing can be additionally handled in the IOPP.</p>

    <p class="text-gray-300">Recall that in the punctured RAA code, the code index additionally contains a description of which are the punctured points. The latter can be described by another permutation π : [n] → [n], where we interpret that the first n ′ < n elements are kept and the rest are discarded.</p>

    <p class="text-gray-300">To check that ˆu is the result of puncturing ˆv, the prover sends the multilinear extension ˆw of the discarded points. We can then recombine ˆv and ˆw into a single multilinear equation and run the permutation check of <a href="#page-28-2">Proposition 5.4</a> to check correctness.</p>

    <p class="text-gray-300">Given a code C : F <sup>k</sup> → F <sup>n</sup> and an integer t ∈ N we define the interleaving of C as the code C t : F <sup>t</sup>×<sup>k</sup> → F <sup>t</sup>×<sup>n</sup> obtained by viewing the input as a t × k dimensional matrix and encoding each row separately using C. It will sometimes be convenient to view this code as operating over the alphabet F t , that is, we view C : (F t ) <sup>k</sup> → (F t ) n .</p>

    <p class="text-gray-300">In this section we show how to "bootstrap" an MLE evaluation protocol for a code C, into a similar MLE protocol for the interleaved code C t . The benefit is that the cost of resulting protocol is a combination of a fixed small cost proportional to the input size O(k ×t) plus an additional cost that is independent of t (and arises from the underlying protocol for C). The cost is a multiplicative in t increase to the verifier's query complexity, or rather, the same query complexity but over a larger alphabet.</p>

    <p class="text-gray-300">Recall the following notation from <a href="#page-20-0">Section 4:</a> if I is an index set, and C = {C<sup>i</sup> : F <sup>k</sup> → F <sup>n</sup>}i∈I is a family of linear codes then</p>

    <div class="my-4 text-center"><span class="math-block">R_{\\mathsf{MLE}}[\\mathcal{C}] := \\left\\{ (i \\in \\mathcal{I}; (z, v) \\in \\mathbb{F}^{\\log k} \\times \\mathbb{F}; y \\in \\mathbb{F}^n; m \\in \\mathbb{F}^k) : \\widehat{m}(z) = v \\text{ and } y = C_i(m) \\right\\},</span></div>

    <p class="text-gray-300">that is, all codewords of C that encode messages whose multilinear extension at the point z is equal to v. We will also use the extension field variant for C t :</p>

    <div class="my-4 text-center"><span class="math-block">R_{\\mathsf{MLE}}[\\mathcal{C}] := \\left\\{ (i \\in \\mathcal{I}; (z, v) \\in \\mathbb{F}^{\\log(tk)} \\times \\mathbb{F}; y \\in \\mathbb{K}^n; m \\in \\mathbb{K}^k) : \\widehat{m}(z) = v \\text{ and } y = C_i(m) \\right\\},</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathbb{K} = \\mathbb{F}^t</span>  is the extension field, and we interpret m simultaneously as  <span class="math">m \\in \\mathbb{K}^k</span>  and  <span class="math">m \\in (\\mathbb{F})^{t \\times k}</span>  in the natural way.</p>

    <p class="text-gray-300"><span id="page-33-2"></span><strong>Lemma 6.1.</strong> Let  <span class="math">C: \\mathbb{F}^k \\to \\mathbb{F}^n</span>  be a linear code with distance  <span class="math">\\lambda</span> . Assume there exists an IOPP for  <span class="math">R_{\\mathsf{MLE}}[\\mathcal{C}]</span>  which, for proximity parameter  <span class="math">\\delta &lt; \\frac{\\lambda}{3}</span> , has the following parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">input and proof alphabet</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathbb{F},</span></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">input query complexity</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">q_{inp}(\\delta,k),</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">index query complexity</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">q_{idx}(\\delta,k),</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">proof query complexity</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">q_{proof}(\\delta,k),</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">rounds</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\ell(k),</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">oracle\\ proof\\ communication</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">cc_{oracle}(k),</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">non-oracle proof communication</td>

            <td class="px-3 py-2 border-b border-gray-700">cc(k),</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">soundness error</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\epsilon(\\delta,k),</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">prover time</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">T_P(\\delta, k)</span> , and</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">verifier time</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">T_V(\\delta,k)</span> .</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then, for every parameter  <span class="math">t = t(k) \\in \\mathbb{N}</span>  there exists an IOPP for the interleaved relation  <span class="math">R_{\\mathsf{MLE}}[\\mathcal{C}^t]</span>  which, for proximity parameter  <span class="math">\\delta</span> , has the following parameters:</p>

    <pre><code class="language-text">\\mathbb{F}^t, q_{inp}(\\delta&#x27;,k),
input alphabet
input query complexity
index and proof alphabet
index query complexity
                                                             q_{idx}(\\delta&#x27;,k),
proof query complexity
                                                            q_{proof}(\\delta&#x27;,k),
                                                                \\ell+1,
rounds
                                                             cc_{\\mathsf{oracle}}(k),
oracle proof communication
                                                            2t + cc(k),
\\epsilon + \\frac{1}{(\\delta - \\delta&#x27;)|\\mathbb{F}|},
non-oracle proof communication
soundness error
                                                      O(tn)+T_P(\\delta&#x27;,k), and
prover time
                                                O(t \\cdot q_{innut}(\\delta&#x27;, k)) + T_V(\\delta&#x27;, k),
verifier time</code></pre>

    <p class="text-gray-300">where  <span class="math">\\delta&#x27; = 0.99\\delta</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Let (P, V) be an IOPP for  <span class="math">R_{\\mathsf{MLE}}[\\mathcal{C}]</span> . We use (P, V) to construct an IOPP for the interleaved relation  <span class="math">R_{\\mathsf{MLE}}[\\mathcal{C}^t]</span>  as follows.</p>

    <p class="text-gray-300">Recall that the verifier is given as explicit input a point  <span class="math">z \\in \\mathbb{F}^{\\log(tk)}</span>  and scalar  <span class="math">v \\in \\mathbb{F}</span>  and let  <span class="math">c = C^t(m) \\in C^t</span>  be the input codeword (to which the verifier has oracle access). We view m and c as matrices, where  <span class="math">m \\in \\mathbb{F}^{t \\times k}</span>  and  <span class="math">c \\in \\mathbb{F}^{t \\times n}</span> . We decompose z into  <span class="math">z_1 \\in \\mathbb{F}^{\\log(t)}</span>  and  <span class="math">z_2 \\in \\mathbb{F}^{\\log(k)}</span>  such that  <span class="math">z = (z_1, z_2)</span> .</p>

    <p class="text-gray-300">We proceed to describe the IOPP for  <span class="math">\\mathcal{L}_{\\mathsf{MLE}}(C^t, z, v)</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-33-0"></span>1. The prover generates a vector  <span class="math">u \\in \\mathbb{F}^t</span> , where for every  <span class="math">i \\in [t]</span> , we set  <span class="math">u_i = \\widehat{m_i}(z_2)</span>  (i.e., the multilinear extension of the <em>i</em>-th row of m, evaluated at the point  <span class="math">z_2</span> ). The prover sends the vector u to the verifier.</li>

      <li><span id="page-33-1"></span>2. The verifier reads u entirely, and, viewing it as a function  <span class="math">u:\\{0,1\\}^{\\log(t)}\\to\\mathbb{F}</span> , checks that  <span class="math">\\widehat{u}(z_1)=v</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-34-2"></span>3. The verifier chooses at random<sup>22</sup>  <span class="math">r \\in \\mathbb{F}^t</span>  and sends r to the prover. Denote by  <span class="math">m_{\\sf combo}</span>  the vector-matrix product  <span class="math">m_{\\sf combo} = r^T \\cdot m</span> . Similarly, let  <span class="math">c_{\\sf combo} = r^T \\cdot c</span> . Note that since C is linear, we have that  <span class="math">c_{\\sf combo} = C(m_{\\sf combo})</span> . The prover computes  <span class="math">c_{\\sf combo}</span> , but does not send it to the verifier.</li>

      <li><span id="page-34-1"></span>4. The prover and verifier engage in the IOPP (P, V) for  <span class="math">R_{\\mathsf{MLE}}[\\mathcal{C}]</span>  relative to the point  <span class="math">z_2 \\in \\mathbb{F}^{\\log(k)}</span>  and value  <span class="math">v&#x27; = \\langle u, r \\rangle</span>  and with implicit access to the input codeword  <span class="math">c_{\\mathsf{combo}}</span> . As the verifier does not have direct oracle access to  <span class="math">c_{\\mathsf{combo}}</span> , it emulates queries to it by reading the corresponding column of c. That is, given a query  <span class="math">j \\in [n]</span> , the verifier emulates the response by computing  <span class="math">\\sum_{i \\in [t]} r_i \\cdot c_{i,j}</span> .</li>

      <li>5. The verifier accepts if and only if all of its tests passed.</li>

    </ul>

    <p class="text-gray-300"><strong>Completeness.</strong> Suppose  <span class="math">((z, v), c) \\in R_{\\mathsf{MLE}}[\\mathcal{C}^t]</span> . Thus, there exists  <span class="math">m \\in \\mathbb{F}^{t \\cdot k}</span>  such that  <span class="math">c = C^t(m)</span>  and  <span class="math">\\widehat{m}(z) = v</span> . As in the protocol, we view m and c as matrices, where  <span class="math">m \\in \\mathbb{F}^{t \\times k}</span>  and  <span class="math">c \\in \\mathbb{F}^{t \\times n}</span> , and decompose z into  <span class="math">(z_1, z_2) \\in \\mathbb{F}^{\\log(t)} \\times \\mathbb{F}^{\\log(k)}</span> . Let  <span class="math">u \\in \\mathbb{F}^t</span>  be the prover's message in Step 1 (recall that  <span class="math">u_i = \\widehat{m_i}(z_2)</span> , for every  <span class="math">i \\in [t]</span> ).</p>

    <p class="text-gray-300">Observe that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\widehat{u}(z_1) &amp;= \\sum_{i \\in \\{0,1\\}^{\\log(t)}} eq(i,z_1) \\cdot u(i) \\\\ &amp;= \\sum_{i \\in \\{0,1\\}^{\\log(t)}} eq(i,z_1) \\cdot \\widehat{m_i}(z_2) \\\\ &amp;= \\sum_{i \\in \\{0,1\\}^{\\log(t)}} eq(i,z_1) \\cdot \\left(\\sum_{j \\in \\{0,1\\}^{\\log(k)}} eq(j,z_2) \\cdot m_{i,j}\\right) \\\\ &amp;= \\sum_{(i,j) \\in \\{0,1\\}^{\\log(t) + \\log(k)}} eq(i,z_1) \\cdot eq(j,z_2) \\cdot m_{i,j} \\\\ &amp;= \\widehat{m}(z_1,z_2) \\\\ &amp;= v. \\end{split}</span></div>

    <p class="text-gray-300">Thus, the verifier's test in Step 2 passes.</p>

    <p class="text-gray-300">Fix  <span class="math">r \\in \\mathbb{F}^t</span> , and let  <span class="math">m_{\\mathsf{combo}} = r^T \\cdot m</span>  and  <span class="math">c_{\\mathsf{combo}} = r^T \\cdot c</span>  as in the protocol, where we observe</p>

    <p class="text-gray-300"><span id="page-34-0"></span> <span class="math">&lt;sup&gt;\\&lt;/sup&gt;overline{}^{22}</span> The vector r can be partially derandomized, see [DP24b, AER24]</p>

    <p class="text-gray-300">that, since C is linear, it holds that  <span class="math">c_{combo} = C(m_{combo})</span> . Note that:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\widehat{m_{\\mathsf{combo}}}(z_2) &amp;= \\sum_{j \\in \\{0,1\\}^{\\log(k)}} eq(j,z_2) \\cdot m_{\\mathsf{combo}}(j) \\\\ &amp;= \\sum_{j \\in \\{0,1\\}^{\\log(k)}} eq(j,z_2) \\cdot \\sum_{i \\in [t]} r_i \\cdot m_{i,j} \\\\ &amp;= \\sum_{i \\in [t]} r_i \\sum_{j \\in \\{0,1\\}^{\\log(k)}} eq(j,z_2) \\cdot m_{i,j} \\\\ &amp;= \\sum_{i \\in [t]} r_i \\cdot \\widehat{m_i}(z_2) \\\\ &amp;= \\langle r, u \\rangle \\end{split}</span></div>

    <p class="text-gray-300">and so the IOPP (P, V) in Step 4 is run on an input  <span class="math">(z_2, v&#x27;, c_{\\mathsf{combo}}) \\in R_{\\mathsf{MLE}}[\\mathcal{C}]</span>  where  <span class="math">v&#x27; = \\langle r, u \\rangle)</span> , and so the verifier always accepts.</p>

    <p class="text-gray-300"><strong>Soundness.</strong> Fix  <span class="math">z = (z_1, z_2) \\in \\mathbb{F}^{\\log(t)} \\times \\mathbb{F}^{\\log(k)}</span>  and  <span class="math">v \\in \\mathbb{F}</span>  and let  <span class="math">c \\in (\\mathbb{F}^t)^n</span>  such that c is  <span class="math">\\delta</span> -far from the affine space  <span class="math">\\mathsf{Aff}_{z,v} = \\{C^t(m) : \\hat{m}(z) = v\\}</span> . Fix a (wlog deterministic) cheating prover strategy  <span class="math">P^*</span>  and denote its first message by  <span class="math">u \\in \\mathbb{F}^t</span> . We assume that  <span class="math">\\hat{u}(z_1) = v</span>  since otherwise the verifier immediately rejects.</p>

    <p class="text-gray-300">From the above, we know that c is  <span class="math">\\delta</span> -far from the affine space  <span class="math">\\mathsf{Aff}_{z,v}</span>  (defined above). It will be convenient to normalize c so that we can measure the distance of its rows from the same corresponding linear (rather than affine) space  <span class="math">(\\mathsf{Lin}_{z_2})^t</span> , where  <span class="math">\\mathsf{Lin}_{z_2} = \\{C(m) : \\hat{m}(z_2) = 0\\}</span> . Here C is over the alphabet  <span class="math">\\mathbb{F}</span>  rather than  <span class="math">\\mathbb{F}^t</span> . This is captured by the following claim.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">Claim 6.1.1.</h4>

    <div class="my-4 text-center"><span class="math-block">\\Delta\\left(c-u\\otimes C(1^k),(\\operatorname{Lin}_{z_2})^t\\right)&gt;\\delta_{z_2}</span></div>

    <p class="text-gray-300">where  <span class="math">1^k</span>  denotes the all ones vector of length k (and  <span class="math">C(1^k)</span>  is its encoding) and  <span class="math">\\otimes</span>  denotes the outer product of the two vectors.</p>

    <p class="text-gray-300">Proof. Suppose toward a contradiction there exists some  <span class="math">c&#x27; \\in (\\operatorname{Lin}_{z_2})^t</span>  such that  <span class="math">\\Delta(c-u \\otimes C(1^k), c&#x27;) \\leq \\delta</span> . Then,  <span class="math">\\Delta(c, c&#x27;&#x27;) \\leq \\delta</span> , where  <span class="math">c&#x27;&#x27; = c&#x27; + u \\otimes C(1^k)</span> . Let  <span class="math">c&#x27;_i</span>  (resp.,  <span class="math">c&#x27;&#x27;_i</span> ) denote the <em>i</em>-th row of c' (resp.,  <span class="math">c&#x27;&#x27;_i</span> ). Then, for every  <span class="math">i \\in [t]</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">c_i&#x27;&#x27; = c_i&#x27; + u_i \\cdot C(1^k).</span></div>

    <p class="text-gray-300">Since  <span class="math">c_i&#x27; \\in C</span>  and  <span class="math">C(1^k) \\in C</span> , by linearity of C, we have that  <span class="math">c_i&#x27;&#x27; \\in C</span> . Letting  <span class="math">m_i&#x27; = C^{-1}(c_i&#x27;)</span> , since  <span class="math">c&#x27; \\in \\operatorname{Lin}_{z_2}</span> , we have that  <span class="math">\\widehat{m_i&#x27;}(z_2) = 0</span> . Since  <span class="math">\\widehat{1^k}(z_2) = 1</span> , we have that  <span class="math">c_i&#x27;&#x27;</span>  is an encoding of the message  <span class="math">m_i&#x27;&#x27; = m_i&#x27; + u_i \\cdot 1^k</span> , whose multilinear evaluation at the point  <span class="math">z_2</span>  is equal to  <span class="math">0 + u_i \\cdot 1 = u_i</span> . Hence, the multilinear evaluation of m'' at the point  <span class="math">(z_1, z_2)</span>  is equal to:</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat{m&#x27;&#x27;}(z_1, z_2) = \\sum_{i \\in \\{0, 1\\}^{\\log(t)}} eq(z_1, i) \\cdot m&#x27;&#x27;(i, z_2) = \\sum_{i \\in \\{0, 1\\}^{\\log(t)}} eq(z_1, i) \\cdot u_i = \\widehat{u}(z_1) = v.</span></div>

    <p class="text-gray-300">Overall we have that c is  <span class="math">\\delta</span> -close to a matrix c'', which is an encoding under  <span class="math">C^t</span>  of a message m'' whose multilinear evaluation at the point  <span class="math">z = (z_1, z_2)</span>  is equal to v. This contradicts our assumption on c.</p>

    <p class="text-gray-300">Given that  <span class="math">c - u \\otimes C(1^k)</span>  is far from the space  <span class="math">(\\text{Lin}_{z_2})^t</span> , Corollary 2.6 implies that a random linear combination of its rows is far from  <span class="math">\\mathcal{L}_{\\mathsf{MLE}}(C, z_2, 0)</span> . In what follows, let  <span class="math">\\delta&#x27; = 0.99\\delta</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Claim 6.1.2. With all but probability  $\\frac{1}{(\\delta - \\delta')</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  over  </span>r \\in \\mathbb{F}^t$ , it holds that:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Delta \\Big( r^T \\cdot (c - u \\otimes C(1^k)), \\operatorname{Lin}_{z_2} \\Big) &gt; \\delta&#x27;.</span></div>

    <p class="text-gray-300"><em>Proof.</em> By Claim 6.1.1, the matrix  <span class="math">c-u\\otimes C(1^k)</span>  is  <span class="math">\\delta</span> -far from the linear space  <span class="math">\\mathsf{Lin}_{z_2}</span> . Since  <span class="math">\\delta&#x27;&lt;\\delta&lt;\\frac{\\lambda}{3}</span> , the claim follows immediately from Corollary 2.6.</p>

    <p class="text-gray-300">In the sequel we assume that r satisfying the condition in the above claim was selected. Next, we translate the distance from the linear space  <span class="math">\\mathsf{Lin}_{z_2}</span>  back to the corresponding affine space.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">Claim 6.1.3.</h4>

    <div class="my-4 text-center"><span class="math-block">\\Delta(r^T c, \\mathsf{Aff}&#x27;_{z_2,\\langle u,r\\rangle}) &gt; \\delta&#x27;,</span></div>

    <p class="text-gray-300">where  <span class="math">\\operatorname{Aff}&#x27;_{z_2,\\langle u,r\\rangle}=\\{C(m):\\hat{m}(z_2)=\\langle u,r\\rangle\\}</span>  and C is over the alphabet  <span class="math">\\mathbb{F}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Suppose toward a contradiction that there exists some  <span class="math">c&#x27; \\in \\mathsf{Aff}&#x27;_{z_2,\\langle u,r\\rangle}</span>  such that  <span class="math">\\Delta(r^Tc,c&#x27;) \\leq \\delta&#x27;</span> . Observe that</p>

    <div class="my-4 text-center"><span class="math-block">r^T \\cdot (c - u \\otimes C(1^k)) - (c&#x27; - \\langle u, r \\rangle \\otimes C(1^k)) = r^T c - \\langle u, r \\rangle \\cdot C(1^k) - (c&#x27; - \\langle u, r \\rangle \\otimes C(1^k))$$ $$= r^T c - c&#x27;$$ $$&lt; \\delta&#x27;</span></div>

    <p class="text-gray-300">and so  <span class="math">r^T \\cdot (c - u \\otimes C(1^k))</span>  is  <span class="math">\\delta&#x27;</span> -close to the codeword  <span class="math">c&#x27;&#x27; = (c&#x27; - \\langle u, r \\rangle \\otimes C(1^k))</span> . Next observe that the multilinear evaluation of  <span class="math">1^k</span>  at the point  <span class="math">z_2</span>  (or any other point for that matter) is equal to 1, and that c' is an encoding of a message whose multilinear evaluation at the point  <span class="math">z_2</span>  is equal to  <span class="math">\\langle u, r \\rangle</span> . Thus, c'' is an encoding of a message whose multilinear evaluation at the point  <span class="math">z_2</span>  is equal to  <span class="math">\\langle u, r \\rangle - \\langle u, r \\rangle \\cdot 1 = 0</span> .</p>

    <p class="text-gray-300">Overall we have that <span class="math-block">r^T \\cdot (c - u \\otimes C(1^k))</span>  is  <span class="math">\\delta&#x27;</span> -close to  <span class="math">c&#x27;&#x27; \\in \\text{Lin}_{z_2}</span> , a contradiction.</p>

    <p class="text-gray-300">Thus, by Claim 6.1.3, the input  <span class="math">c_{\\sf combo} = r^T c</span>  is  <span class="math">\\delta&#x27;</span> -far from  <span class="math">\\mathcal{L}_{\\sf MLE}(C, z_2, \\langle u, r \\rangle)</span> . By the soundness of (P, V), the verifier rejects in Step 4 with probability at least  <span class="math">\\varepsilon</span> .</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">7 Multilinear Evaluation for Interleaved RAA</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let PRAA denote the packed RAA code introduced in Section 5 and for an integer  <span class="math">t \\in \\mathbb{N}</span> , let PRAA<sup>t</sup> denote its t-fold interleaving (effectively this is similar to a  $t \\cdot \\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$  interleaving of RAA). Building on the results established in the previous sections, in this section we derive an IOPP for Multilinear Evaluation of the Interleaved PRAA code.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-36-1"></span><strong>Theorem 7.1</strong> (Multilinear Evaluation of Interleaved RAA). Let  <span class="math">\\lambda</span>  be the security parameter. Let PRAA be a packed RAA code with message length k and block length n over field  <span class="math">\\mathbb{F}</span>  where  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> 2^{\\lambda}<span class="math"> . For every  </span>t = t(k) \\in \\mathbb{N}<span class="math"> , there exists an IOPP for  </span>R_{\\mathsf{MLE}}[\\mathsf{PRAA}^t]<span class="math">  where  </span>\\mathsf{PRAA}^t<span class="math">  is over alphabet  </span>\\mathbb{K} = \\mathbb{F}^t<span class="math"> , which, for proximity parameter  </span>\\delta$ , has the following parameters:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <pre><code class="language-text">\\mathbb{F}^t
input alphabet
                                                               O(\\lambda/\\delta),
input query complexity
index and proof alphabets
index query complexity
                                                               O(\\lambda/\\delta),
proof query complexity
                                                          O(\\lambda \\log(n)/\\delta),
rounds
                                                              O(\\log n),
oracle proof communication
                                                                O(n),
                                                          2t + O(\\log n),
non-oracle proof communication
                                                 \\frac{n}{|\\mathbb{F}|} + 2^{-\\lambda} + O\\left(\\frac{1/\\delta + \\log n}{|\\mathbb{F}|}\\right),O(tn + n \\log n),
soundness error
prover time
                                                      O((t + \\log n) \\cdot \\lambda/\\delta).
verifier time</code></pre>

    <p class="text-gray-300">In particular, when setting  <span class="math">t = \\Theta(\\log n)</span> , the prover time is O(tn) and the verifier time is  <span class="math">O(\\log(n)\\lambda/\\delta)</span> .</p>

    <p class="text-gray-300">We emphasize that the constant overhead underlying the O(tn) term in prover time is small. Let K=tk denote the description size of the input polynomial. Using RAA code with rate 1/r, the prover time is dominated by (r+2)K multiplications and (r+1)K additions over the field  <span class="math">\\mathbb{F}</span> . In our instantiation, r=4, which leads to 6K multiplications and 5K additions over  <span class="math">\\mathbb{F}</span> .</p>

    <p class="text-gray-300">We also note that Theorem 7.1 is only used in the evaluation proof of the PCS. The commitment is done by encoding using the interleaved packed RAA code and then Merkle hashing. The encoding can be implemented using using 2rK field additions.</p>

    <p class="text-gray-300">Proof of Theorem 7.1. Recall that Lemma 5.1 gives an MLIOP for Multilinear Evaluation of PRAA, which has O(1) evaluation queries and prover oracles, prover complexity O(n), and verifier time  <span class="math">O(\\log n)</span> .</p>

    <p class="text-gray-300">Using Lemma 4.2 we transform this MLIOP into an IOPP for  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{PRAA}]</span> , with  <span class="math">O(\\lambda/\\delta)</span>  input queries,  <span class="math">O(\\lambda \\log(n)/\\delta)</span>  proof queries, prover time  <span class="math">O(n \\log n)</span> , and verifier time  <span class="math">O(\\lambda \\log(n)/\\delta)</span> . The MLIOP from Lemma 5.1 involves sending two types of polynomials, one of size k and another of size n > k. For ease of encoding during the MLIOP-to-IOPP transformation, we pad all oracles to size n. In practice, different Reed-Solomon encodings can be applied to each type of polynomial.</p>

    <p class="text-gray-300">Finally, using Lemma 6.1, we "bootstrap" the IOPP for  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{PRAA}]</span>  into an IOPP for the interleaved relation  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{PRAA}^t]</span> , which leads to the result of the theorem. We note that each input query to the IOPP for  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{PRAA}]</span>  is translated to a corresponding input query to the IOPP for  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{PRAA}^t]</span> , where  <span class="math">\\mathsf{PRAA}</span>  is over the alphabet  <span class="math">\\mathbb{F}</span> , and  <span class="math">\\mathsf{PRAA}^t</span>  over the alphabet  <span class="math">\\mathbb{F}^t</span> .</p>

    <p class="text-gray-300">After compiling the IOPP for  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{PRAA}^t]</span>  with Merkle commitments and the Fiat-Shamir transformation, we obtain a polynomial commitment scheme with linear-time prover and  <span class="math">O_{\\lambda}(\\log^2 n)</span>  proof size and verifier time.</p>

    <p class="text-gray-300">In this section, we compare Blaze to other state-of-the-art <em>multilinear</em> polynomial commitment schemes, including Brakedown [GLS<sup>+</sup>23], Basefold [ZCF24], and ZeromorphFri<sup>23</sup>. We also measure a variant which we call "Interleaved Blaze", which has a similar structure to Brakedown/Ligero,</p>

    <p class="text-gray-300"><span id="page-37-1"></span><sup>&</sup>lt;sup>23</sup>ZeromorphFri uses a generic univariate-to-multilinear transformation (due to [KT23]) to obtain a multilinear PCS from a FRI-based univariate PCS [BBHR18a]</p>

    <p class="text-gray-300"><span id="page-38-4"></span>in that it stops after taking a linear combination of rows (without a further composition step). We benchmark Brakedown, Basefold, and ZeromorphFRI over a 64-bit prime field. We benchmark Blaze using a 128-bit binary extension field.<a href="#page-38-1">24</a> We were unable to compare to FRI-Binius as the available implementation was too memory intensive for our large instances.</p>

    <p class="text-gray-300">We measure prover time, verifier time, and communication complexity. Blaze is designed to target large instance sizes. There are two reasons for this. Firstly, we do not have satisfactory distance guarantees for RAA codes of block length smaller than 2<sup>21</sup> . <a href="#page-38-2">25</a> Secondly, Blaze's opening phase executes a constant number of Basefold commitments, and starts to outperform Basefold only after the interleaving parameter t (i.e., the number of rows in the message matrix) exceeds a certain threshold. Thus, we focus our benchmarks on message sizes ranging from 2<sup>25</sup> to 2<sup>31</sup> field elements. To accommodate these large message sizes, we run all of our benchmarks on AWS EC2 Instance c6a.48xlarge, which has 192 vCPUs and 384GiBs of RAM.<a href="#page-38-3">26</a></p>

    <p class="text-gray-300">We compare against Basefold and ZeromorphFRI using a Reed-Solomon code with rate 1/2, and against Brakedown using a Spielman code with rate close to 1 and distance 0.07 (the largest possible distance) . We expect results to generalize to other distances and rates. In particular, by decreasing the distance of the code used by Brakedown one could improve its proving time even further but at great expense to the proof size.</p>

    <p class="text-gray-300">Remark 8.1. Both Basefold (via Binius-Fri [\\[DP24a\\]](#page-80-3)) and Blaze enable the prover to very efficiently commit to a polynomial that evaluates to "small values" (e.g. bits), thereby eliminating the embedding overhead. I contrast, Brakedown and ZeromorphFri require the prover to prove additional range checks.</p>

    <h2 id="sec-34" class="text-2xl font-bold">8.1 Prover and Verifier Runtimes</h2>

    <p class="text-gray-300">We highlight that Blaze is the only scheme capable of running on instances with size 231, all other schemes run out of memory at this scale. Blaze has a faster prover than both Basefold and ZeromorphFRI. For witness size 229, Blaze takes only 30.5 seconds to generate a proof, whereas Basefold takes 145.7 seconds, making Blaze more than 4.5 times faster. ZeromorphFRI runs out of memory for witness size 2<sup>29</sup> because it commits to an additional degree-n univariate polynomial during its opening phase, which doubles its memory usage compared to Basefold. For witness size 2 <sup>28</sup>, ZeromorphFRI takes 242.6 seconds, whereas Blaze only takes 21.9 seconds, more than 9.7 times faster.</p>

    <p class="text-gray-300">Besides Blaze, Brakedown is the only scheme that can prove evaluations on polynomials of size 230. For this size, Brakedown's prover takes 40.7 seconds, whereas Blaze takes 47.5 seconds, a 1.16x slowdown. However, Brakedown's proof sizes are about 10x larger, as discussed in <a href="#page-39-0">Section 8.2</a> and shown in Figure <a href="#page-40-0">4.</a> Furthermore, for 30-variate polynomials, Interleaved RAA takes only 28.2 seconds to commit and compute evaluation proofs, which is 1.44 times faster than Brakedown, and has a smaller proof size to boot. Two advantages of Brakedown over Blaze are i) its opening phase is extremely cheap, at the cost of larger proof sizes and verifier costs, and ii) they better exploit parallelism in their encoding algorithm. We note that a future implementation could better exploit the natural parallelism of the RAA encoding algorithm.</p>

    <p class="text-gray-300"><span id="page-38-2"></span><span id="page-38-1"></span><sup>24</sup>In other words it is essentially Brakedown, but we replace the use of Spielman's code with the packed RAA code. <sup>25</sup>Although with sufficiently long generation procedures the bounds are not too poor.</p>

    <p class="text-gray-300"><span id="page-38-3"></span><sup>26</sup>Blaze can run on smaller machines, but the other schemes run out of memory faster for our large instance sizes. Thus we chose a larger one so that we could gather adequate data for all four protocols.</p>

    <p class="text-gray-300">Blaze has a roughly similar verifier time to Basefold and ZeromorphFRI. It incurs additional costs from the interleaving phase (which we discuss in more detail in Section <a href="#page-39-0">8.2\\)</a>, which consists of a constant number of linear combinations on vectors of size t and additional Merkle tree verifications on a tree with n/t leaves, both of which incur only a small overhead. The Brakedown verifier, however, needs to compute an inner product on vectors of size n/t, which dominates its verifier time. Interleaved RAA has the same limitation, however it uses a fixed row length. As operating on the row is the bottleneck of the verifier, the RAA verifier ends up at around 150ms for all sizes. Brakedown, on the other hand, uses the row-length that will give it the smallest number of verifier queries for a given instance size. Brakedown could also fix its row length, but that would make its proof sizes even larger.</p>

    <p class="text-gray-300"><img src="_page_39_Figure_1.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Figure 3: Proving time and verifier time for all five protocols. Prover time consists of commitment time and evaluation proving time.</p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">8.2 Communication Complexity</h3>

    <p class="text-gray-300">We start with a high level comparison of the communication complexity of the different schemes. Results are listed in Figure <a href="#page-40-0">4.</a> Let n = rk where 1/r is the rate of the RAA code. A Blaze proof for a polynomial with tk coefficients consists of two main components: (i) a constant number of t-length columns of the interleaved code, and (ii) a Basefold proof for witness size n/t. Let d be the minimum distance of the RAA code. Recall from Corollary <a href="#page-16-3">2.6</a> that the verifier must check that the linear combination of the rows is no more than d/3-far from the Interleaved RAA code. Thus to achieve 100 bits of security in the query phase, the number of verifier queries, qRAA, is set <span id="page-40-1"></span>so that  <span class="math">(1-d/3)^{q_{RAA}} &lt; 2^{-100}</span> , or in other words,</p>

    <div class="my-4 text-center"><span class="math-block">q_{\\mathsf{RAA}} &lt; \\frac{100}{\\log_2(1 - d/3)}.</span></div>

    <p class="text-gray-300">Using an RAA code with distance 0.19, yields a query count equal to 1059. Thus, a Blaze proof roughly has an additional  <span class="math">1059 \\cdot 8 \\cdot t</span>  bytes compared to Basefold. Additionally, the proof requires 1059 Merkle Paths for a tree with n/t leaves to prove that the queried columns are consistent with the commitment. Actually, this is a slight overcount because the Basefold proof in the Blaze proof only has instance size n/t, and will be compared to Basefold of instance size n.</p>

    <p class="text-gray-300">Next, we compare Blaze to Brakedown. Brakedown uses a similar interleaving step in its opening proof, however the proof includes the entire linear combination of the rows, which Blaze avoids with the inner IOP. Furthermore, Brakedown uses a Spielman code which has a distance at most 0.07 (and this is the code we compare against). Thus, the number of queries for Brakedown,  <span class="math">q_{\\text{brakedown}}</span>  is equal to  <span class="math">\\frac{100}{\\log_2(1-0.07/3)}</span> , which is approximately 2,953. To summarize, compared to Blaze, Brakedown has almost 3 times as many queries, and then requires an additional n/t field elements.</p>

    <p class="text-gray-300">Finally, we compare Blaze to ZeromorphFRI. First, it is important to note that because we are considering a setting with <em>large</em> instance sizes and relatively <em>small</em> fields, we cannot use the best known results for FRI, such as those from [BSCI<sup>+</sup>20], which enables the verifier to query only a small constant number of elements. Thus, we instead consider results from Deep-FRI [BGKS20], which are agnostic to the field size. According to that result, the verifier needs to check that the FRI oracles are inconsistent with each other in (approximately) no more than  <span class="math">(1-d)^{1/3}</span>  fraction of locations. Thus, the number of queries required is</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{100}{\\log_2((1-d)^{1/3} + \\log_2(n) \\cdot \\epsilon)},</span></div>

    <p class="text-gray-300">where  <span class="math">\\epsilon</span>  is a round-by-round error term. We benchmark ZeromorphFRI with a rate and distance of 1/2, and so the number of queries is 329.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The detailed proof sizes for all schemes are listed in</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 4.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">--------------------------------------------------------</td>

            <td class="px-3 py-2 border-b border-gray-700">-----------</td>

            <td class="px-3 py-2 border-b border-gray-700">--</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># Vars</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Input Size (MB)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Brakedown</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Basefold</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ZeromorphFri</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Blaze</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Interleaved Blaze</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">1.2</td>

            <td class="px-3 py-2 border-b border-gray-700">.949</td>

            <td class="px-3 py-2 border-b border-gray-700">1.3</td>

            <td class="px-3 py-2 border-b border-gray-700">17.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">9.2</td>

            <td class="px-3 py-2 border-b border-gray-700">1.2</td>

            <td class="px-3 py-2 border-b border-gray-700">.949</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4</td>

            <td class="px-3 py-2 border-b border-gray-700">17.7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">1024</td>

            <td class="px-3 py-2 border-b border-gray-700">12.3</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4</td>

            <td class="px-3 py-2 border-b border-gray-700">1.16</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">2048</td>

            <td class="px-3 py-2 border-b border-gray-700">16.6</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4</td>

            <td class="px-3 py-2 border-b border-gray-700">1.16</td>

            <td class="px-3 py-2 border-b border-gray-700">2.5</td>

            <td class="px-3 py-2 border-b border-gray-700">18.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">4096</td>

            <td class="px-3 py-2 border-b border-gray-700">22.7</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">3.7</td>

            <td class="px-3 py-2 border-b border-gray-700">19.7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">8192</td>

            <td class="px-3 py-2 border-b border-gray-700">31.3</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">3.8</td>

            <td class="px-3 py-2 border-b border-gray-700">21.8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">16384</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">6.1</td>

            <td class="px-3 py-2 border-b border-gray-700">26.2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-40-0"></span>Figure 4: # Vars is the number of variables m of the input polynomial. Input size is the overall number of bytes representing the polynomial. Entries have an x if the computer ran out of memory. All sizes are measured in MB.</p>

    <p class="text-gray-300">In this section, we provide an analysis of the minimum distance of RAA codes and the probability they fail to achieve a certain distance according to various code generation procedures. We begin in Section 9.1 by setting the stage for our analysis; in particular, we precisely write an expression for the expected number of codewords of weight  <span class="math">\\leq \\delta n</span>  in an RAA code. In Section 9.2, we begin by bounding the portion of this expectation with small "middle" weight, i.e., those vectors for which after the first round of accumulation their weight is  <span class="math">\\leq n^{\\gamma}</span>  for some  <span class="math">\\gamma \\in (0,1)</span> . Then in Section 9.3, we bound the portion of the expectation for those whose middle weight is  <span class="math">&gt; n^{\\gamma}</span> : the sum of these two bounds then bounds the expectation.</p>

    <p class="text-gray-300">Our initial analysis applies to the generation procedure that samples the two defining permutations uniformly at random. Our main result is the following, which is a more formal version of Theorem 3.1. We state the result as a bound on the expected number of codewords of weight at most  <span class="math">\\delta n</span> ; as mentioned earlier, we can apply Markov's inequality to translate this into an upper bound on the probability the code fails to have distance d.</p>

    <p class="text-gray-300"><span id="page-41-1"></span><strong>Theorem 9.1.</strong> Let  <span class="math">r, n \\in \\mathbb{N}</span> , r even with  <span class="math">r \\geq 4</span> ,  <span class="math">\\delta \\in (0, 1/3)</span>  such that  <span class="math">d = \\delta n \\in \\mathbb{N}</span> ,  <span class="math">\\gamma = 1 - \\frac{2}{r}(1 + \\varepsilon)</span>  for some  <span class="math">\\varepsilon &gt; 0</span> . If r = 4 assume further  <span class="math">\\delta &lt; 1/4</span> . Define  <span class="math">m := \\lfloor n^{\\gamma} \\rfloor</span> ,  <span class="math">v_2^* = \\frac{1+r}{2\\ln(1/\\omega)}</span> ,  <span class="math">\\omega = 4\\delta(1-\\delta)</span> ,  <span class="math">\\alpha_0 = \\frac{r}{n}</span>  and  <span class="math">\\beta_0 = n^{\\gamma-1}</span> . Assume</p>

    <div class="my-4 text-center"><span class="math-block">n \\ge \\max \\left\\{ 101^{1/\\gamma}, 7, 2m + r + 1, \\frac{2}{1-\\xi}m, \\frac{(2/\\xi)^{r/\\varepsilon}}{r^{1/\\varepsilon}} \\right\\}</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\beta_1 = \\frac{1}{2} - \\frac{1 - \\alpha_0}{2} \\sqrt{1 - \\left(\\frac{\\alpha_0}{1 - \\alpha_0}\\right)^{2/r}} &gt; \\beta_0 , \\quad \\sqrt{\\omega} &lt; 1 - 2\\beta_1 - \\frac{\\alpha_0}{2\\beta_0} .</span></div>

    <p class="text-gray-300">Finally, set</p>

    <div class="my-4 text-center"><span class="math-block">B = \\max\\{f(\\alpha_0, \\beta_0, \\delta), \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in CP(r, \\delta)\\}\\}\\</span></div>

    <p class="text-gray-300">where  <span class="math">CP(r, \\delta)</span>  is the set of critical points of f for fixed  <span class="math">\\delta</span> , i.e. the set of  <span class="math">(\\alpha, \\beta)</span>  satisfying equations (19) and (20).</p>

    <p class="text-gray-300">Then the expected number of vectors of weight at most d in a randomly sampled RAA code of rate 1/r with block-length n is at most</p>

    <p class="text-gray-300"><span class="math-block">\\mathbb{I}\\{r=4\\} \\cdot \\frac{3}{n-2} + \\mathbb{I}\\{r=6, \\delta \\ge 1/4\\} \\cdot \\frac{180\\delta^{2}(1-\\delta)}{(n-2)^{2}} + n^{1-r/2} \\cdot \\lceil \\frac{n^{\\gamma}}{2} \\rceil \\cdot \\frac{0.43603}{r} \\cdot \\binom{r}{\\frac{r}{2}} \\cdot \\varphi_{n} \\left(2 \\cdot \\lceil \\frac{m}{2} \\rceil\\right) \\cdot \\varphi_{n}(r) \\cdot (2v_{2}^{<em>})^{\\frac{r+1}{2}} \\cdot \\omega^{v_{2}^{</em>}} + \\frac{0.80192 \\cdot \\delta}{r^{3/2}} \\cdot n^{7/2} \\cdot 2^{Bn} .</span> (3)</p>

    <p class="text-gray-300">Additionally, assuming  <span class="math">\\max\\{f(\\alpha,\\beta,\\delta): (\\alpha,\\beta) \\in \\mathrm{CP}(r,\\delta)\\}\\</span>  < 0, for sufficiently large n we have  <span class="math">B = f(\\alpha_0,\\beta_0,\\delta) = -\\Omega(n^{\\gamma})</span> , so the above is</p>

    <p class="text-gray-300"><span class="math-block">\\leq O(n^{1+\\gamma-r/2}) + 2^{-\\Omega(n^{\\gamma})} = O(n^{1+\\gamma-r/2})</span> .</p>

    <p class="text-gray-300"><span id="page-42-3"></span>One should think of the condition that  <span class="math">\\max\\{f(\\alpha,\\beta,\\delta):(\\alpha,\\beta)\\in \\operatorname{CP}(r,\\delta)\\}&lt;0</span>  as being analogous to the statement of the GV bound, namely, that one requires  <span class="math">R&lt;1-H(\\delta)</span>  to guarantee minimum distance  <span class="math">\\delta</span>  when a randomly sampled code of rate R is sampled. The function f depends on the repetition factor r (and hence the rate 1/r) and, depending on  <span class="math">\\delta</span> , certain expressions (determined by the critical points) need to be negative. For parameters of interest, there are just a constant number of conditions that need to be checked (and a simple computer script can indeed verify they hold). That is, the condition  <span class="math">\\max\\{f(\\alpha,\\beta,\\delta):(\\alpha,\\beta)\\in\\operatorname{CP}(r,\\delta)\\}&lt;0</span>  constrains the rate-distance tradeoffs we can achieve. And, as Figure 2 attests, the achievable rate-distance tradeoff is quite close to the GV bound!</p>

    <p class="text-gray-300">Next, in Section 9.4, we consider generation procedures that verify that low weight messages have sufficiently high-weight encodings, or sometimes just that they do not have an exceedingly poor first stage. In either case, we are able to show that these tests yield significantly improved bounds on the failure probability. The precise statement is given as Theorem 9.16.</p>

    <p class="text-gray-300">Finally, in Section 9.5, we analyze punctured RAA codes. Here, assuming a conjecture, we observe that we can generate codes with new rate-distance tradeoffs whose generation procedures have similar failure probabilities.</p>

    <h2 id="sec-37" class="text-2xl font-bold">9.1 Setup of RAA Analysis</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The simplicity of the accumulator matrix allows for a relatively simple expression for the probability that a <em>uniformly random</em> vector of weight a is mapped to a vector of weight b, where we recall the weight of a vector  <span class="math">x \\in \\mathbb{F}_2^n</span>  is  $\\operatorname{wt}(x) := n \\cdot \\Delta(x,0) =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{i \\in [n] : x_i \\neq 0\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-42-1"></span><strong>Lemma 9.2</strong> ( [DJM98]; see [BFK<sup>+</sup>24, Theorem 2] for a proof). Let x be uniformly sampled from all vectors of weight a in  <span class="math">\\mathbb{F}_2^n</span> , where  <span class="math">a \\ge 1</span> . Then, assuming  <span class="math">\\lceil a/2 \\rceil \\le b</span>  and  <span class="math">\\lfloor a/2 \\rfloor \\le n-b</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">p_{a\\mapsto b} := \\Pr[\\operatorname{wt}(Ax) = b] = \\frac{\\binom{b-1}{\\lceil a/2\\rceil - 1} \\binom{n-b}{\\lfloor a/2\\rfloor}}{\\binom{n}{a}}.</span></div>

    <p class="text-gray-300">Otherwise, this probability is 0.</p>

    <p class="text-gray-300">For intuition, observe that after accumulating a vector of weight a one obtains  <span class="math">\\lceil a/2 \\rceil</span>  "intervals" of 1's: there are  <span class="math">\\lceil a/2 \\rceil</span>  indices that start a string of 1's, and  <span class="math">\\lfloor a/2 \\rfloor</span>  indices that end the string. One must then count the number of ways to arrange these "starting and ending" indices so that the sum of the lengths of the intervals is b.</p>

    <p class="text-gray-300">Applying Lemma 9.2, we can write this expectation as follows (viewing binomial coefficients  <span class="math">\\binom{a}{b}</span>  as 0 if b < 0 or b > a):</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{w_1=1}^{n/r} \\binom{n/r}{w_1} \\sum_{w_2=1}^n \\sum_{w_3=1}^d p_{rw_1 \\mapsto w_2} \\cdot p_{w_2 \\mapsto w_3} \\tag{4}</span></div>

    <p class="text-gray-300"><span id="page-42-2"></span> <span class="math-block">= \\sum_{w_1=1}^{n/r} \\sum_{w_2=1}^{n} \\sum_{w_3=1}^{d} \\binom{n/r}{w_1} \\cdot \\frac{\\binom{w_2-1}{\\lceil rw_1/2 \\rceil - 1} \\binom{n-w_2}{\\lceil rw_1/2 \\rceil}}{\\binom{n}{rw_1}} \\cdot \\frac{\\binom{w_3-1}{\\lceil w_2/2 \\rceil - 1} \\binom{n-w_3}{\\lceil w_2/2 \\rceil}}{\\binom{n}{w_2}} . \\tag{5}</span></p>

    <p class="text-gray-300"><span id="page-43-3"></span>In fact, it will be useful to rewrite the probability in Lemma 9.2 as follows (this is also done in [KZKJ08]):</p>

    <p class="text-gray-300"><span id="page-43-0"></span> <span class="math-block">\\frac{\\binom{b-1}{\\lceil a/2\\rceil-1}\\binom{n-b}{\\lfloor a/2\\rfloor}}{\\binom{n}{a}} = \\frac{\\binom{b}{\\lceil b/2\\rceil}\\binom{n-a}{b-\\lceil a/2\\rceil}}{\\binom{n}{b}} \\cdot \\frac{\\lceil \\frac{a}{2}\\rceil}{b} \\ .</span></p>

    <p class="text-gray-300">The above equality follows from opening up the binomial coefficients. Intuitively, this rewriting is useful, as now only one of the binomial coefficients depends on both a and b. This will allow for an easier analysis of certain expressions which will appear.</p>

    <p class="text-gray-300">Thus, the expectation in (5) is</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{w_1=1}^{n/r} \\sum_{w_2=1}^{n} \\sum_{w_3=1}^{d} \\binom{n/r}{w_1} \\cdot \\frac{\\binom{rw_1}{\\lceil rw_1/2 \\rceil} \\binom{n-rw_1}{w_2-\\lceil rw_1/2 \\rceil}}{\\binom{n}{w_2}} \\cdot \\frac{\\binom{w_2}{\\lceil \\frac{w_2}{2} \\rceil} \\binom{n-w_2}{w_3-\\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{\\lceil rw_1/2 \\rceil \\cdot \\lceil \\frac{w_2}{2} \\rceil}{w_2 w_3} , \\qquad (6)</span></div>

    <p class="text-gray-300">and our target will be to provide meaningful bounds on (6). We now provide some intuition for our approach.</p>

    <p class="text-gray-300">Firstly, we view the two rounds of permuting and accumulating as two "stages" in the encoding. We know that the minimum distance of an RA code – i.e., a code with only 1 round of permuting and accumulating – will never have  <span class="math">\\Omega(1)</span>  minimum distance [BMS08, KZCJ07]: the minimum distance will (with high probability) be something like  <span class="math">n^{-2/r}</span> .</p>

    <p class="text-gray-300">However, this is already quite good: in particular, if after the first round all vectors have weight about  <span class="math">n^{-2/r}</span> , the second stage is very likely to give us our desired minimum distance  <span class="math">\\delta</span> .</p>

    <p class="text-gray-300">To make this intuition concrete, we break the expectation in (6) into two parts: one part with the middle weight  <span class="math">w_2</span>  less than about  <span class="math">n^{1-2/r}</span> , and one part with the middle weight large. We provide a novel analysis of this first part in Section 9.2, and then use ideas from Kliewer <em>et al.</em> [KZKJ08] to bound the second part in Section 9.3.</p>

    <p class="text-gray-300">Let us state two lemmas that we will use throughout this section.</p>

    <p class="text-gray-300"><span id="page-43-1"></span><strong>Lemma 9.3.</strong> Let  <span class="math">w_1, w_2</span>  and  <span class="math">w_3</span>  be the message weight, intermediate weight (after one permutation and accumulator) and output weight, respectively, of an RAA code with rate 1/r and block length n. Then we have</p>

    <p class="text-gray-300"><span class="math-block">\\lceil rw_1/2 \\rceil \\le w_2</span> ,  <span class="math">\\lfloor rw_1/2 \\rfloor \\le n - w_2</span> ,  <span class="math">\\lceil w_2/2 \\rceil \\le w_3</span>  and  <span class="math">\\lfloor w_2/2 \\rfloor \\le n - w_3</span> ,</p>

    <p class="text-gray-300">and in terms of relative weights  <span class="math">\\alpha := \\frac{rw_1}{n}, \\beta := \\frac{w_2}{n}</span>  and  <span class="math">\\rho := \\frac{w_3}{n}</span></p>

    <p class="text-gray-300"><span class="math-block">\\frac{\\alpha}{2} \\le \\beta</span> ,  <span class="math">\\frac{\\alpha}{2} &lt; 1 - \\beta</span> ,  <span class="math">\\frac{\\beta}{2} \\le \\rho</span>  and  <span class="math">\\frac{\\beta}{2} &lt; 1 - \\rho</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Follows immediately from Lemma 9.2.</p>

    <p class="text-gray-300"><span id="page-43-2"></span><strong>Lemma 9.4.</strong> For  <span class="math">k, n \\in \\mathbb{N}</span>  with  <span class="math">k \\leq n</span>  we have the upper-bound</p>

    <div class="my-4 text-center"><span class="math-block">\\binom{n}{k} \\leq \\frac{e^{\\frac{32}{360}}}{\\sqrt{2\\pi}} \\cdot \\sqrt{\\frac{n}{k(n-k)}} \\cdot 2^{n \\cdot H\\left(\\frac{k}{n}\\right)} \\leq \\frac{e^{\\frac{32}{360}}}{\\sqrt{\\pi}} \\cdot 2^{n \\cdot H\\left(\\frac{k}{n}\\right)} \\leq 0.61664 \\cdot 2^{n \\cdot H\\left(\\frac{k}{n}\\right)} \\ ,</span></div>

    <p class="text-gray-300">we have the lower-bound</p>

    <div class="my-4 text-center"><span class="math-block">\\binom{n}{k} \\geq \\frac{e^{-\\frac{61}{360}}}{\\sqrt{2\\pi}} \\cdot \\sqrt{\\frac{n}{k(n-k)}} \\cdot 2^{n \\cdot H\\left(\\frac{k}{n}\\right)} \\geq \\frac{\\sqrt{2} \\cdot e^{-\\frac{61}{360}}}{\\sqrt{\\pi}} \\cdot \\frac{2^{n \\cdot H\\left(\\frac{k}{n}\\right)}}{\\sqrt{n}} \\geq 0.67352 \\cdot \\frac{2^{n \\cdot H\\left(\\frac{k}{n}\\right)}}{\\sqrt{n}} \\ .</span></div>

    <p class="text-gray-300"><em>Proof.</em> The proof is a simple consequence of the following strong form of Stirling's approximation, which says that for all n:</p>

    <div class="my-4 text-center"><span class="math-block">\\sqrt{2\\pi n} \\ \\left(\\frac{n}{e}\\right)^n e^{\\left(\\frac{1}{12n} - \\frac{1}{360n^3}\\right)} &lt; n! &lt; \\sqrt{2\\pi n} \\ \\left(\\frac{n}{e}\\right)^n e^{\\frac{1}{12n}} \\ .</span></div>

    <h2 id="sec-38" class="text-2xl font-bold">9.2 Probability First Stage Fails</h2>

    <p class="text-gray-300">In this section, we essentially bound the probability that some message vector has small weight after the first stage: namely, after (randomly) permuting and accumulating, the obtained intermediate vector has weight at most  <span class="math">n^{\\gamma}</span>  for some  <span class="math">\\gamma \\in (0,1)</span> . More precisely, we prove the following proposition, which makes use of the function</p>

    <div class="my-4 text-center"><span class="math-block">\\varphi_{\\ell}(x) := \\exp\\left(\\frac{x(x-1)}{2\\ell}\\right) .</span></div>

    <p class="text-gray-300"><span id="page-44-2"></span><strong>Proposition 9.5.</strong> Let  <span class="math">r, n \\in \\mathbb{N}</span> , r even, with  <span class="math">r \\geq 4</span> ,  <span class="math">\\delta \\in (0, 1/3)</span>  s.t.  <span class="math">d = \\delta n \\in \\mathbb{N}</span> ,  <span class="math">\\gamma = 1 - \\frac{2}{r}(1+\\varepsilon)</span>  for some  <span class="math">\\varepsilon &gt; 0</span> . If r = 4 assume further  <span class="math">\\delta &lt; 1/4</span> . Define  <span class="math">m := \\lfloor n^{\\gamma} \\rfloor</span> ,  <span class="math">v_2^* = \\frac{1+r}{2\\ln(1/\\eta)}</span>  and  <span class="math">\\eta = 4\\delta(1-\\delta)</span> . Suppose there exists  <span class="math">\\xi \\in (0,1)</span>  such that the following holds</p>

    <div class="my-4 text-center"><span class="math-block">n \\ge \\max\\left\\{7, 2m + r + 1, \\frac{2}{1 - \\xi}m, \\frac{(2/\\xi)^{r/\\varepsilon}}{r^{1/\\varepsilon}}\\right\\} . \\tag{7}</span></div>

    <p class="text-gray-300"><span id="page-44-3"></span><span id="page-44-1"></span></p>

    <p class="text-gray-300">Then:</p>

    <p class="text-gray-300"><span class="math-block">\\sum_{w_1=1}^{n/r} \\sum_{w_2=1}^{m} \\sum_{w_3=1}^{d} \\binom{n/r}{w_1} \\cdot \\frac{\\binom{rw_1}{rw_1/2} \\binom{n-rw_1}{w_2-rw_1/2}}{\\binom{n}{w_2}} \\cdot \\frac{\\binom{w_2}{\\lceil w_2/2 \\rceil} \\binom{n-w_2}{w_3-\\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{rw_1/2 \\cdot \\lceil w_2/2 \\rceil}{w_2w_3}</span> (8)</p>

    <div class="my-4 text-center"><span class="math-block">\\leq \\mathbb{I}\\{r=4\\} \\cdot \\frac{3}{n-2} + \\mathbb{I}\\{r=6, \\delta \\geq 1/4\\} \\cdot \\frac{180\\delta^2(1-\\delta)}{(n-2)^2}</span></div>

    <p class="text-gray-300"><span class="math-block">+ n^{1-r/2} \\cdot \\left\\lceil \\frac{n^{\\gamma}}{2} \\right\\rceil \\cdot \\frac{0.43603}{r} \\cdot \\left( \\frac{r}{\\frac{r}{2}} \\right) \\cdot \\varphi_n \\left( 2 \\cdot \\left\\lceil \\frac{m}{2} \\right\\rceil \\right) \\cdot \\varphi_n(r) \\cdot \\left( 2v_2^<em> \\right)^{\\frac{r+1}{2}} \\cdot \\eta^{v_2^</em>}</span>  (9)</p>

    <div class="my-4 text-center"><span class="math-block">= O(n^{1+\\gamma-r/2}) .</span></div>

    <p class="text-gray-300"><em>Proof.</em> We will bound the sums in (8) by replacing each sum with its largest term multiplied by the number of terms in the sum, starting out with the sum over  <span class="math">w_3</span> . To do so we first rewrite (8) to separate out the factors depending on  <span class="math">w_3</span> .</p>

    <div class="my-4 text-center"><span class="math-block">(8) = \\sum_{w_1 = 1}^{n/r} \\sum_{w_2 = 1}^m \\binom{n/r}{w_1} \\cdot \\frac{\\binom{rw_1}{rw_1/2} \\binom{n - rw_1}{w_2 - rw_1/2}}{\\binom{n}{w_2}} \\cdot \\binom{w_2}{\\lceil w_2/2 \\rceil} \\cdot \\frac{rw_1/2 \\cdot \\lceil w_2/2 \\rceil}{w_2} \\cdot \\sum_{w_3 = 1}^d \\frac{\\binom{n - w_2}{w_3 - \\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{1}{w_3} \\; .</span></div>

    <p class="text-gray-300">We claim that the above expression grows with  <span class="math">w_3</span>  as long as  <span class="math">w_2 \\ge 4</span> . To see this, we show that the ratio between the terms  <span class="math">w_3 + 1</span>  and  <span class="math">w_3</span>  term is > 1, except when  <span class="math">w_2 \\le 3</span> .</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{\\frac{\\binom{n-w_2}{w_3+1-\\lceil w_2/2\\rceil}}{\\binom{n}{w_3+1}} \\cdot \\frac{1}{w_3+1}}{\\frac{\\binom{n-w_2}{w_3-\\lceil w_2/2\\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{1}{w_3}} = \\frac{w_3}{w_3+1} \\cdot \\frac{n-w_2-w_3+\\lceil w_2/2\\rceil}{w_3+1-\\lceil w_2/2\\rceil} \\cdot \\frac{w_3+1}{n-w_3}$$ $$= \\frac{w_3}{w_3+1-\\lceil w_2/2\\rceil} \\cdot \\frac{(n-w_3)-\\lfloor w_2/2\\rfloor}{n-w_3}.</span></div>

    <p class="text-gray-300">The above is > 1 if and only if</p>

    <div class="my-4 text-center"><span class="math-block">w_{3}((n-w_{3})-\\lfloor w_{2}/2\\rfloor) &gt; (n-w_{3})(w_{3}+1-\\lceil w_{2}/2\\rceil)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\iff -w_{3} \\cdot \\lfloor w_{2}/2\\rfloor &gt; (n-w_{3}) \\cdot (1-\\lceil w_{2}/2\\rceil)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\iff -n \\cdot (1-\\lceil w_{2}/2\\rceil) &gt; -w_{3} \\cdot (1-\\lceil w_{2}/2\\rceil) + w_{3} \\cdot \\lfloor w_{2}/2\\rfloor</span></div>

    <div class="my-4 text-center"><span class="math-block">\\iff n \\cdot (\\lceil w_{2}/2\\rceil - 1) &gt; w_{3} \\cdot w_{2} - w_{3}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\iff n \\left(\\frac{\\lceil w_{2}/2\\rceil - 1}{w_{2} - 1}\\right) &gt; w_{3}.</span></div>

    <p class="text-gray-300">The final upper-bound on w<sup>3</sup> becomes w<sup>3</sup> < n/3 assuming w<sup>2</sup> ≥ 4. For w<sup>2</sup> = 2 the upper-bound becomes w<sup>3</sup> < 0 and for w<sup>1</sup> = 1 it is undefined. Thus, if we are willing to settle for a minimum distance δ of at most 1/3, and separately account for the cases w<sup>2</sup> = 1, w<sup>2</sup> = 2 and w<sup>2</sup> = 3, then we can suppose that <a href="#page-44-1">\\(8\\)</a> grows with w3. Furthermore, we observe that if δ < 1/4 then it in fact suffices to just deal with the case w<sup>2</sup> = 1 and w<sup>2</sup> = 2.</p>

    <p class="text-gray-300">Let us first work out the contribution of these additional cases. Recall from <a href="#page-43-1">Lemma 9.3</a> that the accumulator can at most half the weight of any vector. Note that since we consider r ≥ 4, this means that we will never obtain w<sup>2</sup> = 1, and only have to deal with w<sup>2</sup> = 2 and w<sup>2</sup> = 3. Furthermore w<sup>2</sup> = 2 can only be achieved when starting with w<sup>1</sup> = 1 while r = 4; while w<sup>2</sup> = 3 can only be achieved when starting with w<sup>1</sup> = 1 while r ∈ {4, 6}. However, for this latter case we need δ ≥ 1/4, which we assume is not the case when r = 4. Let's first calculate the contribution in the first case (i.e., for  <span class="math">w_1 = 1</span> ,  <span class="math">w_2 = 2</span>  and r = 4):</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\mathbb{I}\\{r=4\\} \\cdot \\sum_{w_1=1}^1 \\sum_{w_2=2}^2 \\binom{n/r}{w_1} \\cdot \\frac{\\binom{rw_1}{rw_1/2} \\binom{n-rw_1}{w_2-rw_1/2}}{\\binom{n}{w_2}} \\cdot \\binom{w_2}{\\lceil w_2/2 \\rceil} \\cdot \\frac{rw_1/2 \\cdot \\lceil w_2/2 \\rceil}{w_2} \\\\ \\cdot \\sum_{w_3=\\lceil w_2/2 \\rceil}^d \\frac{\\binom{n-w_2}{w_3-\\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{1}{w_3} \\\\ &amp;= \\mathbb{I}\\{r=4\\} \\cdot \\frac{n}{r} \\cdot \\frac{\\binom{r}{r} \\binom{n-r}{2-\\frac{r}{2}}}{n(n-1)} \\cdot 2 \\cdot \\frac{\\frac{r}{2} \\cdot 1}{2} \\cdot \\sum_{w_3=1}^d \\frac{\\frac{(n-2)!}{(w_3-1)!(n-w_3-1)!}}{w_3 \\cdot \\frac{n!}{w_3!(n-w_3)!}} \\\\ &amp;= \\mathbb{I}\\{r=4\\} \\cdot \\frac{3}{(n-1)} \\cdot \\sum_{w_3=1}^d \\frac{w_3 \\cdot (n-w_3)}{w_3 \\cdot n(n-1)} \\\\ &amp;= \\mathbb{I}\\{r=4\\} \\cdot \\frac{3}{(n-1)} \\cdot \\left(\\frac{n \\cdot d}{n(n-1)} - \\frac{1}{n(n-1)} \\sum_{w_3=1}^d w_3\\right) \\\\ &amp;= \\mathbb{I}\\{r=4\\} \\cdot \\frac{3}{(n-1)^2} \\cdot \\left(1 - \\frac{d+1}{2n}\\right) \\\\ &amp;= \\mathbb{I}\\{r=4\\} \\cdot \\frac{3d}{(n-1)^2} \\cdot \\left(1 - \\frac{d+1}{2n}\\right) \\\\ &amp;= \\mathbb{I}\\{r=4\\} \\cdot \\frac{3-3\\delta/2-3/n)d}{(n-1)^2} \\\\ &amp;\\leq \\mathbb{I}\\{r=4\\} \\cdot \\frac{3}{n-2} \\cdot \\end{split}</span></div>

    <p class="text-gray-300">We now consider the term with  <span class="math">w_1 = 1</span>  and  <span class="math">w_2 = 3</span> . We recall that this term only arises if  <span class="math">\\delta \\ge 1/4</span>  and r = 6:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\mathbb{I}\\{r = 6, \\delta \\geq 1/4\\} \\cdot \\sum_{w_1 = 1}^{1} \\sum_{w_2 = 3}^{3} \\binom{n/r}{w_1} \\cdot \\frac{\\binom{rw_1}{rw_1/2} \\binom{n - rw_1}{w_2 - rw_1/2}}{\\binom{n}{w_2}} \\cdot \\binom{w_2}{\\lceil w_2/2 \\rceil} \\cdot \\frac{rw_1/2 \\cdot \\lceil w_2/2 \\rceil}{w_2} \\\\ \\cdot \\sum_{w_3 = \\lceil w_2/2 \\rceil}^{d} \\frac{\\binom{n - w_2}{w_3 - \\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{1}{w_3} \\\\ &amp;= \\mathbb{I}\\{r = 6, \\delta \\geq 1/4\\} \\cdot \\binom{n/6}{1} \\cdot \\frac{\\binom{6}{3} \\binom{n - 6}{3 - 3}}{\\binom{n}{3}} \\cdot \\binom{3}{2} \\cdot \\frac{3 \\cdot 2}{3} \\cdot \\sum_{w_3 = 2}^{d} \\frac{\\frac{(n - 3)!}{(w_3 - 2)!(n - w_3 - 1)!}}{w_3 \\cdot \\frac{n!}{w_3!(n - w_3)!}} \\\\ &amp;= \\mathbb{I}\\{r = 6, \\delta \\geq 1/4\\} \\cdot \\frac{n}{6} \\cdot \\frac{20}{n(n - 1)(n - 2)} \\cdot 6 \\cdot 3 \\cdot 2 \\cdot \\sum_{w_3 = 2}^{d} \\frac{(w_3 - 1)(n - w_3)}{n(N - 1)(n - 2)} \\\\ &amp;\\leq \\mathbb{I}\\{r = 6, \\delta \\geq 1/4\\} \\cdot \\frac{120(n - 4)}{(n - 1)(n - 2)} \\cdot d^2(n - d) \\\\ &amp;\\leq \\mathbb{I}\\{r = 6, \\delta \\geq 1/4\\} \\cdot \\frac{180\\delta^2(1 - \\delta)}{(n - 2)^2} \\end{split}</span></div>

    <p class="text-gray-300">where the penultimate inequality uses that  <span class="math">(w_3 - 1)(n - w_3) \\le d(n - d)</span> , which is valid for all  <span class="math">w_3 \\le d = \\delta n \\le n/2</span>  (recall  <span class="math">\\delta &lt; 1/3</span> ), and the last inequality holds for  <span class="math">n \\ge 7</span> .</p>

    <p class="text-gray-300">Thus, the contribution from these terms can be bounded by</p>

    <p class="text-gray-300"><span id="page-47-0"></span> <span class="math-block">\\mathbb{I}\\{r=4\\} \\cdot \\frac{3}{n-2} + \\mathbb{I}\\{r=6, \\delta \\ge 1/4\\} \\cdot \\frac{180\\delta^2(1-\\delta)}{(n-2)^2} \\ . \\tag{10}</span></p>

    <p class="text-gray-300">Returning to bounding the sum over  <span class="math">w_3</span>  gives us</p>

    <div class="my-4 text-center"><span class="math-block">(8) \\leq (10) + \\sum_{w_{1}=1}^{n/r} \\sum_{w_{2}=1}^{m} \\binom{n/r}{w_{1}} \\cdot \\frac{\\binom{rw_{1}}{rw_{1}/2} \\binom{n-rw_{1}}{w_{2}-rw_{1}/2}}{\\binom{n}{w_{2}}} \\cdot \\binom{w_{2}}{\\lceil w_{2}/2 \\rceil} \\cdot \\frac{w_{2}}{\\lceil w_{2}/2 \\rceil} \\cdot \\frac{1}{d}</span></div>

    <div class="my-4 text-center"><span class="math-block">= (10) + \\sum_{w_{2}=1}^{m} \\frac{\\binom{n-w_{2}}{d-\\lceil w_{2}/2 \\rceil}}{\\binom{n}{d}} \\cdot \\frac{1}{\\binom{n}{w_{2}}} \\cdot \\binom{w_{2}}{\\lceil w_{2}/2 \\rceil} \\cdot \\frac{1}{d}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\cdot \\frac{\\lceil w_{2}/2 \\rceil}{w_{2}} \\cdot \\sum_{w_{2}=1}^{\\lfloor \\frac{2w_{2}}{r} \\rfloor} \\binom{n/r}{w_{1}} \\binom{rw_{1}}{rw_{1}/2} \\binom{n-rw_{1}}{w_{2}-rw_{1}/2} \\cdot rw_{1}/2 . \\tag{11}</span></div>

    <p class="text-gray-300">We note that the rewritten upper-bound on the sum over  <span class="math">w_1</span>  follows again from the fact that the accumulator at worst halves the weight of a vector, which follows from Lemma 9.3.</p>

    <p class="text-gray-300">We now claim that the above expression decreases with  <span class="math">w_1</span> , and again argue this by showing that the ratio between the terms  <span class="math">w_1 + 1</span>  and  <span class="math">w_1</span>  is  <span class="math">\\leq 1</span> . We write out the ratio of these terms for each factor involving  <span class="math">w_1</span> . First,</p>

    <p class="text-gray-300"><span id="page-47-1"></span> <span class="math-block">\\frac{\\binom{n/r}{w_1+1}}{\\binom{n/r}{w_1}} \\cdot \\frac{\\frac{r(w_1+1)}{2}}{\\frac{rw_1}{2}} = \\frac{n/r - w_1}{w_1 + 1} \\cdot \\frac{w_1 + 1}{w_1} = \\frac{n/r - w_1}{w_1} \\le \\frac{n}{r} .</span></p>

    <p class="text-gray-300">Next,</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{\\binom{r(w_1+1)}{r(w_1+1)}}{\\binom{rw_1}{rw_1/2}} = \\frac{(rw_1+r)!(rw_1/2)!^2}{(rw_1)!(rw_1/2+\\frac{r}{2})!^2} = \\prod_{j=0}^{\\frac{r}{2}-1} \\frac{(rw_1+2j+1)(rw_1+2j+2)}{(\\frac{rw_1}{2}+j+1)^2} \\ .</span></div>

    <p class="text-gray-300">Lastly,</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{\\binom{n-r(w_1+1)}{w_2-\\frac{r(w_1+1)}{2}}}{\\binom{n-rw_1}{w_2-rw_1/2}} = \\frac{(n-rw_1-r)!(w_2-rw_1/2)!(n-rw_1/2-w_2)!}{(n-rw_1)!(w_2-rw_1/2-\\frac{r}{2})!(n-rw_1/2-w_2-\\frac{r}{2})!}</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\prod_{j=0}^{\\frac{r}{2}-1} \\frac{(w_2-\\frac{rw_1}{2}-j)(n-w_2-\\frac{rw_1}{2}-j)}{(n-rw_1-2j)(n-rw_1-2j-1)}.</span></div>

    <p class="text-gray-300">Now, we first note that for each j</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{rw_1 + 2j + 1}{n - rw_1 - 2j - 1} \\le \\frac{rw_1 + 2j + 2}{n - rw_1 - 2j} .</span></div>

    <p class="text-gray-300">Indeed, calling  <span class="math">x = rw_1 + 2j + 1</span>  and y = n, we wish to show  <span class="math">\\frac{x}{y} \\leq \\frac{x+1}{y+1}</span> , which is true if and only if  <span class="math">x \\leq y</span> , which is true for our setting since we assumed  <span class="math">n \\geq 2m + r + 1</span>  and we have  <span class="math">w_1 \\leq 2w_2/r \\leq 2m/r</span> . Thus, we bound</p>

    <div class="my-4 text-center"><span class="math-block">\\prod_{j=0}^{\\frac{r}{2}-1} \\frac{(rw_1 + 2j + 1)(rw_1 + 2j + 2)}{(\\frac{rw_1}{2} + j + 1)^2} \\cdot \\frac{(w_2 - \\frac{rw_1}{2} - j)(n - \\frac{rw_1}{2} - j)}{(n - w_2 - rw_1 - 2j)(n - rw_1 - 2j - 1)}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\leq \\prod_{j=0}^{\\frac{r}{2}-1} \\frac{(rw_1 + 2j + 2)(rw_1 + 2j + 2)}{(\\frac{rw_1}{2} + j + 1)^2} \\cdot \\frac{(w_2 - \\frac{rw_1}{2} - j)(n - \\frac{rw_1}{2} - j)}{(n - w_2 - rw_1 - 2j)(n - rw_1 - 2j)}</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\prod_{j=0}^{\\frac{r}{2}-1} 2^2 \\cdot \\frac{(w_2 - \\frac{rw_1}{2} - j)(n - w_2 - \\frac{rw_1}{2} - j)}{(n - rw_1 - 2j)^2} . \\tag{12}</span></div>

    <p class="text-gray-300">Now, for fixed j call  <span class="math">x = w_2 - \\frac{rw_1}{2} - j</span>  and  <span class="math">y = (n - w_2 - \\frac{rw_1}{2} - j)</span> . Observe</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{(w_2 - \\frac{rw_1}{2} - j)(n - w_2 - \\frac{rw_1}{2} - j)}{(n - rw_1 - 2j)(n - rw_1 - 2j)} = \\frac{xy}{(x + y)^2} = \\frac{xy}{(y - x)^2 + 4xy}.</span></div>

    <p class="text-gray-300">Instead of upper bounding this ratio, we find it easier to lower bound its reciprocal:</p>

    <p class="text-gray-300"><span id="page-48-0"></span> <span class="math-block">\\frac{(y-x)^2 + 4xy}{xy} = \\frac{(y-x)^2}{xy} + 4.</span></p>

    <p class="text-gray-300">Now, we have  <span class="math">xy \\leq (w_2 - \\frac{rw_1}{2})(n - w_2 - \\frac{rw_1}{2}) \\leq m(n - m) \\leq mn = n^{1+\\gamma}</span> , as  <span class="math">w_2 \\leq m \\leq n/2</span> . On the other hand,  <span class="math">(y - x) = (n - 2w_2) \\geq (n - 2m) \\geq \\xi n</span> , where this last inequality uses the assumption  <span class="math">n \\geq \\frac{2}{1-\\xi}m</span> . Hence,</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{(y-x)^2}{xy} \\ge \\frac{\\xi^2 n^2}{n^{1-\\gamma}} = \\xi^2 n^{1-\\gamma} \\ .</span></div>

    <p class="text-gray-300">Thus, we have the bound</p>

    <div class="my-4 text-center"><span class="math-block">(12) \\le \\prod_{j=0}^{\\frac{r}{2}-1} 4 \\cdot \\frac{1}{\\xi^2 n^{1-\\gamma} + 4} = \\prod_{j=0}^{\\frac{r}{2}-1} \\frac{1}{(\\xi/2)^2 n^{1-\\gamma} + 1}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\le \\prod_{j=0}^{\\frac{r}{2}-1} (2/\\xi)^2 n^{\\gamma-1} = (2/\\xi)^r n^{\\frac{r}{2}(\\gamma-1)} = (2/\\xi)^r n^{-(1+\\varepsilon)}</span></div>

    <p class="text-gray-300">where we used  <span class="math">\\gamma = 1 - \\frac{2}{r}(1+\\varepsilon)</span>  in the last equality. Finally, using the assumption  <span class="math">n \\ge \\frac{(2/\\xi)^{r/\\varepsilon}}{r^{1/\\varepsilon}} \\iff n^{\\varepsilon} \\ge \\frac{(2/\\xi)^r}{r}</span> , we have</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{n}{r} \\cdot (2/\\xi)^r n^{-(1+\\varepsilon)} = \\frac{(2/\\xi)^r}{r} n^{-\\varepsilon} \\le 1</span></div>

    <p class="text-gray-300">establishing that the terms in this summation over  <span class="math">w_1</span>  are indeed decreasing.</p>

    <p class="text-gray-300">Thus, we can conclude that the sum over  <span class="math">w_1</span>  in (11) is maximised by its first term  <span class="math">w_1 = 1</span> , so that we can upper-bound as follows:</p>

    <p class="text-gray-300"><span id="page-49-1"></span> <span class="math-block">(8) \\leq (10) + \\sum_{w_2=1}^{m} \\frac{\\binom{n-w_2}{d-\\lceil w_2/2\\rceil}}{\\binom{n}{d}} \\frac{1}{\\binom{n}{w_2}} \\cdot \\binom{w_2}{\\lceil w_2/2\\rceil} \\cdot \\frac{\\lceil w_2/2\\rceil}{w_2} \\cdot \\lfloor \\frac{2w_2}{r} \\rfloor \\cdot \\binom{n/r}{1} \\binom{r}{\\frac{r}{2}} \\binom{n-r}{w_2-r/2} \\cdot \\frac{r}{2}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\leq (10) + \\frac{n}{r} \\cdot \\binom{r}{\\frac{r}{2}} \\sum_{w_2=1}^{m} \\frac{\\binom{n-w_2}{d-\\lceil w_2/2\\rceil}}{\\binom{n}{d}} \\frac{\\binom{n-r}{w_2-r/2}}{\\binom{n}{w_2}} \\cdot \\binom{w_2}{\\lceil w_2/2\\rceil} \\cdot \\lceil w_2/2\\rceil , \\qquad (13)</span></div>

    <p class="text-gray-300">where we upper-bounded  <span class="math">\\lfloor \\frac{2w_2}{r} \\rfloor</span>  by removing the floor. We would like to bound the final sum over  <span class="math">w_2</span>  in a similar fashion. Unfortunately, this sum isn't maximized by its first or last term, but rather by some term in between. To find this term, we first simplify the sum somewhat. Specifically, we now observe that the sum over  <span class="math">w_2</span>  grows with  <span class="math">w_2</span>  for odd  <span class="math">w_2</span> , i.e. any term for odd  <span class="math">w_2</span>  can be upper-bound by its subsequent (and thus even) term  <span class="math">w_2 + 1</span> . By simplifying the sum in this manner, we will be able to bound it in a good way. But before we do that, let us justify our claim, by once again computing the ratio between subsequent terms in the sum, this time assuming  <span class="math">w_2</span>  is odd:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\frac{\\binom{n-(w_2+1)}{d-\\lceil \\frac{w_2+1}{2} \\rceil}}{\\binom{n-w_2}{d-\\lceil \\frac{w_2+1}{2} \\rceil}} &amp;= \\frac{\\binom{n-w_2-1}{d-\\frac{w_2+1}{2}}}{\\binom{n-w_2}{d-\\lceil \\frac{w_2+1}{2} \\rceil}} = \\frac{(n-w_2-1)! \\left(d-\\frac{w_2+1}{2}\\right)! \\left(n-d-w_2/2+\\frac{1}{2}\\right)!}{(n-w_2)! \\left(d-\\frac{w_2+1}{2}\\right)! \\left(n-d-w_2/2-\\frac{1}{2}\\right)!} &amp;= \\frac{n-d-w_2/2+\\frac{1}{2}}{n-w_2} \\;, \\\\ \\frac{\\binom{n-r}{w_2+1-\\frac{r}{2}}}{\\binom{n-r}{w_2-\\frac{r}{2}}} &amp;= \\frac{(n-r)! \\left(w_2-\\frac{r}{2}\\right)! \\left(n-w_2-\\frac{r}{2}\\right)!}{(n-r)! \\left(w_2-\\frac{r}{2}+1\\right)! \\left(n-w_2-\\frac{r}{2}-1\\right)!} &amp;= \\frac{n-w_2-\\frac{r}{2}}{w_2-\\frac{r}{2}+1} \\;, \\\\ \\frac{\\binom{n}{w_2}}{\\binom{n}{w_2+1}} &amp;= \\frac{n! \\cdot (w_2+1)! (n-w_2-1)!}{n! \\cdot w_2! \\cdot (n-w_2)!} &amp;= \\frac{w_2+1}{n-w_2} \\;, \\\\ \\frac{\\binom{w_2+1}{2}}{\\binom{w_2}{2}} &amp;= \\frac{\\binom{w_2+1}{2}}{\\binom{w_2}{2}} &amp;= \\frac{(w_2+1)! \\left(\\frac{w_2+1}{2}\\right)! \\left(\\frac{w_2-1}{2}\\right)!}{w_2! \\left(\\frac{w_2+1}{2}\\right)! \\left(\\frac{w_2-1}{2}\\right)!} &amp;= \\frac{(w_2+1)!}{\\binom{w_2+1}{2}} &amp;= 2 \\;, \\\\ \\frac{\\lceil \\frac{w_2+1}{2} \\rceil}{\\lceil w_2/2 \\rceil} &amp;= \\frac{\\frac{w_2+1}{2}}{\\frac{w_2+1}{2}} &amp;= 1 \\;. \\end{split}</span></div>

    <p class="text-gray-300">Combining these ratios gives us the following:</p>

    <p class="text-gray-300"><span id="page-49-0"></span> <span class="math-block">\\frac{n - d - w_2/2 + \\frac{1}{2}}{n - w_2} \\cdot \\frac{n - w_2 - \\frac{r}{2}}{w_2 - \\frac{r}{2} + 1} \\cdot \\frac{w_2 + 1}{n - w_2} \\cdot 2 \\cdot 1</span></p>

    <p class="text-gray-300"><span class="math-block">= \\frac{2(n - d) - w_2 + 1}{n - w_2} \\cdot \\frac{n - w_2 - \\frac{r}{2}}{n - w_2} \\cdot \\frac{w_2 + 1}{w_2 - \\frac{r}{2} + 1} .</span> (14)</p>

    <p class="text-gray-300">Recall that we need to show that the above expression (14) is > 1. To do so, we will use the following fact: if  <span class="math">x, y, z \\ge 0</span>  with  <span class="math">y \\ge x &gt; z</span> , then  <span class="math">\\frac{x}{x-z} \\cdot \\frac{y-z}{y} \\ge 1</span> . Indeed, we observe</p>

    <p class="text-gray-300"><span class="math-block">x(y-z) \\ge (x-z)y \\iff xy-xz \\ge xy-zy \\iff zy \\ge xz \\iff y \\ge x</span> .</p>

    <p class="text-gray-300">Applying this claim with  <span class="math">x := w_2 + 1</span> ,  <span class="math">y := n - w_2</span>  and  <span class="math">z := \\frac{r}{2}</span>  tells us that the product of the last two fractions in (14) are  <span class="math">\\geq 1</span> . To show that (14) > 1, it therefore suffices to show that the first</p>

    <p class="text-gray-300"><span id="page-50-1"></span>fraction is > 1:</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{2(n-d)-w_2+1}{n-w_2} \\ge \\frac{2(n-d)-w_2}{n-w_2} \\ge \\frac{2(n-d)}{n} &gt; 1</span></div>

    <p class="text-gray-300">where the second inequality follows from</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{a-x}{b-x} \\ge \\frac{a}{b} \\iff \\frac{(a-x) \\cdot b}{a \\cdot (b-x)} \\iff ab-xb \\ge ab-xa \\iff a \\ge b</span></div>

    <p class="text-gray-300">and the final inequality uses  <span class="math">2(n-d)=2(1-\\delta)n&gt;n</span>  since  <span class="math">\\delta&lt;1/2</span> .</p>

    <p class="text-gray-300">Thus, we have shown that any odd  <span class="math">w_2</span>  term in the sum over  <span class="math">w_2</span>  in (13) is smaller than its subsequent even  <span class="math">w_2</span> , allowing us to bound the odd terms by the subsequent even terms. To do so, let  <span class="math">w_2 := 2v_2</span>  so that we can write:</p>

    <div class="my-4 text-center"><span class="math-block">(8) \\leq (10) + \\frac{n}{r} \\cdot {r \\choose \\frac{r}{2}} \\sum_{w_2=1}^{m} \\frac{\\binom{n-w_2}{d-\\lceil w_2/2 \\rceil}}{\\binom{n}{d}} \\frac{\\binom{n-r}{w_2-r/2}}{\\binom{n}{w_2}} \\cdot {w_2 \\choose \\lceil w_2/2 \\rceil} \\cdot \\lceil w_2/2 \\rceil</span></div>

    <div class="my-4 text-center"><span class="math-block">\\leq (10) + \\frac{n}{r} \\cdot {r \\choose \\frac{r}{2}} \\sum_{v_2=1}^{\\lceil \\frac{m}{2} \\rceil} \\frac{\\binom{n-2v_2}{d-v_2}}{\\binom{n}{d}} \\frac{\\binom{n-r}{w_2-r/2}}{\\binom{n}{2v_2}} \\cdot {v_2 \\choose v_2} \\cdot v_2 . \\tag{15}</span></div>

    <p class="text-gray-300">To bound this expression, we will write out the binomials and then apply the following bound from [KZKJ08]</p>

    <p class="text-gray-300"><span id="page-50-0"></span> <span class="math-block">\\frac{N^{\\ell}}{\\varphi_N(\\ell)} \\le \\prod_{\\lambda=0}^{\\ell-1} (N-\\lambda) \\le N^{\\ell} \\tag{16}</span></p>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">\\varphi_N(\\ell) := \\exp\\left(\\frac{\\ell(\\ell-1)}{2N}\\right) \\; ,</span></div>

    <p class="text-gray-300">which gives us the following:</p>

    <div class="my-4 text-center"><span class="math-block">(8) = (10) + \\frac{n}{r} \\cdot {r \\choose \\frac{r}{2}} \\sum_{v_2=1}^{\\lceil \\frac{m}{2} \\rceil} \\frac{(n-2v_2)! \\cdot d! \\cdot (n-d)!}{n! \\cdot (d-v_2)! (n-d-v_2)!} \\cdot \\frac{(n-r)!(2v_2)! (n-2v_2)!}{n! \\cdot (2v_2 - \\frac{r}{2})! (n-2v_2 - \\frac{r}{2})!} \\cdot {2v_2 \\choose v_2} \\cdot v_2</span></div>

    <div class="my-4 text-center"><span class="math-block">= (10) + \\frac{n}{r} \\cdot {r \\choose \\frac{r}{2}} \\sum_{v_2=1}^{\\lceil \\frac{m}{2} \\rceil} \\frac{\\prod_{j=0}^{v_2-1} (d-j) \\prod_{j=0}^{v_2-1} (n-d-j)}{\\prod_{j=0}^{2v_2-1} (n-j)} \\cdot \\frac{\\prod_{j=0}^{\\frac{r}{2}-1} (2v_2 - j) \\prod_{j=0}^{\\frac{r}{2}-1} (n-2v_2 - j)}{\\prod_{j=0}^{r-1} (n-j)} \\cdot {2v_2 \\choose v_2} \\cdot v_2</span></div>

    <div class="my-4 text-center"><span class="math-block">\\leq (10) + \\frac{n}{r} \\cdot {r \\choose \\frac{r}{2}} \\sum_{v_2=1}^{\\lceil \\frac{m}{2} \\rceil} \\frac{d^{v_2} \\cdot (n-d)^{v_2}}{n^{2v_2}} \\cdot \\varphi_n(2v_2) \\cdot \\frac{(2v_2)^{\\frac{r}{2}} (n-2v_2)^{\\frac{r}{2}}}{n^r} \\cdot \\varphi_n(r) \\cdot {2v_2 \\choose v_2} \\cdot v_2 .</span></div>

    <p class="text-gray-300">To simplify this further, we note that the factor  <span class="math">\\frac{(n-2v_2)^{\\frac{r}{2}}}{n^{r/2}}</span>  will tend to 1 from below, and be extremely close to 1 for larger n, so we remove it (this vastly simplifies finding the maximizing term). Next, we bound the binomial involving  <span class="math">v_2</span>  using Lemma 9.4. We leave out the factor  <span class="math">\\varphi_n(2v_2)</span> , simply</p>

    <p class="text-gray-300"><span id="page-51-2"></span>bounding it as  <span class="math">\\varphi_n(2\\lceil m/2\\rceil)</span> . Finally, we recall that we defined  <span class="math">\\eta := 4\\delta(1-\\delta)</span> . Combing all this gives us the bound:</p>

    <div class="my-4 text-center"><span class="math-block">(8) \\leq (10) + n^{1-r/2} \\cdot \\frac{0.87206}{r} \\cdot \\binom{r}{\\frac{r}{2}} \\cdot \\varphi_n \\left( 2 \\cdot \\lceil \\frac{m}{2} \\rceil \\right) \\cdot \\varphi_n(r) \\sum_{v_2=1}^{\\lceil \\frac{m}{2} \\rceil} (2v_2)^{\\frac{r}{2}} \\cdot v_2 \\cdot \\frac{2^{2v_2}}{\\sqrt{2v_2}} \\cdot \\frac{d^{v_2} \\cdot (n-d)^{v_2}}{n^{2v_2}}</span></div>

    <div class="my-4 text-center"><span class="math-block">= (10) + n^{1-r/2} \\cdot \\frac{0.87206}{2r} \\cdot \\binom{r}{\\frac{r}{2}} \\cdot \\varphi_n \\left( 2 \\cdot \\lceil \\frac{m}{2} \\rceil \\right) \\cdot \\varphi_n(r) \\sum_{v_2=1}^{\\lceil \\frac{m}{2} \\rceil} (2v_2)^{\\frac{r+1}{2}} \\cdot \\eta^{v_2} .</span></div>

    <p class="text-gray-300">To maximize the expression depending on  <span class="math">v_2</span>  we rewrite it as</p>

    <div class="my-4 text-center"><span class="math-block">(2v_2)^{\\frac{r+1}{2}} \\cdot \\eta^{v_2} = \\exp\\left(\\frac{r+1}{2} \\cdot \\ln(2v_2) + v_2 \\cdot \\ln(\\eta)\\right)</span></div>

    <p class="text-gray-300">so that it suffices to maximize the exponent. We do this by setting its derivative to  <span class="math">v_2</span>  equal to 0:</p>

    <p class="text-gray-300"><span class="math-block">\\frac{r+1}{2} \\cdot \\frac{1}{v_2} + \\ln(\\eta) = 0 \\iff v_2 = \\frac{1+r}{2\\ln(1/\\eta)}</span> .</p>

    <p class="text-gray-300">Call this critical point  <span class="math">v_2^<em></span> . To see it is a maximizer, note that the second derivative  <span class="math">-\\frac{r+1}{2}v_2^{-2} &lt; 0</span>  for all  <span class="math">v_2 &gt; 0</span> . So,  <span class="math">v_2^</em></span>  is indeed the maximizer, so the final bound becomes:</p>

    <div class="my-4 text-center"><span class="math-block">(8) = (10) + n^{1-r/2} \\cdot \\left\\lceil \\frac{n^{\\gamma}}{2} \\right\\rceil \\cdot \\frac{0.43603}{r} \\cdot \\binom{r}{\\frac{r}{2}} \\cdot \\varphi_n \\left( 2 \\cdot \\left\\lceil \\frac{m}{2} \\right\\rceil \\right) \\cdot \\varphi_n(r) \\cdot \\left( 2v_2^* \\right)^{\\frac{r+1}{2}} \\cdot \\eta^{v_2^*} .</span></div>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">9.3 Given Successful First Stage, Probability Code has Good Distance</h3>

    <p class="text-gray-300">We now focus on the second half of (6). That is, we wish to bound</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{w_{1}=1}^{n/r} \\sum_{w_{2}=\\lceil n^{\\gamma} \\rceil}^{n} \\sum_{w_{3}=1}^{d} \\binom{n/r}{w_{1}} \\cdot \\frac{\\binom{rw_{1}}{rw_{1}/2} \\binom{n-rw_{1}}{w_{2}-rw_{1}/2}}{\\binom{n}{w_{2}}} \\cdot \\frac{\\binom{w_{2}}{rw_{2}/2} \\binom{n-w_{2}}{w_{3}-\\lceil w_{2}/2 \\rceil}}{\\binom{n}{w_{3}}} \\cdot \\frac{\\lceil rw_{1}/2 \\rceil \\cdot \\lceil w_{2}/2 \\rceil}{w_{2}w_{3}} . \\tag{17}</span></div>

    <p class="text-gray-300"><span id="page-51-1"></span></p>

    <p class="text-gray-300">To do this, we more directly exploit analysis of Kliewer et al. [KZKJ08]. In particular, we consider the following function (as they do):</p>

    <div class="my-4 text-center"><span class="math-block">f(\\alpha,\\beta,\\rho) := \\frac{H(\\alpha)}{r} - H(\\beta) - H(\\rho) + \\alpha + (1-\\alpha)H\\left(\\frac{\\beta - \\alpha/2}{1-\\alpha}\\right) + \\beta + (1-\\beta)H\\left(\\frac{\\rho - \\beta/2}{1-\\beta}\\right) \\ .</span></div>

    <p class="text-gray-300">In the above, we've used  <span class="math">H(\\cdot)</span>  to denote the binary entropy function, which we recall is defined on the interval [0,1] via</p>

    <div class="my-4 text-center"><span class="math-block">H(p) := -p \\log_2 p - (1-p) \\log_2 (1-p)</span></div>

    <p class="text-gray-300">for  <span class="math">p \\in (0,1)</span>  and extended by continuity to the endpoints: H(0) = H(1) = 0.</p>

    <p class="text-gray-300">The motivation for the definition of f stems from the following approximation. Fix  <span class="math">w_1, w_2</span>  and  <span class="math">w_3</span>  in (17), and consider the corresponding term in the sums. Set now  <span class="math">\\alpha = \\frac{rw_1}{n}</span> ,  <span class="math">\\beta = \\frac{w_2}{n}</span>  and  <span class="math">\\rho = \\frac{w_3}{n}</span> , the relative Hamming weights of the corresponding vectors (in the case of  <span class="math">w_1</span> , note this is</p>

    <p class="text-gray-300"><span id="page-52-0"></span>the weight after repeating the message vector). We argue below that we can then write the term as n O(1) · 2 n·f(α,β,ρ) . Thus, we could hope to argue the following: suppose that f(α, β, ρ) < 0 for all admissible α, β, ρ, with maximal value f ∗ , where admissibility is determined by <a href="#page-43-1">Lemma 9.3.</a> Then the bound would be n O(1) · 2 n·f ∗ , and it's reasonable to hope for the second term to overwhelm the first.</p>

    <p class="text-gray-300">So, we look to maximise f over the set of (α, β, ρ) satisfying 0 < α ≤ min{2β, 2 − 2β}, 0 < β ≤ {2ρ, 2 − 2ρ} and 0 < ρ ≤ δ. To do so, we start (see <a href="#page-57-0">Claim 9.9.1\\)</a> by showing that f grows monotonically with ρ, so that to maximise f we can simply set ρ := δ (recall that δ is our target minimum distance). This leaves us with the maximisation of f over α, β; we visualise the admissible region R ⊆ R <sup>2</sup> of points (α, β) as a triangle in <a href="#page-51-1">Section 9.3.</a></p>

    <p class="text-gray-300"><img src="_page_52_Figure_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Figure 5: The region over which we look to maximize f, where ρ = δ is fixed. In fact we assume δ < 1/4 in this image, so that the constraints α ≤ 2−2β and β ≤ 2−2δ can be removed. However, f(0, 0, δ) = 0, so a na¨ıve analysis will not work. The blue curve shows the points for which ∂f ∂α = 0 and the red curve shows the points for which ∂f ∂β = 0.</p>

    <p class="text-gray-300">It was already shown by [\\[KZKJ08\\]](#page-81-10) that all points in this region with α, β > 0 are indeed negative, so that for large enough n almost all codes attain this minimum distance δ (assuming one picks a small enough target minimum distance δ). However, their analysis doesn't specify which point is the maximizer. Indeed, the region R is not compact, so that finding a maximizer might not even be possible. In particular, the supremum value of f on R will be at least 0, as f(0, 0, δ) = 0 and (0, 0) is an accumulation point of R.</p>

    <p class="text-gray-300">Our contribution is to show that we can indeed find a maximum once we restrict the set of admissible (α, β). We can then use this maximum to bound each term in the expectation <a href="#page-51-1">\\(17\\)</a> and give a concrete bound on the error probability of sampling a code with minimum distance δ, even for concrete n. Let us give a brief high-level overview of our argument first.</p>

    <p class="text-gray-300">Note that for fixed n the region over which we maximize does become compact: the permissible points (α, β) can't be real numbers arbitrarily close to 0 anymore, but must be at least α<sup>0</sup> := r/n and β<sup>0</sup> := r/(2n). Visually, this shrinks our triangle, cutting off a slice on the left, containing the ranges 0 < α < r/n and 0 < β < r/(2n).</p>

    <p class="text-gray-300"><span id="page-53-2"></span>This space must then be maximized by a critical point (i.e. an admissible pair  <span class="math">(\\alpha, \\beta)</span>  with  <span class="math">\\alpha \\geq r/n</span>  and  <span class="math">\\beta \\geq r/(2n)</span>  at which both  <span class="math">\\frac{\\partial f}{\\partial \\alpha}</span>  and  <span class="math">\\frac{\\partial f}{\\partial \\beta}</span>  equal 0) or a point on the boundary. Thanks to [KZKJ08], we know an algebraic relation that critical points must satisfy, which in particular implies there are only a constant number of them (and moreover they can be explicitly computed). Specifically, the red line drawn in Figure 9.3 represents the points where the derivative to  <span class="math">\\alpha</span>  is 0 and the blue line represents the points where the derivative to  <span class="math">\\beta</span>  is 0. Their points of intersection are the critical points of f.<sup>27</sup></p>

    <p class="text-gray-300">We will argue that the restrictions of f to either  <span class="math">\\alpha</span>  or  <span class="math">\\beta</span>  (i.e. horizontal or vertical restrictions of the region) are strictly concave. This means that any horizontal "slice" of our region will be maximized by the intersection point of the slice and the blue curve; any vertical "slice" will be maximized by the intersection of the slice and the red curve. We will show that for most  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span>  the red and blue curves lie strictly in the interior of the region. It follows that the boundaries (a), (b) and (c) cannot contain maximizers for f.</p>

    <p class="text-gray-300">The only exception is tiny  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span> . At the very bottom-left, the blue curve exits the interior of the triangle at  <span class="math">(\\alpha_0, \\beta_1)</span>  where  <span class="math">\\beta_1 = \\Omega(n^{-2/r})</span> . Consider now the very bottom of boundary (a) where  <span class="math">\\beta &lt; \\beta_1</span> . A horizontal slice of the region at such a  <span class="math">\\beta</span>  has a critical point on the blue curve. But since this curve is now to the left of our triangle, the maximizer instead becomes the left-most point:  <span class="math">\\alpha_0</span> . This means the points  <span class="math">(\\alpha_0, \\beta)</span>  for  <span class="math">\\beta &lt; \\beta_1</span>  are potential maximizers of f. However, we will argue that f is decreasing with  <span class="math">\\beta</span>  on this range, so that the only potential maximizer is the bottom-left corner of the triangle  <span class="math">(\\alpha_0, \\beta_0)</span> .</p>

    <p class="text-gray-300"><img src="_page_53_Figure_3.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><span id="page-53-1"></span>Figure 6: The region  <span class="math">\\mathcal{R}&#x27;</span>  that we optimize the function f over (again for  <span class="math">\\delta &lt; 1/4</span> ). Notably, we require  <span class="math">\\alpha \\geq \\alpha_0 = r/n</span>  and  <span class="math">\\beta \\geq \\beta_0 = n^{\\gamma-1}</span> , that is, we have a little gap between the axes and the region  <span class="math">\\mathcal{R}&#x27;</span> . Furthermore the region  <span class="math">\\mathcal{R}&#x27;</span>  is now <em>compact</em>. The blue curve, representing the values for which  <span class="math">\\frac{\\partial f}{\\partial \\alpha} = 0</span> , crosses the boundary (a) at some point  <span class="math">\\beta_1 \\geq \\beta_0</span> .</p>

    <p class="text-gray-300">In short, either the bottom-left point or a critical point maximizes f. Unfortunately, the value of</p>

    <p class="text-gray-300"><span id="page-53-0"></span><sup>&</sup>lt;sup>27</sup>For r = 4 these curves are quadratic. For different r they are polynomials of differing degrees. Our drawing just serves to provide some intuition, and doesn't exactly represent the curves for any r.</p>

    <p class="text-gray-300">f at this bottom-left point is so close to 0 that it doesn't suffice to provide small error probability,<sup>28</sup> making this approach unusable as is. However, recall that we have  <span class="math">w_2 \\geq n^{\\gamma}</span>  so that  <span class="math">\\beta \\geq n^{\\gamma-1}</span> . It turns out that this increase of  <span class="math">\\beta</span>  decreases f enough to make this approach usable. Visually, this removes the left-most part of the triangle. This turns our original triangle-shaped region into a quadrilateral-shaped region. We visualise this region in Figure 6.</p>

    <p class="text-gray-300">The analysis remains as above: though we add a new boundary (e), since this boundary lies strictly below  <span class="math">\\beta_1</span>  (as  <span class="math">\\beta_0 = n^{\\gamma-1} &lt; \\beta_1 = \\Omega(n^{-2/r})</span>  for our choice of  <span class="math">\\gamma</span> ), we can still argue that the bottom-left point  <span class="math">(\\alpha_0, \\beta_0) = (r/n, n^{\\gamma-1})</span>  is the only maximizer beyond the critical points in the region. Since the critical points are independent of n, while the bottom-left point decreases with n, for large enough n the bottom-left point is always the maximizer (assuming  <span class="math">\\delta</span>  is not too large (depending on r). The final bound will be  <span class="math">n^{O(1)} \\cdot 2^{f(\\alpha_0,\\beta_0,\\delta)n} = n^{O(1)} \\cdot 2^{-\\Omega(n^{\\gamma})} = 2^{-\\Omega(n^{\\gamma})}</span> , using an estimate  <span class="math">f(\\alpha_0,\\beta_0,\\delta) = -\\Omega(n^{\\gamma})</span>  which we establish. All in all, we derive the following proposition.</p>

    <p class="text-gray-300"><span id="page-54-1"></span><strong>Proposition 9.6.</strong> Let  <span class="math">r, n \\in \\mathbb{N}</span>  with  <span class="math">r \\geq 3</span>  and  <span class="math">r \\mid n</span> ,  <span class="math">\\delta \\in (0, 1/2)</span>  s.t.  <span class="math">d := \\delta n \\in \\mathbb{N}</span> ,  <span class="math">\\gamma = 1 - \\frac{2}{r}(1 + \\varepsilon)</span>  for some  <span class="math">\\varepsilon &gt; 0</span> . Define  <span class="math">\\alpha_0 := \\frac{r}{n}</span>  and  <span class="math">\\beta_0 := n^{\\gamma - 1}</span> . Assume</p>

    <div class="my-4 text-center"><span class="math-block">\\beta_1 = \\frac{1}{2} - \\frac{1 - \\alpha_0}{2} \\sqrt{1 - \\left(\\frac{\\alpha_0}{1 - \\alpha_0}\\right)^{2/r}} &gt; \\beta_0 \\ , \\quad \\sqrt{4\\delta(1 - \\delta)} &lt; 1 - 2\\beta_1 - \\frac{\\alpha_0}{2\\beta_0} \\quad and \\quad n^\\gamma \\ge 101 \\ .</span></div>

    <p class="text-gray-300">Then</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{w_1}^{n/r} \\sum_{w_2 = \\lfloor n^{\\gamma} \\rfloor + 1}^{n} \\sum_{w_3 = 1}^{d} \\binom{n/r}{w_1} \\cdot \\frac{\\binom{rw_1}{\\lceil rw_1/2 \\rceil} \\binom{n - rw_1}{w_2 - \\lceil rw_1/2 \\rceil}}{\\binom{n}{w_2}} \\cdot \\frac{\\binom{w_2}{\\lceil w_2/2 \\rceil} \\binom{n - w_2}{w_3 - \\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{\\lceil rw_1/2 \\rceil \\cdot \\lceil w_2/2 \\rceil}{w_2 w_3} \\\\ \\leq \\frac{0.80192 \\cdot \\delta}{r^{3/2}} \\cdot n^{7/2} \\cdot \\max_{(\\alpha, \\beta) \\in \\mathcal{R}&#x27;} 2^{f(\\alpha, \\beta, \\delta)n} \\\\ \\leq \\frac{0.80192 \\cdot \\delta}{r^{3/2}} \\cdot n^{7/2} \\cdot 2^{Bn} , \\tag{18}</span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">B = \\max\\{f(\\alpha_0, \\beta_0, \\delta), \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in \\mathrm{CP}(r, \\delta)\\}\\}.</span></div>

    <p class="text-gray-300">Above,  <span class="math">CP(r, \\delta)</span>  is the set of critical points of f in  <span class="math">\\mathcal{R}&#x27;</span>  given r and  <span class="math">\\delta</span> , i.e. the set of  <span class="math">(\\alpha, \\beta)</span>  satisfying equations (19) and (20). In particular, if f is negative on all critical points then for sufficiently large n the bound is</p>

    <p class="text-gray-300"><span id="page-54-2"></span> <span class="math-block">\\frac{0.80192 \\cdot \\delta}{r^{3/2}} \\cdot n^{7/2} \\cdot 2^{f(\\alpha_0, \\beta_0, \\delta)n} \\le 2^{-\\Omega(n^{\\gamma})}.</span></p>

    <p class="text-gray-300"><strong>Remark 9.7.</strong> We remark that in the above we do not require r even, nor do we require  <span class="math">\\delta &lt; 1/3</span> ; only Proposition 9.5 requires these bounds.</p>

    <p class="text-gray-300">Before diving into the proof of this proposition, we quickly justify that the constraints are met for large enough n. Clearly the constraint  <span class="math">n^{\\gamma} \\geq 101</span>  just requires large enough n. Furthermore as  <span class="math">\\delta &lt; 1/2</span>  we have  <span class="math">\\sqrt{4\\delta(1-\\delta)} \\leq 1 - \\Omega(1)</span>  whereas  <span class="math">1 - 2\\beta_1 - \\frac{\\alpha_0}{2\\beta_0} = 1 - O(n^{-r/2}) - O(n^{-\\gamma})</span> , so the second requirement is met for reasonable n. For the constraint involving  <span class="math">\\beta_1</span> :</p>

    <p class="text-gray-300"><span id="page-54-0"></span><sup>&</sup>lt;sup>28</sup>We observe that  <span class="math">f(r/n, r/(2n), \\delta) \\approx -\\ln(n)/n</span> , so then  <span class="math">2^{nf(r/n, r/(2n), \\delta)} \\approx 1/n^{\\ln 2} \\approx 1/n^{0.3}</span>  which will not overcome the poly(n) overhead from the union bound.</p>

    <p class="text-gray-300">Claim 9.7.1. Let  <span class="math">r, n, \\delta, \\varepsilon, \\gamma, \\alpha_0, \\beta_0</span>  be as in Proposition 9.6. Then  <span class="math">\\beta_1 = \\Theta(n^{-2/r})</span> , so for large enough  <span class="math">n, \\beta_0 = n^{\\gamma-1} = n^{-\\frac{2}{r}(1+\\varepsilon)} &lt; \\beta_1</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> We have</p>

    <div class="my-4 text-center"><span class="math-block">\\beta_1 \\ge \\frac{1}{2} - \\frac{1 - r/n}{2} \\left( 1 - \\frac{1}{2} \\left( \\frac{r/n}{1 - r/n} \\right)^{2/r} \\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\frac{1}{2} - \\frac{1}{2} + \\frac{1}{2} \\left( \\frac{r/n}{1 - r/n} \\right)^{2/r} + \\frac{r}{2n} - \\frac{1}{4} \\frac{(r/n)^{1+2/r}}{(1 - r/n)^{2/r}} = \\Omega(n^{-2/r}) ,</span></div>

    <p class="text-gray-300">where we use  <span class="math">\\sqrt{1-x} \\le 1-x/2</span>  for all  <span class="math">x \\in [0,1]</span> . Similarly, using  <span class="math">\\sqrt{1-x} \\ge 1-x</span>  one can also establishes  <span class="math">\\beta_1 \\le O(n^{-2/r})</span> , so we conclude  <span class="math">\\beta_1 = \\Theta(n^{-2/r})</span> .</p>

    <p class="text-gray-300">We now turn to the proof of Proposition 9.6.</p>

    <p class="text-gray-300">of Proposition 9.6. We start by showing that we can indeed bound the expectation as (18). We then turn to the maximization of f, and show that it is indeed maximized by one of the points in the set B.</p>

    <p class="text-gray-300">To bound the expression inside the sums, we rewrite the binomials using Lemma 9.4, with the goal of writing this expression as  <span class="math">poly(n) \\cdot 2^{n \\cdot f(\\alpha, \\beta, \\delta)}</span> . After doing so, we work out the poly(n) factors we pick up in the process. We then write out the poly(n)-part of the binomials, and finally remove the sums. We thus write the expression in the sums as</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{pmatrix} n/r \\\\ w_1 \\end{pmatrix} \\cdot \\frac{\\binom{rw_1}{\\lceil rw_1/2 \\rceil} \\binom{n-rw_1}{w_2 - \\lceil rw_1/2 \\rceil}}{\\binom{n}{w_2}} \\cdot \\frac{\\binom{w_2}{\\lceil w_2/2 \\rceil} \\binom{n-w_2}{w_3 - \\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{\\lceil rw_1/2 \\rceil \\cdot \\lceil w_2/2 \\rceil}{w_2 w_3}</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\operatorname{poly}(n) \\cdot \\frac{2^{n/rH \\left(\\frac{w_1}{n/r}\\right)} 2^{(n-rw_1)H \\left(\\frac{w_2 - \\lceil rw_1/2 \\rceil}{n-rw_1}\\right)} 2^{rw_1H \\left(\\frac{\\lceil rw_1/2 \\rceil}{rw_1}\\right)} 2^{w_2H \\left(\\frac{\\lceil w_2/2 \\rceil}{w_2}\\right)} 2^{(n-w_2)H \\left(\\frac{w_3 - \\lceil w_2/2 \\rceil}{n-w_2}\\right)}}{2^{nH \\left(\\frac{w_3}{n}\\right)} 2^{nH \\left(\\frac{w_3}{n}\\right)}}</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\operatorname{poly}(n) \\cdot \\frac{2^{n/rH(\\alpha)} 2^{n(1-\\alpha)H \\left(\\frac{w_2 - \\lceil rw_1/2 \\rceil}{n(1-\\alpha)}\\right)} 2^{n\\alpha H \\left(\\frac{\\lceil rw_1/2 \\rceil}{rw_1}\\right)} 2^{n\\beta H \\left(\\frac{\\lceil w_2/2 \\rceil}{w_2}\\right)} 2^{n(1-\\beta)H \\left(\\frac{w_3 - \\lceil w_2/2 \\rceil}{n(1-\\beta)}\\right)}}{2^{nH(\\beta)} 2^{nH(\\rho)}}</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\operatorname{poly}(n) \\cdot 2^{n \\left(\\frac{H(\\alpha)}{r} + (1-\\alpha)H \\left(\\frac{w_2 - \\lceil rw_1/2 \\rceil}{n(1-\\alpha)}\\right) + \\alpha H \\left(\\frac{\\lceil rw_1/2 \\rceil}{rw_1}\\right) + \\beta H \\left(\\frac{\\lceil w_2/2 \\rceil}{w_2}\\right) + (1-\\beta)H \\left(\\frac{w_3 - \\lceil w_2/2 \\rceil}{n(1-\\beta)}\\right) - H(\\beta) - H(\\rho)}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\leq \\operatorname{poly}(n) \\cdot 2^{n \\left(\\frac{H(\\alpha)}{r} + (1-\\alpha)H \\left(\\frac{\\beta - \\frac{\\alpha}{2}}{1-\\alpha}\\right) + \\alpha + \\beta + (1-\\beta)H \\left(\\frac{\\rho - \\frac{\\beta}{2}}{1-\\beta}\\right) - H(\\beta) - H(\\rho)}</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\operatorname{poly}(n) \\cdot 2^{f(\\alpha,\\beta,\\rho)n} .</span></div>

    <p class="text-gray-300">where the inequality follows because we can upper-bound the second and third H containing a ceiling by H(1/2). The fact that we can remove the other two ceilings is somewhat harder to see. It is not to hard to see that for  <span class="math">\\delta &lt; 1/4</span>  we can remove these ceilings safely using the following lemma.</p>

    <p class="text-gray-300"><strong>Lemma 9.8.</strong> If x < 1/2 then  <span class="math">\\frac{x - \\frac{y}{2}}{1 - y} &lt; 1/2</span>  for any  <span class="math">y \\in (0, 1)</span> .</p>

    <div class="my-4 text-center"><span class="math-block">Proof. \\ \\frac{x-\\frac{y}{2}}{1-y} &lt; 1/2 \\iff x-\\frac{y}{2} &lt; \\frac{1-y}{2} \\iff x &lt; \\frac{1}{2} \\ . \\ \\Box</span></div>

    <p class="text-gray-300">The two ceiling terms we wish to bound indeed have the form  <span class="math">\\frac{x-\\frac{y}{2}}{1-y} - \\epsilon</span>  denoted in the lemma, where in the first one  <span class="math">x = w_2</span>  and in the second one  <span class="math">x = w_3</span> . Thus it follows from the lemma that if  <span class="math">\\rho &lt; 1/2</span>  and  <span class="math">\\beta &lt; 1/2</span> , the small decrease from the ceiling only makes  <span class="math">H(\\frac{x-\\frac{y}{2}}{1-y} - \\epsilon)</span>  smaller, so that we can upper-bound by just removing the ceilings as we did above. However, note that to achieve  <span class="math">\\beta &lt; 1/2</span> , we need our assumption that  <span class="math">\\rho \\le \\delta &lt; 1/4</span> .</p>

    <p class="text-gray-300">In other words, if we are willing to 'settle' for a minimum distance of at most 1/4 then we are free to remove the ceilings at no extra cost. However, if we want to go to a higher minimum distance we can't just remove the ceilings. In these cases, we might be on the right-side of the binary entropy function, where a decrease by  <span class="math">\\epsilon</span>  may increase the output of h. In those cases, we need to bound potential increase caused by the ceiling. By carefully doing this, it turns out that as long as  <span class="math">\\delta &lt; 1/2</span>  we can still remove the ceilings with minor cost.</p>

    <p class="text-gray-300">Lemma 9.9. <span class="math-block">H(a - \\epsilon) \\le H(a) + \\epsilon \\cdot \\log\\left(\\frac{a}{1-a}\\right)</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Note that we can suppose that a > 1/2, or more specifically that  <span class="math">a &gt; \\frac{1-\\epsilon}{2}</span> , as for any smaller value of a we already know that a decrease in  <span class="math">\\epsilon</span>  will decrease h. Let  <span class="math">P_a(x)</span>  be the first-order Taylor polynomial  <span class="math">P_a(x)</span>  of H at point a, and let R(x) be the amount by which the Taylor approximation is off, i.e.  <span class="math">H(x) = P_a(x) + R(x)</span> . We can then write</p>

    <div class="my-4 text-center"><span class="math-block">H(a - \\epsilon) - H(a) = P_a(a - \\epsilon) - P_a(a) + R(a - \\epsilon).</span></div>

    <p class="text-gray-300">The Taylor polynomial  <span class="math">P_a</span>  is of course equal to</p>

    <p class="text-gray-300"><span class="math-block">P_a(x) := H(a) + \\frac{h&#x27;(a)}{1!}(x-a) = H(a) + \\log\\left(\\frac{1-a}{a}\\right)(x-a)</span> ,</p>

    <p class="text-gray-300">and the error term is equal to</p>

    <div class="my-4 text-center"><span class="math-block">R(x) \\le \\frac{h&#x27;&#x27;(\\xi)}{2}(x-a)^2 = \\frac{(x-a)^2}{4\\ln(2)\\xi(\\xi-1)}</span></div>

    <p class="text-gray-300">for some  <span class="math">\\xi \\in (a - \\epsilon, a)</span> . Since  <span class="math">\\xi - 1 &lt; 0</span> , the denominator is always negative. Since the numerator is a square it is always positive. It follows that the error term is negative, so that we are free to ignore it. This means we end up with</p>

    <div class="my-4 text-center"><span class="math-block">H(a - \\epsilon) - H(a) = P_a(a - \\epsilon) - P_a(a) + R(a - \\epsilon)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\leq P_a(a - \\epsilon) - P_a(a)</span></div>

    <div class="my-4 text-center"><span class="math-block">= H(a) + \\log\\left(\\frac{1 - a}{a}\\right)((a - \\epsilon) - a) - H(a)</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\epsilon \\cdot \\log\\left(\\frac{a}{1 - a}\\right).</span></div>

    <p class="text-gray-300">In our case, the expression we want to bound is  <span class="math">H\\left(\\frac{w_3-\\lceil w_2/2\\rceil}{n(1-\\beta)}\\right)</span>  (and the analogous expression where  <span class="math">w_3</span>  becomes  <span class="math">w_2</span>  and  <span class="math">w_2</span>  becomes  <span class="math">rw_1</span> ). Again, in case  <span class="math">w_2</span>  is even this expression simplifies directly to  <span class="math">H\\left(\\frac{\\rho-\\frac{\\beta}{2}}{1-\\beta}\\right)</span> . However, when  <span class="math">w_2</span>  is odd we get</p>

    <div class="my-4 text-center"><span class="math-block">H\\left(\\frac{w_3 - \\lceil w_2/2 \\rceil}{n(1-\\beta)}\\right) = H\\left(\\frac{w_3 - \\frac{w_2+1}{2}}{n(1-\\beta)}\\right) = H\\left(\\frac{\\rho - \\frac{\\beta}{2}}{1-\\beta} - \\frac{1}{2n(1-\\beta)}\\right).</span></div>

    <p class="text-gray-300">We then apply the just-proven lemma with  <span class="math">a = \\frac{\\rho - \\frac{\\beta}{2}}{1-\\beta}</span>  and  <span class="math">\\epsilon = \\frac{1}{2n(1-\\beta)}</span>  to get</p>

    <div class="my-4 text-center"><span class="math-block">H(a - \\epsilon) - H(a) \\le \\epsilon \\log \\left(\\frac{a}{1 - a}\\right) = \\epsilon \\log \\left(\\frac{\\frac{\\rho - \\frac{\\beta}{2}}{1 - \\beta}}{1 - \\frac{\\rho - \\frac{\\beta}{2}}{1 - \\beta}}\\right) = \\epsilon \\log \\left(\\frac{\\rho - \\frac{\\beta}{2}}{1 - \\frac{\\beta}{2} - \\rho}\\right).</span></div>

    <p class="text-gray-300">We would like the above to be negative, as then the ceiling causes no increase at all. The above is negative whenever the fraction inside the log is at most 1, which is true exactly when</p>

    <div class="my-4 text-center"><span class="math-block">\\rho - \\beta/2 &lt; 1 - \\beta/2 - \\rho \\iff 2\\rho \\le 1 \\iff \\rho &lt; 1/2 \\ .</span></div>

    <p class="text-gray-300">In other words, for any  <span class="math">\\delta &lt; 1/2</span>  we can safely the ceilings without suffering any additional increase. Next, we tackle the  <span class="math">\\operatorname{poly}(n)</span> -factors in the above expression. We make use of the bound  <span class="math">\\frac{\\lceil rw_1/2\\rceil \\lceil w_2/2\\rceil}{w_2w_3} = \\frac{\\lceil rw_1/2\\rceil \\lceil w_2/2\\rceil}{w_3} \\frac{\\lceil w_2/2\\rceil}{w_2} \\le \\frac{\\lceil \\frac{4w_3}{2} \\rceil}{w_3} \\cdot \\frac{101}{100} \\le \\frac{102}{100}</span> . This is true because  <span class="math">rw_1 \\le 4w_3</span> , and as long as  <span class="math">w_2 \\ge 101</span>  as  <span class="math">w_2 \\ge n^\\gamma \\ge 101</span>  by assumption. We can then write the  <span class="math">\\operatorname{poly}(n)</span> -factors as follows (for some binomials we keep the  <span class="math">\\sqrt{\\frac{n}{k(n-k)}}</span> -factor from Lemma 9.4 to help us out, while for other binomials we don't bother, as it won't help us much):</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{pmatrix} n/r \\\\ w_1 \\end{pmatrix} \\cdot \\frac{\\binom{rw_1}{\\lceil rw_1/2 \\rceil} \\binom{n-rw_1}{w_2-\\lceil rw_1/2 \\rceil}}{\\binom{n}{w_2}} \\cdot \\frac{\\binom{w_2}{\\lceil w_2/2 \\rceil} \\binom{n-w_2}{w_3-\\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{\\lceil rw_1/2 \\rceil \\cdot \\lceil w_2/2 \\rceil}{w_2w_3}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\leq 2^{f(\\alpha,\\beta,\\rho)n} \\cdot \\frac{102}{100} \\cdot \\frac{0.61664^3 \\cdot 0.43603^2}{0.33675 \\cdot 0.67352} \\cdot \\frac{\\sqrt{\\frac{rw_1}{\\lceil rw_1/2 \\rceil (rw_1-\\lceil rw_1/2 \\rceil)}} \\cdot \\sqrt{\\frac{w_2}{\\lceil w_2/2 \\rceil (w_2-\\lceil w_2/2 \\rceil)}}}{\\sqrt{\\frac{n}{w_2(n-w_2)}} \\cdot \\frac{1}{\\sqrt{n}}}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\leq \\frac{102}{100} \\cdot \\frac{0.61664^3 \\cdot 0.43603^2}{0.33675 \\cdot 0.67352} \\cdot 2^{f(\\alpha,\\beta,\\rho)n} \\cdot \\sqrt{\\frac{4}{rw_1}} \\cdot \\frac{4}{w_2} \\cdot \\frac{w_2(n-w_2)}{n} \\cdot n</span></div>

    <div class="my-4 text-center"><span class="math-block">\\leq \\frac{102}{100} \\cdot \\frac{4 \\cdot 0.61664^3 \\cdot 0.43603^2}{0.33675 \\cdot 0.67352} \\cdot \\frac{1}{\\sqrt{r}} \\cdot 2^{f(\\alpha,\\beta,\\rho)n} \\cdot \\sqrt{n-w_2}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\leq \\frac{0.80192}{\\sqrt{r}} \\cdot \\sqrt{n} \\cdot 2^{f(\\alpha,\\beta,\\rho)n} .</span></div>

    <p class="text-gray-300">Putting these two bounds together gives us the proposed bound (18) on the expectation:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} &amp;\\sum_{w_1=1}^{n/r} \\sum_{w_2=m+1}^n \\sum_{w_3=1}^d \\binom{n/r}{w_1} \\cdot \\frac{\\binom{rw_1}{\\lceil rw_1/2 \\rceil} \\binom{n-rw_1}{w_2-\\lceil rw_1/2 \\rceil}}{\\binom{n}{w_2}} \\cdot \\frac{\\binom{w_2}{\\lceil w_2/2 \\rceil} \\binom{n-w_2}{w_3-\\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{\\lceil rw_1/2 \\rceil \\cdot \\lceil w_2/2 \\rceil}{w_2w_3} \\\\ &amp;\\leq \\sum_{w_1=1}^{n/r} \\sum_{w_2=m+1}^n \\sum_{w_3=1}^d \\frac{0.80192}{\\sqrt{r}} \\cdot \\sqrt{n} \\cdot 2^{f\\left(\\frac{rw_1}{n}, \\frac{w_2}{n}, \\frac{w_3}{n}\\right)n} \\\\ &amp;\\leq \\frac{0.80192 \\cdot \\delta}{\\sqrt{r}} \\cdot n^{3/2} \\sum_{w_1=1}^{n/r} \\sum_{w_2=m+1}^n 2^{f\\left(\\frac{rw_1}{n}, \\frac{w_2}{n}, \\delta\\right)n} \\\\ &amp;\\leq \\frac{0.80192 \\cdot \\delta}{r^{3/2}} \\cdot n^{7/2} \\cdot \\max_{(\\alpha,\\beta) \\in \\mathcal{R}&#x27;} 2^{f(\\alpha,\\beta,\\delta)n} \\; . \\end{split}</span></div>

    <p class="text-gray-300"><span id="page-57-0"></span>Note that the second inequality uses the fact that f grows monotonically with  <span class="math">\\rho</span>  for  <span class="math">\\rho &lt; 1/2</span> , which we prove below.</p>

    <p class="text-gray-300"><span id="page-58-4"></span>Claim 9.9.1. For fixed admissible α, β, the function f is growing with ρ.</p>

    <p class="text-gray-300">Proof. We show that the derivative of f with respect to ρ is positive when ρ < 0.5:</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{\\partial f}{\\partial \\rho} = \\log \\left( \\frac{1 - \\rho - \\beta/2}{\\rho - \\beta/2} \\right) - \\log \\left( \\frac{1 - \\rho}{\\rho} \\right) &gt; 0</span></div>

    <div class="my-4 text-center"><span class="math-block">\\iff \\frac{1 - \\rho - \\beta/2}{\\rho - \\beta/2} &gt; \\frac{1 - \\rho}{\\rho}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\iff \\rho (1 - \\rho - \\beta/2) &gt; (1 - \\rho)(\\rho - \\beta/2)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\iff \\rho - \\rho^2 - \\rho\\beta/2 &gt; \\rho - \\rho^2 - \\beta/2 + \\rho\\beta/2</span></div>

    <div class="my-4 text-center"><span class="math-block">\\iff \\beta/2 &gt; \\rho\\beta</span></div>

    <div class="my-4 text-center"><span class="math-block">\\iff 0.5 &gt; \\rho.</span></div>

    <p class="text-gray-300">Having established the bound, we turn to the maximisation of f over α, β, where we recall the constraints n <sup>γ</sup>−<sup>1</sup> ≤ β ≤ 2δ and r/n ≤ α ≤ 2β. We visualised this region R′ of permissible points (α, β) in Figure <a href="#page-53-1">6.</a> This is a compact space, and since f is continuous it is maximized either by a critical point or some point on the boundary. As explained above, [\\[KZKJ08\\]](#page-81-10) computed the partial derivatives of f with respect to α and β, and provide us equations satisfied by the critical points:</p>

    <p class="text-gray-300"><span id="page-58-1"></span><span id="page-58-0"></span> <span class="math-block">\\frac{\\partial f}{\\partial \\alpha} = 0 \\iff \\beta = \\frac{1}{2} \\pm \\frac{1 - \\alpha}{2} \\sqrt{1 - \\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{2/r}} \\tag{19}</span></p>

    <p class="text-gray-300">where the root using − yields β < 1/2 and the root using + yields β > 1/2, and</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{\\partial f}{\\partial \\beta} = 0 \\iff \\delta = \\frac{1}{2} \\pm \\frac{1 - \\beta}{2} \\sqrt{1 - \\left(\\frac{1 - \\beta}{\\beta} \\cdot \\frac{\\beta - \\alpha/2}{1 - \\beta - \\alpha/2}\\right)^2} , \\tag{20}</span></div>

    <p class="text-gray-300">where again the root using − yields δ < 1/2 and the root using + yields δ > 1/2.<a href="#page-58-2">29</a> Given a target minimum distance δ and a rate 1/r, one can solve the above system of equations to find the set of critical points CP(r, δ). The maximal value of f on these critical points can then be computed.</p>

    <p class="text-gray-300">It remains to deal with potential maximizers on the boundary of our region R′ . As explained, we will argue that the only boundary point that can maximize f is the left-bottom-most point (α0, β0). To show this, we argue that f restricted to only α or only β (visually, a horizontal or vertical "slice" of the region, recall <a href="#page-53-1">Figure 6\\)</a> is strictly concave. Equation <a href="#page-58-0">\\(19\\)</a> then gives the critical points for f restricted to α and <a href="#page-58-1">\\(20\\)</a> then gives the critical points for f restricted to β. We then argue about the location of the critical points for the univariate restrictions, which allow us to conclude that by moving away from boundary points other than (α0, β0) we can increase f's value.</p>

    <p class="text-gray-300"><span id="page-58-3"></span>Lemma 9.10. Let fβ,δ(α) := f(α, β, δ) be the restriction of f to α. For all δ ∈ (0, 1) and β ∈ (0, min{2 − 2δ, 2δ}), this function is strictly concave on its interval α ∈ (0, min{2β, 2 − 2β}).</p>

    <p class="text-gray-300"><span id="page-58-2"></span><sup>29</sup>Since our codes can't achieve δ ≥ 1/2 it may seem we only need the root where δ < 1/2. However, when we puncture these codes in a later section, we will need to bound the probability that a codeword of weight > δn is punctured down to small weight. In particular, we will need to talk about relative weights δ > 1/2, and we will need this second root.</p>

    <p class="text-gray-300"><em>Proof.</em> It suffices to show that the second derivative of  <span class="math">f_{\\beta,\\delta}(\\alpha)</span>  for  <span class="math">\\alpha,\\beta,\\delta</span>  in the ranges given above is negative. The first derivative is</p>

    <div class="my-4 text-center"><span class="math-block">f&#x27;_{\\beta,\\delta}(\\alpha) = 1 + \\frac{1}{r} \\log \\left( \\frac{1-\\alpha}{\\alpha} \\right) + \\frac{1}{2} \\log \\left( \\frac{(1-\\beta-\\alpha/2)(\\beta-\\alpha/2)}{(1-\\alpha)^2} \\right),</span></div>

    <p class="text-gray-300">and therefore</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} f_{\\beta,\\delta}&#x27;&#x27;(\\alpha) &amp;= \\frac{1}{\\ln(2)} \\left( \\frac{1}{r} \\frac{\\alpha}{1-\\alpha} \\frac{-\\alpha - (1-\\alpha)}{\\alpha^2} + \\frac{1}{2} \\left( -\\frac{1/2}{1-\\beta - \\alpha/2} - \\frac{1/2}{\\beta - \\alpha/2} - \\frac{2}{1-\\alpha} \\right) \\right) \\\\ &amp;= \\frac{1}{\\ln(2)} \\left( -\\frac{1}{r \\cdot \\alpha(1-\\alpha)} - \\frac{1}{4(1-\\beta - \\alpha/2)} - \\frac{1}{4(\\beta - \\alpha/2)} - \\frac{1}{1-\\alpha} \\right) \\; . \\end{split}</span></div>

    <p class="text-gray-300">To see that the above is negative, note that the first and fourth terms inside the brackets are clearly negative, as their denominators can't be positive (since  <span class="math">0 &lt; \\alpha &lt; 1</span> ). That the second term is negative follows from  <span class="math">\\alpha &lt; 2 - 2\\beta</span>  and that the third term is negative follows from  <span class="math">\\alpha &lt; 2\\beta</span> .</p>

    <p class="text-gray-300"><span id="page-59-0"></span><strong>Lemma 9.11.</strong> Let  <span class="math">f_{\\alpha,\\delta}(\\beta) := f(\\alpha,\\beta,\\delta)</span>  be the restriction of f to  <span class="math">\\beta</span> . For all  <span class="math">\\delta \\in (0,1)</span>  and  <span class="math">\\alpha \\in (0,1)</span> , this function is strictly concave on its interval  <span class="math">\\beta \\in (\\alpha/2, \\min\\{2\\delta, 2-2\\delta, 1-\\alpha/2\\})</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> It suffices to show that the second derivative of  <span class="math">f_{\\alpha,\\delta}(\\beta)</span>  for  <span class="math">\\alpha,\\beta,\\delta</span>  in the ranges given above is negative. The first derivative is</p>

    <div class="my-4 text-center"><span class="math-block">f_{\\alpha,\\delta}(\\beta)&#x27; = \\frac{1}{\\ln(2)} \\log \\left( \\frac{\\beta(1-\\beta-\\alpha/2)\\sqrt{4(\\delta-\\beta/2)(1-\\delta-\\beta/2)}}{(1-\\beta)^2(\\beta-\\alpha/2)} \\right)</span></div>

    <p class="text-gray-300">Call the numerator  <span class="math">s(\\beta)</span> , the denominator  <span class="math">t(\\beta)</span> . Then we can write the second derivative as</p>

    <div class="my-4 text-center"><span class="math-block">f_{\\alpha,\\delta}(\\beta)&#x27;&#x27; = \\frac{s&#x27;(\\beta)t(\\beta) - s(\\beta)t&#x27;(\\beta)}{s(\\beta)t(\\beta)}.</span></div>

    <p class="text-gray-300">It is not hard to see that the denominator  <span class="math">s(\\beta)t(\\beta) &gt; 0</span> , as it is a product of terms that are all positive. To show that the second derivative is negative, it therefore suffices to show that the numerator is negative. For simpler notation, let  <span class="math">x := \\sqrt{4(\\delta - \\beta/2)(1 - \\delta - \\beta/2)}</span> . We can then write</p>

    <div class="my-4 text-center"><span class="math-block">t&#x27;(\\beta) = 2(1-\\beta)(-1)(\\beta - \\alpha/2) + (1-\\beta)^2,</span></div>

    <p class="text-gray-300">so that</p>

    <div class="my-4 text-center"><span class="math-block">-s(\\beta)t&#x27;(\\beta) = 2\\overbrace{\\beta(1-\\beta-\\alpha/2)x(1-\\beta)(\\beta-\\alpha/2)}^{a} - \\overbrace{\\beta(1-\\beta-\\alpha/2)x(1-\\beta)^{2}}^{b}.</span></div>

    <p class="text-gray-300">Similarly we get</p>

    <div class="my-4 text-center"><span class="math-block">s&#x27;(\\beta) = (1 - \\beta - \\alpha/2)x - \\beta x - \\beta(1 - \\beta - \\alpha/2)(1 - \\beta)/x.</span></div>

    <p class="text-gray-300">so that</p>

    <div class="my-4 text-center"><span class="math-block">s&#x27;(\\beta)t(\\beta) = \\underbrace{(1-\\beta)^{2}(\\beta - \\alpha/2)(1-\\beta - \\alpha/2)x}_{e} - \\underbrace{(1-\\beta)^{3}(\\beta - \\alpha/2)\\beta(1-\\beta - \\alpha/2)/x}_{e} .</span></div>

    <p class="text-gray-300"><img src="_page_60_Figure_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><span id="page-60-0"></span>Figure 7: The region  <span class="math">\\mathcal{R}&#x27;</span>  that we optimize the function f over (for  <span class="math">1/4 &lt; \\delta &lt; 1/2</span> ). As opposed to the regions shown earlier for  <span class="math">\\delta &lt; 1/4</span> , there is a new boundary (d). The blue curve, representing the values for which  <span class="math">\\frac{\\partial f}{\\partial \\alpha} = 0</span> , crosses the boundary (a) at some point  <span class="math">\\beta_1 \\geq \\beta_0</span> .</p>

    <p class="text-gray-300">Thus, to show that the numerator is negative, we need to show that c-d-e+2a-b is negative. We show that this is the case by noting that  <span class="math">d&gt;a,\\ e&gt;a</span>  and  <span class="math">b\\geq c</span> :</p>

    <div class="my-4 text-center"><span class="math-block">b = \\beta(1 - \\beta - \\alpha/2)x(1 - \\beta)^{2} &gt; (\\beta - \\alpha/2)(1 - \\beta - \\alpha/2)x(1 - \\beta)^{2} = c</span></div>

    <div class="my-4 text-center"><span class="math-block">d = (1 - \\beta)^{2}(\\beta - \\alpha/2)\\beta x &gt; (1 - \\beta)(1 - \\beta - \\alpha/2)(\\beta - \\alpha/2)\\beta x = a</span></div>

    <p class="text-gray-300"><span class="math-block">e = (1 - \\beta)^{3}(\\beta - \\alpha/2)\\beta(1 - \\beta - \\alpha/2)/x \\ge (1 - \\beta)(\\beta - \\alpha/2)\\beta(1 - \\beta - \\alpha/2)x = a</span> .</p>

    <p class="text-gray-300">where the final inequality follows from  <span class="math">\\frac{(1-\\beta)^2}{x} \\ge x</span>  which is the same as</p>

    <p class="text-gray-300"><span class="math-block">(1-\\beta)^2 = \\beta^2 - 2\\beta + 1 \\ge x^2 = 4(\\delta - \\beta/2)(1 - \\delta - \\beta/2) = \\beta^2 - 2\\beta + 4\\delta(1 - \\delta) \\iff 4\\delta(1 - \\delta) \\le 1</span>  which holds for any  <span class="math">\\delta \\in (0, 1)</span> .</p>

    <p class="text-gray-300">We now consider boundaries in turn, and argue in each case that they do not yield a maximizer for f. We review the region  <span class="math">\\mathcal{R}&#x27;</span>  and its boundaries in Figure 7.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(b)  <span class="math">2\\beta_0 \\leq \\alpha \\leq \\min\\{4\\delta, 1\\}</span>  and  <span class="math">\\beta = \\alpha/2</span> . Fix some  <span class="math">\\beta</span>  and suppose that the corresponding boundary point  <span class="math">(2\\beta, \\beta)</span>  is a maximizer for f. Consider the horizontal slice  <span class="math">f_{\\beta,\\rho}(\\alpha)</span>  containing this boundary point. Recall that this function is concave over all  <span class="math">\\alpha</span>  in its domain and has a critical point satisfying (19):  <span class="math">\\beta = \\frac{1}{2} \\frac{1-\\alpha}{2}x</span>  where x < 1 (recall that  <span class="math">\\beta &lt; 1/2</span> ). This means that a critical point must satisfy  <span class="math">\\beta &gt; \\frac{1}{2} \\frac{1-\\alpha}{2}</span> , or equivalently, the critical point occurs at  <span class="math">\\alpha &lt; 2\\beta</span> . But our boundary point had  <span class="math">\\alpha = 2\\beta</span> . By concavity this implies that  <span class="math">f_{\\beta,\\rho}</span>  will grow as we move to the left of our boundary point, contradicting our assumption that the boundary point is the maximizer.</li>

      <li>(d)  <span class="math">2-4\\delta \\le \\alpha \\le 1</span> ,  <span class="math">\\beta = 1-\\alpha/2</span> . Fix some  <span class="math">\\beta</span>  and suppose that the corresponding boundary point  <span class="math">(2-2\\beta,\\beta)</span>  is a maximizer for f. Consider again the horizontal slice  <span class="math">f_{\\beta,\\rho}(\\alpha)</span>  containing this</li>

    </ul>

    <p class="text-gray-300">boundary point, which now has a critical point satisfying  <span class="math">\\beta = \\frac{1}{2} + \\frac{1-\\alpha}{2}x</span>  where x < 1 (note that  <span class="math">\\beta &gt; 1/2</span> ). This means that a critical point must satisfy  <span class="math">\\beta &lt; \\frac{1}{2} + \\frac{1-\\alpha}{2}</span> , or equivalently, the critical point occurs at  <span class="math">\\alpha &lt; 2 - 2\\beta</span> . But our boundary point had  <span class="math">\\alpha = 2 - 2\\beta</span> . By concavity this implies that  <span class="math">f_{\\beta,\\rho}</span>  will grow as we move to the left of our boundary point, contradicting our assumption that the boundary point is a maximizer.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(c)  <span class="math">\\alpha_0 \\leq \\alpha \\leq \\min\\{4\\delta, 2-4\\delta\\}</span> ,  <span class="math">\\beta = 2\\delta</span> . Fix some  <span class="math">\\alpha</span>  and suppose that the corresponding boundary point  <span class="math">(\\alpha, 2\\delta)</span>  is a maximizer. Consider now the vertical slice  <span class="math">f_{\\alpha,\\rho}(\\beta)</span>  containing this boundary point, which has a critical point satisfying (20):  <span class="math">\\delta = \\frac{1}{2} \\frac{1-\\beta}{2}x</span>  where x < 1 (note that  <span class="math">\\delta &lt; 1/2</span> ). This means that a critical point must satisfy  <span class="math">\\delta &gt; \\frac{1}{2} \\frac{1-\\beta}{2}</span> , or equivalently, the critical point occurs at  <span class="math">\\beta &lt; 2\\delta</span> . By concavity this implies that  <span class="math">f_{\\alpha,\\rho}</span>  will grow as we move to the bottom of our boundary point, contradicting our assumption that the boundary point is the maximizer.</li>

      <li>(a) At first, we only consider the top portion of this boundary:  <span class="math">\\alpha = \\alpha_0</span> ,  <span class="math">\\beta_1 &lt; \\beta \\le 2\\delta</span> . Recall that we had defined  <span class="math">\\beta_1</span>  in the statement of the theorem. We now claim that the points where the derivative of f to  <span class="math">\\alpha</span>  is 0 (i.e. the critical points of each  <span class="math">f_{\\beta,\\rho}(\\alpha)</span> ) crosses through boundary (a) exactly at  <span class="math">\\beta_1</span> . Recall that these critical points are described by (19). We therefore enter  <span class="math">\\alpha_0 = r/n</span>  into this equation, and note that this recovers  <span class="math">\\beta_1</span> :</li>

    </ul>

    <p class="text-gray-300"><span class="math-block">\\beta_1 = \\frac{1}{2} - \\frac{1 - r/n}{2} \\sqrt{1 - \\left(\\frac{r/n}{1 - r/n}\\right)^{2/r}}</span> .</p>

    <p class="text-gray-300">Recall we assumed  <span class="math">\\beta_1 &gt; \\beta_0</span> , so we conclude that the curve defined by (19) will indeed cross through the boundary (a).</p>

    <p class="text-gray-300">Thus, for  <span class="math">\\beta &gt; \\beta_1</span>  we can assume that the critical points of each horizontal slice lie strictly inside the region  <span class="math">\\mathcal{R}&#x27;</span> , so that an argument analogous to the ones above establishes that this top part of boundary (a) can't contain maximizers.</p>

    <p class="text-gray-300">So, if there is a maximizer on the boundary of  <span class="math">\\mathcal{R}&#x27;</span> , then it must have a  <span class="math">\\beta</span>  value at most  <span class="math">\\beta_1</span> . That is, the only maximizers on the boundary lie in the compact region  <span class="math">\\mathcal{R}&#x27;&#x27; := \\mathcal{R}&#x27; \\cap \\{(\\alpha, \\beta) : \\beta \\leq \\beta_1\\}</span> . We argue that the maximum value for f over the region  <span class="math">\\mathcal{R}&#x27;&#x27;</span>  is necessarily  <span class="math">f(\\alpha_0, \\beta_0)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, suppose  <span class="math">(\\alpha, \\beta) \\in \\mathcal{R}&#x27;&#x27;</span>  with  <span class="math">\\alpha &gt; \\alpha_0</span> . Suppose that  <span class="math">(\\alpha, \\beta)</span>  is a maximizer for f over  <span class="math">\\mathcal{R}&#x27;&#x27;</span> . Consider the horizontal slice  <span class="math">f_{\\beta,\\delta}</span> , and recall that it is concave for  <span class="math">0 &lt; \\alpha \\le 2\\beta</span>  and has a critical point described by (19). As shown just above, for  <span class="math">\\beta &lt; \\beta_1</span> , these critical points occur at  <span class="math">\\alpha &lt; \\alpha_0</span> , so that this holds in particular for our function  <span class="math">f_{\\beta,\\rho}</span> . But then moving  <span class="math">(\\alpha,\\beta)</span>  to the left will increase f, contradicting our assumption that this point is the maximizer of f over  <span class="math">\\mathcal{R}&#x27;&#x27;</span> .</li>

      <li>Lastly, suppose  <span class="math">(\\alpha_0, \\beta) \\in \\mathcal{R}&#x27;&#x27;</span>  with  <span class="math">\\beta &gt; \\beta_0</span>  is a maximizer for f over  <span class="math">\\mathcal{R}&#x27;&#x27;</span> . Consider the vertical slice  <span class="math">f_{\\alpha,\\delta}</span>  containing this point. We claim that this function is decreasing with  <span class="math">\\beta</span>  in this region, i.e. for  <span class="math">\\beta_0 \\leq \\beta \\leq \\beta_1</span> . It follows that moving  <span class="math">(\\alpha, \\beta)</span>  down will increase f, contradicting our assumption that this point is a maximizer for f over  <span class="math">\\mathcal{R}&#x27;&#x27;</span> .</li>

    </ul>

    <p class="text-gray-300">To see that fα0,δ(β) is decreasing for β ≤ β1, we compute its derivative</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} f&#x27;_{r/n,\\delta}(\\beta) &amp;= 1 + \\log\\left(\\frac{\\beta}{1-\\beta}\\right) + \\log\\left(\\frac{1-\\beta-\\alpha_0/2}{\\beta-\\alpha_0/2}\\right) + \\frac{1}{2}\\log\\left(\\frac{(\\delta-\\beta/2)(1-\\delta-\\beta/2)}{(1-\\beta)^2}\\right) \\\\ &amp;= \\log\\left(\\frac{2\\beta(1-\\beta-\\alpha_0)\\sqrt{(\\delta-\\beta/2)(1-\\delta-\\beta/2)}}{(1-\\beta)^2(\\beta-\\alpha_0/2)}\\right) \\;, \\end{split}</span></div>

    <p class="text-gray-300">which is < 0 if and only if</p>

    <div class="my-4 text-center"><span class="math-block">2\\beta(1-\\beta-\\alpha_0)\\sqrt{(\\delta-\\beta/2)(1-\\delta-\\beta/2)} &lt; (1-\\beta)^2(\\beta-\\alpha_0/2)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\iff \\sqrt{4(\\delta-\\beta/2)(1-\\delta-\\beta/2)} &lt; \\frac{(1-\\beta)^2(\\beta-\\alpha_0/2)}{\\beta(1-\\beta-\\alpha_0)},</span></div>

    <p class="text-gray-300">where we note that the LHS is at most p 4δ(1 − δ) which itself is < 1 since δ < 1/2. It therefore suffices to show that the RHS is very close to 1:</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{(1-\\beta)^2(\\beta-\\alpha_0/2)}{\\beta(1-\\beta-\\alpha_0)} &gt; \\frac{(1-\\beta)^2(\\beta-\\alpha_0/2)}{\\beta} &gt; (1-2\\beta)(1-\\frac{\\alpha_0}{2\\beta})$$ $$&gt; 1-2\\beta-\\frac{\\alpha_0}{2\\beta} &gt; 1-2\\beta_1-\\frac{\\alpha_0}{2\\beta_0} \\ .</span></div>

    <p class="text-gray-300">By assumption p 4δ(1 − δ) < 1 − 2β<sup>1</sup> − α<sup>0</sup> 2β<sup>0</sup> , so we indeed find that the derivative is negative.</p>

    <p class="text-gray-300">To conclude, we have established that f is maximized either by a critical point in CP(r, δ) or by the point (α0, β0). Finally, we will establish that f(α0, β0, δ) = −Θ(β0) = −Θ(n γ−1 ). This implies that if max{f(α, β) : (α, β) ∈ CP(r, δ)} < 0 for sufficiently large n we will have f(α0, β0, δ) > max{f(α, β, δ) : (α, β) ∈ CP(r, δ)}: if the right-hand side is negative, as it is independent of n, it is a negative constant, so f(α0, β0, δ) (which tends to 0 as n grows) will be larger for large enough n.</p>

    <p class="text-gray-300">Firstly, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{1}{r}H(\\alpha_0) = \\frac{1}{r}H(r/n) \\le \\frac{(1+o(1))}{n}\\log(n/r) .</span></div>

    <p class="text-gray-300">Next, we consider</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\alpha_0 + (1 - \\alpha_0) H \\left( \\frac{\\beta_0 - \\alpha_0/2}{1 - \\alpha_0} \\right) - H(\\beta_0) \\\\ &amp;= \\alpha_0 + (\\beta_0 - \\alpha_0/2) \\log \\left( \\frac{1 - \\alpha_0}{\\beta_0 - \\alpha_0/2} \\right) + (1 - \\beta_0 - \\alpha_0/2) \\log \\left( \\frac{1 - \\alpha_0}{1 - \\beta_0 - \\alpha_0/2} \\right) \\\\ &amp;- \\beta_0 \\log \\frac{1}{\\beta_0} - (1 - \\beta_0) \\log \\frac{1}{1 - \\beta_0} \\\\ &amp;= \\alpha_0 + \\beta_0 \\log \\left( \\frac{(1 - \\alpha_0)\\beta_0}{\\beta_0 - \\alpha_0} \\right) + (1 - \\beta_0) \\log \\left( \\frac{(1 - \\alpha_0)(1 - \\beta_0)}{1 - \\beta_0 - \\alpha_0/2} \\right) \\\\ &amp;+ \\frac{\\alpha_0}{2} \\log \\left( \\frac{\\beta_0 - \\alpha_0/2}{1 - \\alpha_0} \\right) + \\frac{\\alpha_0}{2} \\log \\left( \\frac{1 - \\beta_0 - \\alpha_0/2}{1 - \\alpha_0} \\right) \\\\ &amp;= \\beta_0 \\log \\left( \\frac{1 - \\alpha_0}{1 - \\alpha_0/(2\\beta_0)} \\right) + (1 - \\beta_0) \\log \\left( \\frac{1 - \\alpha_0}{1 - \\alpha_0/(2(1 - \\beta_0))} \\right) \\\\ &amp;+ \\alpha_0 \\log \\left( \\frac{\\sqrt{4(\\beta_0 - \\alpha_0/2)(1 - \\beta_0 - \\alpha_0/2)}}{1 - \\alpha_0} \\right) \\,. \\end{split}</span></div>

    <p class="text-gray-300">Now, we first observe that</p>

    <div class="my-4 text-center"><span class="math-block">\\beta_0 \\log \\left( \\frac{1 - \\alpha_0}{1 - \\alpha_0 / (2\\beta_0)} \\right) + (1 - \\beta_0) \\log \\left( \\frac{1 - \\alpha_0}{1 - \\alpha_0 / (2(1 - \\beta_0))} \\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\leq \\beta_0 \\log(1 - \\alpha_0) + (1 - \\beta_0) \\log(1 - \\alpha_0)</span></div>

    <div class="my-4 text-center"><span class="math-block">= \\log(1 - \\alpha_0) \\leq -\\frac{\\alpha_0}{\\ln 2}.</span></div>

    <p class="text-gray-300">Next, we claim that</p>

    <div class="my-4 text-center"><span class="math-block">\\log \\left( \\frac{\\sqrt{4(\\beta_0 - \\alpha_0/2)(1 - \\beta_0 - \\alpha_0/2)}}{1 - \\alpha_0} \\right) \\le 0 ,</span></div>

    <p class="text-gray-300">which is of course equivalent to</p>

    <p class="text-gray-300"><span id="page-63-0"></span> <span class="math-block">\\frac{\\sqrt{4(\\beta_0 - \\alpha_0/2)(1 - \\beta_0 - \\alpha_0/2)}}{1 - \\alpha_0} \\le 1 . \\tag{21}</span></p>

    <p class="text-gray-300">And indeed, this holds as (1 − α0) <sup>2</sup> = 1 − 2α<sup>0</sup> + α 2 <sup>0</sup> while</p>

    <div class="my-4 text-center"><span class="math-block">4(\\beta_0 - \\alpha_0/2)(1 - \\beta_0 - \\alpha_0/2) = 4\\beta_0(1 - \\beta_0) - 2\\beta_0\\alpha_0 - 2(1 - \\beta_0)\\alpha_0 + \\alpha_0^2$$ $$= 4(\\beta_0 - \\alpha_0/2) - 2\\alpha_0 + \\alpha_0^2,</span></div>

    <p class="text-gray-300"><a href="#page-63-0">\\(21\\)</a> follows from the fact that 4β0(1−β0) ≤ 1, which itself follows from the fact that 0 ≤ β<sup>0</sup> ≤ 1/2. Hence, putting these bounds together, we find that</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha_0 + (1 - \\alpha_0)H\\left(\\frac{\\beta_0 - \\alpha_0/2}{1 - \\alpha_0}\\right) - H(\\beta_0) \\le -\\frac{\\alpha_0}{\\ln 2}.</span></div>

    <p class="text-gray-300">Completely analogously, as still 4δ(1 − δ) < 1 we can derive that</p>

    <p class="text-gray-300"><span class="math-block">\\beta_0 + (1 - \\beta_0) H\\left(\\frac{\\delta - \\beta_0/2}{1 - \\beta_0}\\right) - H(\\delta) \\le -\\frac{\\beta_0}{\\ln 2}</span> .</p>

    <p class="text-gray-300">Thus,</p>

    <p class="text-gray-300"><span class="math-block">f(\\alpha_0, \\beta_0, \\delta) \\le \\frac{1 + o(1)}{n} \\log(n/r) - \\frac{\\alpha_0}{\\ln 2} - \\frac{\\beta_0}{\\ln 2}</span> .</p>

    <p class="text-gray-300">Since β<sup>0</sup> = Θ(n γ−1 ) while α<sup>0</sup> = Θ(n −1 ), we conclude that</p>

    <p class="text-gray-300"><span class="math-block">f(\\alpha_0, \\beta_0, \\delta) = -\\Theta(n^{\\gamma - 1})</span> .</p>

    <p class="text-gray-300">Thus, we derive the claimed asymptotic bound of</p>

    <p class="text-gray-300"><span class="math-block">O(n^{7/2}) \\cdot 2^{f(\\alpha_0, \\beta_0, \\delta)n} \\le 2^{-\\Omega(n^{\\gamma})}</span> .</p>

    <p class="text-gray-300">By combining <a href="#page-44-2">Proposition 9.5</a> and <a href="#page-54-1">Proposition 9.6,</a> we obtain our target <a href="#page-41-1">Theorem 9.1.</a></p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">9.4 Conditioning on Low Weight Messages Having Good First Stage</h4>

    <p class="text-gray-300">So far, we have offered a bound on the expected number of low-weight codewords, which via Markov's inequality can be translated into a bound on the probability that an RAA code fails to have good distance. We can thereby conclude that, say, a random RAA code with block length  <span class="math">n=2^{23}</span>  of rate 1/4 will have minimum distance about 0.19, except with probability about  <span class="math">2^{-12}</span> . As mentioned in the introduction, we consider a generation procedure for RAA codes that runs certain tests and, conditioned on the tests passing, we show that the failure probability provably decreases.</p>

    <p class="text-gray-300">Looking at the expectation in (6), we note that a large contribution comes from weight 1 messages. Even the individual case  <span class="math">w_1 = 1</span>  and  <span class="math">w_2 = 2</span> , which we separated out into (10), contributes  <span class="math">\\Omega(1/n)</span>  to the expectation, limiting the overall error probability to be at best inverse linear. This motivates us to test low weight messages, and ensure that they all have sufficiently high weight encodings (i.e., of weight at least  <span class="math">d = \\delta n</span> ). If we test all nonzero messages of weight at most w, the test takes time  <span class="math">O(n^{w+1})</span>  (recall every message vector can be encoded in linear time).</p>

    <p class="text-gray-300">We can show that this test almost always passes, and that conditioned on it passing, the error probability for rate 1/4 improves from roughly inverse linear to roughly  <span class="math">1/n^w</span> . To back this up, define the event  <span class="math">E_{\\leq w}</span>  to be the event that some nonzero message of a weight  <span class="math">\\leq w</span>  is encoded by the RAA code into a codeword of weight  <span class="math">\\leq d</span> . Similarly, let  <span class="math">E_{&gt;w}</span>  denote the event that some nonzero message of weight > w has encoding of weight  <span class="math">\\leq d</span> . Then, if E is the event that the RAA code has minimum distance  <span class="math">\\leq \\delta</span> , we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\neg E_{\\leq w}\\right] = \\frac{\\Pr[E \\land \\neg E_{\\leq w}]}{\\Pr[\\neg E_{\\leq w}]} = \\frac{\\Pr[E_{>w}]}{\\Pr[\\neg E_{\\leq w}]}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"> (22)</p>

    <p class="text-gray-300">Below (see Proposition 9.12) we show roughly that  <span class="math">\\Pr[E_{&gt;w}] = O(n^{-(w+1)(\\frac{r}{2}-1)+\\gamma})</span>  (assuming the targeted minimum distance  <span class="math">\\delta</span>  is not too large). As  <span class="math">\\Pr[\\neg E_{\\leq w}]</span>  is very small (definitely  <span class="math">\\leq 1/2</span> , see Proposition 9.13), we essentially boost the failure probability from  <span class="math">O(n^{-\\frac{r}{2}+1+\\gamma})</span>  to  <span class="math">O(n^{-(w+1)(\\frac{r}{2}-1)+\\gamma})</span>  (i.e., ignoring  <span class="math">\\gamma \\in (0,1)</span> , the exponent is multiplied by w+1). Thus, the generation procedure without tests is analogous to the setting of w=0.</p>

    <p class="text-gray-300">We actually consider the following faster test: for nonzero messages of weight at most w-1 we still check if they have encodings of weight at least d, but for messages of weight exactly w we only check if their weight after the first accumulation round is at least  <span class="math">n^{\\kappa}</span> , where  <span class="math">\\kappa \\in (0,1)</span>  is again a tunable parameter. For w = O(1) checking the weight of the vector after one round of accumulation requires only  <span class="math">O(\\log k)</span>  time: if its support after permuting is  <span class="math">\\{i_1, i_2, \\ldots, i_{wr}\\}</span> , after reordering the support  <span class="math">j_1 &lt; j_2 &lt; \\cdots &lt; j_{wr}</span>  we can compute the weight of the accumulated vector as  <span class="math">(j_2 - j_1) + (j_4 - j_3) + \\cdots + (j_{wr} - j_{wr-1})</span> . This test can then be implemented in  <span class="math">\\tilde{O}(k^w)</span>  time, and moreover conditioning on this faster test passing the probability decreases almost as much as if we had conditioned on the slower  <span class="math">O(k^{w+1})</span> -time test passing.</p>

    <p class="text-gray-300">Concretely, let  <span class="math">\\tilde{E}_{\\leq w}</span>  denote the event that some nonzero message of weight at most w-1 has an RAA encoding of weight at most d or that some message of weight w has weight at most  <span class="math">n^{\\kappa}</span>  after one round of accumulation. With E,  <span class="math">E_{\\leq w}</span>  and  <span class="math">E_{&gt;w}</span>  as before, we find</p>

    <p class="text-gray-300"><span id="page-65-1"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr[E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\neg \\tilde{E}_{\\leq w}] = \\frac{\\Pr[E \\wedge \\neg \\tilde{E}_{\\leq w}]}{\\Pr[\\neg \\tilde{E}_{\\leq w}]}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">= \\frac{\\Pr[E \\wedge \\neg \\tilde{E}_{\\leq w} \\wedge \\neg E_{\\leq w}]}{\\Pr[\\neg \\tilde{E}_{\\leq w}]} + \\frac{\\Pr[E \\wedge \\neg \\tilde{E}_{\\leq w} \\wedge E_{\\leq w}]}{\\Pr[\\neg \\tilde{E}_{\\leq w}]}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\leq \\frac{\\Pr[E \\wedge \\neg E_{\\leq w}]}{\\Pr[\\neg \\tilde{E}_{\\leq w}]} + \\frac{\\Pr[E_{\\leq w} \\wedge \\neg \\tilde{E}_{\\leq w}]}{\\Pr[\\neg \\tilde{E}_{\\leq w}]}</span></div>

    <p class="text-gray-300"><span class="math-block">= \\frac{\\Pr[E_{&gt;w}]}{\\Pr[\\neg \\tilde{E}_{&lt; w}]} + \\frac{\\Pr[E_{\\leq w} \\wedge \\neg \\tilde{E}_{\\leq w}]}{\\Pr[\\neg \\tilde{E}_{&lt; w}]}.</span> (23)</p>

    <p class="text-gray-300">We will still find that the new dominant term in the above expression will be  <span class="math">\\Pr[E_{&gt;w}]</span> , of the order  <span class="math">n^{(w+1)(1-r/2)+\\gamma}</span>  (at least, for reasonable choices of  <span class="math">\\kappa</span> , say  <span class="math">\\kappa=0.4</span> . In particular, assuming n large we will find that  <span class="math">\\Pr[E_{\\leq w} \\land \\neg \\tilde{E}_{\\leq w}]</span>  — which is the probability that some vector of weight w has weight at least  <span class="math">n^{\\kappa}</span>  after one round but weight at most d after two rounds — is at most  <span class="math">2^{-\\Omega(n^{\\kappa})}</span>  (see Proposition 9.15). And again,  <span class="math">\\Pr[\\tilde{E}_{\\leq w}]</span>  will be shown to be very small (definitely  <span class="math">\\leq 1/2</span> ; see Proposition 9.14), so the</p>

    <p class="text-gray-300">Regarding how to set  <span class="math">\\kappa</span> , note that  <span class="math">\\Pr[\\tilde{E}_{\\leq w}]</span>  is the event that <em>some</em> message of weight w has weight w after one round or some nonzero message of weight w as RAA encoding of weight at most w. We should expect this probability to increase with w, as this makes it easier to obtain weight w. This implies we want to make w small so that the denominator is close to 1. Conversely, note that  <span class="math">\\Pr[E_{\\leq w} \\wedge \\neg \\tilde{E}_{\\leq w}]</span>  is the event that some nonzero message of weight w is mapped to weight w and then mapped to weight w. We should expect this to decrease with w, as having a larger weight after one round is likely to increase your weight after two rounds, making it harder to get a small weight w. In practice we find that any w as a reasonable choice.</p>

    <p class="text-gray-300">First, we analyze the probability that the slower test passes, and argue that it is very close to 1. We note that this is not required for our main result Theorem 9.16, but we still provide it for intuition.</p>

    <p class="text-gray-300"><span id="page-65-0"></span><strong>Proposition 9.12.</strong> Let  <span class="math">r, n, \\delta, d, \\varepsilon, \\gamma, \\alpha_0</span>  and  <span class="math">\\beta_0</span>  be as in Theorem 9.1. Let</p>

    <div class="my-4 text-center"><span class="math-block">B&#x27; := \\max\\{f(\\alpha_0, \\beta_0, \\delta), \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in \\operatorname{CP}(r, \\delta), \\ \\alpha \\le w/n\\}\\}</span></div>

    <p class="text-gray-300">Let  <span class="math">E_{\\leq w}</span>  be the event that some message of weight  <span class="math">\\leq w = O(1)</span>  is encoded by an RAA code into a codeword of weight  <span class="math">\\leq d</span> . Let  <span class="math">v_2^* = \\frac{r-1}{2\\ln(1/\\eta)}</span> . Then</p>

    <p class="text-gray-300"><span class="math-block">\\Pr[E_{\\leq w}] \\leq \\mathbb{I}\\{r = 4\\} \\cdot \\frac{3}{n-2} + \\mathbb{I}\\{r = 6, \\delta \\geq 1/4\\} \\cdot \\frac{180\\delta^{2}(1-\\delta)}{(n-2)^{2}} + n^{1-r/2} \\cdot \\lceil \\frac{n^{\\gamma}}{2} \\rceil \\cdot w \\cdot 0.43603 \\cdot \\binom{r}{\\frac{r}{2}} \\cdot \\varphi_{n} \\left(2 \\cdot \\lceil \\frac{m}{2} \\rceil\\right) \\cdot \\varphi_{n}(r) \\cdot (2v_{2}^{<em>})^{\\frac{r+1}{2}} \\cdot \\eta^{v_{2}^{</em>}} + \\frac{0.80192 \\cdot \\delta \\cdot w}{\\sqrt{r}} \\cdot n^{5/2} \\cdot 2^{B&#x27;n} .</span> (24)</p>

    <p class="text-gray-300">Moreover, assuming B'<0 for sufficiently large n we will have  <span class="math">B&#x27;=f(\\alpha_0,\\beta_0,\\delta)=-\\Omega(n^{-\\gamma})</span>  yielding the asymptotic bound</p>

    <p class="text-gray-300"> <span class="math">O(n^{1+\\gamma-r/2}) + 2^{-\\Omega(n^{\\gamma})} .</span></p>

    <p class="text-gray-300"><em>Proof.</em> By Markov's inequality, we can bound  <span class="math">Pr[E_{\\leq w}]</span>  as follows</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr[E_{\\leq w}] \\leq \\sum_{w_1=1}^w \\sum_{w_2=1}^n \\sum_{w_3=1}^d \\binom{n/r}{w_1} \\cdot \\frac{\\binom{rw_1}{rw_1/2} \\binom{n-rw_1}{w_2-rw_1/2}}{\\binom{n}{w_2}} \\cdot \\frac{\\binom{w_2}{\\lceil w_2/2 \\rceil} \\binom{n-w_2}{w_3-\\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{rw_1/2 \\cdot \\lceil w_2/2 \\rceil}{w_2w_3} \\ .</span></div>

    <p class="text-gray-300">We split up the sum over  <span class="math">w_2</span> , treating the  <span class="math">w_2 \\leq n^{\\gamma}</span> -part analogous to Proposition 9.5, and treating the  <span class="math">w_2 &gt; n^{\\gamma}</span>  part analogous to Proposition 9.6.</p>

    <p class="text-gray-300">For the first part, note that the expression we have here is almost the same as the expression that we bounded in Proposition 9.5, with the only difference that here  <span class="math">w_1 = 1, ..., w</span>  while there we had  <span class="math">w_1 = 1, ..., \\lfloor \\frac{2w_2}{r} \\rfloor</span> . In that proposition, we observed that the expression grew with  <span class="math">w_3</span> , so that we could bound the sum over  <span class="math">w_3</span>  by setting  <span class="math">w_3 = d</span>  (except for two cases with small  <span class="math">w_2</span> ). We then observed that the sum over  <span class="math">w_1</span>  decreased with  <span class="math">w_1</span> , so that we could bound the sum over  <span class="math">w_1</span>  by setting  <span class="math">w_1 = 1</span> . This gave us the final expression (13). But since we set  <span class="math">w_1 = 1</span>  this means that we can use (13) as bound for our current expression, as long as we remember to remove the  <span class="math">\\lfloor \\frac{2w_2}{r} \\rfloor</span>  factor that counted the number of iterations over  <span class="math">w_1</span> , and add in a factor w to count the number of iterations in our sum.</p>

    <p class="text-gray-300">This leaves bounding the sum over  <span class="math">w_2</span> . We again follow the same strategy: we first substitute  <span class="math">w_2 := 2v_2</span>  (showing that we can indeed bound each odd  <span class="math">w_2</span>  entry by the subsequent even entry is analogous to before), and then maximize by setting the derivative to  <span class="math">v_2</span>  equal to 0. Since our current expression is exactly a factor  <span class="math">\\frac{2w_2}{r}</span>  smaller than the expression we had before, it simple to see that this changes the maximizer from  <span class="math">v_2^<em> = \\frac{r+1}{2\\ln(1/\\eta)}</span>  to  <span class="math">v_2^</em> = \\frac{r-1}{2\\ln(1/\\eta)}</span> , and changes the final bound from (9) to</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\mathbb{I}\\{r=4\\} \\cdot \\frac{3}{n-2} + \\mathbb{I}\\{r=6, \\delta \\geq 1/4\\} \\cdot \\frac{180\\delta^2(1-\\delta)}{(n-2)^2} \\\\ + n^{1-r/2} \\cdot \\lceil \\frac{n^{\\gamma}}{2} \\rceil \\cdot w \\cdot 0.43603 \\cdot \\binom{r}{\\frac{r}{2}} \\cdot \\varphi_n \\left(2 \\cdot \\lceil \\frac{m}{2} \\rceil\\right) \\cdot \\varphi_n(r) \\cdot \\left(2v_2^*\\right)^{\\frac{r+1}{2}} \\cdot \\eta^{v_2^*} \\end{split}</span></div>

    <p class="text-gray-300">Next we consider the large  <span class="math">w_2</span>  part of the expectation. Again, the only change with Proposition 9.6 is the fact that  <span class="math">w_1</span>  only has a constant number of terms. This causes two changes. First, we lose a factor n/r in the final bound (which we originally picked up to count the number of iterations in the sum over  <span class="math">w_1</span> ) and obtain a factor w. Second, we now only optimize over the region  <span class="math">\\mathcal{R}&#x27; \\cap \\{(\\alpha, \\beta) : \\alpha \\leq w/n\\}</span> . So we get the bound of</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{0.80192 \\cdot \\delta \\cdot (w-1)}{\\sqrt{r}} \\cdot n^{5/2} \\cdot 2^{B&#x27; \\cdot n} .</span></div>

    <p class="text-gray-300">The reasoning for the "moreover" portion is analogous to that of Theorem 9.1.</p>

    <p class="text-gray-300">Next, we bound the probability that a message vector of weight above w has a low weight encoding.</p>

    <p class="text-gray-300"><span id="page-66-0"></span><strong>Proposition 9.13.</strong> Let  <span class="math">r, n, \\delta, d, \\varepsilon, \\gamma, \\alpha_0</span>  and  <span class="math">\\beta_0</span>  be as in Theorem 9.1. Let</p>

    <div class="my-4 text-center"><span class="math-block">B&#x27; := \\max\\{f(\\alpha_0, \\beta_0, \\delta), \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in \\operatorname{CP}(r, \\delta), \\ \\alpha \\ge (w+1)/n\\}\\}</span></div>

    <p class="text-gray-300">Let  <span class="math">E_{&gt;w}</span>  be the event that some message of weight > w is encoded by an RAA code into a codeword of weight  <span class="math">\\leq d</span> . Let  <span class="math">v_2^* = \\frac{r(w+1)+1}{2\\ln(1/\\eta)}</span> . Then</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr[E_{&gt;w}] \\le n^{-r(w+1)/2} \\cdot \\binom{n/r}{w+1} \\cdot \\lceil \\frac{n^{\\gamma}}{2} \\rceil \\cdot 0.43603 \\cdot \\binom{r(w+1)}{r(w+1)/2} \\\\ \\cdot r(w+1)\\varphi_n \\left( 2 \\cdot \\lceil \\frac{m}{2} \\rceil \\right) \\varphi_n(r(w+1)) \\cdot \\left( 2v_2^* \\right)^{\\frac{r(w+1)+1}{2}} \\cdot \\eta^{v_2^*} \\\\ + \\frac{0.80192 \\cdot \\delta}{r^{1.5}} \\cdot n^{7/2} \\cdot 2^{B&#x27;n} .</span></div>

    <p class="text-gray-300">Moreover, assuming B' < 0, for sufficently large n this bound is asymptotically</p>

    <div class="my-4 text-center"><span class="math-block">O(n^{w+1+\\gamma-\\frac{r}{2}(w+1)}) + 2^{-\\Omega(n^{\\gamma})} = O(n^{-(w+1)(\\frac{r}{2}-1)+\\gamma})</span></div>

    <p class="text-gray-300"><em>Proof.</em> By Markov's inequality, we can bound  <span class="math">Pr[E_{&gt;w}]</span>  as follows</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr[E_{&gt;w}] \\leq \\sum_{w_1 = w+1}^{n/r} \\sum_{w_2 = 1}^{n} \\sum_{w_3 = 1}^{d} \\binom{n/r}{w_1} \\cdot \\frac{\\binom{rw_1}{rw_1/2} \\binom{n - rw_1}{w_2 - rw_1/2}}{\\binom{n}{w_2}} \\cdot \\frac{\\binom{w_2}{\\lceil w_2/2 \\rceil} \\binom{n - w_2}{w_3 - \\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{rw_1/2 \\cdot \\lceil w_2/2 \\rceil}{w_2w_3} \\ .</span></div>

    <p class="text-gray-300">We again split up the sum over  <span class="math">w_2</span> , treating the  <span class="math">w_2 \\leq n^{\\gamma}</span> -part analogous to Proposition 9.5, and treating the  <span class="math">w_2 &gt; n^{\\gamma}</span>  part analogous to Proposition 9.6.</p>

    <p class="text-gray-300">We start with the first case. What changes when we drop the terms with  <span class="math">w_1 = 1, 2, ..., w</span> ? First, the separate terms (which arose for r = 4 or r = 6) don't arise (they required  <span class="math">w_1 = 1</span> ). Second, recall that we bounded the sum over  <span class="math">w_1</span>  by arguing that it is decreasing with  <span class="math">w_1</span> , so that it's maximized by its first term. By dropping the first w terms, the new maximizing term becomes  <span class="math">w_1 = w + 1</span> . Let's see what the effect of this is. Recall that earlier we took the expression (11) and bounded it by setting  <span class="math">w_1 = 1</span>  giving us (13). The factors involving  <span class="math">w_1</span>  are</p>

    <div class="my-4 text-center"><span class="math-block">\\binom{n/r}{w_1} \\binom{rw_1}{rw_1/2} \\binom{n-rw_1}{w_2-rw_1/2} \\cdot rw_1/2 .</span></div>

    <p class="text-gray-300">and so the factors  <span class="math">\\frac{n}{r} \\cdot \\binom{r}{r/2} \\cdot r/2 = \\text{change to } \\binom{n/r}{w+1} \\cdot \\binom{2r(w+1)}{r(w+1)} \\cdot r(w+1)/2</span> . More importantly, the factor  <span class="math">\\binom{n-r}{w_2-r/2}</span>  changes to  <span class="math">\\binom{n-r(w+1)}{w_2-r(w+1)/2}</span> . Again, one can demonstrate that the terms in the sum are maximized by an even  <span class="math">w_2</span> , so we consider even  <span class="math">2v_2</span>  values. Recall that we bounded</p>

    <div class="my-4 text-center"><span class="math-block">\\binom{n-r}{2v_2 - r/2} \\le \\frac{(2v_2)^{\\frac{r}{2}}(n-2v_2)^{\\frac{r}{2}}}{n^r} \\cdot \\varphi_n(r) ;</span></div>

    <p class="text-gray-300">similar reasoning leads to the bound</p>

    <div class="my-4 text-center"><span class="math-block">\\binom{n - r(w+1)}{2v_2 - r(w+1)/2} \\le \\frac{(2v_2)^{r(w+1)/2}(n - 2v_2)^{r(w+1)/2}}{n^{r(w+1)}} \\cdot \\varphi_n(r(w+1)) .</span></div>

    <p class="text-gray-300">This changes the factor  <span class="math">(2v_2/n)^{r/2}</span>  in the bound to  <span class="math">(2v_2/n)^{r(w+1)}</span> . Moreover, this changes the maximizing value of  <span class="math">v_2</span>  from  <span class="math">\\frac{r+1}{2\\ln(1/\\eta)}</span>  to  <span class="math">v_2^* = \\frac{r(w+1)+1}{2\\ln(1/\\eta)}</span> . The final bound then becomes</p>

    <div class="my-4 text-center"><span class="math-block">n^{-r(w+1)/2} \\cdot \\binom{n/r}{w+1} \\cdot \\lceil \\frac{n^{\\gamma}}{2} \\rceil \\cdot 0.43603 \\cdot \\binom{r(w+1)}{r(w+1)/2} \\\\ \\cdot r(w+1)\\varphi_n \\left( 2 \\cdot \\lceil \\frac{m}{2} \\rceil \\right) \\varphi_n(r(w+1)) \\cdot \\left( 2v_2^* \\right)^{\\frac{r(w+1)+1}{2}} \\cdot \\eta^{v_2^*}</span></div>

    <p class="text-gray-300">We then move to the second case. The contribution of this case to the error probability was summarised in Proposition 9.6. The effect of  <span class="math">w_1 = 1</span>  messages lies in  <span class="math">\\alpha_0 = r/n</span>  being the smallest allowed value for  <span class="math">\\alpha</span> . By moving to  <span class="math">w_1 \\geq w</span> , the minimum value for  <span class="math">\\alpha</span>  increases to  <span class="math">w \\cdot \\alpha_0 = r \\cdot w/n</span> . Recall that either  <span class="math">(\\alpha_0, \\beta_0)</span>  or a critical point maximized the function f. It follows directly from our argument that this first maximizer changes to  <span class="math">(w \\cdot \\alpha_0, \\beta_0)</span>  (recall that the restriction  <span class="math">f_{\\beta_0, \\delta}(\\alpha)</span>  of f to  <span class="math">\\alpha</span>  was strictly concave for  <span class="math">\\alpha &gt; 0</span>  and  <span class="math">\\alpha \\leq 2\\beta_0</span>  and has a critical point strictly smaller than r/n).</p>

    <p class="text-gray-300">We now move to analyzing the faster test. We first argue it is likely to pass.</p>

    <p class="text-gray-300"><span id="page-68-0"></span><strong>Proposition 9.14.</strong> Let  <span class="math">r, n, \\delta, d, \\varepsilon, \\gamma, \\alpha_0</span>  and  <span class="math">\\beta_0</span>  be as in Theorem 9.1. Let</p>

    <div class="my-4 text-center"><span class="math-block">B&#x27; := \\max\\{f(\\alpha_0, \\beta_0, \\delta), \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in \\operatorname{CP}(r, \\delta), \\ \\alpha \\le (w - 1)/n\\}\\}\\</span></div>

    <p class="text-gray-300">Let  <span class="math">\\tilde{E}_{\\leq w}</span>  be the event that some message of weight  <span class="math">\\leq w = O(1)</span>  is encoded by an RAA code into a codeword of weight  <span class="math">\\leq d</span> , or that some message of weight w is encoded by the first round of permuting and accumulating into a vector of weight  <span class="math">\\leq n^{\\kappa}</span> , where  <span class="math">\\kappa \\in (0,1)</span> . Assume  <span class="math">n^{\\kappa} \\leq \\frac{rw/2-1}{rw-1}n</span> . Then</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\Pr[\\tilde{E}_{\\leq w}] &amp;\\leq \\binom{n/r}{w} \\frac{rw}{2} \\binom{rw}{\\frac{rw}{2}} \\frac{\\binom{n-rw}{n^{\\kappa} - \\frac{rw}{2}}}{\\binom{n}{n^{\\kappa}}} \\\\ &amp;+ \\mathbb{I}\\{r=4\\} \\cdot \\frac{3}{n-2} + \\mathbb{I}\\{r=6, \\delta \\geq 1/4\\} \\cdot \\frac{180\\delta^2(1-\\delta)}{(n-2)^2} \\\\ &amp;+ n^{1-r/2} \\cdot \\lceil \\frac{n^{\\gamma}}{2} \\rceil \\cdot w \\cdot 0.43603 \\cdot \\binom{r}{\\frac{r}{2}} \\cdot \\varphi_n \\left(2 \\cdot \\lceil \\frac{m}{2} \\rceil\\right) \\cdot \\varphi_n(r) \\cdot \\left(2v_2^*\\right)^{\\frac{r+1}{2}} \\cdot \\eta^{v_2^*} \\\\ &amp;+ \\frac{0.80192 \\cdot \\delta \\cdot w}{\\sqrt{r}} \\cdot n^{5/2} \\cdot 2^{B&#x27;n} \\ . \\end{split}</span></div>

    <p class="text-gray-300">Moreover, assuming  <span class="math">\\kappa &lt; 1/2</span>  we have</p>

    <div class="my-4 text-center"><span class="math-block">\\binom{n/r}{w} \\frac{rw}{2} \\binom{rw}{\\frac{rw}{2}} \\frac{\\binom{n-rw}{n^{\\kappa} - \\frac{rw}{2}}}{\\binom{n}{n^{\\kappa}}} \\le \\binom{n/r}{w} \\frac{rw}{2} \\binom{rw}{\\frac{rw}{2}} n^{\\frac{rw}{2}(\\kappa-1)} \\varphi_n(n^{\\kappa})</span></div>

    <p class="text-gray-300">so assuming B' < 0 the overall bound is  <span class="math">O(n^{1+\\gamma-r/2}) + O(n^{w(1+\\frac{r}{2}(\\kappa-1))})</span> , which as  <span class="math">\\kappa &lt; 1/2 \\le 1 - \\frac{2}{r}</span>  is indeed decreasing with n.</p>

    <p class="text-gray-300"><em>Proof.</em> If  <span class="math">\\tilde{E}_w</span>  is the event that some message of weight w is encoded by the first round of permuting and accumulating into a vector of weight  <span class="math">\\leq n^{\\kappa}</span> , then  <span class="math">\\tilde{E}_{\\leq w} = E_{\\leq w-1} \\cup \\tilde{E}_w</span> . By a union bound  <span class="math">\\Pr[\\tilde{E}_{\\leq w}] \\leq \\Pr[E_{\\leq w-1}] + \\Pr[\\tilde{E}_w]</span> . Proposition 9.12 provides a bound on the first term, and so it suffices for us to bound  <span class="math">\\Pr[\\tilde{E}_w]</span> .</p>

    <p class="text-gray-300">By Markov's inequality it suffices to bound the expect number of messages of weight w that have weight  <span class="math">\\leq n^{\\kappa}</span>  after one round, that is,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr[\\tilde{E}_w] \\le \\binom{n/r}{w} \\frac{rw}{2} \\binom{rw}{\\frac{rw}{2}} \\sum_{w=1}^{n^{\\kappa}} \\frac{\\binom{n-rw}{w_2 - \\frac{rw}{2}}}{\\binom{n}{w_2} w_2}</span></div>

    <p class="text-gray-300"><span id="page-68-1"></span><sup>&</sup>lt;sup>30</sup>Although this doesn't change the asymptotic characterisation  <span class="math">2^{\\Omega(n^{\\gamma})}</span>  (as we always have  <span class="math">n^{\\gamma-1} &lt; w_1 \\cdot n^{-1}</span>  for large enough n), it does improve the bound somewhat. However, recall that the bottleneck is the  <span class="math">w_2 \\leq n^{\\gamma}</span>  part of the analysis, so the overall effect is not so significant.</p>

    <p class="text-gray-300">We now note that the expression in the sum over  <span class="math">w_2</span>  is analogous to the expression in the sum over  <span class="math">w_3</span>  in (8). We had argued that (8) grew with  <span class="math">w_3</span>  if and only if  <span class="math">w_3 \\leq n \\left(\\frac{\\lceil w_2/2 \\rceil}{w_2 - 1}\\right)</span> . Our case is analogous, except we replace  <span class="math">w_2</span>  with rw and  <span class="math">w_3</span>  with  <span class="math">w_2</span> , giving the condition that our expression grows with  <span class="math">w_2</span>  if and only if  <span class="math">w_2 \\leq \\frac{rw/2 - 1}{rw - 1}n</span> . As we assume  <span class="math">n^{\\kappa} \\leq \\frac{rw/2 - 1}{rw - 1}n</span>  and  <span class="math">w_2 \\leq n^{\\kappa}</span> , it follows these terms indeed are increasing in  <span class="math">w_2</span> . So, we obtain the bound</p>

    <div class="my-4 text-center"><span class="math-block">\\binom{n/r}{w}\\frac{rw}{2}\\binom{rw}{\\frac{rw}{2}}\\frac{\\binom{n-rw}{n^\\kappa-\\frac{rw}{2}}}{\\binom{n}{n^\\kappa}}\\ .</span></div>

    <p class="text-gray-300">For the moreover part of the statement we can rewrite the fraction of the two binomials as follows</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{\\binom{n-rw}{n^{\\kappa}-rw/2}}{\\binom{n}{n^{\\kappa}}} = \\frac{(n-rw)!}{(n-rw-n^{\\kappa}+rw/2)} \\cdot \\frac{n^{\\kappa}!}{(n^{\\kappa}-rw/2)!} \\cdot \\frac{(n-n^{\\kappa})!}{n!}$$ $$= \\frac{\\prod_{i=0}^{rw/2-1} (n^{\\kappa}-i) \\cdot \\prod_{i=0}^{n^{\\kappa}-rw/2-1} (n-rw-i)}{\\prod_{i=1}^{n^{\\kappa}} (n-i)},</span></div>

    <p class="text-gray-300">to which we can apply (16) and obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{\\binom{n-rw}{n^{\\kappa}-rw/2}}{\\binom{n}{n^{\\kappa}}} \\le n^{\\frac{rw}{2}(\\kappa-1)} \\varphi_n(n^{\\kappa})</span></div>

    <p class="text-gray-300">Thus, we have the final bound on this term as</p>

    <div class="my-4 text-center"><span class="math-block">\\binom{n/r}{w} \\frac{rw}{2} \\binom{rw}{\\frac{rw}{2}} \\frac{\\binom{n-rw}{n^{\\kappa} - \\frac{rw}{2}}}{\\binom{n}{n^{\\kappa}}} \\le \\binom{n/r}{w} \\frac{rw}{2} \\binom{rw}{\\frac{rw}{2}} n^{\\frac{rw}{2}(\\kappa-1)} \\varphi_n(n^{\\kappa})</span></div>

    <p class="text-gray-300">As we now assume  <span class="math">\\kappa &lt; 1/2</span> ,  <span class="math">\\varphi_n(n^{\\kappa}) = \\exp(n^{\\kappa}(n^{\\kappa}-1)/(2n)) = O(1)</span> , and so this term is</p>

    <p class="text-gray-300"><span class="math-block">O(n^w \\cdot n^{\\frac{rw}{2}(\\kappa-1)}) = O(n^{w(1+\\frac{r}{2}(\\kappa-1))})</span> .</p>

    <p class="text-gray-300">Finally, we consider the event that every message of weight w has weight at least  <span class="math">n^{\\kappa}</span>  after the first round, but nonetheless some message of weight w has an encoding of weight < d.</p>

    <p class="text-gray-300"><span id="page-69-0"></span><strong>Proposition 9.15.</strong> Let  <span class="math">n, r, \\delta, d, \\alpha_0</span>  be as in Theorem 9.1. Let  <span class="math">w \\in \\mathbb{N}</span>  and define the events  <span class="math">E_{\\leq w}</span>  and  <span class="math">\\tilde{E}_{\\leq w}</span>  as before. Let</p>

    <div class="my-4 text-center"><span class="math-block">B&#x27; := \\max\\{f(\\alpha_0, n^{\\kappa-1}, \\delta), \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in \\mathrm{CP}(r, \\delta), \\ \\beta \\ge n^{\\kappa-1}\\}\\} \\ .</span></div>

    <p class="text-gray-300">Then</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr[E_{\\leq w} \\land \\neg \\tilde{E}_{\\leq w}] \\leq \\frac{0.80192 \\cdot \\delta \\cdot (w-1)}{\\sqrt{r}} \\cdot n^{5/2} \\cdot 2^{B&#x27;n}</span></div>

    <p class="text-gray-300"><em>Proof.</em> It suffices to bound the expected number of weight w messages that are mapped to a weight  <span class="math">&gt; n^{\\kappa}</span>  vector after one round, and then mapped to a weight  <span class="math">\\leq d</span>  codeword after the second round. That is:</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{w_2=n^{\\kappa}+1}^{2d} \\sum_{w_3=1}^{d} \\binom{n/r}{w} \\cdot \\frac{\\binom{rw}{rw_1/2} \\binom{n-rw}{w_2-rw/2}}{\\binom{n}{w_2}} \\cdot \\frac{\\binom{w_2}{\\lceil w_2/2 \\rceil} \\binom{n-w_2}{w_3-\\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{rw_1/2 \\cdot \\lceil w_2/2 \\rceil}{w_2w_3}</span></div>

    <p class="text-gray-300">We can leverage the analysis from Proposition 9.6 as we have a good enough lower-bound on  <span class="math">w_2</span>  (recall that for  <span class="math">w_1, w_2 = O(1)</span>  that analysis was not sufficient to prove decent error probability). That is, we can bound the above as</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{0.80192 \\cdot \\delta \\cdot (w-1)}{\\sqrt{r}} \\cdot n^{5/2} \\cdot 2^{B&#x27;n} . \\qquad \\Box</span></div>

    <p class="text-gray-300">The conclusion of all these bounds is the following theorem.</p>

    <p class="text-gray-300"><span id="page-70-0"></span><strong>Theorem 9.16.</strong> Let  <span class="math">r, n, \\delta, d, \\varepsilon, \\gamma, \\alpha_0, \\beta_0</span>  and  <span class="math">CP(r, \\delta)</span>  be as in Theorem 9.1. Let  <span class="math">\\kappa \\in (0, 1)</span>  and  <span class="math">w \\in \\mathbb{N}</span> . Let  <span class="math">v_2^*</span>  be as in Proposition 9.13. There is  <span class="math">\\tilde{O}(n^w)</span>  generation procedure procedure outputting rate 1/r RAA codes with minimum distance  <span class="math">\\delta</span>  except with probability at most  <span class="math">\\frac{p_{&gt;w}}{1-\\tilde{p}_{&lt;w}} + \\frac{q_w}{1-\\tilde{p}_{&lt;w}}</span> , where</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} p_{&gt;w} &amp;:= n^{-r(w+1)/2} \\cdot \\binom{n/r}{w+1} \\cdot \\lceil \\frac{n^{\\gamma}}{2} \\rceil \\cdot 0.43603 \\cdot \\binom{r(w+1)}{r(w+1)/2} \\\\ &amp; \\cdot r(w+1) \\varphi_n \\left( 2 \\cdot \\lceil \\frac{m}{2} \\rceil \\right) \\varphi_n(r(w+1)) \\cdot \\left( 2v_2^* \\right)^{\\frac{r(w+1)+1}{2}} \\cdot \\eta^{v_2^*} \\\\ &amp; + \\frac{0.80192 \\cdot \\delta}{r^{1.5}} \\cdot n^{7/2} \\cdot 2^{B_1 n} \\\\ \\tilde{p}_{\\leq w} &amp;= \\binom{n/r}{w} \\frac{rw}{2} \\binom{rw}{\\frac{rw}{2}} \\frac{\\binom{n-rw}{n^{\\kappa} - \\frac{rw}{2}}{\\binom{n}{n^{\\kappa}}}}{\\binom{n}{n^{\\kappa}}} \\\\ &amp; + \\mathbb{I}\\{r=4\\} \\cdot \\frac{3}{n-2} + \\mathbb{I}\\{r=6, \\delta \\geq 1/4\\} \\cdot \\frac{180\\delta^2(1-\\delta)}{(n-2)^2} \\\\ &amp; + n^{1-r/2} \\cdot \\lceil \\frac{n^{\\gamma}}{2} \\rceil \\cdot w \\cdot 0.43603 \\cdot \\binom{r}{\\frac{r}{2}} \\cdot \\varphi_n \\left( 2 \\cdot \\lceil \\frac{m}{2} \\rceil \\right) \\cdot \\varphi_n(r) \\cdot \\left( 2v_2^* \\right)^{\\frac{r+1}{2}} \\cdot \\eta^{v_2^*} \\\\ &amp; + \\frac{0.80192 \\cdot \\delta \\cdot w}{\\sqrt{r}} \\cdot n^{5/2} \\cdot 2^{B_2 n} \\ , \\\\ q_w &amp;:= \\frac{0.80192 \\cdot \\delta \\cdot (w-1)}{\\sqrt{r}} \\cdot n^{5/2} \\cdot 2^{B_3 n} \\ . \\end{split}</span></div>

    <p class="text-gray-300">Above,</p>

    <div class="my-4 text-center"><span class="math-block">B_1 := \\max\\{f(\\alpha_0, \\beta_0, \\delta), \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in \\operatorname{CP}(r, \\delta), \\ \\alpha \\ge (w+1)/n\\}\\}</span></div>

    <div class="my-4 text-center"><span class="math-block">B_2 := \\max\\{f(\\alpha_0, \\beta_0, \\delta), \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in \\operatorname{CP}(r, \\delta), \\ \\alpha \\le (w-1)/n\\}\\}</span></div>

    <div class="my-4 text-center"><span class="math-block">B_3 := \\max\\{f(\\alpha_0, n^{\\kappa-1}, \\delta), \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in \\operatorname{CP}(r, \\delta), \\ \\beta \\ge n^{\\kappa-1}\\}\\}.</span></div>

    <p class="text-gray-300">Assuming  <span class="math">\\max\\{f(\\alpha,\\beta): (\\alpha,\\beta) \\in \\operatorname{CP}(r,\\delta)\\}\\</span>  < 0, then the bound is asymptotically  <span class="math">O(n^{-(w+1)(\\frac{r}{2}-1)+\\gamma}+2^{-\\Omega(n^{\\gamma})}+2^{-\\Omega(n^{\\kappa})})</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> We use the fast test for weight w: namely, check that all nonzero messages of weight  <span class="math">\\leq w-1</span>  have encodings of weight at least d, and that all messages of weight w have weight at least  <span class="math">n^{\\kappa}</span>  after one round. As discussed earlier, this test is implementable in  <span class="math">\\tilde{O}(k^w)</span>  time, and by Proposition 9.14 a random RAA is very likely to pass.</p>

    <p class="text-gray-300">Recalling (23), we have that conditioned on the test pass the failure probability is at most</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{\\Pr[E_{&gt;w}]}{\\Pr[\\neg \\tilde{E}_w]} + \\frac{\\Pr[E_{\\leq w} \\wedge \\neg \\tilde{E}_{\\leq w}]}{\\Pr[\\neg \\tilde{E}_w]} .</span></div>

    <p class="text-gray-300"><span id="page-71-3"></span>That  <span class="math">\\Pr[E_{&gt;w}] \\leq p_{&gt;w}</span> ,  <span class="math">\\Pr[\\neg \\tilde{E}_w] \\geq 1 - \\tilde{p}_{\\leq w}</span>  and  <span class="math">\\Pr[E_{\\leq w} \\land \\neg \\tilde{E}_{\\leq w}] \\leq q_w</span>  follow from Proposition 9.13, Proposition 9.14 and Proposition 9.15, respectively.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">9.5 Puncturing</h3>

    <p class="text-gray-300">Lastly, we consider the possibility of puncturing an RAA code so as to obtain a higher rate code while still (mostly) preserving the encoding time. Specifically, suppose we start with a (randomly sampled) RAA code with repetition factor r and block-length n, and then we puncture down to keep only  <span class="math">\\omega n</span>  coordinates for some  <span class="math">\\omega \\in (0,1)</span>  (hence, the final rate will be  <span class="math">1/(r\\omega)</span> ).</p>

    <p class="text-gray-300">We were not able to provide a completely satisfactory analysis of the failure probability in this case. However, based on a conjecture – which we consider believable given our analysis of (unpunctured) RAA codes – we can obtain good bounds on the failure probability. We sketch this analysis below.</p>

    <p class="text-gray-300">Our strategy is to once again bound the expected number of codewords with weight at most  <span class="math">\\delta&#x27; n&#x27;</span> , where  <span class="math">\\delta&#x27;</span>  is the target minimum distance of our punctured code. We can write the probability that a weight  <span class="math">w_3</span>  string of length n is punctured into a weight  <span class="math">w_4</span>  string of length n' as</p>

    <p class="text-gray-300"><span id="page-71-2"></span> <span class="math-block">\\frac{\\binom{w_3}{w_4}\\binom{n-w_3}{n&#x27;-w_4}}{\\binom{n}{n&#x27;}}.</span></p>

    <p class="text-gray-300">This means we can write the expectation we need to bound as</p>

    <p class="text-gray-300"><span class="math-block">\\sum_{w_{1}}^{n/r} \\sum_{w_{2}=1}^{n} \\sum_{w_{3}=1}^{n} \\sum_{w_{4}=1}^{d&#x27;} \\binom{n/r}{w_{1}} \\cdot \\frac{\\binom{rw_{1}}{\\lceil rw_{1}/2 \\rceil} \\binom{n-rw_{1}}{w_{2}-\\lceil rw_{1}/2 \\rceil}}{\\binom{n}{w_{2}}} \\cdot \\frac{\\binom{w_{2}}{\\lceil w_{2}/2 \\rceil} \\binom{n-w_{2}}{w_{3}-\\lceil w_{2}/2 \\rceil}}{\\binom{n}{w_{3}}} \\cdot \\frac{\\binom{rw_{1}/2}{\\lceil w_{2}/2 \\rceil} \\binom{rw_{3}}{m_{2}/2}}{\\binom{n}{w_{4}} \\binom{n-w_{3}}{n&#x27;-w_{4}}}}{\\binom{n}{m&#x27;}},</span> (25)</p>

    <p class="text-gray-300">where  <span class="math">d&#x27; = \\delta&#x27; n&#x27; = \\delta&#x27; \\eta n</span> .</p>

    <p class="text-gray-300">We will split this sum up based on the value of  <span class="math">w_3</span>  (the weight of the rate 1/r RAA code, just before puncturing), specifically we separately consider  <span class="math">w_3 \\leq d</span>  and  <span class="math">w_3 &gt; d</span> .<sup>31</sup> For the former case, we can re-use our bound on the error probability of sampling an unpunctured RAA code from Theorem Eq. (18), as this exactly bounded the contribution of  <span class="math">w_3 \\leq d</span>  to the expectation. For the latter, we need to do some more work. Specifically, inspired again by [KZKJ08], we will do something similar to the proof of Proposition 9.6, where we rewrite the expression in the sum as some function  <span class="math">F(\\alpha, \\beta, \\rho, \\rho&#x27;)</span>  over the relative weights, and we attempt to maximize F over the legal range of these weights. Note that we can get away with this since we have a linear lower-bound on  <span class="math">w_3</span> ; as we noted before, in case all weights are constant, the maximization of F will be too large to obtain a small error probability.</p>

    <p class="text-gray-300">Specifically, recall from the proof of Proposition 9.6 that we can write the contribution of the first three fractions of the expression inside the sums in (25) as  <span class="math">poly(n) \\cdot 2^{n \\cdot f(\\alpha,\\beta,\\rho)}</span>  where</p>

    <div class="my-4 text-center"><span class="math-block">f(\\alpha,\\beta,\\rho) := \\frac{H(\\alpha)}{r} + (1-\\alpha)H\\left(\\frac{\\beta - \\frac{\\alpha}{2}}{1-\\alpha}\\right) + \\alpha + \\beta + (1-\\beta)H\\left(\\frac{\\rho - \\frac{\\beta}{2}}{1-\\beta}\\right) - H(\\beta) - H(\\rho) .</span></div>

    <p class="text-gray-300"><span id="page-71-1"></span> <span class="math">&lt;sup&gt;\\&lt;/sup&gt;overline{^{31}}</span> In fact, one could potentially a threshold t potentially below d, as long as  <span class="math">\\omega t &gt; d&#x27;</span> .</p>

    <p class="text-gray-300"><span id="page-72-1"></span>Looking at Equation (39) in [KZKJ08], we can write the contribution of the fourth fraction (accounting for the puncturing step) as  <span class="math">poly(n) \\cdot 2^{n \\cdot \\varphi(\\rho, \\rho&#x27;)}</span>  where</p>

    <div class="my-4 text-center"><span class="math-block">\\varphi(\\rho, \\rho&#x27;) := H\\left(\\omega \\frac{\\rho&#x27;}{\\rho}\\right) \\rho + H\\left((1 - \\omega) \\frac{1 - \\rho&#x27;}{1 - \\rho}\\right) (1 - \\rho) - H(\\omega) .</span></div>

    <p class="text-gray-300">The crux of the argument for the case  <span class="math">w_3 &gt; d</span>  is now to maximize the following function</p>

    <p class="text-gray-300"><span class="math-block">F(\\alpha, \\beta, \\rho, \\rho&#x27;) := f(\\alpha, \\beta, \\rho) + \\varphi(\\rho, \\rho&#x27;)</span> .</p>

    <p class="text-gray-300">where as before  <span class="math">\\alpha = rw_1/n</span> ,  <span class="math">\\beta = w_2/n</span> ,  <span class="math">\\rho = w_3/n</span> , and now we think of  <span class="math">\\rho&#x27; = w_4/n</span> . In particular, note that the maximum value of  <span class="math">\\rho&#x27;</span>  is  <span class="math">d&#x27;/n = \\omega \\delta</span> .</p>

    <p class="text-gray-300">To do this in a manageable way, we will start by arguing that F is increasing on  <span class="math">\\rho&#x27;</span> , so that we can simply set  <span class="math">\\rho&#x27; := \\omega \\delta&#x27;</span> . Specifically, we prove the lemma below, and this will imply that for all  <span class="math">\\alpha, \\beta, \\rho \\in (0, 1)</span>  and  <span class="math">\\rho&#x27; \\in [0, \\delta&#x27;]</span> ,</p>

    <p class="text-gray-300"><span class="math-block">F(\\alpha, \\beta, \\rho, \\rho&#x27;) \\leq F(\\alpha, \\beta, \\rho, \\delta&#x27;)</span> .</p>

    <p class="text-gray-300"><strong>Lemma 9.17.</strong> Fix  <span class="math">\\rho \\in (0,1)</span> , and consider the univariate function</p>

    <div class="my-4 text-center"><span class="math-block">\\psi = \\psi_{\\rho} : [0, \\delta&#x27;] \\to \\mathbb{R}, \\quad \\rho&#x27; \\mapsto \\varphi(\\rho, \\rho&#x27;)</span></div>

    <p class="text-gray-300">where  <span class="math">\\rho &gt; \\frac{\\omega \\delta&#x27;}{1 - (1 - \\omega)(1 - \\delta&#x27;)}</span>  and  <span class="math">1 - \\frac{1}{2}(1 - \\omega) &gt; \\delta&#x27;</span> . The function  <span class="math">\\psi</span>  is increasing on its domain.</p>

    <p class="text-gray-300"><em>Proof.</em> We begin by considering the derivative of  <span class="math">\\varphi</span>  with respect to  <span class="math">\\rho&#x27;</span> , which is</p>

    <div class="my-4 text-center"><span class="math-block">\\omega \\log \\left( \\frac{(\\rho - \\omega \\rho&#x27;) \\cdot (1 - (1 - \\omega)(1 - \\rho&#x27;))}{\\omega \\rho&#x27;(1 - \\omega)(1 - \\rho&#x27;)} \\right) - \\log \\left( \\frac{1 - (1 - \\omega)(1 - \\rho&#x27;)}{(1 - \\omega)(1 - \\rho&#x27;)} \\right) .</span></div>

    <p class="text-gray-300">We claim this expression is always > 0, i.e., that</p>

    <div class="my-4 text-center"><span class="math-block">\\omega \\log \\left( \\frac{(\\rho - \\omega \\rho&#x27;) \\cdot (1 - (1 - \\omega)(1 - \\rho&#x27;))}{\\omega \\rho&#x27;(1 - \\omega)(1 - \\rho&#x27;)} \\right) &gt; \\log \\left( \\frac{1 - (1 - \\omega)(1 - \\rho&#x27;)}{(1 - \\omega)(1 - \\rho&#x27;)} \\right) . \\tag{26}</span></div>

    <p class="text-gray-300">We first observe that the RHS above is negative, which is equivalent to</p>

    <p class="text-gray-300"><span id="page-72-0"></span> <span class="math-block">1 - (1 - \\omega)(1 - \\rho&#x27;) &gt; (1 - \\omega)(1 - \\rho&#x27;)</span> .</p>

    <p class="text-gray-300">Straightforward algebraic manipulations show that the above condition is equivalent to  <span class="math">1 - \\frac{1}{2}(1 - \\omega) &gt; \\rho&#x27;</span> , which follows from one of our assumptions on  <span class="math">\\delta&#x27;</span>  (recall  <span class="math">\\rho&#x27; \\leq \\delta&#x27;</span> ). Hence, it now suffices to argue that the LHS of (26) is positive, which is itself equivalent to</p>

    <div class="my-4 text-center"><span class="math-block">(\\rho - \\omega \\rho&#x27;) \\cdot (1 - (1 - \\omega)(1 - \\rho&#x27;)) &gt; \\omega \\rho&#x27;(1 - \\omega)(1 - \\rho&#x27;).</span></div>

    <p class="text-gray-300">Expanding the LHS above yields</p>

    <div class="my-4 text-center"><span class="math-block">\\rho - \\omega \\rho&#x27; - \\rho (1 - \\omega)(1 - \\rho&#x27;) + \\omega \\rho&#x27; (1 - \\omega)(1 - \\rho&#x27;)</span></div>

    <p class="text-gray-300">and so it suffices to argue</p>

    <div class="my-4 text-center"><span class="math-block">\\rho - \\omega \\rho&#x27; - \\rho (1 - \\omega)(1 - \\rho&#x27;) &gt; 0 \\iff \\rho &gt; \\frac{\\omega \\rho&#x27;}{1 - (1 - \\omega)(1 - \\rho&#x27;)}.</span></div>

    <p class="text-gray-300">As we assumed  <span class="math">\\rho &gt; \\frac{\\omega \\delta&#x27;}{1-(1-\\omega)(1-\\delta&#x27;)}</span>  and the function  <span class="math">\\rho&#x27; \\mapsto \\frac{\\omega \\rho&#x27;}{1-(1-\\omega)(1-\\rho&#x27;)}</span>  is increasing on the interval  <span class="math">[0,\\delta&#x27;]</span>  (the derivative  <span class="math">\\frac{\\omega(1-(1-\\omega)(1-\\rho&#x27;))+\\omega\\rho&#x27;(1-\\omega)}{(1-(1-\\omega)(1-\\rho&#x27;))^2}</span>  is manifestly positive on this domain), our desired conclusion follows.</p>

    <p class="text-gray-300"><span id="page-73-2"></span>Upon fixing  <span class="math">\\rho&#x27;</span>  to  <span class="math">\\delta&#x27;</span> , we are now reduced to considering a trivariate function. We now consider fixing  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span> , and observe that the resulting function is <em>concave</em>. This is analogous to Lemma 9.10 and Lemma 9.11.</p>

    <p class="text-gray-300"><strong>Lemma 9.18.</strong> Fix  <span class="math">\\alpha, \\beta \\in (0,1)</span> , and consider the univariate function</p>

    <div class="my-4 text-center"><span class="math-block">\\tau = \\tau_{\\alpha,\\beta} : (\\max\\{\\delta,\\beta/2\\}, \\min\\{\\omega(1+\\delta&#x27;-\\omega\\delta&#x27;), 1-\\beta/2\\}) \\to \\mathbb{R}, \\quad \\rho \\mapsto F(\\alpha,\\beta,\\rho,\\omega\\delta&#x27;) .</span></div>

    <p class="text-gray-300">The function  <span class="math">\\tau</span>  is concave on its domain.</p>

    <p class="text-gray-300">It thus makes sense to find values  <span class="math">\\rho</span>  maximizing F by looking for critical points, i.e., points where  <span class="math">\\frac{\\partial F}{\\partial \\rho} = 0</span> . Looking at Equation (42) in [KZKJ08], this is true exactly when we have</p>

    <p class="text-gray-300"><span id="page-73-1"></span> <span class="math-block">\\rho&#x27; = \\frac{\\rho(c+1) - 1/2}{1+c} \\quad \\text{where} \\quad c = \\frac{(1-\\rho)^2(\\rho - \\beta/2)}{\\rho^2(1-\\rho - \\beta/2)} \\,, \\tag{27}</span></p>

    <p class="text-gray-300"><em>Proof.</em> We can first compute the derivative (following [KZKJ08, Equation (41)])</p>

    <p class="text-gray-300"><span id="page-73-0"></span> <span class="math-block">\\frac{d\\tau}{d\\rho} = \\log\\left(\\frac{\\rho^2(1-\\rho-\\beta/2)((1-\\rho)-(1-\\omega)(1-\\omega\\delta&#x27;))}{(1-\\rho)^2(\\rho-\\beta/2)(\\rho-\\omega\\delta&#x27;)}\\right).</span></p>

    <p class="text-gray-300">Calling the numerator inside the logarithm  <span class="math">s(\\rho)</span>  and the denominator  <span class="math">t(\\rho)</span> , it follows that</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{d^2\\tau}{d\\rho^2} = \\frac{1}{\\ln 2} \\frac{t(\\rho)}{s(\\rho)} \\cdot \\frac{t(\\rho)s&#x27;(\\rho) - s(\\rho)t&#x27;(\\rho)}{(t(\\rho))^2} = \\frac{1}{\\ln 2} = \\frac{t(\\rho)s&#x27;(\\rho) - s(\\rho)t&#x27;(\\rho)}{s(\\rho)t(\\rho)} . \\tag{28}</span></div>

    <p class="text-gray-300">First, we note that  <span class="math">\\frac{1}{\\ln 2} &gt; 0</span> , and similarly that  <span class="math">s(\\rho)t(\\rho) &gt; 0</span> . Indeed,</p>

    <div class="my-4 text-center"><span class="math-block">s(\\rho)t(\\rho) = \\rho^{2}(1 - \\rho - \\beta/2)(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))(1 - \\rho)^{2}(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;)</span></div>

    <p class="text-gray-300">and it is immediate to verify that for  <span class="math">\\delta \\in (\\max\\{\\delta, \\beta/2\\}, \\min\\{\\omega(1+\\delta&#x27;-\\omega\\delta&#x27;), 1-\\beta/2\\})</span>  all the terms appearing above are positive (using that  <span class="math">\\rho &gt; \\delta \\ge \\omega\\delta&#x27;</span> ). Hence, it suffices to argue that the numerator of (28) is negative.</p>

    <p class="text-gray-300">We have</p>

    <div class="my-4 text-center"><span class="math-block">t(\\rho)s&#x27;(\\rho) - s(\\rho)t&#x27;(\\rho)</span></div>

    <div class="my-4 text-center"><span class="math-block">= (1 - \\rho)^{2}(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;) \\left[ 2\\rho(1 - \\rho - \\beta/2)(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;)) - \\rho^{2}(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;)) - \\rho^{2}(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;)) \\right]</span></div>

    <div class="my-4 text-center"><span class="math-block">- \\rho^{2}(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;)) \\left[ -2(1 - \\rho)(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;) + (1 - \\rho)^{2}(\\rho - \\omega\\delta&#x27;) + (1 - \\rho)^{2}(\\rho - \\omega\\delta&#x27;) + (1 - \\rho)^{2}(\\rho - \\beta/2) \\right]</span></div>

    <div class="my-4 text-center"><span class="math-block">= 2(1 - \\rho)^{2}(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;)\\rho(1 - \\rho - \\beta/2)(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))</span></div>

    <div class="my-4 text-center"><span class="math-block">+ 2\\rho^{2}(1 - \\rho - \\beta/2)(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))(1 - \\rho)(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;)</span></div>

    <div class="my-4 text-center"><span class="math-block">- (1 - \\rho)^{2}(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;)\\rho^{2}(1 - \\rho - \\beta/2)</span></div>

    <div class="my-4 text-center"><span class="math-block">- (1 - \\rho)^{2}(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;)\\rho^{2}(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))</span></div>

    <div class="my-4 text-center"><span class="math-block">- \\rho^{2}(1 - \\rho - \\beta/2)(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))(1 - \\rho)^{2}(\\rho - \\beta/2)</span></div>

    <div class="my-4 text-center"><span class="math-block">- \\rho^{2}(1 - \\rho - \\beta/2)(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))(1 - \\rho)^{2}(\\rho - \\omega\\delta&#x27;)</span></div>

    <p class="text-gray-300">That the above is negative follows from the following four inequalities, which are all easily derived:</p>

    <p class="text-gray-300">• First,</p>

    <div class="my-4 text-center"><span class="math-block">(1 - \\rho)^{2}(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;)\\rho(1 - \\rho - \\beta/2)(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))</span></div>

    <div class="my-4 text-center"><span class="math-block">&lt; \\rho^{2}(1 - \\rho - \\beta/2)(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))(1 - \\rho)^{2}(\\rho - \\beta/2)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\iff \\rho - \\omega\\delta&#x27; &lt; \\rho ,</span></div>

    <p class="text-gray-300">which holds since ωδ′ > 0.</p>

    <p class="text-gray-300">• Second,</p>

    <div class="my-4 text-center"><span class="math-block">(1-\\rho)^2(\\rho-\\beta/2)(\\rho-\\omega\\delta&#x27;)\\rho(1-\\rho-\\beta/2)(1-\\rho-(1-\\omega)(1-\\omega\\delta&#x27;))</span></div>

    <div class="my-4 text-center"><span class="math-block">&lt;\\rho^2(1-\\rho-\\beta/2)(1-\\rho-(1-\\omega)(1-\\omega\\delta&#x27;))(1-\\rho)^2(\\rho-\\omega\\delta&#x27;)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\iff \\rho-\\beta/2&lt;\\rho \\ ,</span></div>

    <p class="text-gray-300">which holds since β > 0.</p>

    <p class="text-gray-300">• Third,</p>

    <div class="my-4 text-center"><span class="math-block">\\rho^{2}(1 - \\rho - \\beta/2)(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))(1 - \\rho)(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;)</span></div>

    <div class="my-4 text-center"><span class="math-block">&lt; (1 - \\rho)^{2}(\\rho - \\beta/2)(\\rho - \\delta&#x27;)\\rho^{2}(1 - \\rho - \\beta/2)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\iff 1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;) &lt; 1 - \\rho ,</span></div>

    <p class="text-gray-300">which holds since (1 − ω)(1 − ωδ′ ) > 0.</p>

    <p class="text-gray-300">• Lastly,</p>

    <div class="my-4 text-center"><span class="math-block">\\rho^{2}(1 - \\rho - \\beta/2)(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))(1 - \\rho)(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;)</span></div>

    <div class="my-4 text-center"><span class="math-block">&lt; (1 - \\rho)^{2}(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;)\\rho^{2}(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))</span></div>

    <div class="my-4 text-center"><span class="math-block">\\iff 1 - \\rho - \\beta/2 &lt; 1 - \\rho,</span></div>

    <p class="text-gray-300">which again holds since β > 0.</p>

    <p class="text-gray-300">Thus, the second derivative of τ is negative on the domain (max{δ, β/2}, min{ω(1 + δ ′ − ωδ′ ), 1 − β/2}), implying that τ is concave, as claimed.</p>

    <p class="text-gray-300">The idea now is to provide an argument analogous to the end of the proof of <a href="#page-54-1">Proposition 9.6.</a> Namely, we argue that either a maximizer for F (with ρ ′ fixed to ωδ′ ) on the relevant domain occurs at a critical point (in which case we have either set δ or δ ′ too large), or that the "smallest" point is the maximizer. In our case, since ρ ≥ δ, this minimum value would be (r/n, r/(2n), δ,). However, we cannot fully establish this, so we leave the following conjecture.</p>

    <p class="text-gray-300">Conjecture 9.19. The maximum value for F over the set of all (α, β, ρ, ωδ′ ) for which</p>

    <p class="text-gray-300"><span class="math-block">\\beta \\le \\alpha/2, \\ \\frac{\\alpha}{2} \\le 1 - \\beta, \\ \\frac{\\beta}{2} \\le \\rho, \\ \\frac{\\beta}{2} &lt; 1 - \\rho\\delta</span>   <span class="math">\\le \\rho, \\ \\rho \\le (1 - \\omega) + \\omega\\delta&#x27;</span> .</p>

    <p class="text-gray-300">either occurs at a critical point, i.e., a point (α, β, ρ, ωδ) for which <a href="#page-58-0">\\(19\\)</a>, <a href="#page-58-1">\\(20\\)</a>, and <a href="#page-73-1">\\(27\\)</a> holds; or at the point (r/n, r/(2n), δ, ωδ′ ).</p>

    <p class="text-gray-300"><span id="page-75-5"></span>Assuming this conjecture, we can bound the failure probability of this second term quite naturally: namely, it will be of the form  <span class="math">\\operatorname{poly}(n)2^{Bn}</span> , where, assuming F is negative at all critical points, will be  <span class="math">F(r/n, r/(2n), \\delta, \\omega \\delta&#x27;)</span>  for large enough n. This term is actually of the order  <span class="math">-\\Omega(1)</span> , so the failure probability would be something like  <span class="math">2^{-\\Omega(n)}</span> . By combining this with the bound from the RAA code generation procedure – i.e., the probability that the RAA code prior to puncturing has minimum distance less than d – we can obtain meaningful bounds on the probability that a random punctured RAA code has minimum distance at most  <span class="math">\\delta&#x27;</span> , which we recorded in Figure 2.</p>

    <p class="text-gray-300">Lastly, we indicate that we can still run tests on the sampled RAA code, and correspondingly decrease the value of the first term. Thus, with an  <span class="math">\\tilde{O}(n^w)</span>  generation procedure, the failure probability will thus be  <span class="math">O(n^{-(w+1)(\\frac{r}{2}-1)+\\gamma})</span> .</p>

    <p class="text-gray-300">We thank Alex Block for helpful clarifications about [BGK<sup>+</sup>23] and Yuval Ishai for useful discussions on RAA codes. B. Chen was funded by DARPA, the Simons Foundation, UBRI, and NTT Research. Opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of DARPA. N. Resch is supported by an NWO (Dutch Research Council) grant with number C.2324.0590. This work was done in part while N. Resch was visiting the Simons Institute for the Theory of Computing, supported by DOE grant #DE-SC0024124.</p>

    <h2 id="sec-43" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-75-0"></span>[ACFY24] Gal Arnon, Alessandro Chiesa, Giacomo Fenzi, and Eylon Yogev. STIR: Reed-Solomon proximity testing with fewer queries. In Leonid Reyzin and Douglas Stebila, editors, Advances in Cryptology - CRYPTO 2024 - 44th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 18-22, 2024, Proceedings, Part X, volume 14929 of Lecture Notes in Computer Science, pages 380-413. Springer, 2024. 1, 11</li>

      <li><span id="page-75-4"></span>[AER24] Guillermo Angeris, Alex Evans, and Gyumin Roh. A note on Ligero and logarithmic randomness. Cryptology ePrint Archive, Paper 2024/1399, 2024. 33</li>

      <li><span id="page-75-3"></span>[AFLN24] Martin R Albrecht, Giacomo Fenzi, Oleksandra Lapiha, and Ngoc Khanh Nguyen. Slap: succinct lattice-based polynomial commitments from standard assumptions. In Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages 90–119. Springer, 2024. 12</li>

      <li><span id="page-75-1"></span>[AHIV23] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. Ligero: lightweight sublinear arguments without a trusted setup. <em>Des. Codes Cryptogr.</em>, 91(11):3379–3424, 2023. 4, 5, 6, 10, 11, 15</li>

      <li><span id="page-75-2"></span>[AS92] Sanjeev Arora and Shmuel Safra. Probabilistic checking of proofs; A new characterization of NP. In 33rd Annual Symposium on Foundations of Computer Science, Pittsburgh, Pennsylvania, USA, 24-27 October 1992, pages 2–13. IEEE Computer Society, 1992. 11</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-76-2"></span>[AST24] Arasu Arun, Srinath T. V. Setty, and Justin Thaler. Jolt: SNARKs for virtual machines via lookups. In Marc Joye and Gregor Leander, editors, Advances in Cryptology - EUROCRYPT 2024 - 43rd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zurich, Switzerland, May 26-30, 2024, Proceedings, Part VI, volume 14656 of Lecture Notes in Computer Science, pages 3–33. Springer, 2024. <a href="#page-0-0">1</a></li>

      <li><span id="page-76-5"></span>[BBB+18] Benedikt B¨unz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Gregory Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In 2018 IEEE Symposium on Security and Privacy, SP 2018, Proceedings, 21-23 May 2018, San Francisco, California, USA, pages 315–334. IEEE Computer Society, 2018. <a href="#page-12-0">11</a></li>

      <li><span id="page-76-0"></span>[BBHR18a] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Fast Reed-Solomon interactive oracle proofs of proximity. In Ioannis Chatzigiannakis, Christos Kaklamanis, D´aniel Marx, and Donald Sannella, editors, 45th International Colloquium on Automata, Languages, and Programming, ICALP 2018, July 9-13, 2018, Prague, Czech Republic, volume 107 of LIPIcs, pages 14:1–14:17. Schloss Dagstuhl - Leibniz-Zentrum f¨ur Informatik, 2018. <a href="#page-0-0">1,</a> <a href="#page-37-2">36</a></li>

      <li><span id="page-76-1"></span>[BBHR18b] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. IACR Cryptol. ePrint Arch., page 46, 2018. <a href="#page-0-0">1</a></li>

      <li><span id="page-76-6"></span>[BBHV22] Laasya Bangalore, Rishabh Bhadauria, Carmit Hazay, and Muthuramakrishnan Venkitasubramaniam. On black-box constructions of time and space efficient sublinear arguments from symmetric-key primitives. In Eike Kiltz and Vinod Vaikuntanathan, editors, Theory of Cryptography - 20th International Conference, TCC 2022, Chicago, IL, USA, November 7-10, 2022, Proceedings, Part I, volume 13747 of Lecture Notes in Computer Science, pages 417–446. Springer, 2022. <a href="#page-13-4">12</a></li>

      <li><span id="page-76-7"></span>[BC24] Dan Boneh and Binyi Chen. LatticeFold: A lattice-based folding scheme and its applications to succinct proof systems. Cryptology ePrint Archive, Paper 2024/257, 2024. <a href="#page-13-4">12</a></li>

      <li><span id="page-76-4"></span>[BCC+16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In Marc Fischlin and Jean-S´ebastien Coron, editors, Advances in Cryptology - EURO-CRYPT 2016 - 35th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Vienna, Austria, May 8-12, 2016, Proceedings, Part II, volume 9666 of Lecture Notes in Computer Science, pages 327–357. Springer, 2016. <a href="#page-12-0">11</a></li>

      <li><span id="page-76-3"></span>[BCG+17] Jonathan Bootle, Andrea Cerulli, Essam Ghadafi, Jens Groth, Mohammad Hajiabadi, and Sune K. Jakobsen. Linear-time zero-knowledge proofs for arithmetic circuit satisfiability. In Tsuyoshi Takagi and Thomas Peyrin, editors, Advances in Cryptology - ASIACRYPT 2017 - 23rd International Conference on the Theory and Applications of Cryptology and Information Security, Hong Kong, China, December 3-7, 2017, Proceedings, Part III, volume 10626 of Lecture Notes in Computer Science, pages 336–365. Springer, 2017. <a href="#page-5-3">4</a></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-77-1"></span>[BCG20] Jonathan Bootle, Alessandro Chiesa, and Jens Groth. Linear-time arguments with sublinear verification from tensor codes. In Rafael Pass and Krzysztof Pietrzak, editors, Theory of Cryptography - 18th International Conference, TCC 2020, Durham, NC, USA, November 16-19, 2020, Proceedings, Part II, volume 12551 of Lecture Notes in Computer Science, pages 19–46. Springer, 2020. <a href="#page-1-0">2,</a> <a href="#page-5-3">4,</a> <a href="#page-15-2">14</a></li>

      <li><span id="page-77-0"></span>[BCG+22] Elette Boyle, Geoffroy Couteau, Niv Gilboa, Yuval Ishai, Lisa Kohl, Nicolas Resch, and Peter Scholl. Correlated pseudorandomness from expand-accumulate codes. In Yevgeniy Dodis and Thomas Shrimpton, editors, Advances in Cryptology - CRYPTO 2022 - 42nd Annual International Cryptology Conference, CRYPTO 2022, Santa Barbara, CA, USA, August 15-18, 2022, Proceedings, Part II, volume 13508 of Lecture Notes in Computer Science, pages 603–633. Springer, 2022. <a href="#page-1-0">2,</a> <a href="#page-5-3">4,</a> <a href="#page-9-3">8,</a> <a href="#page-11-1">10</a></li>

      <li><span id="page-77-3"></span>[BCG+23] Elette Boyle, Geoffroy Couteau, Niv Gilboa, Yuval Ishai, Lisa Kohl, Nicolas Resch, and Peter Scholl. Oblivious transfer with constant computational overhead. In Carmit Hazay and Martijn Stam, editors, Advances in Cryptology - EUROCRYPT 2023 - 42nd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Lyon, France, April 23-27, 2023, Proceedings, Part I, volume 14004 of Lecture Notes in Computer Science, pages 271–302. Springer, 2023. <a href="#page-1-0">2</a></li>

      <li><span id="page-77-6"></span>[BCHO22] Jonathan Bootle, Alessandro Chiesa, Yuncong Hu, and Michele Orr\`u. Gemini: Elastic SNARKs for diverse environments. In Orr Dunkelman and Stefan Dziembowski, editors, Advances in Cryptology - EUROCRYPT 2022 - 41st Annual International Conference on the Theory and Applications of Cryptographic Techniques, Trondheim, Norway, May 30 - June 3, 2022, Proceedings, Part II, volume 13276 of Lecture Notes in Computer Science, pages 427–457. Springer, 2022. <a href="#page-13-4">12</a></li>

      <li><span id="page-77-4"></span>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In Martin Hirt and Adam D. Smith, editors, Theory of Cryptography - 14th International Conference, TCC 2016-B, Beijing, China, October 31 - November 3, 2016, Proceedings, Part II, volume 9986 of Lecture Notes in Computer Science, pages 31–60, 2016. <a href="#page-4-2">3,</a> <a href="#page-6-0">5,</a> <a href="#page-14-2">13,</a> <a href="#page-20-2">19</a></li>

      <li><span id="page-77-2"></span>[BFK+24] Alexander R Block, Zhiyong Fang, Jonathan Katz, Justin Thaler, Hendrik Waldner, and Yupeng Zhang. Field-agnostic SNARKs from expand-accumulate codes. In Annual International Cryptology Conference, pages 276–307. Springer, 2024. <a href="#page-1-0">2,</a> <a href="#page-10-0">9,</a> <a href="#page-11-1">10,</a> <a href="#page-12-0">11,</a> <a href="#page-42-3">41</a></li>

      <li><span id="page-77-7"></span>[BFS20] Benedikt B¨unz, Ben Fisch, and Alan Szepieniec. Transparent SNARKs from DARK compilers. In Anne Canteaut and Yuval Ishai, editors, Advances in Cryptology - EURO-CRYPT 2020 - 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zagreb, Croatia, May 10-14, 2020, Proceedings, Part I, volume 12105 of Lecture Notes in Computer Science, pages 677–706. Springer, 2020. <a href="#page-15-2">14</a></li>

      <li><span id="page-77-5"></span>[BGG+88] Michael Ben-Or, Oded Goldreich, Shafi Goldwasser, Johan H˚astad, Joe Kilian, Silvio Micali, and Phillip Rogaway. Everything provable is provable in zero-knowledge. In Shafi Goldwasser, editor, Advances in Cryptology - CRYPTO '88, 8th Annual International Cryptology Conference, Santa Barbara, California, USA, August 21-25, 1988,</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proceedings, volume 403 of Lecture Notes in Computer Science, pages 37–56. Springer, 1988. <a href="#page-4-2">3</a></li>

      <li><span id="page-78-3"></span>[BGH+06] Eli Ben-Sasson, Oded Goldreich, Prahladh Harsha, Madhu Sudan, and Salil P. Vadhan. Robust PCPs of proximity, shorter PCPs, and applications to coding. SIAM J. Comput., 36(4):889–974, 2006. <a href="#page-12-0">11</a></li>

      <li><span id="page-78-7"></span>[BGK+23] Alexander R. Block, Albert Garreta, Jonathan Katz, Justin Thaler, Pratyush Ranjan Tiwari, and Michal Zajac. Fiat-Shamir security of FRI and related SNARKs. In Advances in Cryptology - ASIACRYPT 2023 - 29th International Conference on the Theory and Application of Cryptology and Information Security, Guangzhou, China, December 4-8, 2023, Proceedings, Part II, volume 14439, pages 3–40. Springer, 2023. <a href="#page-75-5">74,</a> <a href="#page-85-1">84</a></li>

      <li><span id="page-78-0"></span>[BGKS20] Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, and Shubhangi Saraf. DEEP-FRI: sampling outside the box improves soundness. In Thomas Vidick, editor, 11th Innovations in Theoretical Computer Science Conference, ITCS 2020, January 12-14, 2020, Seattle, Washington, USA, volume 151 of LIPIcs, pages 5:1–5:32. Schloss Dagstuhl - Leibniz-Zentrum f¨ur Informatik, 2020. <a href="#page-0-0">1,</a> <a href="#page-40-1">39</a></li>

      <li><span id="page-78-4"></span>[BHR+20] Alexander R. Block, Justin Holmgren, Alon Rosen, Ron D. Rothblum, and Pratik Soni. Public-coin zero-knowledge arguments with (almost) minimal time and space overheads. In Rafael Pass and Krzysztof Pietrzak, editors, Theory of Cryptography - 18th International Conference, TCC 2020, Durham, NC, USA, November 16-19, 2020, Proceedings, Part II, volume 12551 of Lecture Notes in Computer Science, pages 168–197. Springer, 2020. <a href="#page-13-4">12</a></li>

      <li><span id="page-78-5"></span>[BHR+21] Alexander R. Block, Justin Holmgren, Alon Rosen, Ron D. Rothblum, and Pratik Soni. Time- and space-efficient arguments from groups of unknown order. In Tal Malkin and Chris Peikert, editors, Advances in Cryptology - CRYPTO 2021 - 41st Annual International Cryptology Conference, CRYPTO 2021, Virtual Event, August 16-20, 2021, Proceedings, Part IV, volume 12828 of Lecture Notes in Computer Science, pages 123–152. Springer, 2021. <a href="#page-13-4">12</a></li>

      <li><span id="page-78-2"></span>[BKS18] Eli Ben-Sasson, Swastik Kopparty, and Shubhangi Saraf. Worst-case to average case reductions for the distance to a code. In Rocco A. Servedio, editor, 33rd Computational Complexity Conference, CCC 2018, June 22-24, 2018, San Diego, CA, USA, volume 102 of LIPIcs, pages 24:1–24:23. Schloss Dagstuhl - Leibniz-Zentrum f¨ur Informatik, 2018. <a href="#page-11-1">10,</a> <a href="#page-16-4">15</a></li>

      <li><span id="page-78-1"></span>[BMS08] Louay Bazzi, Mohammad Mahdian, and Daniel A Spielman. The minimum distance of turbo-like codes. IEEE Transactions on Information Theory, 55(1):6–15, 2008. <a href="#page-4-2">3,</a> <a href="#page-8-2">7,</a> <a href="#page-9-3">8,</a> <a href="#page-43-3">42</a></li>

      <li><span id="page-78-6"></span>[BS23] Ward Beullens and Gregor Seiler. Labrador: compact proofs for r1cs from module-sis. In Annual International Cryptology Conference - CRYPTO, pages 518–548. Springer, 2023. <a href="#page-13-4">12</a></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-79-2"></span>[BSCI+20] Eli Ben-Sasson, Dan Carmon, Yuval Ishai, Swastik Kopparty, and Shubhangi Saraf. Proximity gaps for Reed–Solomon codes. In 2020 IEEE 61st Annual Symposium on Foundations of Computer Science (FOCS), pages 900–909. IEEE, 2020. <a href="#page-7-2">6,</a> <a href="#page-12-0">11,</a> <a href="#page-23-4">22,</a> <a href="#page-40-1">39</a></li>

      <li><span id="page-79-0"></span>[CBBZ23] Binyi Chen, Benedikt B¨unz, Dan Boneh, and Zhenfei Zhang. Hyperplonk: Plonk with linear-time prover and high-degree custom gates. In 42nd Annual International Conference on Theory and Applications of Cryptographic Techniques, EUROCRYPT 2023, pages 499–530. Springer Science and Business Media Deutschland GmbH, 2023. <a href="#page-0-0">1,</a> <a href="#page-10-0">9,</a> <a href="#page-12-0">11,</a> <a href="#page-14-2">13,</a> <a href="#page-23-4">22,</a> <a href="#page-28-3">27,</a> <a href="#page-84-1">83</a></li>

      <li><span id="page-79-9"></span>[CCH+19] Ran Canetti, Yilei Chen, Justin Holmgren, Alex Lombardi, Guy N Rothblum, Ron D Rothblum, and Daniel Wichs. Fiat-Shamir: from practice to theory. In Proceedings of the 51st Annual ACM SIGACT Symposium on Theory of Computing, pages 1082–1090, 2019. <a href="#page-21-4">20,</a> <a href="#page-83-7">82,</a> <a href="#page-84-1">83,</a> <a href="#page-85-1">84</a></li>

      <li><span id="page-79-5"></span>[CFFZ24] Alessandro Chiesa, Elisabetta Fedele, Giacomo Fenzi, and Andrew Zitek-Estrada. A time-space tradeoff for the sumcheck prover. IACR Cryptol. ePrint Arch., page 524, 2024. <a href="#page-13-4">12</a></li>

      <li><span id="page-79-7"></span>[CHM+20] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas Ward. Marlin: Preprocessing zkSNARKs with universal and updatable SRS. In Advances in Cryptology–EUROCRYPT 2020: 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zagreb, Croatia, May 10–14, 2020, Proceedings, Part I 39, pages 738–768. Springer, 2020. <a href="#page-15-2">14</a></li>

      <li><span id="page-79-4"></span>[CMNW24] Valerio Cini, Giulio Malavolta, Ngoc Khanh Nguyen, and Hoeteck Wee. Polynomial commitments from lattices: post-quantum security, fast verification and transparent setup. In Annual International Cryptology Conference - CRYPTO, pages 207–242. Springer, 2024. <a href="#page-13-4">12</a></li>

      <li><span id="page-79-8"></span>[CMS19] Alessandro Chiesa, Peter Manohar, and Nicholas Spooner. Succinct arguments in the quantum random oracle model. In Theory of Cryptography: 17th International Conference, TCC 2019, Nuremberg, Germany, December 1–5, 2019, Proceedings, Part II 17, pages 1–29. Springer, 2019. <a href="#page-20-2">19,</a> <a href="#page-21-4">20,</a> <a href="#page-83-7">82</a></li>

      <li><span id="page-79-6"></span>[COS20] Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. Fractal: Post-quantum and transparent recursive proofs from holography. In Advances in Cryptology–EUROCRYPT 2020: 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zagreb, Croatia, May 10–14, 2020, Proceedings, Part I 39, pages 769–793. Springer, 2020. <a href="#page-14-2">13,</a> <a href="#page-20-2">19,</a> <a href="#page-83-7">82</a></li>

      <li><span id="page-79-1"></span>[CY24] Alessandro Chiesa and Eylon Yogev. Building Cryptographic Proofs from Hash Functions. 2024. <a href="#page-4-2">3</a></li>

      <li><span id="page-79-3"></span>[dHS24] Thomas den Hollander and Daniel Slamanig. A crack in the firmament: Restoring soundness of the Orion proof system and more. Cryptology ePrint Archive, Paper 2024/1164, 2024. <a href="#page-12-0">11</a></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-80-6"></span>[DJM98] Dariush Divsalar, Hui Jin, and Robert J McEliece. Coding theorems for "turbo-like" codes. In Proceedings of the annual Allerton Conference on Communication control and Computing, volume 36, pages 201–210. University Of Illinois, 1998. <a href="#page-8-2">7,</a> <a href="#page-42-3">41</a></li>

      <li><span id="page-80-2"></span>[DP23] Benjamin E. Diamond and Jim Posen. Succinct arguments over towers of binary fields. IACR Cryptol. ePrint Arch., page 1784, 2023. <a href="#page-0-0">1,</a> <a href="#page-10-0">9,</a> <a href="#page-11-1">10,</a> <a href="#page-12-0">11</a></li>

      <li><span id="page-80-3"></span>[DP24a] Benjamin E. Diamond and Jim Posen. Polylogarithmic proofs for multilinears over binary towers. Cryptology ePrint Archive, Paper 2024/504, 2024. <a href="https://eprint.iacr.org/2024/504">https://eprint.</a> <a href="https://eprint.iacr.org/2024/504">iacr.org/2024/504</a>. <a href="#page-0-0">1,</a> <a href="#page-6-0">5,</a> <a href="#page-10-0">9,</a> <a href="#page-12-0">11,</a> <a href="#page-21-4">20,</a> <a href="#page-38-4">37</a></li>

      <li><span id="page-80-11"></span>[DP24b] Benjamin E. Diamond and Jim Posen. Proximity testing with logarithmic randomness. IACR Commun. Cryptol., 1(1):2, 2024. <a href="#page-34-2">33</a></li>

      <li><span id="page-80-7"></span>[FPP24] Cody Freitag, Omer Paneth, and Rafael Pass. Public-coin, complexity-preserving, succinct arguments of knowledge for NP from collision-resistance. In Marc Joye and Gregor Leander, editors, Advances in Cryptology - EUROCRYPT 2024 - 43rd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zurich, Switzerland, May 26-30, 2024, Proceedings, Part IV, volume 14654 of Lecture Notes in Computer Science, pages 112–141. Springer, 2024. <a href="#page-13-4">12</a></li>

      <li><span id="page-80-4"></span>[FS86] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Andrew M. Odlyzko, editor, Advances in Cryptology - CRYPTO '86, Santa Barbara, California, USA, 1986, Proceedings, volume 263 of Lecture Notes in Computer Science, pages 186–194. Springer, 1986. <a href="#page-0-0">1,</a> <a href="#page-4-2">3</a></li>

      <li><span id="page-80-1"></span>[GKR15] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. Delegating computation: Interactive proofs for muggles. J. ACM, 62(4):27:1–27:64, 2015. <a href="#page-0-0">1,</a> <a href="#page-32-2">31</a></li>

      <li><span id="page-80-5"></span>[GLS+23] Alexander Golovnev, Jonathan Lee, Srinath Setty, Justin Thaler, and Riad S Wahby. Brakedown: Linear-time and field-agnostic SNARKs for R1CS. In Annual International Cryptology Conference, pages 193–226, 2023. <a href="#page-1-0">2,</a> <a href="#page-4-2">3,</a> <a href="#page-5-3">4,</a> <a href="#page-6-0">5,</a> <a href="#page-11-1">10,</a> <a href="#page-12-0">11,</a> <a href="#page-37-2">36</a></li>

      <li><span id="page-80-8"></span>[GMR89] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof systems. SIAM J. Comput., 18(1):186–208, 1989. <a href="#page-13-4">12</a></li>

      <li><span id="page-80-9"></span>[GR17] Tom Gur and Ron D. Rothblum. A hierarchy theorem for interactive proofs of proximity. In Christos H. Papadimitriou, editor, 8th Innovations in Theoretical Computer Science Conference, ITCS 2017, January 9-11, 2017, Berkeley, CA, USA, volume 67 of LIPIcs, pages 39:1–39:43. Schloss Dagstuhl - Leibniz-Zentrum f¨ur Informatik, 2017. <a href="#page-14-2">13</a></li>

      <li><span id="page-80-0"></span>[HLP24] Ulrich Hab¨ock, David Levit, and Shahar Papini. Circle STARKs. IACR Cryptol. ePrint Arch., page 278, 2024. <a href="#page-0-0">1,</a> <a href="#page-12-0">11</a></li>

      <li><span id="page-80-10"></span>[HR18] Justin Holmgren and Ron D. Rothblum. Delegating computations with (almost) minimal time and space overhead. In Mikkel Thorup, editor, 59th IEEE Annual Symposium on Foundations of Computer Science, FOCS 2018, Paris, France, October 7-9, 2018, pages 124–135. IEEE Computer Society, 2018. <a href="#page-27-1">26</a></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-81-4"></span>[HR22] Justin Holmgren and Ron D. Rothblum. Faster sounder succinct arguments and IOPs. In Yevgeniy Dodis and Thomas Shrimpton, editors, Advances in Cryptology - CRYPTO 2022 - 42nd Annual International Cryptology Conference, CRYPTO 2022, Santa Barbara, CA, USA, August 15-18, 2022, Proceedings, Part I, volume 13507 of Lecture Notes in Computer Science, pages 474–503. Springer, 2022. <a href="#page-5-3">4</a></li>

      <li><span id="page-81-9"></span>[HSS24] Intak Hwang, Jinyeong Seo, and Yongsoo Song. Concretely efficient lattice-based polynomial commitment from standard assumptions. In Annual International Cryptology Conference - CRYPTO, pages 414–448. Springer, 2024. <a href="#page-13-4">12</a></li>

      <li><span id="page-81-0"></span>[Kil92] Joe Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In S. Rao Kosaraju, Mike Fellows, Avi Wigderson, and John A. Ellis, editors, Proceedings of the 24th Annual ACM Symposium on Theory of Computing, May 4-6, 1992, Victoria, British Columbia, Canada, pages 723–732. ACM, 1992. <a href="#page-4-2">3</a></li>

      <li><span id="page-81-5"></span>[KPV22] Assimakis A Kattis, Konstantin Panarin, and Alexander Vlasov. RedShift: transparent SNARKs from list polynomial commitments. In Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security, 2022. <a href="#page-6-0">5</a></li>

      <li><span id="page-81-11"></span>[KT23] Tohru Kohrita and Patrick Towa. Zeromorph: Zero-knowledge multilinear-evaluation proofs from homomorphic univariate commitments. Cryptology ePrint Archive, 2023:917, 2023. <a href="#page-37-2">36</a></li>

      <li><span id="page-81-1"></span>[KZCJ07] J¨org Kliewer, Kamil S Zigangirov, and Daniel J Costello Jr. New results on the minimum distance of repeat multiple accumulate codes. In Proc. 45th Annual Allerton Conf. Commun., Control, and Computing, 2007. <a href="#page-4-2">3,</a> <a href="#page-8-2">7,</a> <a href="#page-9-3">8,</a> <a href="#page-18-3">17,</a> <a href="#page-43-3">42</a></li>

      <li><span id="page-81-7"></span>[KZG10] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-size commitments to polynomials and their applications. In Masayuki Abe, editor, Advances in Cryptology - ASIACRYPT 2010 - 16th International Conference on the Theory and Application of Cryptology and Information Security, Singapore, December 5-9, 2010. Proceedings, volume 6477 of Lecture Notes in Computer Science, pages 177–194. Springer, 2010. <a href="#page-12-0">11</a></li>

      <li><span id="page-81-10"></span>[KZKJ08] J¨org Kliewer, Kamil S. Zigangirov, Christian Koller, and Daniel J. Costello Jr. Coding theorems for repeat multiple accumulate codes, 2008. <a href="#page-18-3">17,</a> <a href="#page-43-3">42,</a> <a href="#page-50-1">49,</a> <a href="#page-51-2">50,</a> <a href="#page-52-0">51,</a> <a href="#page-53-2">52,</a> <a href="#page-58-4">57,</a> <a href="#page-71-3">70,</a> <a href="#page-72-1">71,</a> <a href="#page-73-2">72</a></li>

      <li><span id="page-81-8"></span>[Lee20] Jonathan Lee. Dory: Efficient, transparent arguments for generalised inner products and polynomial commitments. IACR Cryptol. ePrint Arch., page 1274, 2020. <a href="#page-12-0">11</a></li>

      <li><span id="page-81-6"></span>[LF80] Richard E. Ladner and Michael J. Fischer. Parallel prefix computation. J. ACM, 27(4):831–838, 1980. <a href="#page-8-2">7</a></li>

      <li><span id="page-81-2"></span>[LFKN92] Carsten Lund, Lance Fortnow, Howard J. Karloff, and Noam Nisan. Algebraic methods for interactive proof systems. J. ACM, 39(4):859–868, 1992. <a href="#page-5-3">4,</a> <a href="#page-14-2">13</a></li>

      <li><span id="page-81-3"></span>[Mei13] Or Meir. IP = PSPACE using error-correcting codes. SIAM J. Comput., 42(1):380– 403, 2013. <a href="#page-5-3">4</a></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-82-4"></span>[Mic00] Silvio Micali. Computationally sound proofs. SIAM J. Comput., 30(4):1253–1298, 2000. <a href="#page-4-2">3</a></li>

      <li><span id="page-82-9"></span>[NS24] Ngoc Khanh Nguyen and Gregor Seiler. Greyhound: Fast polynomial commitments from lattices. In Annual International Cryptology Conference - CRYPTO, pages 243– 275. Springer, 2024. <a href="#page-13-4">12</a></li>

      <li><span id="page-82-10"></span>[Rot24] Ron D. Rothblum. A note on efficient computation of the multilinear extension. Cryptology ePrint Archive, Paper 2024/1103, 2024. <a href="https://eprint.iacr.org/2024/1103">https://eprint.iacr.org/2024/</a> <a href="https://eprint.iacr.org/2024/1103">1103</a>. <a href="#page-13-4">12</a></li>

      <li><span id="page-82-5"></span>[RR22] Noga Ron-Zewi and Ron D. Rothblum. Proving as fast as computing: succinct arguments with constant prover overhead. In Stefano Leonardi and Anupam Gupta, editors, STOC '22: 54th Annual ACM SIGACT Symposium on Theory of Computing, Rome, Italy, June 20 - 24, 2022, pages 1353–1363. ACM, 2022. <a href="#page-5-3">4</a></li>

      <li><span id="page-82-2"></span>[RR24] Noga Ron-Zewi and Ron Rothblum. Local proofs approaching the witness length. J. ACM, 71(3):18, 2024. <a href="#page-0-0">1,</a> <a href="#page-5-3">4,</a> <a href="#page-14-2">13</a></li>

      <li><span id="page-82-6"></span>[RRR16] Omer Reingold, Ron D. Rothblum, and Guy N. Rothblum. Constant-round interactive proofs for delegating computation. Electron. Colloquium Comput. Complex., TR16- 061, 2016. <a href="#page-6-0">5,</a> <a href="#page-14-2">13,</a> <a href="#page-15-2">14</a></li>

      <li><span id="page-82-7"></span>[RVW13] Guy N. Rothblum, Salil P. Vadhan, and Avi Wigderson. Interactive proofs of proximity: delegating computation in sublinear time. In Dan Boneh, Tim Roughgarden, and Joan Feigenbaum, editors, Symposium on Theory of Computing Conference, STOC'13, Palo Alto, CA, USA, June 1-4, 2013, pages 793–802. ACM, 2013. <a href="#page-7-2">6,</a> <a href="#page-16-4">15</a></li>

      <li><span id="page-82-0"></span>[Set20] Srinath T. V. Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In Daniele Micciancio and Thomas Ristenpart, editors, Advances in Cryptology - CRYPTO 2020 - 40th Annual International Cryptology Conference, CRYPTO 2020, Santa Barbara, CA, USA, August 17-21, 2020, Proceedings, Part III, volume 12172 of Lecture Notes in Computer Science, pages 704–737. Springer, 2020. <a href="#page-0-0">1</a></li>

      <li><span id="page-82-8"></span>[SL20] Srinath T. V. Setty and Jonathan Lee. Quarks: Quadruple-efficient transparent zk-SNARKs. IACR Cryptol. ePrint Arch., page 1275, 2020. <a href="#page-10-0">9,</a> <a href="#page-28-3">27</a></li>

      <li><span id="page-82-3"></span>[Spi96] Daniel A. Spielman. Linear-time encodable and decodable error-correcting codes. IEEE Trans. Inf. Theory, 42(6):1723–1731, 1996. <a href="#page-1-0">2</a></li>

      <li><span id="page-82-11"></span>[Sta23] StarkWare. ethSTARK documentation. Cryptology ePrint Archive, Paper 2021/582, 2023. <a href="#page-85-1">84</a></li>

      <li><span id="page-82-1"></span>[STW24] Srinath T. V. Setty, Justin Thaler, and Riad S. Wahby. Unlocking the lookup singularity with Lasso. In Marc Joye and Gregor Leander, editors, Advances in Cryptology - EUROCRYPT 2024 - 43rd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zurich, Switzerland, May 26-30, 2024, Proceedings, Part VI, volume 14656 of Lecture Notes in Computer Science, pages 180–209. Springer, 2024. <a href="#page-0-0">1</a></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-83-7"></span><span id="page-83-6"></span>[Tha13] Justin Thaler. Time-optimal interactive proofs for circuit evaluation. In Ran Canetti and Juan A. Garay, editors, Advances in Cryptology - CRYPTO 2013 - 33rd Annual Cryptology Conference, Santa Barbara, CA, USA, August 18-22, 2013. Proceedings, Part II, volume 8043 of Lecture Notes in Computer Science, pages 71–89. Springer, 2013. <a href="#page-14-2">13</a></li>

      <li><span id="page-83-5"></span>[Tha22] Justin Thaler. Proofs, arguments, and zero-knowledge. Found. Trends Priv. Secur., 4(2-4):117–660, 2022. <a href="#page-13-4">12,</a> <a href="#page-32-2">31</a></li>

      <li><span id="page-83-4"></span>[VSBW13] Victor Vu, Srinath T. V. Setty, Andrew J. Blumberg, and Michael Walfish. A hybrid architecture for interactive verifiable computation. In 2013 IEEE Symposium on Security and Privacy, SP 2013, Berkeley, CA, USA, May 19-22, 2013, pages 223–237. IEEE Computer Society, 2013. <a href="#page-13-4">12</a></li>

      <li><span id="page-83-3"></span>[WTS+18] Riad S. Wahby, Ioanna Tzialla, Abhi Shelat, Justin Thaler, and Michael Walfish. Doubly-efficient zkSNARKs without trusted setup. In 2018 IEEE Symposium on Security and Privacy, SP 2018, Proceedings, 21-23 May 2018, San Francisco, California, USA, pages 926–943. IEEE Computer Society, 2018. <a href="#page-12-0">11</a></li>

      <li><span id="page-83-2"></span>[XZS22] Tiancheng Xie, Yupeng Zhang, and Dawn Song. Orion: Zero knowledge proof with linear prover time. In Yevgeniy Dodis and Thomas Shrimpton, editors, Advances in Cryptology - CRYPTO 2022 - 42nd Annual International Cryptology Conference, CRYPTO 2022, Santa Barbara, CA, USA, August 15-18, 2022, Proceedings, Part IV, volume 13510 of Lecture Notes in Computer Science, pages 299–328. Springer, 2022. <a href="#page-1-0">2,</a> <a href="#page-4-2">3,</a> <a href="#page-12-0">11</a></li>

      <li><span id="page-83-1"></span>[ZCF24] Hadas Zeilberger, Binyi Chen, and Ben Fisch. Basefold: Efficient field-agnostic polynomial commitment schemes from foldable codes. In Leonid Reyzin and Douglas Stebila, editors, Advances in Cryptology - CRYPTO 2024 - 44th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 18-22, 2024, Proceedings, Part X, volume 14929 of Lecture Notes in Computer Science, pages 138–169. Springer, 2024. <a href="#page-0-0">1,</a> <a href="#page-6-0">5,</a> <a href="#page-10-0">9,</a> <a href="#page-12-0">11,</a> <a href="#page-21-4">20,</a> <a href="#page-37-2">36</a></li>

    </ul>

    <p class="text-gray-300">In this section, we sketch the proof idea of the round-by-round soundness of the IOPP for RMLE[PRAA<sup>t</sup> ]. As discussed in <a href="#page-20-0">Section 4,</a> after compiling the IOPP with Merkle commitments and the Fiat-Shamir transformation, the resulting argument preserves soundness and is therefore a polynomial commitment <a href="#page-79-8">\\[CMS19,</a>[COS20\\]](#page-79-6).</p>

    <p class="text-gray-300">We begin by briefly reviewing the concept of round-by-round (RBR) soundness <a href="#page-79-9">\\[CCH</a>+19]. A public-coin interactive protocol for a language L is round-by-round sound if there exists a state function over (partial) transcripts that satisfies the following three properties. (i) If the instance x is not in L, then the initial state of the protocol is doomed, i.e., State(x, ∅) = reject. (ii) In each round, if the current transcript is already in a doomed state, no matter how a malicious prover chooses its next message, with overwhelming probability over the verifier's challenge, the protocol state will remain doomed. (iii) If the full transcript is in a doomed state, the verifier will reject.</p>

    <p class="text-gray-300">We establish the RBR soundness of the IOPP for RMLE[PRAA<sup>t</sup> ] via the following steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-84-1"></span>1. We start by arguing the RBR soundness of the key building blocks, which include the evaluation batching protocol from Hyperplonk, the BaseFold IOPP for RMLE[RS], and the MLIOP for RMLE[PRAA] as described in <a href="#page-25-0">Section 5.</a></li>

      <li>2. Next, we argue that the MLIOP-to-IOPP transformation from <a href="#page-21-0">Section 4.1</a> preserves RBR soundness, assuming that the underlying evaluation batching protocol and the building block IOPP for RMLE[C] are RBR sound. By <a href="#page-21-3">Lemma 4.2</a> and the result in Step 1, we conclude that our IOPP for RMLE[PRAA] is RBR sound.</li>

      <li>3. Finally, we show that the interleaving IOPP for RMLE[C t ] (from <a href="#page-32-1">Section 6\\)</a> preserves RBR soundness if the underlying IOPP for RMLE[C] is RBR sound. Building on the conclusion from Step 2, this yields the desired result that the IOPP for RMLE[PRAA<sup>t</sup> ] is RBR sound.</li>

    </ul>

    <h2 id="sec-45" class="text-2xl font-bold">A.1 RBR Soundness of the Building Block Protocols</h2>

    <p class="text-gray-300">Evaluation batching. The evaluation batching protocol from Hyperplonk reduces t = 2<sup>ℓ</sup> > 1 multilinear evaluation claims into a single one. Let m denote the number of variables in each multilinear polynomial. The protocol begins with the verifier sampling and sending a random challenge vector r ∈ F ℓ . This challenge reduces the t multilinear evaluation claims into a single sumcheck claim over an (m+ℓ)-variate polynomial. The prover and the verifier then run a sumcheck protocol, which ultimately reduces the sumcheck claim to a single multilinear evaluation claim.</p>

    <p class="text-gray-300">Recall that we define the initial state as doomed if the instance x is not in L, meaning that one of the multilinear evaluation claims is false. After the verifier sends the first challenge vector r, we say that the partial transcript is doomed if and only if the resulting sumcheck claim is false wrt r and the t multilinear polynomials. It is straightforward to see that, if x /∈ L, then with overwhelming probability over r, the sumcheck claim will be false and state remains doomed. The protocol then proceeds with the sumcheck protocol, and the round-by-round soundness follows naturally from the RBR soundness of the sumcheck protocol <a href="#page-79-9">\\[CCH</a>+19].</p>

    <p class="text-gray-300">The MLIOP for RMLE[PRAA]. Given the instance x := (z, v, y), the MLIOP for RMLE[PRAA] <a href="#page-25-0">\\(Section 5\\)</a> proceeds as follows:</p>

    <p class="text-gray-300">First, the prover sends polynomials ˆm, ˆu2, ˆu<sup>3</sup> and ˆu<sup>4</sup> to the verifier. Let ˆu<sup>1</sup> denote the polynomial representing r copies of m. We define a partial transcript state as doomed if either ˆm(z) ̸= v or any of the equations below is not satisfied. Note that the state will be doomed if x /∈ L(RMLE[PRAA]).</p>

    <div class="my-4 text-center"><span class="math-block">u_2 = M_{\\pi_1} \\cdot u_1</span></div>

    <p class="text-gray-300"> <span class="math">u_3 = A \\cdot u_2</span>  <span class="math">u_4 = M_{\\pi_2} \\cdot u_3</span>  <span class="math">y = A \\cdot u_4</span> .</p>

    <p class="text-gray-300">Next, the verifier samples and sends random challenges α, β ∈ F, reducing the permutation relations to checking the existence of polynomials f1, g1, f2, g<sup>2</sup> that satisfy certain zero-check (or Hadamard check) relations—i.e., certain expressions evaluates to zero at every point in the boolean hypercube. The prover then provides oracles for f1, g1, f2, and g2. The doomed transcript states are redefined similarly to before, except that permutation checks are replaced by zero-checks. By the argument from <a href="#page-79-0">\\[CBBZ23,</a> Section 3.5], with overwhelming probability over α, β, the state will remain doomed if it was initially doomed.</p>

    <p class="text-gray-300"><span id="page-85-1"></span>After this, the verifier samples and sends a random challenge  <span class="math">r \\in \\mathbb{F}^{\\log n}</span>  that reduces the zero-check claims to a bunch of evaluation and sumcheck claims. The doomed transcript states are again defined similarly, now replacing the zero-checks with evaluation and sumcheck checks. By the Schwartz-Zippel lemma, with overwhelming probability over r, the state will remain doomed.</p>

    <p class="text-gray-300">Finally, the prover and the verifier run a sumcheck protocol to reduce the sumcheck claims to a single evaluation claim. The final transcript is doomed if  <span class="math">\\hat{m}(z) \\neq v</span>  or any of the evaluation claims fails. Recall that the sumcheck protocol is RBR sound, and the verifier indeed check  <span class="math">\\hat{m}(z) = v</span>  and the rest of the evaluations, thus rejecting if the final transcript is doomed. This finishes the proof.</p>

    <p class="text-gray-300">The BaseFold IOPP for  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{RS}]</span> . The BaseFold IOPP for  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{RS}]</span>  works by interleaving a sumcheck protocol with a FRI-like proximity check. The proximity check ensures that the implicit input y is close to an encoding of a message m, while the sumcheck guarantees that the evaluation claim regarding m holds. This evaluation claim can be equivalently expressed as a sumcheck statement. Crucially, in each round of the BaseFold IOPP, the verifier's challenge  <span class="math">r_i</span>  serves as both the sumcheck challenge and the folding challenge in the FRI protocol, which is essential for security.</p>

    <p class="text-gray-300">We prove the RBR soundness of BaseFold by combining the strategies for proving that of sumcheck  <span class="math">[CCH^+19]</span>  and FRI  <span class="math">[BGK^+23, Sta23]</span> .</p>

    <p class="text-gray-300">For any instance  <span class="math">(z, v, y) \\notin \\mathcal{L}(R_{\\mathsf{MLE}}[\\mathsf{RS}])</span> , note that either  <span class="math">\\pi_0 := y</span>  is  <span class="math">\\delta</span> -far from codewords, or the decoded message  <span class="math">m \\in \\mathbb{F}^{2^\\ell}</span>  of y doesn't satisfy the evaluation claim  <span class="math">\\hat{m}(z) = v</span> . Here, the claim  <span class="math">\\hat{m}(z) = v</span>  can be viewed as a sumcheck statement  <span class="math">v = \\sum_b \\hat{m}(b) \\cdot \\hat{eq}_z(b)</span> .</p>

    <p class="text-gray-300">For each round  <span class="math">i \\in [1, \\ell]</span> , let  <span class="math">\\pi&#x27;_1, \\ldots, \\pi&#x27;_i</span>  denote the oracle strings sent by the prover, let  <span class="math">r_0, \\ldots, r_i</span>  be the verifier's challenges, and  <span class="math">\\pi_1, \\ldots, \\pi_i</span>  denote the honestly folded proof oracles derived from  <span class="math">\\pi_0 = y</span>  and  <span class="math">r_0, \\ldots, r_{i-1}</span> . (Note that  <span class="math">\\pi_0</span>  is  <span class="math">\\delta</span> -far by assumption.) Let  <span class="math">m_i</span>  denote the decoding of  <span class="math">\\pi&#x27;_i</span>  (or  <span class="math">\\perp</span>  if  <span class="math">\\pi&#x27;_i</span>  is  <span class="math">\\delta</span> -far). We define the partial transcript state for round i as doomed if any of the following hold: (i) fold( <span class="math">\\pi_i, r_i</span> ) is  <span class="math">\\delta</span> -far from codewords; or (ii) for some  <span class="math">j \\in [1, i]</span>  where  <span class="math">\\pi_j := \\text{fold}(\\pi_{j-1}, r_{j-1})</span>  is  <span class="math">\\delta</span> -far from codewords, it holds that  <span class="math">\\pi&#x27;_j \\neq \\pi_j</span> ; or (iii) the reduced sumcheck claim (with respect to  <span class="math">m_i</span> ) fails. By sumcheck soundness and Theorem 2.5, with overwhelming probability over the verifier's challenge, the transcript remains doomed if it initially was.</p>

    <p class="text-gray-300">At the query phase, the verifier checks the final evaluation claim and performs consistency checks as required by the FRI and sumcheck protocols. Given the FRI query challenges, we modify the definition of doomed state for the final transcript (that includes the query challenges). In particular, we additionally check the consistency of  <span class="math">\\{\\pi&#x27;_j\\}_j</span>  over the query sets. The state is also doomed if any evaluation checks fail, or if the final proof string  <span class="math">\\pi&#x27;_\\ell</span>  sent by the prover is not an RS codeword. Using similar arguments as in Lemma 5.3 and Lemma 5.4 from [BGK<sup>+</sup>23], we can show that the final transcript is doomed with overwhelming probability if it was the case previously. This concludes the proof as the verifier will reject any doomed final state.</p>

    <h4 id="sec-46" class="text-lg font-semibold mt-6">A.2 RBR Soundness of the MLIOP-to-IOPP Transformation</h4>

    <p class="text-gray-300">We establish the RBR soundness of the MLIOP-to-IOPP transformation from Section 4, assuming that the underlying MLIOP for  <span class="math">\\mathcal{R}</span> , the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span> , and the batch evaluation protocol  <span class="math">\\Pi_{\\mathsf{batch}}</span>  are all RBR sound. To proceed, we define the set of doomed states and bound the probability of escaping the doomed set. Here, let  <span class="math">\\delta</span>  denote the proximity parameter for the building block IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span> , and set  <span class="math">\\delta&#x27; = c\\delta</span> , where c is the rate of code C.</p>

    <p class="text-gray-300">At the start of the protocol, when the transcript is empty, the state is considered doomed if the instance inst = (i, x, y) is  <span class="math">\\delta&#x27;</span> -far from any  <span class="math">(i, x, y^*) \\in \\mathcal{L}(\\mathcal{R})</span> . Initially, given the first oracle  <span class="math">\\tilde{y}</span>  sent</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">by the prover, denote  $\\pi_y = (y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{y})<span class="math"> , and set y&#x27; as the decoded message of  </span>\\pi_y<span class="math">  if  </span>\\pi_y<span class="math">  is  </span>\\delta<span class="math"> -close to C (otherwise, set  </span>y' = \\bot<span class="math"> ). We append  </span>\\pi_y<span class="math">  to the current transcript  </span>\\tau<span class="math">  and define the state as doomed if either  </span>y' = \\bot<span class="math">  or State&#x27;(inst&#x27;,  </span>\\emptyset<span class="math"> ) = reject, where inst&#x27; = (i, x, y&#x27;) and State&#x27; is the state function in the RBR soundness proof for the MLIOP. Clearly, if (i, x, y) is  </span>\\delta'<span class="math"> -far from any  </span>(i, x, y^*) \\in \\mathcal{L}(\\mathcal{R})<span class="math">  while  </span>\\pi_y<span class="math">  is  </span>\\delta<span class="math"> -close to C, then y is  </span>\\delta'<span class="math"> -close to y&#x27; and inst&#x27; =  </span>(i, x, y') \\notin \\mathcal{L}(\\mathcal{R})$ . Thus the state in the MLIOP will be doomed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For each subsequent MLIOP verifier challenge r, we append it to both the transcript  <span class="math">\\tau</span>  and the simulated transcript  <span class="math">\\tau&#x27;</span>  for the MLIOP. For every oracle  <span class="math">\\pi</span>  sent by the prover, let m be the decoded message of  <span class="math">\\pi</span>  if it is  <span class="math">\\delta</span> -close to C (set  <span class="math">m=\\bot</span>  otherwise). We append  <span class="math">\\pi</span>  to the transcript  <span class="math">\\tau</span>  and append m to the simulated transcript  <span class="math">\\tau&#x27;</span> . We say that (inst,  <span class="math">\\tau</span> ) is in a doomed state if State'(inst',  <span class="math">\\tau&#x27;</span> ) = reject. Wlog we assume that State'(inst',  <span class="math">\\tau&#x27;</span> ) is always doomed if  <span class="math">\\tau&#x27;</span>  includes any  <span class="math">\\bot</span>  symbols. By the RBR soundness of the MLIOP, the probability that a doomed transcript state escapes from the doomed set is negligible.</p>

    <p class="text-gray-300">Next, the prover and verifier run a batch evaluation protocol  <span class="math">\\Pi_{\\text{batch}}</span>  to reduce multiple evaluation claims to a single claim. We append the set of evaluation claims  <span class="math">\\text{inst}_{\\text{batch}}</span>  and the transcript  <span class="math">\\tau_{\\text{batch}}</span>  of  <span class="math">\\Pi_{\\text{batch}}</span>  to  <span class="math">\\tau</span> . We consider the transcript to be in a doomed state if  <span class="math">\\text{State}_{\\text{batch}}(\\text{inst}_{\\text{batch}}, \\tau_{\\text{batch}}) = \\text{reject}</span> , where  <span class="math">\\text{State}_{\\text{batch}}</span>  is the state function used in the proof of RBR soundness for  <span class="math">\\Pi_{\\text{batch}}</span> . By the RBR soundness of the batching protocol, the probability that a doomed transcript state escapes from the doomed set is negligible.</p>

    <p class="text-gray-300">Finally, the prover and verifier run a single IOPP  <span class="math">\\Sigma_C</span>  for  <span class="math">R_{\\mathsf{MLE}}[C]</span>  to check the reduced multilinear evaluation statement. We append this statement and the transcript of  <span class="math">\\Sigma_C</span>  to  <span class="math">\\tau</span> , and define the state according to the state function used in the proof of RBR soundness for  <span class="math">\\Sigma_C</span> . The RBR soundness of the transformation follows naturally from the RBR soundness of the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span> .</p>

    <p class="text-gray-300">We establish the RBR soundness of the IOPPs for interleaved codes from Section 6. Assume that the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span>  is RBR sound, where C is a base code over the alphabet  <span class="math">\\mathbb{F}</span> . To prove the RBR soundness of the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C^t]</span> , where  <span class="math">C^t</span>  is over the alphabet  <span class="math">\\mathbb{K} = \\mathbb{F}^t</span> , we define the set of doomed states and bound the probability of escaping from this set.</p>

    <p class="text-gray-300">Consider an instance  <span class="math">x = (i, z \\in \\mathbb{F}, v \\in \\mathbb{F}, c \\in \\mathbb{K}^n) \\notin \\mathcal{L}(R_{\\mathsf{MLE}}[C^t])</span> . We define m as the decoded message of c if c is  <span class="math">\\delta</span> -close to  <span class="math">C^t</span> ; otherwise we set  <span class="math">m = \\bot</span> . Since  <span class="math">x \\notin \\mathcal{L}(R_{\\mathsf{MLE}}[C^t])</span> , it follows that either  <span class="math">m = \\bot</span> , or  <span class="math">\\hat{m}(z) \\neq v</span> , where  <span class="math">\\hat{m}</span>  is the multilinear extension of m. Here, m is viewed as a t-by-k matrix over  <span class="math">\\mathbb{F}</span>  instead of  <span class="math">\\mathbb{K}</span> . In what follows, we decompose z into  <span class="math">(z_1, z_2) \\in \\mathbb{F}^{\\log t} \\times \\mathbb{F}^{\\log k}</span> .</p>

    <p class="text-gray-300">At the start of the protocol, the prover sends an oracle  <span class="math">u \\in \\mathbb{F}^t</span> , claimed to be the list of evaluations  <span class="math">\\{\\hat{m}_i(z_2)\\}_{i \\in [t]}</span> , where  <span class="math">m_i</span>  is the <em>i</em>-th row of the matrix m. We append u to the transcript and define the state as doomed if one of the following holds: (i)  <span class="math">m = \\bot</span>  (i.e., c is far from  <span class="math">C^t</span> ),(ii)  <span class="math">\\hat{u}(z_1) \\neq v</span> , or (iii)  <span class="math">u_i \\neq \\hat{m}_i(z_2)</span>  for some  <span class="math">i \\in [t]</span> . Importantly, if the instance  <span class="math">x \\notin \\mathcal{L}(R_{\\mathsf{MLE}}[C^t])</span> , the state will always be doomed.</p>

    <p class="text-gray-300">Next, the verifier samples a challenge  <span class="math">r \\in \\mathbb{F}^t</span>  and the prover folds both  <span class="math">c \\in \\mathbb{K}^n</span>  and u to  <span class="math">c_{\\mathsf{combo}} = r^\\top y \\in \\mathbb{F}^n</span>  and  <span class="math">v&#x27; = \\langle u, r \\rangle \\in \\mathbb{F}</span> . The state is then set as doomed if one of the following holds: (i)  <span class="math">c_{\\mathsf{combo}}</span>  is  <span class="math">(\\delta&#x27; = 0.99\\delta)</span> -far from C, or (ii)  <span class="math">\\hat{m}_{\\mathsf{combo}}(z_2) \\neq v&#x27;</span> , where  <span class="math">\\hat{m}_{\\mathsf{combo}}</span>  is the decoding of  <span class="math">c_{\\mathsf{combo}}</span> . Equivalently, it is doomed if and only if  <span class="math">(i, z_2, v&#x27;, c_{\\mathsf{combo}}) \\notin R_{\\mathsf{MLE}}[C]</span> . By Corollary 2.6 and Claim 6.1.1, the state remains doomed with high probability if it was doomed previously.</p>

    <p class="text-gray-300">Finally, the prover and verifier engage in the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span>  on the instance  <span class="math">x&#x27; = (i, z_2, v&#x27;, c_{\\mathsf{combo}})</span> . The RBR soundness of the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C^t]</span>  follows naturally from that of the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span> .</p>`;
---

<BaseLayout title="Blaze: Fast SNARKs from Interleaved RAA Codes (2024/1609)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/1609
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
