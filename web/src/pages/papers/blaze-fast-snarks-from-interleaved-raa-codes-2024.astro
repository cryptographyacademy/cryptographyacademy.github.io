---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/1609';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Blaze: Fast SNARKs from Interleaved RAA Codes';
const AUTHORS_HTML = 'Martijn Brehm, Binyi Chen, Ben Fisch, Nicolas Resch, Ron D. Rothblum, Hadas Zeilberger';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">In this work we construct a new and highly efficient multilinear polynomial commitment scheme (MLPCS) over binary  fields, which we call \\emph{Blaze}.    Polynomial commitment schemes allow a server to commit to a large polynomial and later decommit to its evaluations. Such schemes have emerged as a key component in recent efficient SNARK constructions.
    
Blaze has an extremely efficient prover, both asymptotically and concretely. The commitment is dominated by $8n$ field additions (i.e., XORs) and one Merkle tree computation. The evaluation proof generation is dominated by $6n$ additions and $5n$ multiplications over the field. The verifier runs in time $O_\\lambda(\\log^2(n))$. Concretely, for sufficiently large message sizes, the prover is faster than all prior schemes except for Brakedown (Golovnev et al., Crypto 2023), but offers significantly smaller proofs than the latter.

The scheme is obtained by combining two ingredients:

1. Building on the code-switching technique (Ron-Zewi and Rothblum, JACM 2024), we show how to compose any error-correcting code together with an interactive oracle proof of proximity (IOPP) underlying existing MLPCS constructions, into a new MLPCS. The new MLPCS inherits its proving time from the code&#x27;s encoding time, and its verification complexity from the underlying MLPCS. The composition is distinctive in that it is done purely on the information-theoretic side.

2. We apply the above methodology using an extremely efficient error-correcting code known as the Repeat-Accumulate-Accumulate (RAA) code. We give new asymptotic and concrete bounds, which demonstrate that (for sufficiently large message sizes) this code has a better encoding time vs. distance tradeoff than previous linear-time encodable codes that were considered in the literature.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> PCS &middot; SNARKs &middot; RAA codes</p>
    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">Throughout this work for equal length strings  <span class="math">x, y \\in \\Sigma^n</span>  over an alphabet  <span class="math">\\Sigma</span> , we denote their relative Hamming distance by  <span class="math">\\Delta(x,y) := \\frac{1}{n} |\\{i \\in [n] : x_i \\neq y_i\\}|</span> . For a non-empty set  <span class="math">S \\subseteq \\Sigma^n</span>  and  <span class="math">x \\in \\Sigma^n</span> , we define  <span class="math">\\Delta(u,S) := \\min\\{\\Delta(u,s) : s \\in S\\}</span> . The Hamming weight of a string is the number of non-zero coordinates.</p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Multilinear Extension</h3>

    <p class="text-gray-300">Let  <span class="math">\\mathbb{F}</span>  be a finite field and  <span class="math">m \\in \\mathbb{N}</span>  be an integer. For every function  <span class="math">f : \\{0,1\\}^m \\to \\mathbb{F}</span>  there exists a unique multilinear polynomial  <span class="math">\\widehat{f} : \\mathbb{F}^m \\to \\mathbb{F}</span>  that agrees with f on  <span class="math">\\{0,1\\}^m</span> . We refer to  <span class="math">\\widehat{f}</span>  as the multilinear extension (MLE) of f.</p>

    <p class="text-gray-300">The polynomial  <span class="math">\\widehat{f}</span>  can be expressed explicitly as:</p>

    <p class="text-gray-300"><span class="math">$\\widehat{f}(x) = \\sum_{b \\in \\{0,1\\}^m} eq(x,b) \\cdot f(b), \\tag{1}</span>$</p>

    <p class="text-gray-300">where  <span class="math">eq(x, b) = \\prod_{i \\in [m]} eq_1(x_i, b_i)</span>  and  <span class="math">eq_1(x_i, b_i) = x_i \\cdot b_i + (1 - x_i) \\cdot (1 - b_i)</span> .</p>

    <p class="text-gray-300">For a given  <span class="math">x \\in \\mathbb{F}^m</span> , the sequence of values  <span class="math">(eq(x,b))_{b \\in \\{0,1\\}^m}</span>  can be generated very efficiently, as demonstrated by the following proposition (see also [VSBW13, CFFZ24] and [Tha22, Section 3.5]).</p>

    <p class="text-gray-300"><strong>Proposition 2.1</strong> ([Rot24, Proposition 1 and Section 2.1]). Let  <span class="math">\\mathbb{F}</span>  be a binary extension field. Given as input  <span class="math">z \\in \\mathbb{F}^m</span> , the sequence of values  <span class="math">(eq(z,b))_{b \\in \\{0,1\\}^m}</span>  can be generated in lexicographic order in time  <span class="math">O(2^m)</span>  and space O(m). In more detail, the algorithm performs exactly  <span class="math">2^m</span>  field multiplications and an additional O(m) additions, multiplications and inversions over the field.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 Interactive Proofs and IOPs</h3>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{R}</span>  be an NP relation and denote the corresponding language by  <span class="math">\\mathcal{L}(\\mathcal{R}) = \\{x : \\exists w, (x, w) \\in \\mathcal{R}\\}</span> . Throughout, we will think of the language  <span class="math">\\mathcal{L}(\\mathcal{R})</span>  itself as a pair language - that is, the inputs are a pair (x, y) where x (which will typically be short) is called the <em>explicit input</em> and y (which is long) is called the <em>implicit input</em>. In certain cases, we may work with an <em>indexed relation</em>, where the input additionally includes an index i, such as the description of a circuit or a linear code.</p>

      <h4 id="sec-2.2.1" class="text-lg font-semibold mt-6">2.2.1 Interactive Proofs and Sumcheck</h4>

    <p class="text-gray-300">Interactive proofs [GMR89] are protocols enabling a prover to convince a verifier of the correctness of a statement  <span class="math">x \\in L</span>  by back and forth interaction. We do not formally define interactive proofs since</p>

    <p class="text-gray-300">this work focuses on a different form of proof, called an <em>interactive oracle proof</em> [BCS16, RRR16], which we define below. Still, we will make use of the celebrated sumcheck protocol [LFKN92], with a linear-time prover [Tha13], as described next:</p>

    <p class="text-gray-300"><strong>Lemma 2.2</strong> (The Sumcheck Protocol). Let  <span class="math">\\mathbb{F}</span>  be a finite field and  <span class="math">m, d \\in \\mathbb{N}</span> . There exists a protocol between a prover, who is given as input a description of an m-variate polynomial  <span class="math">Q : \\mathbb{F}^m \\to \\mathbb{F}</span>  of individual degree d, and a verifier who gets as input  <span class="math">\\alpha \\in \\mathbb{F}</span>  and either rejects or outputs  <span class="math">(z, v) \\in \\mathbb{F}^m \\times \\mathbb{F}</span> . The protocol satisfies the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Complexity: the protocol has m rounds. In each round the prover sends d+1 field elements and the verifier responds with a single field element. The verifier performs  <span class="math">O(d \\cdot m)</span>  field operations. The prover runs in time  <span class="math">O((d+1)^m)</span> .</li>
      <li>Completeness: if  <span class="math">\\alpha = \\sum_{x \\in \\{0,1\\}^m} Q(x)</span>  then when interacting with the honest prover, the verifier always outputs (z,v) such that Q(z) = v.</li>
      <li>Soundness: if  <span class="math">\\alpha \\neq \\sum_{x \\in \\{0,1\\}^m} Q(x)</span>  then, when interacting with any prover, with probability at least  <span class="math">1 \\frac{dm}{|\\mathbb{F}|}</span> , the verifier either rejects or outputs (z, v) such that  <span class="math">Q(z) \\neq v</span> .</li>
    </ul>

    <p class="text-gray-300">Remark 2.3 (Batch Sumcheck). Suppose we wish to simultaneously check k sumcheck statements  <span class="math">\\alpha_1 = \\sum_x f_1(x), \\ldots, \\alpha_k = \\sum_x f_k(x)</span> , where each  <span class="math">f_i : \\mathbb{F}^m \\to \\mathbb{F}</span>  is an individual degree d polynomial. Rather than running k separate sumcheck protocols, we can batch them by having the verifier select a random  <span class="math">\\lambda \\in \\mathbb{F}</span>  and running a single sumcheck on the statement  <span class="math">\\sum_{x \\in \\{0,1\\}^m} Q(x) = \\sum_{i=0}^{k-1} \\lambda^i \\cdot \\alpha_i</span> , where Q is the individual degree d polynomial defined as  <span class="math">Q(x) = \\sum_{i=0}^{k-1} \\lambda^i \\cdot f_i(x)</span> . This batching incurs an additional  <span class="math">k/|\\mathbb{F}|</span>  soundness error.</p>

    <p class="text-gray-300">Interactive Proofs for Batching Polynomial Evaluations. We recall an interactive protocol that reduce multiple multilinear evaluation claims into a single one [RR24, CBBZ23]. We state the result from [CBBZ23] due to its optimal prover complexity.</p>

    <p class="text-gray-300"><strong>Theorem 2.4</strong> ( [CBBZ23, Algorithm 4]). Let  <span class="math">f: \\{0,1\\}^{\\ell} \\to \\mathbb{F}</span>  be a function and denote by  <span class="math">\\widehat{f}</span>  its multilinear extension. There exists an interactive protocol that reduces t &gt; 1 evaluation claims for  <span class="math">\\widehat{f}</span>  to a single evaluation claim for  <span class="math">\\widehat{f}</span> . The protocol has soundness error  <span class="math">\\frac{2\\ell+3\\log_2(t)}{|\\mathbb{F}|}</span> , prover time  <span class="math">O(t \\cdot 2^{\\ell})</span> , verifier time  <span class="math">O(t\\ell)</span> , communication complexity  <span class="math">O(\\ell+\\log(t))</span>  and  <span class="math">\\ell+\\log_2(t)+O(1)</span>  rounds.</p>

      <h4 id="sec-2.2.2" class="text-lg font-semibold mt-6">2.2.2 Interactive Oracle Proofs</h4>

    <p class="text-gray-300">Interactive Oracle Proofs (IOP) [BCS16, RRR16] are a hybrid between interactive proofs, and probabilistically checkable proofs. In a nutshell, an IOP is an interactive protocol in which the prover can send long messages from which the verifier only reads very few symbols. In this work we focus on variants of IOPs which are introduced next.</p>

    <p class="text-gray-300"><strong>Holographic IOP.</strong> Holographic IOPs [COS20] combine features of IOPs and holographic interactive proofs [GR17]. Let  <span class="math">\\mathcal{R}</span>  be an indexed relation. A holographic IOP for  <span class="math">\\mathcal{R}</span>  is specified by an indexer I, a prover P and a verifier V. The IOP consists of an offline phase and an online phase.</p>

    <p class="text-gray-300">In the offline phase, the indexer I outputs an oracle  <span class="math">\\mathsf{idx}(i)</span>  given index i. In the online phase, the prover receives the input  <span class="math">(i, x, y, w) \\in \\mathcal{R}</span> , while the verifier receives x along with oracle access</p>

    <p class="text-gray-300">to idx(i) and y. The prover and verifier then engage in multiple rounds of interaction, where the prover sends an oracle proof string in each round, and the verifier responds with a message. At the end of the interaction, the verifier accepts or rejects.</p>

    <p class="text-gray-300">The protocol satisfies completeness if for every (i, x, y, w) &isin; R, the prover convinces the verifier with probability 1. The protocol has soundness error &#1013; if for every (i, x, y) &isin; L / (R) and every malicious prover P &lowast; in the IOP model, the probability that the verifier accepts is at most &#1013;.</p>

    <p class="text-gray-300">Multilinear polynomial IOPs (MLIOP). Next, we define the notion of a multilinear polynomial IOP (MLIOP)<a href="#page-15-1">11</a>. Let R be an indexed relation as described earlier, where the online inputs are pairs of an explicit and implicit input. An MLIOP for R is a public coin interactive protocol between a prover, a verifier, and optionally a trusted indexer. The indexer is omitted when the relation has no index component. The protocol consists of following phases:</p>

    <p class="text-gray-300">Offline phase: The trusted indexer provides the verifier with a multilinear polynomial oracle idx, which encodes the index of the relation R.</p>

    <p class="text-gray-300">Interaction phase: The verifier receives the explicit input x &isin; X and has access to the multilinear extension of the implicit input y &isin; Y and multilinear access to idx. The prover receives (x, y) and the witness w &isin; W. The prover and verifier engage in multiple rounds of communication, where in each round the prover sends a set of multilinear polynomial oracles and possibly an additional string. The verifier responds with a list of random challenges.</p>

    <p class="text-gray-300">Query phase: The verifier evaluates the multilinear polynomial oracles at specific points and queries certain entries of y. Finally, the verifier accepts or rejects.</p>

    <p class="text-gray-300">The protocol satisfies completeness if for all (i, x, y, w) &isin; R, the verifier accepts with probability 1 in an honest execution. The protocol has soundness error &epsilon; if for every malicious prover P &lowast; in the MLIOP model (i.e., P &lowast; can only send multilinear polynomials as oracles), and every input (i, x, y) &isin; L/ (R), the probability that the verifier accepts is at most &#1013;(&delta;).</p>

    <p class="text-gray-300">Complexity metrics. When measuring proof communication complexity for MLIOPs and IOPs, we count both the oracle communication (i.e., the total length of the prover oracles being sent) and the non-oracle communication (i.e., the length of the additional strings being sent). We define the total proof communication complexity as the sum of the oracle and non-oracle communications. In MLIOPs, the prover's time for generating the MLE oracle is the size of the polynomial (i.e., O(2m) for an m-variate multilinear polynomial).</p>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8">2.3 Coding Background</h3>

    <p class="text-gray-300">A code C over a finite field F is an injective function C : F <sup>k</sup> &rarr; F n . We refer to k as the message length and n as the block length. We will sometimes overload this notation and also use C to denote the image of the function (i.e., {C(x) : x &isin; F <sup>k</sup>}). The rate of a code C is R = k n and its minimum distance is min{&#8710;(x, y) : x, y &isin; C, x &#824;= y}. Intuitively, thinking of a codeword as a robust</p>

    <p class="text-gray-300"><sup>11</sup>This notion was originally called &quot;probabilistically checkable interactive proof wrt encoded provers&quot; by Reingold et al. <a href="#page-82-6">[RRR16]</a> and also called &quot;polynomial IOP&quot; by Bunz et al. <a href="#page-77-7">[BFS20]</a> and Chiesa et al. <a href="#page-79-7">[CHM</a><sup>+</sup>20]. We use the term multilinear IOP (MLIOP) to emphasize that the polynomials are multilinear. Multilinear IOPs are also a special case of Tensor IOPs <a href="#page-77-1">[BCG20]</a>.</p>

    <p class="text-gray-300">representation for some data, the rate quantifies the efficiency of the encoding, while the minimum distance quantifies its noise-resilience.</p>

    <p class="text-gray-300">If C is a linear function over F then we say that it is a linear code; henceforth all codes in this work are linear. Note that for a linear code, the minimum distance is the equal to the minimal Hamming weight of a non-zero codeword &ndash; i.e., min{&#8710;(x, 0) : x &isin; C \\ {0}}. A code is systematic if the the first k codeword symbols are always equal to the message.</p>

    <p class="text-gray-300">A linear code C &sube; F <sup>n</sup> of dimension k can be conveniently presented in terms of a generator matrix, which is a matrix G &isin; F n&times;k for which</p>

    <p class="text-gray-300"><span class="math">$C = \\{Gx : x \\in \\mathbb{F}^k\\} \\ .</span>$</p>

    <p class="text-gray-300">Note that in general a linear code has many generator matrices; however, it will be convenient for us to design codes with accompanying generator matrices allowing for very efficient encoding, i.e., the computation of Gx from x will be very fast.</p>

    <p class="text-gray-300">Proximity Gaps. We will make use of the following lemma from <a href="#page-78-2">[BKS18]</a> (see also <a href="#page-82-7">[RVW13,</a> <a href="#page-75-1">AHIV23]</a>), which informally states that any linear code V &sube; F <sup>n</sup> with sufficiently good distance satisfies a &quot;proximity gap&quot;.<a href="#page-16-1">12</a> That is, if U is any other linear space that has at least one vector that is far from all elements of V , then in fact most vectors in U are far from V (at least, assuming |F| is sufficiently large). That is, there is a &quot;gap&quot; in terms of proximity: either all elements of U are close to V , or almost all are far.</p>

    <p class="text-gray-300">Theorem 2.5 ( <a href="#page-78-2">[BKS18,</a> Theorem 4.1]). Let V &sube; F n be a linear space over a finite field F with distance &lambda;. Let U be an affine space and suppose &exist;u &isin; U for which &#8710;(u, V ) &gt; &delta;. Then, for any &epsilon; &gt; 0 such that &delta; &minus; &epsilon; &lt; &lambda;/3,</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{u \\in U}[\\Delta(u, V) &lt; \\delta - \\varepsilon] \\le \\frac{1}{\\varepsilon |\\mathbb{F}|}.</span>$</p>

    <p class="text-gray-300">For our purposes it will be convenient to reformulate <a href="#page-16-2">Theorem 2.5</a> in the language of matrices and codes. If C &sube; F n is a code, we denote by C t the t-fold interleaving of C &ndash; namely, the space of all t &times; n dimensional matrices whose rows belong to C.</p>

    <p class="text-gray-300">Corollary 2.6. Let C &sube; F n be a linear code with distance &lambda;, let t &isin; N and let M &isin; F t&times;n be a matrix such that &#8710;(M, C<sup>t</sup> ) &gt; &delta;. For any &epsilon; &gt; 0 such that &delta; &minus; &epsilon; &lt; &lambda;/3,</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{r \\in \\mathbb{F}^t} [\\Delta(r^T M, C) &lt; \\delta - \\varepsilon] \\le \\frac{1}{\\varepsilon |\\mathbb{F}|}.</span>$</p>

    <p class="text-gray-300">Proof. If M is &delta;-far from C t then at least one of its rows is &delta;-far from C. Thus, there exists a vector in the row span of M that is &delta;-far from C. <a href="#page-16-2">Theorem 2.5</a> now implies that a random vector in the row span is (&delta; &minus; &epsilon;)-far from C with all but <sup>1</sup> &epsilon;||F| probability.</p>

    <p class="text-gray-300">Our proof system makes use of repeat-accumulate-accumulate (RAA) codes over the binary field F<sup>2</sup> = {0, 1}. For an integer n &isin; N, which we assume to be divisible by a constant r &isin; N, we shall need the following three ingredients to specify a generator matrix for the RAA code as a composition of linear operators.</p>

    <p class="text-gray-300"><sup>12</sup>Actually, a weaker statement is true even for general linear spaces (i.e., with poor distance), see <a href="#page-82-7">[RVW13]</a>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For a constant  <span class="math">r \\in \\mathbb{N}</span>  dividing n, let  <span class="math">F_r \\in \\{0,1\\}^{n \\times n/r}</span>  denote the matrix corresponding to the linear operator that repeats each entry in the vector r times. That is,  <span class="math">F_r[i,j] = 1</span>  if and only if  <span class="math">\\lfloor j/r \\rfloor + 1 = i</span> .</li>
      <li>Let  <span class="math">A \\in \\{0,1\\}^{n \\times n}</span>  be the accumulator matrix, A[i,j] = 1 if and only if  <span class="math">i \\ge j</span> .</li>
      <li>For a permutation  <span class="math">\\pi:[n] \\to [n]</span> , let  <span class="math">M_{\\pi} \\in \\{0,1\\}^{n \\times n}</span>  be the permutation matrix corresponding to  <span class="math">\\pi</span> . That is, M[i,j] = 1 if and only if  <span class="math">\\pi(i) = j</span> .</li>
    </ul>

    <p class="text-gray-300">Using these ingredients, the generator matrix for the rate 1/r RAA code  <span class="math">\\mathsf{RAA}_{\\pi_1,\\pi_2}:\\{0,1\\}^{n/r}\\to\\{0,1\\}^n</span>  code is defined as</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{RAA}_{\\pi_1,\\pi_2}(x) = A \\cdot M_{\\pi_2} \\cdot A \\cdot M_{\\pi_1} \\cdot F_r \\cdot x.</span>$</p>

    <p class="text-gray-300">    <img src="_page_17_Figure_5.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 1: A pictorial representation of (a generator matrix for) an RAA code with rate R = 1/3 and block-length n = 9.</p>

    <p class="text-gray-300">Our main result the following theorem, which is a more formal version of Theorem 3 from the introduction. The following function will play an important role: for fixed even  <span class="math">r \\in \\mathbb{N}</span> ,  <span class="math">r \\geq 4</span> , we define</p>

    <p class="text-gray-300"><span class="math">$f(\\alpha,\\beta,\\rho) := \\frac{H(\\alpha)}{r} - H(\\beta) - H(\\rho) + \\alpha + (1-\\alpha)H\\left(\\frac{\\beta - \\alpha/2}{1-\\alpha}\\right) + \\beta + (1-\\beta)H\\left(\\frac{\\rho - \\beta/2}{1-\\beta}\\right)</span>$</p>

    <p class="text-gray-300">where  <span class="math">H(p) := -p \\log p - (1-p) \\log (1-p)</span>  is the binary entropy function (and log's here, and elsewhere, are base-2 unless otherwise specified). We also use  <span class="math">\\mathbb{I}</span>  to denote the indicator for a given condition, i.e.,  <span class="math">\\mathbb{I}\\{\\mathcal{E}\\}</span>  is 1 if the condition  <span class="math">\\mathcal{E}</span>  holds and is 0 otherwise.</p>

    <p class="text-gray-300"><strong>Theorem 3.1.</strong> Let  <span class="math">r, n \\in \\mathbb{N}</span>  be integers,  <span class="math">r \\geq 4</span>  with r even and r|n. Let  <span class="math">\\delta \\in (0, 1/3)</span>  and, if r = 4, assume  <span class="math">\\delta &lt; 1/4</span> . Let  <span class="math">\\varepsilon &gt; 0</span> . Assume n is sufficiently large compared to  <span class="math">r, \\delta</span>  and  <span class="math">\\varepsilon</span> . Then, there exists a near-linear time generation algorithm that outputs a representation for a rate 1/r RAA code with block-length n which has minimum distance  <span class="math">\\geq \\delta</span>  with probability  <span class="math">\\geq 1 - p</span> , where</p>

    <p class="text-gray-300">
<span class="math">$p \\leq \\mathbb{I}\\{r = 4\\} \\cdot \\frac{3}{n-2} + \\mathbb{I}\\{r = 6, \\delta \\geq 1/4\\} \\cdot \\frac{180\\delta^{2}(1-\\delta)}{(n-2)^{2}} + n^{1-r/2} \\cdot \\lceil \\frac{n^{\\gamma}}{2} \\rceil \\cdot \\frac{0.43603}{r} \\cdot \\binom{r}{\\frac{r}{2}} \\cdot \\varphi_{n} \\left(2 \\cdot \\lceil \\frac{m}{2} \\rceil\\right) \\cdot \\varphi_{n}(r) \\cdot (2v_{2}^{*})^{\\frac{r+1}{2}} \\cdot \\eta^{v_{2}^{*}} + \\frac{0.80192 \\cdot \\delta}{r^{3/2}} \\cdot n^{7/2} \\cdot 2^{Bn} .</span>$</p>

    <p class="text-gray-300"><span class="math">$(2)</span>$</p>

    <p class="text-gray-300">In the above,  <span class="math">d := \\delta n \\in \\mathbb{N}</span> ,  <span class="math">m := \\lfloor n^{\\gamma} \\rfloor</span> ,  <span class="math">\\gamma := 1 - \\frac{2}{r}(1 + \\varepsilon)</span> ,  <span class="math">\\eta := 4(\\delta(1 - \\delta))</span> ,  <span class="math">v_2^* = \\frac{1+r}{2\\ln(1/\\eta)} = O(1)</span> ,  <span class="math">\\varphi_n(x) := \\exp\\left(\\frac{x(x-1)}{2n}\\right)</span> , and</p>

    <p class="text-gray-300"><span class="math">$B = \\max\\{f(\\alpha_0, \\beta_0, \\delta), \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in CP(r, \\delta)\\}\\}\\</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\alpha_0 := r/n</span> ,  <span class="math">\\beta_0 := n^{\\gamma-1}</span>  and  <span class="math">CP(r, \\delta)</span>  is the set of critical points of f for fixed r and  <span class="math">\\delta</span>  (defined by equations (19) and (20), and further we only consider critical points lying in a certain region  <span class="math">\\mathcal{R}&#x27;</span>  introduced in Section 9.3).</p>

    <p class="text-gray-300">Additionally, assuming  <span class="math">\\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in \\mathrm{CP}(r, \\delta)\\} &lt; 0</span> , for sufficiently large n we have  <span class="math">B = f(\\alpha_0, \\beta_0, \\delta) = -\\Omega(n^{\\gamma})</span> , so we find</p>

    <p class="text-gray-300"><span class="math">$(2) \\le O(n^{1+\\gamma-r/2}) + 2^{-\\Omega(n^{\\gamma})} = O(n^{1+\\gamma-r/2})</span>$
.</p>

    <p class="text-gray-300">In the above theorem, we have taken great efforts to obtain the tightest bound possible (even up to constants), as we wish to obtain good guarantees for concrete values of n. We now provide some interpretation. Firstly, imagine requiring  <span class="math">B&#x27; := \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in \\operatorname{CP}(r, \\delta)\\} &lt; 0</span> , which is a certain set of equations depending on r and  <span class="math">\\delta</span> ; while the exact expression is quite messy to state formally, they are easy to evaluate on a computer. Requiring B' &lt; 0 is what constrains the minimum distance  <span class="math">\\delta</span>  in terms of the rate R = 1/r: this can be compared to something like the GV bound that states we need  <span class="math">R \\leq 1 - H(\\delta)</span> . Nonetheless, we emphasize that the bound (2) is completely explicit, and can be computed easily for concrete values of n (and we provide some calculations in Figure 2 below). An even more detailed version of this theorem is provided as Theorem 9.1, which provides the explicit requirements on n beyond the above &quot;sufficiently large compared to r,  <span class="math">\\varepsilon</span>  and  <span class="math">\\delta</span> .&quot;</p>

    <p class="text-gray-300">The condition of r even is largely for convenience, and a natural adaptation of our techniques handle odd  <span class="math">r \\geq 3</span> .<sup>13</sup> As our target applications of this theorem choose r as a power of 2, we do not bother with supporting odd r. Furthermore for rate 1/4 the GV bound only guarantees codes with minimum distance  <span class="math">\\approx 0.21</span> , so assuming  <span class="math">\\delta &lt; 1/4</span>  in this case is not meaningfully constraining.</p>

    <p class="text-gray-300">Briefly, our approach is the following: we look at the expected number of RAA codewords of weight at most  <span class="math">d^{14}</span>  and split up the terms based on whether the &quot;middle weight&quot; &ndash; i.e., weight after one round of accumulating and permuting &ndash; is small or large. When it is small, we give a novel combinatorial argument and provide a  <span class="math">O(n^{1+\\gamma-\\frac{r}{2}})</span>  bound on this portion. For large middle weight, we repurpose the approach of [KZCJ07] which, along with some additional care to obtain concrete bounds, yields the  <span class="math">2^{-\\Omega(n^{\\gamma})}</span>  portion of the bound (assuming B &lt; 0).</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 Adding Tests</h3>

    <p class="text-gray-300">The above gives us meaningful bounds on the failure probability: for message length  <span class="math">k=2^{22}</span> , a rate 1/4 RAA code has minimum distance  <span class="math">\\delta=0.19</span>  except with probability  <span class="math">2^{-13}</span> . While this error probability is perhaps sufficient in some cases (recall this is a one-time set-up procedure), we would like to do better. In this section, we argue that with more sophisticated generation algorithms we can decrease the failure probability significantly. For example, a still near-linear time generation procedure has failure probability  <span class="math">2^{-27}</span> , and a near-quadratic time procedure has failure probability  <span class="math">2^{-42}</span> .</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;13</sup>However, as [KZKJ08, page 14] indicates, for r=2 the failure probability would be  <span class="math">\\Omega(1)</span> .</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{14}&lt;/sup&gt;</span> By Markov's inequality, this suffices for bounding the probability the minimum distance is at most d.</p>

    <p class="text-gray-300">Consider the following generation procedure: after sampling the permutations &pi;<sup>1</sup> and &pi;2, we check to see if low weight messages are problematic. That is, we run the following test: for all O(n <sup>w</sup>) nonzero messages of weight &le; w (where w = O(1) is a parameter of choice), we check to see if any of them have encoding of weight at most d.</p>

    <p class="text-gray-300">The bulk of the cost of this test is of course in encoding all O(k <sup>w</sup>) messages of weight w: even with the linear-time encoding of RAA codes, this still costs O(k <sup>w</sup>+1) time. Thus, for weight exactly w we in fact to a simplified test: we just check that after the first round the permuting and accumulating, the weight of all these codewords is at least n <sup>&kappa;</sup> where &kappa; &isin; (0, 1 &minus; 2/r) is a tunable parameter (e.g., &kappa; = 0.4 is a reasonable choice). Note that for a weight rw vector (obtained after repeating and permuting a weight w message), given its support {i<sup>1</sup> &lt; i<sup>2</sup> &lt; &middot; &middot; &middot; &lt; irw} we can quickly compute its weight after the accumulation step as (i<sup>2</sup> &minus; i1) + (i<sup>4</sup> &minus; i3) + &middot; &middot; &middot; + (irw &minus; irw&minus;1).</p>

    <p class="text-gray-300">We thereby obtain the following informally stated theorem. Due to space constraints, a formal version (analogous to <a href="#page-17-0">Theorem 3.1)</a> only appears in the appendix as <a href="#page-70-0">Theorem 9.16.</a></p>

    <p class="text-gray-300">Theorem 3.2. Let r, n, &delta;, &gamma; and B be as in <a href="#page-17-0">Theorem 3.1,</a> and assume B &lt; 0. Let also w &isin; N. Then there exists a O(n <sup>w</sup> log(n)) generation algorithm that outputs a representation for a rate 1/r RAA code with block-length n which has minimum distance &ge; &delta; with probability &ge; 1 &minus; p, where p = O(n (w+1)(1&minus;r/2)+&gamma; ).</p>

    <p class="text-gray-300">Morally speaking, <a href="#page-17-0">Theorem 3.1</a> is the &quot;w = 0&quot; case of the above theorem. Ignoring the &gamma; portion, the moral is that the exponent of the inverse polynomial decay is multiplied by w+ 1 when we use an O&tilde;(n <sup>w</sup>) time test.</p>

    <p class="text-gray-300">As a final contribution, we also consider and analyze punctured RAA codes. By puncturing, we mean that a subset of the coordinates is chosen at random and discarded from all the codewords, which increases the rate of the code but will also decreases the distance. Formally, for a code C &sube; F n 2 and a subset S &sube; [n], C punctured to S is the code C|<sup>S</sup> = {c|<sup>S</sup> : c &isin; C}, where for x &isin; F n <sup>2</sup> x|<sup>S</sup> = (xi)i&isin;<sup>S</sup> is the subvector consisting only of coordinates in S. Note that to encode a punctured RAA codeword one typically would encode the entire RAA codeword and then remove the unnecessary coordinates: i.e., this puncturing operation adds some inefficiency to the encoding.</p>

    <p class="text-gray-300">We provide a formal analysis of the parameters achievable by puncturing RAA codes along with concrete failure probabilities. As we do not eventually use this result in our proposed proof system we defer a more formal discussion &ndash; including precise theorem statements &ndash; to <a href="#page-19-0">Section 3.2.</a> Informally, we again find that we can achieve codes very close to the GV bound, and now for higher rates; e.g., rate 1/2 is now achievable. In settings of interest, the probability of failure is dominated by the probability that the original &quot;unpunctured&quot; RAA code had much smaller distance than expected: in particular, using our O&tilde;(n <sup>w</sup>) time generation procedure, the failure probability will still be asymptotically O(n (w+1)(1&minus;r/2)+&gamma; ).</p>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">3.3 Concrete Numbers</h3>

    <p class="text-gray-300">To conclude, we provide in <a href="#page-20-1">Fig. 2</a> achievable parameters for (generation procedures of) RAA codes, along with provable failure bounds.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Message Length<br>k</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Rate 1/r</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Distance<br>&delta;</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Generation Time</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Failure Probability</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1/4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">k</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&minus;25.4<br>2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1/4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">k</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&minus;27.4<br>2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1/4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2<br>k</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&minus;38.5<br>2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1/4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.19</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2<br>k</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&minus;41.5<br>2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1/8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.29</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">k</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&minus;86.2<br>2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22<br>2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1/8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.29</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">k</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&minus;92.2<br>2</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 2: We list parameters achievable by RAA codes along with the running time of the generation procedure (the run-times have the O&tilde;(&middot; &middot; &middot;)'s removed). We used the following Mathematica script to compute the relatively complicated expressions for the failure probabilities <a href="https://github.com/raa-code-analysis/raa-code-analysis" target="_blank" rel="noopener noreferrer">https://github.</a> <a href="https://github.com/raa-code-analysis/raa-code-analysis" target="_blank" rel="noopener noreferrer">com/raa-code-analysis/raa-code-analysis</a>.</p>

    <p class="text-gray-300">In this section we introduce the notion of a holographic IOP for Multilinear Evaluation. Loosely speaking this is the information-theoretic primitive underlying &quot;hash-based&quot; constructions of (multilinear) polynomial commitment schemes (more on this below). In addition to defining the notion, we also give an overview and systemization of existing tools from the literature, which will be used in our eventual construction.</p>

    <p class="text-gray-300">Let I be an index set, and let C = {C<sup>i</sup> : F <sup>k</sup> &rarr; F <sup>n</sup>}i&isin;I be a family of linear codes, indexed by i &isin; I, where k is a power of 2. We define the indexed relation RMLE[C] as</p>

    <p class="text-gray-300"><span class="math">$R_{\\mathsf{MLE}}[\\mathcal{C}] := \\left\\{ (i \\in \\mathcal{I}; \\, (z, v) \\in \\mathbb{F}^{\\log k} \\times \\mathbb{F}; \\, y \\in \\mathbb{F}^n; \\, m \\in \\mathbb{F}^k) \\, : \\, \\widehat{m}(z) = v \\, \\, \\text{and} \\, \\, y = C_i(m) \\right\\}.</span>$</p>

    <p class="text-gray-300">Here i is an index, (z, v) &isin; F log <sup>k</sup> &times; F is the explicit input, y &isin; F n is an implicit input and m &isin; F k is the witness. Intuitively, (i, z, v, y, m) is in RMLE[C] if and only if y is the encoding of m (wrt code <sup>C</sup>i) and the multilinear evaluation <sup>m</sup><sup>b</sup> (z) equals <sup>v</sup>. In the following, if the code family <sup>C</sup> has only one code C, we simply write RMLE[C] and omit the index i. Recall that in an IOP for (i, z, v, y, m) &isin; RMLE[C], the verifier has oracle access to the encoding idx(i) of index i.</p>

    <p class="text-gray-300">We will sometimes be interested in IOPs for Multilinear Evaluation in which the code C is defined over a field extension of the field F. Let K = F t , for t &isin; N be a field extension, and {C<sup>i</sup> : K<sup>k</sup> &rarr; Kn}i&isin;I be a family of linear codes over K, indexed by i &isin; I. where k is a power of 2. We define the indexed relation RMLE[C] as</p>

    <p class="text-gray-300"><span class="math">$R_{\\mathsf{MLE}}[\\mathcal{C}] := \\left\\{ (i \\in \\mathcal{I}; \\, (z, v) \\in \\mathbb{F}^{\\log(tk)} \\times \\mathbb{F}; \\, y \\in \\mathbb{K}^n; \\, m \\in \\mathbb{K}^k) \\, : \\, \\widehat{m}(z) = v \\, \\, \\text{and} \\, \\, y = C_i(m) \\right\\},</span>$</p>

    <p class="text-gray-300">where m &isin; K<sup>k</sup> is interpreted as a vector in m &isin; F t&middot;k in the natural way and then we require that the multilinear extension &circ;m over F at the point z is equal to v.</p>

    <p class="text-gray-300">Polynomial commitments from IOPPs. For a linear code C with good distance d, an IOPP for RMLE[C] naturally leads to a multilinear polynomial commitment via Merkle hashing (or more generally via composition with a vector commitment) <a href="#page-77-4">[BCS16,</a> <a href="#page-79-8">CMS19,</a> <a href="#page-79-6">COS20]</a>: the polynomial commitment to m is the Merkle commitment to y = C(m); each proof oracle string is replaced with the corresponding Merkle commitment, and each IOP query is replaced with a Merkle path opening. IOPP verifier challenges are generated via the Fiat-Shamir transformation. The scheme is a PCS, or equivalently a SNARG (or SNARK) for the polynomial evaluation relation, so long as the IOPP satisfies round-by-round (knowledge) soundness <a href="#page-79-9">[CCH</a>+19, <a href="#page-79-8">CMS19]</a>. We defer the detailed discussion of the RBR soundness of our IOPP constructions to <a href="#page-83-0">Appendix A.</a></p>

    <p class="text-gray-300">The binding property of the commitment follows from the fact that the IOPP has proximity error &delta; less than the unique decoding radius: if the prover commits to a string that is &delta;-far from any codeword, it will be caught with high probability given the IOPP soundness. Otherwise, the committed string is &delta;-close to a unique codeword and the binding property naturally holds.</p>

    <p class="text-gray-300">The above construction generalizes for any code family C whereas only a negligble fraction of codes C &isin; C have a poor distance. The idea is to randomly pick a code C from C (which has good distance with high probability), the parties then run the same protocol as above wrt code C.</p>

    <p class="text-gray-300">A building block: IOPPs for RMLE[RS]. BaseFold <a href="#page-83-1">[ZCF24]</a> constructed an IOPP for RMLE[C] with polylogarithmic verifiers, where C can be any foldable codes. For simplicity, we consider the case where C = RS is a Reed-Solomon code (which is indeed foldable). FRI-Binius <a href="#page-80-3">[DP24a]</a> further extended BaseFold to support committing polynomials with small coefficients over binary fields.</p>

    <p class="text-gray-300">Theorem 4.1 ( <a href="#page-83-1">[ZCF24,</a><a href="#page-80-3">DP24a]</a>). Let &lambda; &isin; N be the security parameter. Let k &isin; N be a power of 2 and let RS := RS[F, k, n] be a Reed-Solomon code with message length k, blocklength n = O(k) and relative distance d &isin; (0, 1) over the field F (where |F| &gt; 2 &lambda; ). Moreover, F is either a binary extension field or a smooth field.<a href="#page-21-1">15</a> There exists an IOPP for RMLE[RS] (with alphabet F) which, for proximity parameter &delta; &lt; d/3, has the following parameters:</p>

    <pre><code class="language-text">input query complexity O (&lambda;/&delta;),
proof query complexity O (&lambda; log k/&delta;),
rounds complexity O(log k),
oracle proof communication O(n),
non-oracle proof communication O(log k),
soundness error 2
                        &minus;&lambda; + O(
                              log n
                              |F|
                                ),
prover time O(n),
verifier time O (&lambda; log k/&delta;).
</code></pre>

    <p class="text-gray-300">We note that in BaseFold, generating the implicit input encoding y takes O(n log n) time, but the IOPP prover's complexity is linear in n given access to y.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 From MLIOP to IOPP</h3>

    <p class="text-gray-300">In this section, we describe an efficient transformation from a holographic MLIOP for a relation R to a holographic IOPP for R. Recall that in an MLIOP the prover is restricted to sending multilinear polynomials, whereas in an IOP, the prover can send arbitrary messages. Looking ahead, this transformation will be used to compile the MLIOP for the multilinear evaluation relation wrt RAA codes (in <a href="#page-25-0">Section 5)</a> to an IOPP for the same relation.</p>

    <p class="text-gray-300">The transformation is summarized in the following lemma:</p>

    <p class="text-gray-300"><sup>15</sup>A field is smooth if the domain L &sub; F of the code is a multiplicative group whose order is a power of 2.</p>

    <p class="text-gray-300"><strong>Lemma 4.2.</strong> Let  <span class="math">\\lambda</span>  be the security parameter and let  <span class="math">\\Pi</span>  be an MLIOP protocol for a relation  <span class="math">\\mathcal{R}</span>  with parameters</p>

    <p class="text-gray-300"><span class="math">$(\\mathbb{F}, q_{\\mathsf{inp}}, q_{idx}, q_{\\mathsf{pf}}, \\mathsf{rnd}, cc_{\\mathsf{oracle}}, cc, \\epsilon, T_P, T_V, n_{\\mathsf{oracle}}),</span>$</p>

    <p class="text-gray-300">where  <span class="math">|\\mathbb{F}| &gt; 2^{\\lambda}</span>  and the largest polynomial being sent has  <span class="math">\\ell</span>  variables. Set  <span class="math">Q := q_{\\mathsf{inp}} + q_{\\mathsf{idx}} + q_{\\mathsf{pf}}</span>  as the total number of evaluation queries. Let  <span class="math">\\mathsf{RS} := \\mathsf{RS}[\\mathbb{F}, 2^{\\ell}, n]</span>  be the Reed-Solomon code defined in Theorem 4.1 with relative distance d and let  <span class="math">\\delta &lt; d/3</span>  denote the proximity parameter. There exists an IOPP for relation  <span class="math">\\mathcal{R}</span>  with alphabet  <span class="math">\\mathbb{F}</span>  and has the following complexity parameters:</p>

    <pre><code class="language-text">\\begin{array}{lll} input \\ and \\ index \\ query \\ complexity \\\\ proof \\ query \\ complexity \\\\ rounds \\\\ oracle \\ proof \\ communication \\\\ non-oracle \\ proof \\ communication \\\\ soundness \\ error \\\\ prover \\ time \\\\ verifier \\ time \\\\ \\end{array} \\begin{array}{ll} O(\\lambda/\\delta), \\\\ O((n_{\\mathsf{oracle}} + \\ell)\\lambda/\\delta), \\\\ \\mathsf{rnd} + \\log_2(Q) + O(\\ell), \\\\ \\mathsf{noracle} \\cdot n + O(n) \\\\ \\mathsf{cc} + O(\\ell + \\log Q), \\\\ \\epsilon + 2^{-\\lambda} + O\\left(\\frac{\\ell + \\log Q}{|\\mathbb{F}|}\\right), \\\\ T_P + O(n_{\\mathsf{oracle}} \\cdot n \\log n + Q \\cdot 2^\\ell), \\\\ \\mathsf{verifier} \\ time \\\\ \\end{array}
</code></pre>

    <p class="text-gray-300">Before describing the scheme, let us recall a nice feature of multilinear polynomials. A multilinear polynomial  <span class="math">f(x_1, \\ldots, x_k)</span>  can be written as</p>

    <p class="text-gray-300"><span class="math">$f(x_1,...,x_k) = x_1 \\cdot f(1,x_2,...,x_k) + (1-x_1) \\cdot f(0,x_2,...,x_k).</span>$</p>

    <p class="text-gray-300">Thus we can split f into two multilinear polynomials  <span class="math">f_0(\\cdot) = f(0, \\cdot)</span>  and  <span class="math">f_1(\\cdot) = f(1, \\cdot)</span>  of k-1 variables without losing information. Similarly, we can merge two polynomials of k variables into one with k+1 variables. This approach extends to splitting a single polynomial to more than 2 polynomials or merging more than 2 polynomials into one.</p>

    <p class="text-gray-300">Let (I, P, V) be an MLIOP for an indexed relation  <span class="math">\\mathcal{R}</span> . We assume wlog that the prover P sends at most one multilinear oracle per round, as multiple polynomials can be merged into one using the previous technique. Let  <span class="math">(P_{\\mathsf{mle}}, V_{\\mathsf{mle}})</span>  be an IOPP for the multilinear evaluation relation  <span class="math">R_{\\mathsf{MLE}}[C]</span> , where C is a systematic linear code. A straightforward IOPP for  <span class="math">\\mathcal{R}</span>  works by simulating the MLIOP execution, but replacing each multilinear oracle  <span class="math">\\widehat{m}</span>  with the oracle string C(m). For each multilinear evaluation query  <span class="math">\\widehat{m}(z) = v</span>  made by the MLIOP verifier, the protocol runs an IOPP protocol for the claim  <span class="math">(z, v, m, C(m)) \\in R_{\\mathsf{MLE}}[C]</span> . However, this protocol is inefficient, as it requires running a separate IOPP for each evaluation query.</p>

    <p class="text-gray-300">To improve efficiency, we leverage the batching protocols from Theorem 2.4 that reduces multiple multilinear evaluation claims into one. Let  <span class="math">\\Pi_{\\mathsf{batch}}</span>  denote the batching protocol. Let (I, P, V) be the MLIOP for  <span class="math">\\mathcal{R}</span>  where every multilinear oracle has  <span class="math">\\ell</span>  variables. Let  <span class="math">\\Sigma_C := (P_{\\mathsf{mle}}, V_{\\mathsf{mle}})</span>  be the building block IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span>  wrt a systematic code C with message length  <span class="math">2^{\\ell}</span> . We now describe the holographic IOPP  <span class="math">(\\mathcal{I}_{\\mathsf{iop}}, \\mathcal{P}_{\\mathsf{iop}}, \\mathcal{V}_{\\mathsf{iop}})</span>  for  <span class="math">\\mathcal{R}</span> .</p>

    <p class="text-gray-300">Offline phase: Given the multilinear polynomial idx sent by the MLIOP indexer I, the indexer  <span class="math">\\mathcal{I}_{iop}</span>  encodes idx and outputs the index oracle  <span class="math">\\mathbb{I} = C(idx)</span> .</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;16</sup>In our instantiation, C is a Reed-Solomon code and we omit the indexer. One can extend to a family of codes by picking C uniformly random from the family C and let  <span class="math">(P_{\\mathsf{mle}}, V_{\\mathsf{mle}})</span>  denote the corresponding IOPP wrt a code C.</p>

    <p class="text-gray-300">Online phase: The prover  <span class="math">\\mathcal{P}_{\\mathsf{iop}}</span>  and the verifier  <span class="math">\\mathcal{V}_{\\mathsf{iop}}</span>  simulate the interaction phase of the MLIOP between the prover P and the verifier V. Wlog we denote by  <span class="math">y \\in \\mathbb{F}^{2^{\\ell}}</span>  the implicit input of  <span class="math">\\mathcal{R}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The prover  <span class="math">\\mathcal{P}_{\\mathsf{iop}}</span>  provides the verifier with an oracle  <span class="math">\\tilde{y}</span>  containing the non-systematic part of C(y). Together, the oracles to y and  <span class="math">\\tilde{y}</span>  simulate oracle access to  <span class="math">C(y) = (y||\\tilde{y})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For every MLE oracle  <span class="math">\\widehat{m}</span>  sent by P, the prover  <span class="math">\\mathcal{P}_{iop}</span>  sends the oracle string C(m) instead.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let  <span class="math">\\mathcal{O}</span>  denote the set of multilinear oracles sent by P. For every oracle  <span class="math">\\widehat{m} \\in \\mathcal{O} \\cup \\{\\widehat{y}, \\mathsf{idx}\\}</span> , let  <span class="math">S_m</span>  denote the set of V's evaluation queries to  <span class="math">\\widehat{m}</span> .</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a)  <span class="math">\\mathcal{P}_{\\mathsf{iop}}</span>  and  <span class="math">\\mathcal{V}_{\\mathsf{iop}}</span>  run the batching protocol  <span class="math">\\Pi_{\\mathsf{batch}}</span>  to reduce the evaluation claims to a single claim  <span class="math">\\widehat{m}(z_m) = v_m</span> .</li>
      <li>(b) Run the IOPP  <span class="math">(P_{\\mathsf{mle}}, V_{\\mathsf{mle}})</span>  for  <span class="math">R_{\\mathsf{MLE}}[C]</span>  on instance  <span class="math">(z_m, v_m, C(m), m)</span> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Note that the batch protocols and IOPPs for different multilinear oracles run in parallel.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">V_{\\text{iop}}</span>  accepts if V accepts in the simulated MLIOP, and  <span class="math">V_{\\text{mle}}</span>  accepts in all IOPP executions.</li>
    </ol>

    <p class="text-gray-300">We can further reduce the number of IOPP executions via the optimization below.</p>

    <p class="text-gray-300"><strong>Remark 4.3.</strong> The batching technique from Theorem 2.4 [CBBZ23] extends to batch evaluations over different polynomials. By combining this with the FRI batching techniques from [BSCI <span class="math">^+</span> 20], we can reduce evaluation claims across different multilinear polynomials to a single evaluation claim over a (virtual) multilinear polynomial. A single query to the encoding of this virtual multilinear polynomial is simulated by corresponding queries to the encodings of the original polynomials&mdash;one per polynomial. As a result, the number of IOPP executions for  <span class="math">R_{\\text{MLE}}[C]</span>  is reduced to one, albeit with a slightly worse proximity parameter depening on the batched FRI.</p>

    <p class="text-gray-300"><strong>Proposition 4.4.</strong>  <span class="math">\\Pi_{\\mathsf{IOPP}}^{\\mathcal{R}}[\\Sigma_C]</span>  is an IOPP for the relation  <span class="math">\\mathcal{R}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Completeness follows from the completeness property of the MLIOP, the batching protocol and the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span> . We next prove soundness.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{P}_{\\mathsf{iop}}^*</span>  be any IOPP adversary for  <span class="math">\\Pi_{\\mathsf{IOPP}}^{\\mathcal{R}}[\\Sigma_C]</span> , wlog we assume that  <span class="math">\\mathcal{P}_{\\mathsf{iop}}^*</span>  is deterministic.<sup>17</sup> Now, consider an unbounded multilinear IOP adversary  <span class="math">\\tilde{P}</span>  that simulates the execution of  <span class="math">\\mathcal{P}_{\\mathsf{iop}}^*</span> .</p>

    <p class="text-gray-300">Let  <span class="math">\\tilde{y}</span>  be the first oracle string sent by  <span class="math">\\mathcal{P}^*_{\\text{iop}}</span>  that is alleged to be the non-systematic part of a codeword. For ease of exposition, we instead set the first oracle as  <span class="math">\\pi_y := (y||\\tilde{y})</span>  where y is the implicit input. Fix any  <span class="math">\\delta &lt; d/3</span> . For every oracle string  <span class="math">\\pi</span>  sent by  <span class="math">\\mathcal{P}^*_{\\text{iop}}</span> , the prover  <span class="math">\\tilde{P}</span>  checks whether  <span class="math">\\pi</span>  is within  <span class="math">\\delta</span> -distance to C, and decodes  <span class="math">\\pi</span>  to m if it is. (Note that  <span class="math">\\tilde{P}</span>  can be computationally unbounded.) If  <span class="math">\\pi</span>  is  <span class="math">\\delta</span> -far from any codeword,  <span class="math">\\tilde{P}</span>  aborts; otherwise it sends the corresponding oracle  <span class="math">\\hat{m}</span> . In particular, the decoding of  <span class="math">\\pi_y</span>  is set as the implicit input of the MLIOP execution. Finally,  <span class="math">\\tilde{P}</span>  forwards  <span class="math">\\mathcal{P}^*_{\\text{iop}}</span> 's responses to the evaluation queries.</p>

    <p class="text-gray-300">Denote  <span class="math">\\epsilon_1</span> ,  <span class="math">\\epsilon_2</span>  and  <span class="math">\\epsilon_3</span>  as the soundness error of the MLIOP, the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span>  and the batching protocol, respectively. Fix  <span class="math">\\delta&#x27; := \\delta/c</span>  where  <span class="math">c \\in (0,1)</span>  is the rate<sup>18</sup> of code C. Consider an indexed input (i,x,y) such that y is  <span class="math">\\delta&#x27;</span> -far from the set  <span class="math">\\{y^* : (i,x,y^*) \\in \\mathcal{L}(\\mathcal{R})\\}</span> . We argue that the success probability of  <span class="math">\\mathcal{P}^*_{\\mathsf{lop}}</span>  is at most  <span class="math">\\epsilon_1 + \\epsilon_2(\\delta) + \\epsilon_3</span> .</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;17</sup>For a randomized adversary  <span class="math">\\mathcal{P}_{iop}^*</span> , we can choose its internal randomness that maximizes its success probability, which leads to a deterministic adversary with success probability no less than that of  <span class="math">\\mathcal{P}_{iop}^*</span> .</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{18}&lt;/sup&gt;C</span>  is instantiated with Reed-Solomon codes in our solutions, so the rate can be large (e.g. 1/2).</p>

    <p class="text-gray-300">Fix  <span class="math">\\vec{\\alpha}</span>  as any public coin challenges in the MLIOP protocol and consider the execution  <span class="math">\\mathcal{P}^*_{\\text{iop}}(\\vec{\\alpha})</span> . Denote by  <span class="math">O_{\\vec{\\alpha}} := \\{\\pi_j\\}</span>  the proof strings sent by  <span class="math">\\mathcal{P}^*_{\\text{iop}}</span>  and let  <span class="math">S_{\\vec{\\alpha}} := \\{(j, z, v)\\}</span>  be the set of evaluation claims, where j refers to the j-th oracle, z is the evaluation point and v is the evaluation result. Since  <span class="math">\\vec{\\alpha}</span>  is fixed,  <span class="math">O_{\\vec{\\alpha}}</span>  and  <span class="math">S_{\\vec{\\alpha}}</span>  are fixed and well-defined. We now consider two cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>There exists  <span class="math">\\pi_j \\in O_{\\vec{\\alpha}}</span>  that is  <span class="math">\\delta</span> -far from code C. By the soundness of the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span> , the probability that the verifier  <span class="math">\\mathcal{V}_{\\mathsf{iop}}</span>  accepts is at most  <span class="math">\\epsilon_2(\\delta)</span> , where the randomness is over the public coins of the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>All oracles in  <span class="math">O_{\\vec{\\alpha}}</span>  are  <span class="math">\\delta</span> -close to C, but there exists  <span class="math">(j, z, v) \\in S_{\\vec{\\alpha}}</span>  such that for the unique codeword  <span class="math">C(m_j)</span>  that is  <span class="math">\\delta</span> -close to  <span class="math">\\pi_j</span> , it holds that  <span class="math">\\widehat{m_j}(z) \\neq v</span> . Then by the soundness of the batching protocol and the soundness of the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span> , the probability that the verifier  <span class="math">\\mathcal{V}_{\\mathsf{iop}}</span>  accepts is at most  <span class="math">\\epsilon_2(\\delta) + \\epsilon_3</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">If neither of the two cases above occurs, then  <span class="math">\\tilde{P}(\\vec{\\alpha})</span>  passes the verification with at least the same probability as  <span class="math">\\mathcal{P}^*_{\\text{iop}}(\\vec{\\alpha})</span> . Therefore, the probability that  <span class="math">\\mathcal{P}^*_{\\text{iop}}</span>  passes the verification is no more than that of  <span class="math">\\tilde{P}</span>  plus  <span class="math">\\epsilon_2(\\delta) + \\epsilon_3</span> , where the randomness is over the choice of  <span class="math">\\vec{\\alpha}</span>  and the randomness of the batching protocol and the IOPP for  <span class="math">R_{\\text{MLE}}[C]</span> .</p>

    <p class="text-gray-300">Next, we upper-bound the success probability of  <span class="math">\\tilde{P}</span> . Wlog we assume that  <span class="math">\\pi_y</span>  is  <span class="math">\\delta</span> -close to C (as otherwise  <span class="math">\\tilde{P}</span>  immediately aborts). Let y' be the decoding<sup>19</sup> of  <span class="math">\\pi_y = (y||\\tilde{y})</span> . Therefore,  <span class="math">\\pi_y</span>  is  <span class="math">\\delta</span> -close to C(y'), which implies that y is  <span class="math">\\delta&#x27;</span> -close to y'. On the other hand, y is  <span class="math">\\delta&#x27;</span> -far from the set  <span class="math">\\{y^*: (i, x, y^*) \\in \\mathcal{L}(\\mathcal{R})\\}</span> , thus  <span class="math">(i, x, y&#x27;) \\notin \\mathcal{L}(\\mathcal{R})</span> . By the soundness of the MLIOP, the success probability of  <span class="math">\\tilde{P}</span>  is at most  <span class="math">\\epsilon_1</span> .</p>

    <p class="text-gray-300">In sum, the success probability of  <span class="math">\\mathcal{P}_{\\text{iop}}^*</span>  is at most  <span class="math">\\epsilon_1 + \\epsilon_2(\\delta) + \\epsilon_3</span> , which finishes the proof.  <span class="math">\\square</span></p>

    <p class="text-gray-300">Combining Proposition 4.4 and Remark 4.3, we get the following proposition.</p>

    <p class="text-gray-300"><strong>Proposition 4.5.</strong> Let  <span class="math">\\lambda \\in \\mathbb{N}</span>  be the security parameter. Let  <span class="math">\\Pi = (I, P, V)</span>  be an MLIOP protocol for a relation  <span class="math">\\mathcal{R}</span>  with parameters</p>

    <p class="text-gray-300"><span class="math">$(\\mathbb{F}, q_{\\mathsf{inp}}, q_{idx}, q_{\\mathsf{pf}}, \\mathsf{rnd}, cc_{\\mathsf{oracle}}, cc, \\epsilon, T_P, T_V, n_{\\mathsf{oracle}})</span>$</p>

    <p class="text-gray-300">where  <span class="math">|\\mathbb{F}| &gt; 2^{\\lambda}</span>  and  <span class="math">n_{\\mathsf{oracle}}</span>  is the total number of oracles sent by the prover with the largest oracle being an  <span class="math">\\ell</span> -variate multilinear polynomial. Wlog we assume that there is only one index oracle. Set  <span class="math">Q := q_{\\mathsf{inp}} + q_{\\mathsf{idx}} + q_{\\mathsf{pf}}</span>  as total number of evaluation queries. Let C be a systematic code with message length  <span class="math">2^{\\ell}</span> , blocklength n, and encoding complexity  <span class="math">T_C</span> . Let  <span class="math">\\Sigma_C := (P_{\\mathsf{mle}}, V_{\\mathsf{mle}})</span>  be an IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span>  with parameters</p>

    <p class="text-gray-300"><span class="math">$(q_{\\mathsf{inp}}&#x27;, q_{\\mathsf{pf}}&#x27;, \\mathsf{rnd}&#x27;, cc_{\\mathsf{oracle}}&#x27;, cc&#x27;, \\epsilon&#x27;, T_P&#x27;, T_V&#x27;) \\,.</span>$</p>

    <p class="text-gray-300">There is an IOPP  <span class="math">\\Pi_{\\mathsf{IOPP}}^{\\mathcal{R}}[\\Sigma_C]</span>  for relation  <span class="math">\\mathcal{R}</span>  with alphabet  <span class="math">\\mathbb{F}</span>  and following complexity parameters:</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{lll} \\textit{input and index query complexity} &amp; q&#x27;_{\\mathsf{inp}}, \\\\ \\textit{proof query complexity} &amp; n_{\\mathsf{oracle}} \\cdot q&#x27;_{\\mathsf{inp}} + q&#x27;_{\\mathsf{pf}}, \\\\ \\textit{rounds} &amp; \\mathsf{rnd} + \\mathsf{rnd}&#x27; + \\ell + \\log_2(Q) + O(1), \\\\ \\textit{oracle proof communication} &amp; n_{\\mathsf{oracle}} \\cdot n + cc&#x27;_{\\mathsf{oracle}}, \\\\ \\textit{non-oracle proof communication} &amp; cc + cc&#x27; + O(\\ell + \\log Q), \\\\ \\textit{soundness error} &amp; \\epsilon + \\epsilon&#x27; + \\frac{2\\ell + 3\\log_2(Q)}{|\\mathbb{F}|}, \\\\ \\textit{prover time} &amp; T_P + n_{\\mathsf{oracle}} \\cdot T_C + T&#x27;_P + O(Q \\cdot 2^\\ell), \\\\ \\textit{verifier time} &amp; T_V + T&#x27;_V + O(Q\\ell)). \\end{array}</span>$</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;19</sup>Note that y' is fixed because  <span class="math">\\mathcal{P}_{\\mathsf{iop}}^*</span>  is deterministic and  <span class="math">\\tilde{y}</span>  is sent before receiving any challenges.</p>

    <p class="text-gray-300">Using the IOPP for RMLE[RS] from <a href="#page-21-2">Theorem 4.1,</a> and setting C as the Reed-Solomon code, the compiler described above establishes <a href="#page-21-3">Lemma 4.2.</a></p>

    <p class="text-gray-300">Remark 4.6. While the IOPP in <a href="#page-21-2">Theorem 4.1</a> has a linear-time prover, the prover complexity in <a href="#page-21-3">Lemma 4.2</a> has a term noracle &middot; n log n. This is because the IOPP prover for R needs to compute the RS encoding of the polynomials provided by the MLIOP prover, which requires quasilinear time.</p>

    <p class="text-gray-300">Recall that the RAA code is parameterized by a repetition parameter r &isin; N and two permutations &pi;1, &pi;<sup>2</sup> : [n] &rarr; [n] (see <a href="#page-16-0">Section 3</a> for details). We view the repetition parameter as fixed, but the permutations are thought of as &quot;indexing&quot; the code, as described in <a href="#page-20-0">Section 4.</a> For convenience, throughout this section we sometimes omit the parameterization and simply refer to the code as RAA.</p>

    <p class="text-gray-300">Packed RAA Codes. In this section we will consider a simple extension of the RAA code over a larger alphabet F which is a binary extension field (i.e., a field of characteristic 2), which we call packed RAA. There are different ways to view this extension:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>We consider a list of log(|F|) RAA codewords over the base field GF(2) and view these as a single codeword over F, where the i-th symbol is constructed by taking the i-th bits of the RAA codewords, viewing them as a log(|F|)-dimensional bit vector, and interpreting the latter as an elemenf in F in the natural way.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If we consider the encoding process of the RAA code, an equivalent view to the above is that given a message in F <sup>k</sup> we repeat each field element, and then permute and accumulate twice, where the accumulation is using field's addition operation (which can be viewed as a bitwise XOR) and the permutation is also at level of field elements (i.e., we still use two permutations &pi;1, &pi;<sup>2</sup> : [n] &rarr; [n]).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Note that the packed RAA code has the same minimal distance as the standard RAA code, and that it is a linear code over F. We further remark that the packed RAA code is entirely analogous to interleaving, except that here we use a fixed interleaving parameter which is log(|F|) and we view the interleaved symbols as elements of our field F in the natural way. We use PRAA to denote the packed RAA code.</p>

    <p class="text-gray-300">MLIOP for PRAA. The goal of this section is to construct an efficient MLIOP for the relation RMLE[PRAA]. As discussed in <a href="#page-20-0">Section 4,</a> such an MLIOP can then be converted into an IOP which can be further compiled into a multilinear commitment scheme although this will not be the path that we follow - rather in the subsequent sections we will consider an interleaving of the PRAA code, for better efficiency.</p>

    <p class="text-gray-300">We proceed to present the MLIOP for PRAA. Recall that in such an MLIOP, the explicit input is a point z &isin; F <sup>m</sup> and a scalar v &isin; F. The implicit input is a string y &isin; F n , and the verifier has access to the multilinear extension &circ;y of y. The goal is to check whether there exists m &isin; F k such that <sup>y</sup> <sup>=</sup> PRAA(m) such that <sup>m</sup><sup>b</sup> (z) = <sup>v</sup>. In addition, the verifier is gives access to the multilinear extension of the index &ndash; namely, to a description of the two permutations  <span class="math">\\pi_1, \\pi_2</span> .<sup>20</sup> The MLIOP that we construct is captured by the following lemma.</p>

    <p class="text-gray-300"><strong>Lemma 5.1.</strong> The relation  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{PRAA}]</span>  has an MLIOP with the following parameters:</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{ll} \\textit{input, index and proof query complexity} &amp; O(1), \\\\ \\textit{rounds} &amp; \\log_2(n) + O(1), \\\\ \\textit{soundness error} &amp; \\frac{n+13\\log(n)+7}{|\\mathbb{F}|}, \\\\ \\textit{prover time} &amp; O(n), \\\\ \\textit{verifier time} &amp; O(\\log n). \\end{array}</span>$</p>

    <p class="text-gray-300">The communication consists of 2 multilinear oracles each on  <span class="math">\\log_2(n) + O(1)</span>  variables and an additional O(m) field elements.</p>

    <p class="text-gray-300">The focus of this section is proving Lemma 5.1. In a nutshell, this will be done by decomposing the RAA computation into the distinct accumulation and permutation steps and handling each of these separately.</p>

    <p class="text-gray-300"><strong>Notation.</strong> Throughout this section we identify a vector  <span class="math">x \\in \\mathbb{F}^n</span>  with a function  <span class="math">x : \\{0,1\\}^m \\to \\mathbb{F}</span> , where  <span class="math">m = \\log_2(n)</span> , in the natural way (i.e., the vector is viewed as the truth table of the function). Likewise, we will identify a function  <span class="math">M : \\{0,1\\}^m \\times \\{0,1\\}^m \\to \\mathbb{F}</span>  with the  <span class="math">n \\times n</span>  dimensional matrix  <span class="math">M_{i,j} = M(i,j)</span> . Thus, for  <span class="math">x : \\{0,1\\}^m \\to \\mathbb{F}</span>  and  <span class="math">M : \\{0,1\\}^m \\times \\{0,1\\}^m \\to \\mathbb{F}</span> , the vector Mx can be viewed as the function  <span class="math">Mx : \\{0,1\\}^m \\to \\mathbb{F}</span>  defined as  <span class="math">Mx(i) = \\sum_{j \\in \\{0,1\\}^m} M(i,j) \\cdot x(i)</span> , for every  <span class="math">i \\in \\{0,1\\}^m</span> , and  <span class="math">\\widehat{Mx} : \\mathbb{F}^m \\to \\mathbb{F}</span>  denotes the multilinear extension of this function.</p>

    <p class="text-gray-300"><strong>Section Organization.</strong> In Section 5.1 we show how to reduce checking &quot;simple&quot; linear relations between multilinear polynomials to sumcheck, and show that the accumulation step is indeed simple in the above sense. In Section 5.2 we show how to handle permutations. Finally, we combine these steps and prove Lemma 5.1 in Section 5.3.</p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8">5.1 Checking Simple Linear Operations</h3>

    <p class="text-gray-300">The next proposition shows that, given oracle access to the multilinear polynomials  <span class="math">\\widehat{x}, \\widehat{y} : \\mathbb{F}^m \\to \\mathbb{F}</span>  and  <span class="math">\\widehat{M} : \\mathbb{F}^m \\times \\mathbb{F}^m \\to \\mathbb{F}</span>  it is possible to reduce checking that y = Mx to an instance of sumcheck. Here M should be thought of as a simple function whose low degree extension can be efficiently computed by anyone, whereas  <span class="math">\\widehat{x}</span>  and  <span class="math">\\widehat{y}</span>  are the (implicit) input.</p>

    <p class="text-gray-300"><strong>Proposition 5.2.</strong> Let  <span class="math">M: \\{0,1\\}^m \\times \\{0,1\\}^m \\to \\mathbb{F}</span>  and  <span class="math">x,y: \\{0,1\\}^m \\to \\mathbb{F}</span> , and let  <span class="math">\\widehat{M}, \\widehat{x}, \\widehat{y}</span>  be their corresponding multilinear extensions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If y = Mx then for every  <span class="math">r \\in \\mathbb{F}^m</span>  it holds that  <span class="math">\\widehat{y}(r) = \\sum_{j \\in \\{0,1\\}^m} x(j) \\cdot \\widehat{M}(r,j)</span> .</li>
      <li>If  <span class="math">y \\neq Mx</span>  then, with probability  <span class="math">1 \\frac{m}{|\\mathbb{F}|}</span>  over  <span class="math">r \\in \\mathbb{F}^m</span> , it holds that  <span class="math">\\widehat{y}(r) \\neq \\sum_{j \\in \\{0,1\\}^m} x(j) \\cdot \\widehat{M}(r,j)</span> .</li>
    </ul>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;20</sup>Formally, the verifier is given oracle access to the multilinear extension of the concatenation of  <span class="math">\\pi_1</span>  and  <span class="math">\\pi_2</span> . This is merely a technicality and in particular access to the above can be used to emulate access to the individual multilinear extensions.</p>

    <p class="text-gray-300">Before proving Proposition 5.2, we note that it can be directly used to reduce checking whether y = Mx to a sumcheck instance, by having the verifier select at random  <span class="math">r \\in \\mathbb{F}</span> , reading  <span class="math">\\widehat{y}(r)</span>  and checking, via sumcheck, that it is equal to  <span class="math">\\sum_{j} \\widehat{x}(j) \\cdot \\widehat{M}(r,j)</span>  (the sumcheck involves a single query to  <span class="math">\\widehat{x}</span>  and to  <span class="math">\\widehat{M}</span> ).</p>

    <p class="text-gray-300">Proof of Proposition 5.2. For the first item, if Mx = y then, simply by definition of matrix-vector multiplication, for  <span class="math">r \\in \\{0,1\\}^m</span>  it clearly holds that  <span class="math">\\widehat{y}(r) = \\sum_{j \\in \\{0,1\\}^m} x(j) \\cdot \\widehat{M}(r,j)</span> . However, as both sides of the equation are multilinear polynomials (in r), this means that the equation holds for all  <span class="math">r \\in \\mathbb{F}^m</span> .</p>

    <p class="text-gray-300">For the second item, if  <span class="math">y \\neq Mx</span>  then the two sides of the equation are distinct multilinear polynomials in r, and so, by the Schwartz-Zippel Lemma, they can agree on at most an  <span class="math">m/|\\mathbb{F}|</span>  fraction of the domain.</p>

    <p class="text-gray-300"><strong>Accumulations are Simple.</strong> The following proposition shows that the accumulation operation, which is central in the RAA construction, is compatible with Proposition 5.2.</p>

    <p class="text-gray-300"><strong>Proposition 5.3</strong> (Efficient Computation of MLE of Accumulation). Let  <span class="math">A: \\{0,1\\}^m \\times \\{0,1\\}^m \\to \\{0,1\\}</span>  be such that A(i,j)=1 if and only if  <span class="math">i \\geq j</span> , where the inequality interprets i and j as integers (in  <span class="math">\\{0,\\ldots,2^m-1\\}</span> ) in the natural way. Then,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Given  <span class="math">r \\in \\mathbb{F}^m</span> , the vector  <span class="math">(\\widehat{A}(r,b))_{b \\in \\{0,1\\}^m}</span>  can be generated in time  <span class="math">O(2^m)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The polynomial  <span class="math">\\widehat{A}: \\mathbb{F}^m \\times \\mathbb{F}^m \\to \\mathbb{F}</span>  can be evaluated (on a single point) using O(m) arithmetic operations over  <span class="math">\\mathbb{F}</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><em>Proof.</em> For the first item, note that by definition of the multilinear extension, it holds that  <span class="math">\\widehat{A}(r,b) = \\sum_{x \\in \\{0,1\\}^m} eq(x,r) \\cdot A(x,b) = \\sum_{x \\geq b} eq(x,r)</span> . Using Proposition 2.1 we can generate all values eq(x,r) and aggregate them in the correct order.</p>

    <p class="text-gray-300">For the second item, observe that, up to reordering of the input bits, A(i,j) can be computed by a width 3 read-once branching program. Thus, by [HR18, Theorem 5.2], the multi-linear extension  <span class="math">\\widehat{A}</span>  can be computed using O(m) arithmetic operations. For sake of self-containment, we also provide an explicit multilinear formula for computing A(i,j), as follows.</p>

    <p class="text-gray-300">For every m &gt; 0, letting  <span class="math">(i_1, i_2), (j_1, j_2) \\in \\{0, 1\\} \\times \\{0, 1\\}^{m-1}</span>  be such that  <span class="math">i = (i_1, i_2)</span>  and  <span class="math">j = (j_1, j_2)</span>  (i.e.,  <span class="math">i_1</span>  and  <span class="math">j_1</span>  are MSBs, respectively of i and j). Then, we can express  <span class="math">A_m</span>  recursively as</p>

    <p class="text-gray-300"><span class="math">$A_m(i,j) = ((i_1 = 1) \\land (j_1 = 0)) \\lor ((i_1 = j_1) \\land A_{m-1}(i_2, j_2)),</span>$</p>

    <p class="text-gray-300">where  <span class="math">A_m</span>  denotes the accumulation function for inputs of size m (and  <span class="math">A_0 \\equiv 1</span> ). The foregoing equation can be easily used to express  <span class="math">\\widehat{A}_m</span>  as the following multilinear polynomial:</p>

    <p class="text-gray-300"><span class="math">$\\widehat{A}_m(i,j) = i_1 \\cdot (j_1 - 1) + (i_1 \\cdot j_1 + (1 - i_1) \\cdot (1 - j_1)) \\cdot \\widehat{A}_{m-1}(i_2, j_2),</span>$</p>

    <p class="text-gray-300">which can be computed recursively for  <span class="math">i, j \\in \\mathbb{F}^m</span> , using exactly m multiplications and O(m) additions over the field.</p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8">5.2 Checking Permutations</h3>

    <p class="text-gray-300">We use a method for checking permutations from [CBBZ23, Section 3.5] (which relies on a grand product argument from [SL20, Section 5]). The argument goes through several steps (permutation  <span class="math">\\rightarrow</span>  grand product  <span class="math">\\rightarrow</span>  zero-check  <span class="math">\\rightarrow</span>  sum-check), for sake of convenience for our eventual protocol we simply combine all of these steps and describe the eventual reduction to sumcheck claims in the following proposition:</p>

    <p class="text-gray-300"><strong>Proposition 5.4</strong> ( [CBBZ23, Section 3.5]). Assume that  <span class="math">|\\mathbb{F}| \\geq 2^m</span> . Let  <span class="math">\\pi : \\{0,1\\}^m \\to \\{0,1\\}^m</span>  be a permutation. We view  <span class="math">\\pi</span>  also as a function  <span class="math">\\pi : \\{0,1\\}^m \\to \\mathbb{F}</span>  by associate the range of  <span class="math">\\pi</span>  with some subset of  <span class="math">2^m</span>  elements in  <span class="math">\\mathbb{F}</span> . We use  <span class="math">\\widehat{\\pi} : \\mathbb{F}^m \\to \\mathbb{F}</span>  to denote the multilinear extension in the latter view.</p>

    <p class="text-gray-300">Let  <span class="math">x, y: \\{0,1\\}^m \\to \\mathbb{F}</span> , and let  <span class="math">\\widehat{x}, \\widehat{y}: \\mathbb{F}^m \\to \\mathbb{F}</span>  be their corresponding multilinear extensions. Then:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">y(b) = x(\\pi(b))</span>  for every  <span class="math">b \\in \\{0,1\\}^m</span> , then for every  <span class="math">\\alpha, \\beta \\in \\mathbb{F}</span>  there exist multilinear polynomials  <span class="math">f, g : \\mathbb{F}^{m+1} \\to \\mathbb{F}</span>  such that for every  <span class="math">r \\in \\mathbb{F}^m</span> :</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">f(1^m, 0) = g(1^m, 0)</span> .</li>
      <li><span class="math">f(0,r) = \\alpha (\\widehat{x}(r) + \\beta \\cdot \\pi(r)).</span></li>
      <li><span class="math">g(0,r) = \\alpha (\\widehat{y}(r) + \\beta \\cdot r)</span> .</li>
      <li><span class="math">0 = \\sum_{x \\in \\{0,1\\}^m} eq(x,r) \\cdot (f(1,x) f(x,0) \\cdot f(x,1)).</span></li>
      <li><span class="math">0 = \\sum_{x \\in \\{0,1\\}^m} eq(x,r) \\cdot (g(1,x) g(x,0) \\cdot g(x,1)).</span></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Moreover, given  <span class="math">(x, y, \\alpha, \\beta)</span> , the polynomials f and g can be found in time  <span class="math">O(2^m)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">y(b) \\neq x(\\pi(b))</span>  for some  <span class="math">b \\in \\{0,1\\}^m</span> , then with all but probability  <span class="math">\\frac{2^m+1}{|\\mathbb{F}|}</span>  over  <span class="math">\\alpha, \\beta \\in \\mathbb{F}</span> , for every multilinear polynomials  <span class="math">f, g : \\mathbb{F}^{m+1} \\to \\mathbb{F}</span>  it holds that for all but  <span class="math">\\frac{10m}{|\\mathbb{F}|}</span>  fraction of  <span class="math">r \\in \\mathbb{F}^m</span>  at least one of the following is false.</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">f(1^m, 0) = g(1^m, 0)</span> .</li>
      <li><span class="math">f(0,r) = \\alpha (\\widehat{x}(r) + \\beta \\cdot \\pi(r)).</span></li>
      <li><span class="math">g(0,r) = \\alpha (\\widehat{y}(r) + \\beta \\cdot r)</span> .</li>
      <li><span class="math">0 = \\sum_{x \\in \\{0,1\\}^m} eq(x,r) \\cdot (f(1,x) f(x,0) \\cdot f(x,1)).</span></li>
      <li><span class="math">0 = \\sum_{x \\in \\{0,1\\}^m} eq(x,r) \\cdot (g(1,x) g(x,0) \\cdot g(x,1)).</span></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Let  <span class="math">\\pi_1, \\pi_2 : [n] \\to [n]</span>  be permutations and  <span class="math">r \\in \\mathbb{N}</span>  be a repetition parameter for the RAA code. Observe that the packed RAA code PRAA with these parameters can be viewed as the linear operator  <span class="math">\\mathsf{RAA}(m) = A \\cdot M_{\\pi_2} \\cdot A \\cdot M_{\\pi_1} \\cdot F_r \\cdot m</span> , where A denotes the accumulation matrix,  <span class="math">M_{\\pi}</span>  denotes the permutation matrix associated with  <span class="math">\\pi</span> , and  <span class="math">F_r</span>  is the &quot;repetition operator&quot; (observe that all operations are over the field  <span class="math">\\mathbb{F}</span> ).</p>

    <p class="text-gray-300">Using the results from the previous subsections, we proceed to construct an MLIOP for  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{PRAA}]</span> , thereby proving Lemma 5.1.</p>

    <p class="text-gray-300">An MLIOP for  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{PRAA}]</span> . Recall that the explicit input for the verifier is a point  <span class="math">z \\in \\mathbb{F}^{\\log(k)}</span>  and value  <span class="math">v \\in \\mathbb{F}</span>  and the implicit input is an alleged codeword  <span class="math">y \\in \\mathbb{F}^n</span>  of PRAA. Recall that the verifier in an MLIOP has access to the multilinear extension of y. In addition, the verifier has access to the multilinear extensions  <span class="math">\\hat{\\pi}_1, \\hat{\\pi}_2 : \\mathbb{F}^m \\to \\mathbb{F}</span>  of the permutations describing the RAA code. The claim is that there exists  <span class="math">m \\in \\mathbb{F}^k</span>  such that  <span class="math">y = \\mathsf{PRAA}(m)</span>  and  <span class="math">\\hat{m}(z) = v</span> . The prover is given as input  <span class="math">m, \\pi_1, \\pi_2, \\mathsf{PRAA}(m), z</span>  and v.</p>

    <p class="text-gray-300">For a message  <span class="math">m \\in \\mathbb{F}^k</span>  we denote the results of the main intermediate steps of the PRAA encoding as follows:</p>

    <p class="text-gray-300"><span class="math">$u_1 = F_r \\cdot m</span>$</p>

    <p class="text-gray-300"><span class="math">u_2 = M_{\\pi_1} \\cdot u_1</span>
<span class="math">u_3 = A \\cdot u_2</span>
<span class="math">u_4 = M_{\\pi_2} \\cdot u_3</span>
<span class="math">u_5 = A \\cdot u_4</span> .</p>

    <p class="text-gray-300">Note that in a correct computation it holds that  <span class="math">u_5 = y</span> . The MLIOP for  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{PRAA}]</span>  proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1. The prover sends to the verifier (as oracles) the multilinear polynomials  <span class="math">\\widehat{m}: \\mathbb{F}^{\\log(k)} \\to \\mathbb{F}</span>  and  <span class="math">\\widehat{u}_2, \\widehat{u}_3, \\widehat{u}_4: \\mathbb{F}^{\\log(n)} \\to \\mathbb{F}</span> . We use  <span class="math">\\widehat{u}_1: \\mathbb{F}^{\\log(n)} \\to \\mathbb{F}</span>  to denote the multilinear function  <span class="math">\\widehat{u}_1(x,\\cdot) = \\widehat{m}(x)</span>  (and notice that the verifier can emulate each query to  <span class="math">\\widehat{u}_1</span>  via a single query to  <span class="math">\\widehat{m}</span> ). We also use  <span class="math">\\widehat{u}_5</span>  to denote  <span class="math">\\widehat{y}</span>  and observe that the verifier has query access to  <span class="math">\\widehat{u}_5</span>  since in the MLIOP model it has access to  <span class="math">\\widehat{y}</span> .</li>
      <li>2. The verifier checks that  <span class="math">\\widehat{m}(z) = v</span> .</li>
      <li>3. The verifier chooses at random  <span class="math">\\alpha, \\beta \\in \\mathbb{F}</span>  and sends them to the prover.</li>
      <li>4. Using Proposition 5.4, wrt the claims  <span class="math">(u_2 = M_{\\pi_1} \\cdot u_1)</span>  and wrt  <span class="math">(u_4 = M_{\\pi_2} \\cdot u_3)</span> , the prover finds the corresponding pairs  <span class="math">(f_1, g_1)</span>  and  <span class="math">(f_2, g_2)</span> . The prover sends these 4 oracles to the verifier.</li>
      <li>5. The verifier checks that  <span class="math">f_1(1^{\\log(n)}, 0) = g_1(1^{\\log(n)}, 0)</span>  and  <span class="math">f_2(1^{\\log(n)}, 0) = g_2(1^{\\log(n)}, 0)</span> .</li>
      <li>6. The verifier samples at random  <span class="math">r \\in \\mathbb{F}^{\\log(n)}</span>  and checks the following equations (arising from Proposition 5.4) hold:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a)  <span class="math">f_1(0,r) = \\alpha (\\widehat{u_1}(r) + \\beta \\cdot \\pi_1(r)).</span></li>
      <li>(b)  <span class="math">g_1(0,r) = \\alpha (\\widehat{u_2}(r) + \\beta \\cdot r).</span></li>
      <li>(c)  <span class="math">f_2(0,r) = \\alpha (\\widehat{u_3}(r) + \\beta \\cdot \\pi_2(r)).</span></li>
      <li>(d)  <span class="math">g_2(0,r) = \\alpha (\\widehat{u_4}(r) + \\beta \\cdot r).</span></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">The verifier also sends r to the prover.</p>

    <p class="text-gray-300">7. The prover and verifier engage in a batch sumcheck (see Remark 2.3) protocol to check that the following sums all hold:</p>

    <p class="text-gray-300">(a)
<span class="math">$\\widehat{u_3}(r) = \\sum_{j \\in \\{0,1\\}^{\\log(n)}} \\widehat{u_2}(j) \\cdot \\widehat{A}(r,j)</span>$
.</p>

    <p class="text-gray-300">(b)
<span class="math">$\\widehat{u_5}(r) = \\sum_{j \\in \\{0,1\\}^{\\log(n)}} \\widehat{u_4}(j) \\cdot \\widehat{A}(r,j).</span>$</p>

    <p class="text-gray-300">(c)
<span class="math">$0 = \\sum_{x \\in \\{0,1\\}^{\\log(n)}} eq(x,r) \\cdot (f_1(1,x) - f_1(x,0) \\cdot f_1(x,1)).</span>$</p>

    <p class="text-gray-300">(d)
<span class="math">$0 = \\sum_{x \\in \\{0,1\\}^{\\log(n)}} eq(x,r) \\cdot (g_1(1,x) - g_1(x,0) \\cdot g_1(x,1)).</span>$</p>

    <p class="text-gray-300">(e)
<span class="math">$0 = \\sum_{x \\in \\{0,1\\}^{\\log(n)}} eq(x,r) \\cdot (f_2(1,x) - f_2(x,0)) \\cdot f_2(x,1)</span>$</p>

    <p class="text-gray-300">(f)
<span class="math">$0 = \\sum_{x \\in \\{0,1\\}^{\\log(n)}} eq(x,r) \\cdot (g_2(1,x) - g_2(x,0) \\cdot g_2(x,1)).</span>$</p>

    <p class="text-gray-300">(Checks 7a and 7b arise from the accumulation test of Proposition 5.3 and 7c-7f arise from the permutation test of Proposition 5.4)</p>

    <p class="text-gray-300">To run the sumcheck, the prover first generates the vector  <span class="math">(A(r,b))_{b\\in\\{0,1\\}^k}</span>  using Proposition 5.3. At the conclusion of the batch sumcheck, the verifier needs to make a single query to  <span class="math">\\widehat{A}</span>  (which can be computed using Proposition 5.3), one query to each of  <span class="math">\\widehat{u_2}, \\widehat{u_3}, \\widehat{u_4}, \\widehat{u_5}</span>  and two queries each to  <span class="math">f_1, g_1, f_2, g_2</span> .</p>

    <p class="text-gray-300"><strong>Completeness.</strong> Let  <span class="math">z \\in \\mathbb{F}^{\\log(k)}</span> ,  <span class="math">v \\in \\mathbb{F}</span>  and  <span class="math">c = \\mathsf{PRAA}(m)</span> , such that  <span class="math">\\widehat{m}(z) = v</span> . Let  <span class="math">\\widehat{m}, \\widehat{u_1}, \\dots, \\widehat{u_5}</span>  be the messages sent by the prover as in Step 1. Note that  <span class="math">\\widehat{m}(z) = v</span>  and so the verifier does not reject in Step 2.</p>

    <p class="text-gray-300">Fix a choice of  <span class="math">\\alpha, \\beta \\in \\mathbb{F}</span>  for the verifier in Step 3 and the prover's responses in Step 4 (according to Proposition 5.4) by  <span class="math">(f_1, g_1)</span>  and  <span class="math">(f_2, g_2)</span> . Since  <span class="math">u_2(\\cdot) = u_1(\\pi_1(\\cdot))</span>  and  <span class="math">u_4(\\cdot) = u_3(\\pi_3(\\cdot))</span> , for the value  <span class="math">r \\in \\mathbb{F}^k</span>  sampled in Step 6 it holds that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">f_1(1^{\\log(n)}, 0) = g_1(1^{\\log(n)}, 0).</span></li>
      <li><span class="math">f_1(0,r) = \\alpha (\\widehat{u_2}(r) + \\beta \\cdot \\pi_1(r)).</span></li>
      <li><span class="math">g_1(0,r) = \\alpha (\\widehat{u_1}(r) + \\beta \\cdot r).</span></li>
      <li><span class="math">0 = \\sum_{x \\in \\{0,1\\}^{\\log(n)}} eq(x,r) \\cdot (f_1(1,x) f_1(x,0) \\cdot f_1(x,1)).</span></li>
      <li><span class="math">0 = \\sum_{x \\in \\{0,1\\}^{\\log(n)}} eq(x,r) \\cdot (g_1(1,x) g_1(x,0) \\cdot g_1(x,1)).</span></li>
      <li><span class="math">f_2(1^{\\log(n)}, 0) = g_2(1^{\\log(n)}, 0).</span></li>
      <li><span class="math">f_2(0,r) = \\alpha (\\widehat{u_3}(r) + \\beta \\cdot \\pi_2(r)).</span></li>
      <li><span class="math">g_2(0,r) = \\alpha (\\widehat{u_4}(r) + \\beta \\cdot r).</span></li>
      <li><span class="math">0 = \\sum_{x \\in \\{0,1\\}^{\\log(n)}} eq(x,r) \\cdot (f_2(1,x) f_2(x,0) \\cdot f_2(x,1)).</span></li>
      <li><span class="math">0 = \\sum_{x \\in \\{0,1\\}^{\\log(n)}} eq(x,r) \\cdot (g_2(1,x) g_2(x,0) \\cdot g_2(x,1)).</span></li>
    </ul>

    <p class="text-gray-300">and so the tests in Step 6 pass and the bottom four sumcheck claims in Step 7 also pass. Since  <span class="math">u_3 = A \\cdot u_2</span>  and  <span class="math">u_5 = A \\cdot u_4</span> , by Proposition 5.2, it holds that:</p>

    <p class="text-gray-300"><span class="math">$\\widehat{u_3}(r) = \\sum_{j \\in \\{0,1\\}^{\\log(n)}} \\widehat{u_2}(j) \\cdot \\widehat{A}(r,j), \\text{ and}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\widehat{u_5}(r) = \\sum_{j \\in \\{0,1\\}^{\\log(n)}} \\widehat{u_4}(j) \\cdot \\widehat{A}(r,j).</span>$</p>

    <p class="text-gray-300">Thus, the top two sumcheck claims are also true. From the completeness of the (batched) sumcheck, we get that the verifier always accepts.</p>

    <p class="text-gray-300"><strong>Soundness.</strong> Let  <span class="math">z \\in \\mathbb{F}^{\\log(k)}</span>  and  <span class="math">v \\in \\mathbb{F}</span> . Let  <span class="math">y \\notin \\{\\mathsf{PRAA}(m) : \\widehat{m}(z) = v\\}</span> . Fix a (wlog determinstic) cheating prover strategy. As in the protocol, denote the multilinear oracles<sup>21</sup> that the prover sends in its first message by  <span class="math">\\widehat{m} : \\mathbb{F}^{\\log(k)} \\to \\mathbb{F}</span>  and  <span class="math">\\widehat{u}_2, \\widehat{u}_3, \\widehat{u}_4 : \\mathbb{F}^{\\log(n)} \\to \\mathbb{F}</span> . Also, similarly to the protocol, use  <span class="math">\\widehat{u}_1 : \\mathbb{F}^{\\log(n)} \\to \\mathbb{F}</span>  to denote  <span class="math">\\widehat{u}_1(x, \\cdot) = \\widehat{m}(x)</span>  and  <span class="math">\\widehat{u}_5 \\equiv \\widehat{y}</span> .</p>

    <p class="text-gray-300"><strong>Proposition 5.5.</strong> If  <span class="math">u_5 \\neq \\mathsf{PRAA}_{\\pi_1,\\pi_2}(m)</span>  then the verifier rejects with probability at least  <span class="math">1 - \\frac{n+13\\log(n)+7}{|\\mathbb{F}|}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The proof proceeds by a somewhat tedious case analysis, that the individual components in the RAA computation were computed correctly:</p>

    <p class="text-gray-300">Case 1: Suppose  <span class="math">u_2 \\neq M_{\\pi_1}u_1</span> . After the verifier sends  <span class="math">\\alpha, \\beta</span> , the prover responds with  <span class="math">f_1, g_1</span> . By Proposition 5.4 with probability at least  <span class="math">1 - \\frac{n+1}{|\\mathbb{F}|}</span>  over  <span class="math">\\alpha, \\beta</span>  it holds that for the  <span class="math">f_1, g_1</span>  that the prover selected, with probability at least  <span class="math">1 - \\frac{10 \\log(n)}{|\\mathbb{F}|}</span>  over  <span class="math">r \\in \\mathbb{F}^{\\log(n)}</span> , one of the following is false then</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">f_1(1^{\\log(n)}, 0) = g_1(1^{\\log(n)}, 0)</span> . In this case the verifier rejects in Step 5.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">f_1(0,r) = \\alpha (\\widehat{u_1}(r) + \\beta \\cdot \\pi_1(r))</span> . In this case the verifier rejects in Step 6.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">g_1(0,r) = \\alpha (\\widehat{u_2}(r) + \\beta \\cdot r)</span> . Similar to the previous case.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">0 = \\sum_{x \\in \\{0,1\\}^{\\log(n)}} eq(x,r) \\cdot (f_1(1,x) f_1(x,0) \\cdot f_1(x,1))</span> . In this case, one of the sums in Step 7 is false, and so with probability at least  <span class="math">1 \\frac{3\\log(n) + 6}{|\\mathbb{F}|}</span>  (see Remark 2.3) the verifier rejects.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">0 = \\sum_{x \\in \\{0,1\\}^{\\log(n)}} eq(x,r) \\cdot (g_1(1,x) g_1(x,0) \\cdot g_1(x,1))</span> . Similar to the previous case.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Case 2: Suppose  <span class="math">u_3 \\neq A \\cdot u_2</span> . Then, by Proposition 5.2 we have that with probability  <span class="math">1 - \\frac{\\log(n)}{|\\mathbb{F}|}</span>  over r it holds that  <span class="math">\\widehat{u_3}(r) \\neq \\sum_{j \\in \\{0,1\\}^{\\log(n)}} \\widehat{u_2}(j) \\cdot \\widehat{A}(r,j)</span> . In this case, one of the sums in Step 7 is false, and so with probability at least  <span class="math">1 - \\frac{3\\log(n)+6}{|\\mathbb{F}|}</span>  the verifier rejects.</p>

    <p class="text-gray-300">Case 3: Suppose  <span class="math">u_4 \\neq M_{\\pi_2} \\cdot u_3</span> . This case is analyzed similarly to Case 1.</p>

    <p class="text-gray-300">Case 4: Suppose  <span class="math">u_5 \\neq A \\cdot u_4</span> . This case is analyzed similarly to Case 2.</p>

    <p class="text-gray-300">(Note that the soundness error is the maximum between these different cases rather than the sum.)</p>

    <p class="text-gray-300">Thus, by Proposition 5.5, we may assume that  <span class="math">u_5 = \\mathsf{PRAA}_{\\pi_1,\\pi_2}(m)</span> .</p>

    <p class="text-gray-300">Notice that we may also assume that  <span class="math">\\widehat{m}(z) = v</span>  since otherwise the verifier immediately rejects (in Step 2). Thus,  <span class="math">y \\in \\{\\mathsf{PRAA}(m) : \\widehat{m}(z) = v\\}</span>  in contradiction to our assumption.</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;\\&lt;/sup&gt;overline{^{21}}</span> Recall that in an MLIOP, when instructed to, the prover <em>must</em> send multilinear polynomials of the right size.</p>

    <p class="text-gray-300">Optimizations. We remark that some aspects of our MLIOP for RMLE[PRAA] can be further optimized:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In particular, rather than sending u2, u3, u<sup>4</sup> we can take a &quot;GKR-like&quot; approach to gradually reduce claims about them until we get to a claim about the input &circ;m.</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In this approach, the verifier starts by sampling a random point from the input &circ;u5. Then, as in GKR <a href="#page-80-1">[GKR15]</a>, in sequence it reduces this claim to a claim about &circ;u<sup>4</sup> and then &circ;u<sup>3</sup> and so on it until it derives a claim about &circ;m which it can check (since &circ;m is sent by the prover). We emphasize that in this variant &circ;u2, ....u&circ;<sup>4</sup> are not sent by the prover, but rather claims about them are derived in a gradual process. We remark that in this approach the f and g polynomials for the permutation argument are still sent.</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>An orthogonal optimization is to batch the two permutation checks that are done (i.e., to check u<sup>4</sup> and u2). This can be done via &quot;fingerprinting&quot;, see <a href="#page-83-5">[Tha22,</a> Section 6.6.2].</li>
    </ol></li>
    </ul>

      <h3 id="sec-5.4" class="text-xl font-semibold mt-8">5.4 Puncturing</h3>

    <p class="text-gray-300">Since we do not end up using it our system, we give only a brief explanation of how puncturing can be additionally handled in the IOPP.</p>

    <p class="text-gray-300">Recall that in the punctured RAA code, the code index additionally contains a description of which are the punctured points. The latter can be described by another permutation &pi; : [n] &rarr; [n], where we interpret that the first n &prime; &lt; n elements are kept and the rest are discarded.</p>

    <p class="text-gray-300">To check that &circ;u is the result of puncturing &circ;v, the prover sends the multilinear extension &circ;w of the discarded points. We can then recombine &circ;v and &circ;w into a single multilinear equation and run the permutation check of <a href="#page-28-2">Proposition 5.4</a> to check correctness.</p>

    <p class="text-gray-300">Given a code C : F <sup>k</sup> &rarr; F <sup>n</sup> and an integer t &isin; N we define the interleaving of C as the code C t : F <sup>t</sup>&times;<sup>k</sup> &rarr; F <sup>t</sup>&times;<sup>n</sup> obtained by viewing the input as a t &times; k dimensional matrix and encoding each row separately using C. It will sometimes be convenient to view this code as operating over the alphabet F t , that is, we view C : (F t ) <sup>k</sup> &rarr; (F t ) n .</p>

    <p class="text-gray-300">In this section we show how to &quot;bootstrap&quot; an MLE evaluation protocol for a code C, into a similar MLE protocol for the interleaved code C t . The benefit is that the cost of resulting protocol is a combination of a fixed small cost proportional to the input size O(k &times;t) plus an additional cost that is independent of t (and arises from the underlying protocol for C). The cost is a multiplicative in t increase to the verifier's query complexity, or rather, the same query complexity but over a larger alphabet.</p>

    <p class="text-gray-300">Recall the following notation from <a href="#page-20-0">Section 4:</a> if I is an index set, and C = {C<sup>i</sup> : F <sup>k</sup> &rarr; F <sup>n</sup>}i&isin;I is a family of linear codes then</p>

    <p class="text-gray-300"><span class="math">$R_{\\mathsf{MLE}}[\\mathcal{C}] := \\left\\{ (i \\in \\mathcal{I}; (z, v) \\in \\mathbb{F}^{\\log k} \\times \\mathbb{F}; y \\in \\mathbb{F}^n; m \\in \\mathbb{F}^k) : \\widehat{m}(z) = v \\text{ and } y = C_i(m) \\right\\},</span>$</p>

    <p class="text-gray-300">that is, all codewords of C that encode messages whose multilinear extension at the point z is equal to v. We will also use the extension field variant for C t :</p>

    <p class="text-gray-300"><span class="math">$R_{\\mathsf{MLE}}[\\mathcal{C}] := \\left\\{ (i \\in \\mathcal{I}; (z, v) \\in \\mathbb{F}^{\\log(tk)} \\times \\mathbb{F}; y \\in \\mathbb{K}^n; m \\in \\mathbb{K}^k) : \\widehat{m}(z) = v \\text{ and } y = C_i(m) \\right\\},</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathbb{K} = \\mathbb{F}^t</span>  is the extension field, and we interpret m simultaneously as  <span class="math">m \\in \\mathbb{K}^k</span>  and  <span class="math">m \\in (\\mathbb{F})^{t \\times k}</span>  in the natural way.</p>

    <p class="text-gray-300"><strong>Lemma 6.1.</strong> Let  <span class="math">C: \\mathbb{F}^k \\to \\mathbb{F}^n</span>  be a linear code with distance  <span class="math">\\lambda</span> . Assume there exists an IOPP for  <span class="math">R_{\\mathsf{MLE}}[\\mathcal{C}]</span>  which, for proximity parameter  <span class="math">\\delta &lt; \\frac{\\lambda}{3}</span> , has the following parameters:</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">input and proof alphabet</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\mathbb{F},</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">input query complexity</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">q_{inp}(\\delta,k),</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">index query complexity</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">q_{idx}(\\delta,k),</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">proof query complexity</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">q_{proof}(\\delta,k),</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">rounds</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\ell(k),</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">oracle\\ proof\\ communication</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">cc_{oracle}(k),</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">non-oracle proof communication</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">cc(k),</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">soundness error</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\epsilon(\\delta,k),</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">prover time</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">T_P(\\delta, k)</span> , and</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">verifier time</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">T_V(\\delta,k)</span> .</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Then, for every parameter  <span class="math">t = t(k) \\in \\mathbb{N}</span>  there exists an IOPP for the interleaved relation  <span class="math">R_{\\mathsf{MLE}}[\\mathcal{C}^t]</span>  which, for proximity parameter  <span class="math">\\delta</span> , has the following parameters:</p>

    <pre><code class="language-text">\\mathbb{F}^t, q_{inp}(\\delta&#x27;,k),
input alphabet
input query complexity
index and proof alphabet
index query complexity
                                                             q_{idx}(\\delta&#x27;,k),
proof query complexity
                                                            q_{proof}(\\delta&#x27;,k),
                                                                \\ell+1,
rounds
                                                             cc_{\\mathsf{oracle}}(k),
oracle proof communication
                                                            2t + cc(k),
\\epsilon + \\frac{1}{(\\delta - \\delta&#x27;)|\\mathbb{F}|},
non-oracle proof communication
soundness error
                                                      O(tn)+T_P(\\delta&#x27;,k), and
prover time
                                                O(t \\cdot q_{innut}(\\delta&#x27;, k)) + T_V(\\delta&#x27;, k),
verifier time
</code></pre>

    <p class="text-gray-300">where  <span class="math">\\delta&#x27; = 0.99\\delta</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Let (P, V) be an IOPP for  <span class="math">R_{\\mathsf{MLE}}[\\mathcal{C}]</span> . We use (P, V) to construct an IOPP for the interleaved relation  <span class="math">R_{\\mathsf{MLE}}[\\mathcal{C}^t]</span>  as follows.</p>

    <p class="text-gray-300">Recall that the verifier is given as explicit input a point  <span class="math">z \\in \\mathbb{F}^{\\log(tk)}</span>  and scalar  <span class="math">v \\in \\mathbb{F}</span>  and let  <span class="math">c = C^t(m) \\in C^t</span>  be the input codeword (to which the verifier has oracle access). We view m and c as matrices, where  <span class="math">m \\in \\mathbb{F}^{t \\times k}</span>  and  <span class="math">c \\in \\mathbb{F}^{t \\times n}</span> . We decompose z into  <span class="math">z_1 \\in \\mathbb{F}^{\\log(t)}</span>  and  <span class="math">z_2 \\in \\mathbb{F}^{\\log(k)}</span>  such that  <span class="math">z = (z_1, z_2)</span> .</p>

    <p class="text-gray-300">We proceed to describe the IOPP for  <span class="math">\\mathcal{L}_{\\mathsf{MLE}}(C^t, z, v)</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">1. The prover generates a vector  <span class="math">u \\in \\mathbb{F}^t</span> , where for every  <span class="math">i \\in [t]</span> , we set  <span class="math">u_i = \\widehat{m_i}(z_2)</span>  (i.e., the multilinear extension of the <em>i</em>-th row of m, evaluated at the point  <span class="math">z_2</span> ). The prover sends the vector u to the verifier.</p></li>
      <li><p class="text-gray-300">2. The verifier reads u entirely, and, viewing it as a function  <span class="math">u:\\{0,1\\}^{\\log(t)}\\to\\mathbb{F}</span> , checks that  <span class="math">\\widehat{u}(z_1)=v</span> .</p></li>
      <li><p class="text-gray-300">3. The verifier chooses at random<sup>22</sup>  <span class="math">r \\in \\mathbb{F}^t</span>  and sends r to the prover. Denote by  <span class="math">m_{\\sf combo}</span>  the vector-matrix product  <span class="math">m_{\\sf combo} = r^T \\cdot m</span> . Similarly, let  <span class="math">c_{\\sf combo} = r^T \\cdot c</span> . Note that since C is linear, we have that  <span class="math">c_{\\sf combo} = C(m_{\\sf combo})</span> . The prover computes  <span class="math">c_{\\sf combo}</span> , but does not send it to the verifier.</p></li>
      <li><p class="text-gray-300">4. The prover and verifier engage in the IOPP (P, V) for  <span class="math">R_{\\mathsf{MLE}}[\\mathcal{C}]</span>  relative to the point  <span class="math">z_2 \\in \\mathbb{F}^{\\log(k)}</span>  and value  <span class="math">v&#x27; = \\langle u, r \\rangle</span>  and with implicit access to the input codeword  <span class="math">c_{\\mathsf{combo}}</span> . As the verifier does not have direct oracle access to  <span class="math">c_{\\mathsf{combo}}</span> , it emulates queries to it by reading the corresponding column of c. That is, given a query  <span class="math">j \\in [n]</span> , the verifier emulates the response by computing  <span class="math">\\sum_{i \\in [t]} r_i \\cdot c_{i,j}</span> .</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The verifier accepts if and only if all of its tests passed.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><strong>Completeness.</strong> Suppose  <span class="math">((z, v), c) \\in R_{\\mathsf{MLE}}[\\mathcal{C}^t]</span> . Thus, there exists  <span class="math">m \\in \\mathbb{F}^{t \\cdot k}</span>  such that  <span class="math">c = C^t(m)</span>  and  <span class="math">\\widehat{m}(z) = v</span> . As in the protocol, we view m and c as matrices, where  <span class="math">m \\in \\mathbb{F}^{t \\times k}</span>  and  <span class="math">c \\in \\mathbb{F}^{t \\times n}</span> , and decompose z into  <span class="math">(z_1, z_2) \\in \\mathbb{F}^{\\log(t)} \\times \\mathbb{F}^{\\log(k)}</span> . Let  <span class="math">u \\in \\mathbb{F}^t</span>  be the prover's message in Step 1 (recall that  <span class="math">u_i = \\widehat{m_i}(z_2)</span> , for every  <span class="math">i \\in [t]</span> ).</p>

    <p class="text-gray-300">Observe that</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\widehat{u}(z_1) &amp;= \\sum_{i \\in \\{0,1\\}^{\\log(t)}} eq(i,z_1) \\cdot u(i) \\\\ &amp;= \\sum_{i \\in \\{0,1\\}^{\\log(t)}} eq(i,z_1) \\cdot \\widehat{m_i}(z_2) \\\\ &amp;= \\sum_{i \\in \\{0,1\\}^{\\log(t)}} eq(i,z_1) \\cdot \\left(\\sum_{j \\in \\{0,1\\}^{\\log(k)}} eq(j,z_2) \\cdot m_{i,j}\\right) \\\\ &amp;= \\sum_{(i,j) \\in \\{0,1\\}^{\\log(t) + \\log(k)}} eq(i,z_1) \\cdot eq(j,z_2) \\cdot m_{i,j} \\\\ &amp;= \\widehat{m}(z_1,z_2) \\\\ &amp;= v. \\end{split}</span>$</p>

    <p class="text-gray-300">Thus, the verifier's test in Step 2 passes.</p>

    <p class="text-gray-300">Fix  <span class="math">r \\in \\mathbb{F}^t</span> , and let  <span class="math">m_{\\mathsf{combo}} = r^T \\cdot m</span>  and  <span class="math">c_{\\mathsf{combo}} = r^T \\cdot c</span>  as in the protocol, where we observe</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;\\&lt;/sup&gt;overline{}^{22}</span> The vector r can be partially derandomized, see [DP24b, AER24]</p>

    <p class="text-gray-300">that, since C is linear, it holds that  <span class="math">c_{combo} = C(m_{combo})</span> . Note that:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\widehat{m_{\\mathsf{combo}}}(z_2) &amp;= \\sum_{j \\in \\{0,1\\}^{\\log(k)}} eq(j,z_2) \\cdot m_{\\mathsf{combo}}(j) \\\\ &amp;= \\sum_{j \\in \\{0,1\\}^{\\log(k)}} eq(j,z_2) \\cdot \\sum_{i \\in [t]} r_i \\cdot m_{i,j} \\\\ &amp;= \\sum_{i \\in [t]} r_i \\sum_{j \\in \\{0,1\\}^{\\log(k)}} eq(j,z_2) \\cdot m_{i,j} \\\\ &amp;= \\sum_{i \\in [t]} r_i \\cdot \\widehat{m_i}(z_2) \\\\ &amp;= \\langle r, u \\rangle \\end{split}</span>$</p>

    <p class="text-gray-300">and so the IOPP (P, V) in Step 4 is run on an input  <span class="math">(z_2, v&#x27;, c_{\\mathsf{combo}}) \\in R_{\\mathsf{MLE}}[\\mathcal{C}]</span>  where  <span class="math">v&#x27; = \\langle r, u \\rangle)</span> , and so the verifier always accepts.</p>

    <p class="text-gray-300"><strong>Soundness.</strong> Fix  <span class="math">z = (z_1, z_2) \\in \\mathbb{F}^{\\log(t)} \\times \\mathbb{F}^{\\log(k)}</span>  and  <span class="math">v \\in \\mathbb{F}</span>  and let  <span class="math">c \\in (\\mathbb{F}^t)^n</span>  such that c is  <span class="math">\\delta</span> -far from the affine space  <span class="math">\\mathsf{Aff}_{z,v} = \\{C^t(m) : \\hat{m}(z) = v\\}</span> . Fix a (wlog deterministic) cheating prover strategy  <span class="math">P^*</span>  and denote its first message by  <span class="math">u \\in \\mathbb{F}^t</span> . We assume that  <span class="math">\\hat{u}(z_1) = v</span>  since otherwise the verifier immediately rejects.</p>

    <p class="text-gray-300">From the above, we know that c is  <span class="math">\\delta</span> -far from the affine space  <span class="math">\\mathsf{Aff}_{z,v}</span>  (defined above). It will be convenient to normalize c so that we can measure the distance of its rows from the same corresponding linear (rather than affine) space  <span class="math">(\\mathsf{Lin}_{z_2})^t</span> , where  <span class="math">\\mathsf{Lin}_{z_2} = \\{C(m) : \\hat{m}(z_2) = 0\\}</span> . Here C is over the alphabet  <span class="math">\\mathbb{F}</span>  rather than  <span class="math">\\mathbb{F}^t</span> . This is captured by the following claim.</p>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6">Claim 6.1.1.</h4>

    <p class="text-gray-300"><span class="math">$\\Delta\\left(c-u\\otimes C(1^k),(\\operatorname{Lin}_{z_2})^t\\right)&gt;\\delta_{z_2}</span>$</p>

    <p class="text-gray-300">where  <span class="math">1^k</span>  denotes the all ones vector of length k (and  <span class="math">C(1^k)</span>  is its encoding) and  <span class="math">\\otimes</span>  denotes the outer product of the two vectors.</p>

    <p class="text-gray-300">Proof. Suppose toward a contradiction there exists some  <span class="math">c&#x27; \\in (\\operatorname{Lin}_{z_2})^t</span>  such that  <span class="math">\\Delta(c-u \\otimes C(1^k), c&#x27;) \\leq \\delta</span> . Then,  <span class="math">\\Delta(c, c&#x27;&#x27;) \\leq \\delta</span> , where  <span class="math">c&#x27;&#x27; = c&#x27; + u \\otimes C(1^k)</span> . Let  <span class="math">c&#x27;_i</span>  (resp.,  <span class="math">c&#x27;&#x27;_i</span> ) denote the <em>i</em>-th row of c' (resp.,  <span class="math">c&#x27;&#x27;_i</span> ). Then, for every  <span class="math">i \\in [t]</span> ,</p>

    <p class="text-gray-300"><span class="math">$c_i&#x27;&#x27; = c_i&#x27; + u_i \\cdot C(1^k).</span>$</p>

    <p class="text-gray-300">Since  <span class="math">c_i&#x27; \\in C</span>  and  <span class="math">C(1^k) \\in C</span> , by linearity of C, we have that  <span class="math">c_i&#x27;&#x27; \\in C</span> . Letting  <span class="math">m_i&#x27; = C^{-1}(c_i&#x27;)</span> , since  <span class="math">c&#x27; \\in \\operatorname{Lin}_{z_2}</span> , we have that  <span class="math">\\widehat{m_i&#x27;}(z_2) = 0</span> . Since  <span class="math">\\widehat{1^k}(z_2) = 1</span> , we have that  <span class="math">c_i&#x27;&#x27;</span>  is an encoding of the message  <span class="math">m_i&#x27;&#x27; = m_i&#x27; + u_i \\cdot 1^k</span> , whose multilinear evaluation at the point  <span class="math">z_2</span>  is equal to  <span class="math">0 + u_i \\cdot 1 = u_i</span> . Hence, the multilinear evaluation of m'' at the point  <span class="math">(z_1, z_2)</span>  is equal to:</p>

    <p class="text-gray-300"><span class="math">$\\widehat{m&#x27;&#x27;}(z_1, z_2) = \\sum_{i \\in \\{0, 1\\}^{\\log(t)}} eq(z_1, i) \\cdot m&#x27;&#x27;(i, z_2) = \\sum_{i \\in \\{0, 1\\}^{\\log(t)}} eq(z_1, i) \\cdot u_i = \\widehat{u}(z_1) = v.</span>$</p>

    <p class="text-gray-300">Overall we have that c is  <span class="math">\\delta</span> -close to a matrix c'', which is an encoding under  <span class="math">C^t</span>  of a message m'' whose multilinear evaluation at the point  <span class="math">z = (z_1, z_2)</span>  is equal to v. This contradicts our assumption on c.</p>

    <p class="text-gray-300">Given that  <span class="math">c - u \\otimes C(1^k)</span>  is far from the space  <span class="math">(\\text{Lin}_{z_2})^t</span> , Corollary 2.6 implies that a random linear combination of its rows is far from  <span class="math">\\mathcal{L}_{\\mathsf{MLE}}(C, z_2, 0)</span> . In what follows, let  <span class="math">\\delta&#x27; = 0.99\\delta</span> .</p>

    <p class="text-gray-300">Claim 6.1.2. With all but probability  <span class="math">\\frac{1}{(\\delta - \\delta&#x27;)|\\mathbb{F}|}</span>  over  <span class="math">r \\in \\mathbb{F}^t</span> , it holds that:</p>

    <p class="text-gray-300"><span class="math">$\\Delta \\Big( r^T \\cdot (c - u \\otimes C(1^k)), \\operatorname{Lin}_{z_2} \\Big) &gt; \\delta&#x27;.</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> By Claim 6.1.1, the matrix  <span class="math">c-u\\otimes C(1^k)</span>  is  <span class="math">\\delta</span> -far from the linear space  <span class="math">\\mathsf{Lin}_{z_2}</span> . Since  <span class="math">\\delta&#x27;&lt;\\delta&lt;\\frac{\\lambda}{3}</span> , the claim follows immediately from Corollary 2.6.</p>

    <p class="text-gray-300">In the sequel we assume that r satisfying the condition in the above claim was selected. Next, we translate the distance from the linear space  <span class="math">\\mathsf{Lin}_{z_2}</span>  back to the corresponding affine space.</p>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6">Claim 6.1.3.</h4>

    <p class="text-gray-300"><span class="math">$\\Delta(r^T c, \\mathsf{Aff}&#x27;_{z_2,\\langle u,r\\rangle}) &gt; \\delta&#x27;,</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\operatorname{Aff}&#x27;_{z_2,\\langle u,r\\rangle}=\\{C(m):\\hat{m}(z_2)=\\langle u,r\\rangle\\}</span>  and C is over the alphabet  <span class="math">\\mathbb{F}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Suppose toward a contradiction that there exists some  <span class="math">c&#x27; \\in \\mathsf{Aff}&#x27;_{z_2,\\langle u,r\\rangle}</span>  such that  <span class="math">\\Delta(r^Tc,c&#x27;) \\leq \\delta&#x27;</span> . Observe that</p>

    <p class="text-gray-300"><span class="math">$r^T \\cdot (c - u \\otimes C(1^k)) - (c&#x27; - \\langle u, r \\rangle \\otimes C(1^k)) = r^T c - \\langle u, r \\rangle \\cdot C(1^k) - (c&#x27; - \\langle u, r \\rangle \\otimes C(1^k))</span>$
<span class="math">$= r^T c - c&#x27;</span>$
<span class="math">$&lt; \\delta&#x27;</span>$</p>

    <p class="text-gray-300">and so  <span class="math">r^T \\cdot (c - u \\otimes C(1^k))</span>  is  <span class="math">\\delta&#x27;</span> -close to the codeword  <span class="math">c&#x27;&#x27; = (c&#x27; - \\langle u, r \\rangle \\otimes C(1^k))</span> . Next observe that the multilinear evaluation of  <span class="math">1^k</span>  at the point  <span class="math">z_2</span>  (or any other point for that matter) is equal to 1, and that c' is an encoding of a message whose multilinear evaluation at the point  <span class="math">z_2</span>  is equal to  <span class="math">\\langle u, r \\rangle</span> . Thus, c'' is an encoding of a message whose multilinear evaluation at the point  <span class="math">z_2</span>  is equal to  <span class="math">\\langle u, r \\rangle - \\langle u, r \\rangle \\cdot 1 = 0</span> .</p>

    <p class="text-gray-300">Overall we have that
<span class="math">$r^T \\cdot (c - u \\otimes C(1^k))</span>$
is  <span class="math">\\delta&#x27;</span> -close to  <span class="math">c&#x27;&#x27; \\in \\text{Lin}_{z_2}</span> , a contradiction.</p>

    <p class="text-gray-300">Thus, by Claim 6.1.3, the input  <span class="math">c_{\\sf combo} = r^T c</span>  is  <span class="math">\\delta&#x27;</span> -far from  <span class="math">\\mathcal{L}_{\\sf MLE}(C, z_2, \\langle u, r \\rangle)</span> . By the soundness of (P, V), the verifier rejects in Step 4 with probability at least  <span class="math">\\varepsilon</span> .</p>

    </section>

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold">7 Multilinear Evaluation for Interleaved RAA</h2>

    <p class="text-gray-300">Let PRAA denote the packed RAA code introduced in Section 5 and for an integer  <span class="math">t \\in \\mathbb{N}</span> , let PRAA<sup>t</sup> denote its t-fold interleaving (effectively this is similar to a  <span class="math">t \\cdot \\log(|\\mathbb{F}|)</span>  interleaving of RAA). Building on the results established in the previous sections, in this section we derive an IOPP for Multilinear Evaluation of the Interleaved PRAA code.</p>

    <p class="text-gray-300"><strong>Theorem 7.1</strong> (Multilinear Evaluation of Interleaved RAA). Let  <span class="math">\\lambda</span>  be the security parameter. Let PRAA be a packed RAA code with message length k and block length n over field  <span class="math">\\mathbb{F}</span>  where  <span class="math">|\\mathbb{F}| &gt; 2^{\\lambda}</span> . For every  <span class="math">t = t(k) \\in \\mathbb{N}</span> , there exists an IOPP for  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{PRAA}^t]</span>  where  <span class="math">\\mathsf{PRAA}^t</span>  is over alphabet  <span class="math">\\mathbb{K} = \\mathbb{F}^t</span> , which, for proximity parameter  <span class="math">\\delta</span> , has the following parameters:</p>

    <pre><code class="language-text">\\mathbb{F}^t
input alphabet
                                                               O(\\lambda/\\delta),
input query complexity
index and proof alphabets
index query complexity
                                                               O(\\lambda/\\delta),
proof query complexity
                                                          O(\\lambda \\log(n)/\\delta),
rounds
                                                              O(\\log n),
oracle proof communication
                                                                O(n),
                                                          2t + O(\\log n),
non-oracle proof communication
                                                 \\frac{n}{|\\mathbb{F}|} + 2^{-\\lambda} + O\\left(\\frac{1/\\delta + \\log n}{|\\mathbb{F}|}\\right),O(tn + n \\log n),
soundness error
prover time
                                                      O((t + \\log n) \\cdot \\lambda/\\delta).
verifier time
</code></pre>

    <p class="text-gray-300">In particular, when setting  <span class="math">t = \\Theta(\\log n)</span> , the prover time is O(tn) and the verifier time is  <span class="math">O(\\log(n)\\lambda/\\delta)</span> .</p>

    <p class="text-gray-300">We emphasize that the constant overhead underlying the O(tn) term in prover time is small. Let K=tk denote the description size of the input polynomial. Using RAA code with rate 1/r, the prover time is dominated by (r+2)K multiplications and (r+1)K additions over the field  <span class="math">\\mathbb{F}</span> . In our instantiation, r=4, which leads to 6K multiplications and 5K additions over  <span class="math">\\mathbb{F}</span> .</p>

    <p class="text-gray-300">We also note that Theorem 7.1 is only used in the evaluation proof of the PCS. The commitment is done by encoding using the interleaved packed RAA code and then Merkle hashing. The encoding can be implemented using using 2rK field additions.</p>

    <p class="text-gray-300">Proof of Theorem 7.1. Recall that Lemma 5.1 gives an MLIOP for Multilinear Evaluation of PRAA, which has O(1) evaluation queries and prover oracles, prover complexity O(n), and verifier time  <span class="math">O(\\log n)</span> .</p>

    <p class="text-gray-300">Using Lemma 4.2 we transform this MLIOP into an IOPP for  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{PRAA}]</span> , with  <span class="math">O(\\lambda/\\delta)</span>  input queries,  <span class="math">O(\\lambda \\log(n)/\\delta)</span>  proof queries, prover time  <span class="math">O(n \\log n)</span> , and verifier time  <span class="math">O(\\lambda \\log(n)/\\delta)</span> . The MLIOP from Lemma 5.1 involves sending two types of polynomials, one of size k and another of size n &gt; k. For ease of encoding during the MLIOP-to-IOPP transformation, we pad all oracles to size n. In practice, different Reed-Solomon encodings can be applied to each type of polynomial.</p>

    <p class="text-gray-300">Finally, using Lemma 6.1, we &quot;bootstrap&quot; the IOPP for  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{PRAA}]</span>  into an IOPP for the interleaved relation  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{PRAA}^t]</span> , which leads to the result of the theorem. We note that each input query to the IOPP for  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{PRAA}]</span>  is translated to a corresponding input query to the IOPP for  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{PRAA}^t]</span> , where  <span class="math">\\mathsf{PRAA}</span>  is over the alphabet  <span class="math">\\mathbb{F}</span> , and  <span class="math">\\mathsf{PRAA}^t</span>  over the alphabet  <span class="math">\\mathbb{F}^t</span> .</p>

    <p class="text-gray-300">After compiling the IOPP for  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{PRAA}^t]</span>  with Merkle commitments and the Fiat-Shamir transformation, we obtain a polynomial commitment scheme with linear-time prover and  <span class="math">O_{\\lambda}(\\log^2 n)</span>  proof size and verifier time.</p>

    <p class="text-gray-300">In this section, we compare Blaze to other state-of-the-art <em>multilinear</em> polynomial commitment schemes, including Brakedown [GLS<sup>+</sup>23], Basefold [ZCF24], and ZeromorphFri<sup>23</sup>. We also measure a variant which we call &quot;Interleaved Blaze&quot;, which has a similar structure to Brakedown/Ligero,</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;23</sup>ZeromorphFri uses a generic univariate-to-multilinear transformation (due to [KT23]) to obtain a multilinear PCS from a FRI-based univariate PCS [BBHR18a]</p>

    <p class="text-gray-300">in that it stops after taking a linear combination of rows (without a further composition step). We benchmark Brakedown, Basefold, and ZeromorphFRI over a 64-bit prime field. We benchmark Blaze using a 128-bit binary extension field.<a href="#page-38-1">24</a> We were unable to compare to FRI-Binius as the available implementation was too memory intensive for our large instances.</p>

    <p class="text-gray-300">We measure prover time, verifier time, and communication complexity. Blaze is designed to target large instance sizes. There are two reasons for this. Firstly, we do not have satisfactory distance guarantees for RAA codes of block length smaller than 2<sup>21</sup> . <a href="#page-38-2">25</a> Secondly, Blaze's opening phase executes a constant number of Basefold commitments, and starts to outperform Basefold only after the interleaving parameter t (i.e., the number of rows in the message matrix) exceeds a certain threshold. Thus, we focus our benchmarks on message sizes ranging from 2<sup>25</sup> to 2<sup>31</sup> field elements. To accommodate these large message sizes, we run all of our benchmarks on AWS EC2 Instance c6a.48xlarge, which has 192 vCPUs and 384GiBs of RAM.<a href="#page-38-3">26</a></p>

    <p class="text-gray-300">We compare against Basefold and ZeromorphFRI using a Reed-Solomon code with rate 1/2, and against Brakedown using a Spielman code with rate close to 1 and distance 0.07 (the largest possible distance) . We expect results to generalize to other distances and rates. In particular, by decreasing the distance of the code used by Brakedown one could improve its proving time even further but at great expense to the proof size.</p>

    <p class="text-gray-300">Remark 8.1. Both Basefold (via Binius-Fri <a href="#page-80-3">[DP24a]</a>) and Blaze enable the prover to very efficiently commit to a polynomial that evaluates to &quot;small values&quot; (e.g. bits), thereby eliminating the embedding overhead. I contrast, Brakedown and ZeromorphFri require the prover to prove additional range checks.</p>

      <h3 id="sec-8.1" class="text-xl font-semibold mt-8">8.1 Prover and Verifier Runtimes</h3>

    <p class="text-gray-300">We highlight that Blaze is the only scheme capable of running on instances with size 231, all other schemes run out of memory at this scale. Blaze has a faster prover than both Basefold and ZeromorphFRI. For witness size 229, Blaze takes only 30.5 seconds to generate a proof, whereas Basefold takes 145.7 seconds, making Blaze more than 4.5 times faster. ZeromorphFRI runs out of memory for witness size 2<sup>29</sup> because it commits to an additional degree-n univariate polynomial during its opening phase, which doubles its memory usage compared to Basefold. For witness size 2 <sup>28</sup>, ZeromorphFRI takes 242.6 seconds, whereas Blaze only takes 21.9 seconds, more than 9.7 times faster.</p>

    <p class="text-gray-300">Besides Blaze, Brakedown is the only scheme that can prove evaluations on polynomials of size 230. For this size, Brakedown's prover takes 40.7 seconds, whereas Blaze takes 47.5 seconds, a 1.16x slowdown. However, Brakedown's proof sizes are about 10x larger, as discussed in <a href="#page-39-0">Section 8.2</a> and shown in Figure <a href="#page-40-0">4.</a> Furthermore, for 30-variate polynomials, Interleaved RAA takes only 28.2 seconds to commit and compute evaluation proofs, which is 1.44 times faster than Brakedown, and has a smaller proof size to boot. Two advantages of Brakedown over Blaze are i) its opening phase is extremely cheap, at the cost of larger proof sizes and verifier costs, and ii) they better exploit parallelism in their encoding algorithm. We note that a future implementation could better exploit the natural parallelism of the RAA encoding algorithm.</p>

    <p class="text-gray-300"><sup>24</sup>In other words it is essentially Brakedown, but we replace the use of Spielman's code with the packed RAA code. <sup>25</sup>Although with sufficiently long generation procedures the bounds are not too poor.</p>

    <p class="text-gray-300"><sup>26</sup>Blaze can run on smaller machines, but the other schemes run out of memory faster for our large instance sizes. Thus we chose a larger one so that we could gather adequate data for all four protocols.</p>

    <p class="text-gray-300">Blaze has a roughly similar verifier time to Basefold and ZeromorphFRI. It incurs additional costs from the interleaving phase (which we discuss in more detail in Section <a href="#page-39-0">8.2)</a>, which consists of a constant number of linear combinations on vectors of size t and additional Merkle tree verifications on a tree with n/t leaves, both of which incur only a small overhead. The Brakedown verifier, however, needs to compute an inner product on vectors of size n/t, which dominates its verifier time. Interleaved RAA has the same limitation, however it uses a fixed row length. As operating on the row is the bottleneck of the verifier, the RAA verifier ends up at around 150ms for all sizes. Brakedown, on the other hand, uses the row-length that will give it the smallest number of verifier queries for a given instance size. Brakedown could also fix its row length, but that would make its proof sizes even larger.</p>

    <p class="text-gray-300">    <img src="_page_39_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 3: Proving time and verifier time for all five protocols. Prover time consists of commitment time and evaluation proving time.</p>

      <h3 id="sec-8.2" class="text-xl font-semibold mt-8">8.2 Communication Complexity</h3>

    <p class="text-gray-300">We start with a high level comparison of the communication complexity of the different schemes. Results are listed in Figure <a href="#page-40-0">4.</a> Let n = rk where 1/r is the rate of the RAA code. A Blaze proof for a polynomial with tk coefficients consists of two main components: (i) a constant number of t-length columns of the interleaved code, and (ii) a Basefold proof for witness size n/t. Let d be the minimum distance of the RAA code. Recall from Corollary <a href="#page-16-3">2.6</a> that the verifier must check that the linear combination of the rows is no more than d/3-far from the Interleaved RAA code. Thus to achieve 100 bits of security in the query phase, the number of verifier queries, qRAA, is set so that  <span class="math">(1-d/3)^{q_{RAA}} &lt; 2^{-100}</span> , or in other words,</p>

    <p class="text-gray-300"><span class="math">$q_{\\mathsf{RAA}} &lt; \\frac{100}{\\log_2(1 - d/3)}.</span>$</p>

    <p class="text-gray-300">Using an RAA code with distance 0.19, yields a query count equal to 1059. Thus, a Blaze proof roughly has an additional  <span class="math">1059 \\cdot 8 \\cdot t</span>  bytes compared to Basefold. Additionally, the proof requires 1059 Merkle Paths for a tree with n/t leaves to prove that the queried columns are consistent with the commitment. Actually, this is a slight overcount because the Basefold proof in the Blaze proof only has instance size n/t, and will be compared to Basefold of instance size n.</p>

    <p class="text-gray-300">Next, we compare Blaze to Brakedown. Brakedown uses a similar interleaving step in its opening proof, however the proof includes the entire linear combination of the rows, which Blaze avoids with the inner IOP. Furthermore, Brakedown uses a Spielman code which has a distance at most 0.07 (and this is the code we compare against). Thus, the number of queries for Brakedown,  <span class="math">q_{\\text{brakedown}}</span>  is equal to  <span class="math">\\frac{100}{\\log_2(1-0.07/3)}</span> , which is approximately 2,953. To summarize, compared to Blaze, Brakedown has almost 3 times as many queries, and then requires an additional n/t field elements.</p>

    <p class="text-gray-300">Finally, we compare Blaze to ZeromorphFRI. First, it is important to note that because we are considering a setting with <em>large</em> instance sizes and relatively <em>small</em> fields, we cannot use the best known results for FRI, such as those from [BSCI<sup>+</sup>20], which enables the verifier to query only a small constant number of elements. Thus, we instead consider results from Deep-FRI [BGKS20], which are agnostic to the field size. According to that result, the verifier needs to check that the FRI oracles are inconsistent with each other in (approximately) no more than  <span class="math">(1-d)^{1/3}</span>  fraction of locations. Thus, the number of queries required is</p>

    <p class="text-gray-300"><span class="math">$\\frac{100}{\\log_2((1-d)^{1/3} + \\log_2(n) \\cdot \\epsilon)},</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\epsilon</span>  is a round-by-round error term. We benchmark ZeromorphFRI with a rate and distance of 1/2, and so the number of queries is 329.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">The detailed proof sizes for all schemes are listed in</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Figure 4.</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">--------------------------------------------------------</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-----------</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">--</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"># Vars</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Input Size (MB)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Brakedown</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Basefold</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">ZeromorphFri</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Blaze</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Interleaved Blaze</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">.949</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17.6</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">512</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">9.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">.949</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17.7</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1024</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">12.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2048</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.16</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18.5</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">29</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4096</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">x</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.7</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">19.7</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8192</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">X</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">x</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3.8</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21.8</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">16384</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">x</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">X</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">x</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26.2</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Figure 4: # Vars is the number of variables m of the input polynomial. Input size is the overall number of bytes representing the polynomial. Entries have an x if the computer ran out of memory. All sizes are measured in MB.</p>

    <p class="text-gray-300">In this section, we provide an analysis of the minimum distance of RAA codes and the probability they fail to achieve a certain distance according to various code generation procedures. We begin in Section 9.1 by setting the stage for our analysis; in particular, we precisely write an expression for the expected number of codewords of weight  <span class="math">\\leq \\delta n</span>  in an RAA code. In Section 9.2, we begin by bounding the portion of this expectation with small &quot;middle&quot; weight, i.e., those vectors for which after the first round of accumulation their weight is  <span class="math">\\leq n^{\\gamma}</span>  for some  <span class="math">\\gamma \\in (0,1)</span> . Then in Section 9.3, we bound the portion of the expectation for those whose middle weight is  <span class="math">&gt; n^{\\gamma}</span> : the sum of these two bounds then bounds the expectation.</p>

    <p class="text-gray-300">Our initial analysis applies to the generation procedure that samples the two defining permutations uniformly at random. Our main result is the following, which is a more formal version of Theorem 3.1. We state the result as a bound on the expected number of codewords of weight at most  <span class="math">\\delta n</span> ; as mentioned earlier, we can apply Markov's inequality to translate this into an upper bound on the probability the code fails to have distance d.</p>

    <p class="text-gray-300"><strong>Theorem 9.1.</strong> Let  <span class="math">r, n \\in \\mathbb{N}</span> , r even with  <span class="math">r \\geq 4</span> ,  <span class="math">\\delta \\in (0, 1/3)</span>  such that  <span class="math">d = \\delta n \\in \\mathbb{N}</span> ,  <span class="math">\\gamma = 1 - \\frac{2}{r}(1 + \\varepsilon)</span>  for some  <span class="math">\\varepsilon &gt; 0</span> . If r = 4 assume further  <span class="math">\\delta &lt; 1/4</span> . Define  <span class="math">m := \\lfloor n^{\\gamma} \\rfloor</span> ,  <span class="math">v_2^* = \\frac{1+r}{2\\ln(1/\\omega)}</span> ,  <span class="math">\\omega = 4\\delta(1-\\delta)</span> ,  <span class="math">\\alpha_0 = \\frac{r}{n}</span>  and  <span class="math">\\beta_0 = n^{\\gamma-1}</span> . Assume</p>

    <p class="text-gray-300"><span class="math">$n \\ge \\max \\left\\{ 101^{1/\\gamma}, 7, 2m + r + 1, \\frac{2}{1-\\xi}m, \\frac{(2/\\xi)^{r/\\varepsilon}}{r^{1/\\varepsilon}} \\right\\}</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$\\beta_1 = \\frac{1}{2} - \\frac{1 - \\alpha_0}{2} \\sqrt{1 - \\left(\\frac{\\alpha_0}{1 - \\alpha_0}\\right)^{2/r}} &gt; \\beta_0 , \\quad \\sqrt{\\omega} &lt; 1 - 2\\beta_1 - \\frac{\\alpha_0}{2\\beta_0} .</span>$</p>

    <p class="text-gray-300">Finally, set</p>

    <p class="text-gray-300"><span class="math">$B = \\max\\{f(\\alpha_0, \\beta_0, \\delta), \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in CP(r, \\delta)\\}\\}\\</span>$</p>

    <p class="text-gray-300">where  <span class="math">CP(r, \\delta)</span>  is the set of critical points of f for fixed  <span class="math">\\delta</span> , i.e. the set of  <span class="math">(\\alpha, \\beta)</span>  satisfying equations (19) and (20).</p>

    <p class="text-gray-300">Then the expected number of vectors of weight at most d in a randomly sampled RAA code of rate 1/r with block-length n is at most</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{I}\\{r=4\\} \\cdot \\frac{3}{n-2} + \\mathbb{I}\\{r=6, \\delta \\ge 1/4\\} \\cdot \\frac{180\\delta^{2}(1-\\delta)}{(n-2)^{2}} + n^{1-r/2} \\cdot \\lceil \\frac{n^{\\gamma}}{2} \\rceil \\cdot \\frac{0.43603}{r} \\cdot \\binom{r}{\\frac{r}{2}} \\cdot \\varphi_{n} \\left(2 \\cdot \\lceil \\frac{m}{2} \\rceil\\right) \\cdot \\varphi_{n}(r) \\cdot (2v_{2}^{*})^{\\frac{r+1}{2}} \\cdot \\omega^{v_{2}^{*}} + \\frac{0.80192 \\cdot \\delta}{r^{3/2}} \\cdot n^{7/2} \\cdot 2^{Bn} .</span>$
(3)</p>

    <p class="text-gray-300">Additionally, assuming  <span class="math">\\max\\{f(\\alpha,\\beta,\\delta): (\\alpha,\\beta) \\in \\mathrm{CP}(r,\\delta)\\}\\</span>  &lt; 0, for sufficiently large n we have  <span class="math">B = f(\\alpha_0,\\beta_0,\\delta) = -\\Omega(n^{\\gamma})</span> , so the above is</p>

    <p class="text-gray-300"><span class="math">$\\leq O(n^{1+\\gamma-r/2}) + 2^{-\\Omega(n^{\\gamma})} = O(n^{1+\\gamma-r/2})</span>$
.</p>

    <p class="text-gray-300">One should think of the condition that  <span class="math">\\max\\{f(\\alpha,\\beta,\\delta):(\\alpha,\\beta)\\in \\operatorname{CP}(r,\\delta)\\}&lt;0</span>  as being analogous to the statement of the GV bound, namely, that one requires  <span class="math">R&lt;1-H(\\delta)</span>  to guarantee minimum distance  <span class="math">\\delta</span>  when a randomly sampled code of rate R is sampled. The function f depends on the repetition factor r (and hence the rate 1/r) and, depending on  <span class="math">\\delta</span> , certain expressions (determined by the critical points) need to be negative. For parameters of interest, there are just a constant number of conditions that need to be checked (and a simple computer script can indeed verify they hold). That is, the condition  <span class="math">\\max\\{f(\\alpha,\\beta,\\delta):(\\alpha,\\beta)\\in\\operatorname{CP}(r,\\delta)\\}&lt;0</span>  constrains the rate-distance tradeoffs we can achieve. And, as Figure 2 attests, the achievable rate-distance tradeoff is quite close to the GV bound!</p>

    <p class="text-gray-300">Next, in Section 9.4, we consider generation procedures that verify that low weight messages have sufficiently high-weight encodings, or sometimes just that they do not have an exceedingly poor first stage. In either case, we are able to show that these tests yield significantly improved bounds on the failure probability. The precise statement is given as Theorem 9.16.</p>

    <p class="text-gray-300">Finally, in Section 9.5, we analyze punctured RAA codes. Here, assuming a conjecture, we observe that we can generate codes with new rate-distance tradeoffs whose generation procedures have similar failure probabilities.</p>

      <h3 id="sec-9.1" class="text-xl font-semibold mt-8">9.1 Setup of RAA Analysis</h3>

    <p class="text-gray-300">The simplicity of the accumulator matrix allows for a relatively simple expression for the probability that a <em>uniformly random</em> vector of weight a is mapped to a vector of weight b, where we recall the weight of a vector  <span class="math">x \\in \\mathbb{F}_2^n</span>  is  <span class="math">\\operatorname{wt}(x) := n \\cdot \\Delta(x,0) = |\\{i \\in [n] : x_i \\neq 0\\}|</span> .</p>

    <p class="text-gray-300"><strong>Lemma 9.2</strong> ( [DJM98]; see [BFK<sup>+</sup>24, Theorem 2] for a proof). Let x be uniformly sampled from all vectors of weight a in  <span class="math">\\mathbb{F}_2^n</span> , where  <span class="math">a \\ge 1</span> . Then, assuming  <span class="math">\\lceil a/2 \\rceil \\le b</span>  and  <span class="math">\\lfloor a/2 \\rfloor \\le n-b</span> ,</p>

    <p class="text-gray-300"><span class="math">$p_{a\\mapsto b} := \\Pr[\\operatorname{wt}(Ax) = b] = \\frac{\\binom{b-1}{\\lceil a/2\\rceil - 1} \\binom{n-b}{\\lfloor a/2\\rfloor}}{\\binom{n}{a}}.</span>$</p>

    <p class="text-gray-300">Otherwise, this probability is 0.</p>

    <p class="text-gray-300">For intuition, observe that after accumulating a vector of weight a one obtains  <span class="math">\\lceil a/2 \\rceil</span>  &quot;intervals&quot; of 1's: there are  <span class="math">\\lceil a/2 \\rceil</span>  indices that start a string of 1's, and  <span class="math">\\lfloor a/2 \\rfloor</span>  indices that end the string. One must then count the number of ways to arrange these &quot;starting and ending&quot; indices so that the sum of the lengths of the intervals is b.</p>

    <p class="text-gray-300">Applying Lemma 9.2, we can write this expectation as follows (viewing binomial coefficients  <span class="math">\\binom{a}{b}</span>  as 0 if b &lt; 0 or b &gt; a):</p>

    <p class="text-gray-300"><span class="math">$\\sum_{w_1=1}^{n/r} \\binom{n/r}{w_1} \\sum_{w_2=1}^n \\sum_{w_3=1}^d p_{rw_1 \\mapsto w_2} \\cdot p_{w_2 \\mapsto w_3} \\tag{4}</span>$</p>

    <p class="text-gray-300">
<span class="math">$= \\sum_{w_1=1}^{n/r} \\sum_{w_2=1}^{n} \\sum_{w_3=1}^{d} \\binom{n/r}{w_1} \\cdot \\frac{\\binom{w_2-1}{\\lceil rw_1/2 \\rceil - 1} \\binom{n-w_2}{\\lceil rw_1/2 \\rceil}}{\\binom{n}{rw_1}} \\cdot \\frac{\\binom{w_3-1}{\\lceil w_2/2 \\rceil - 1} \\binom{n-w_3}{\\lceil w_2/2 \\rceil}}{\\binom{n}{w_2}} . \\tag{5}</span>$</p>

    <p class="text-gray-300">In fact, it will be useful to rewrite the probability in Lemma 9.2 as follows (this is also done in [KZKJ08]):</p>

    <p class="text-gray-300">
<span class="math">$\\frac{\\binom{b-1}{\\lceil a/2\\rceil-1}\\binom{n-b}{\\lfloor a/2\\rfloor}}{\\binom{n}{a}} = \\frac{\\binom{b}{\\lceil b/2\\rceil}\\binom{n-a}{b-\\lceil a/2\\rceil}}{\\binom{n}{b}} \\cdot \\frac{\\lceil \\frac{a}{2}\\rceil}{b} \\ .</span>$</p>

    <p class="text-gray-300">The above equality follows from opening up the binomial coefficients. Intuitively, this rewriting is useful, as now only one of the binomial coefficients depends on both a and b. This will allow for an easier analysis of certain expressions which will appear.</p>

    <p class="text-gray-300">Thus, the expectation in (5) is</p>

    <p class="text-gray-300"><span class="math">$\\sum_{w_1=1}^{n/r} \\sum_{w_2=1}^{n} \\sum_{w_3=1}^{d} \\binom{n/r}{w_1} \\cdot \\frac{\\binom{rw_1}{\\lceil rw_1/2 \\rceil} \\binom{n-rw_1}{w_2-\\lceil rw_1/2 \\rceil}}{\\binom{n}{w_2}} \\cdot \\frac{\\binom{w_2}{\\lceil \\frac{w_2}{2} \\rceil} \\binom{n-w_2}{w_3-\\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{\\lceil rw_1/2 \\rceil \\cdot \\lceil \\frac{w_2}{2} \\rceil}{w_2 w_3} , \\qquad (6)</span>$</p>

    <p class="text-gray-300">and our target will be to provide meaningful bounds on (6). We now provide some intuition for our approach.</p>

    <p class="text-gray-300">Firstly, we view the two rounds of permuting and accumulating as two &quot;stages&quot; in the encoding. We know that the minimum distance of an RA code &ndash; i.e., a code with only 1 round of permuting and accumulating &ndash; will never have  <span class="math">\\Omega(1)</span>  minimum distance [BMS08, KZCJ07]: the minimum distance will (with high probability) be something like  <span class="math">n^{-2/r}</span> .</p>

    <p class="text-gray-300">However, this is already quite good: in particular, if after the first round all vectors have weight about  <span class="math">n^{-2/r}</span> , the second stage is very likely to give us our desired minimum distance  <span class="math">\\delta</span> .</p>

    <p class="text-gray-300">To make this intuition concrete, we break the expectation in (6) into two parts: one part with the middle weight  <span class="math">w_2</span>  less than about  <span class="math">n^{1-2/r}</span> , and one part with the middle weight large. We provide a novel analysis of this first part in Section 9.2, and then use ideas from Kliewer <em>et al.</em> [KZKJ08] to bound the second part in Section 9.3.</p>

    <p class="text-gray-300">Let us state two lemmas that we will use throughout this section.</p>

    <p class="text-gray-300"><strong>Lemma 9.3.</strong> Let  <span class="math">w_1, w_2</span>  and  <span class="math">w_3</span>  be the message weight, intermediate weight (after one permutation and accumulator) and output weight, respectively, of an RAA code with rate 1/r and block length n. Then we have</p>

    <p class="text-gray-300"><span class="math">$\\lceil rw_1/2 \\rceil \\le w_2</span>$
,  <span class="math">\\lfloor rw_1/2 \\rfloor \\le n - w_2</span> ,  <span class="math">\\lceil w_2/2 \\rceil \\le w_3</span>  and  <span class="math">\\lfloor w_2/2 \\rfloor \\le n - w_3</span> ,</p>

    <p class="text-gray-300">and in terms of relative weights  <span class="math">\\alpha := \\frac{rw_1}{n}, \\beta := \\frac{w_2}{n}</span>  and  <span class="math">\\rho := \\frac{w_3}{n}</span></p>

    <p class="text-gray-300"><span class="math">$\\frac{\\alpha}{2} \\le \\beta</span>$
,  <span class="math">\\frac{\\alpha}{2} &lt; 1 - \\beta</span> ,  <span class="math">\\frac{\\beta}{2} \\le \\rho</span>  and  <span class="math">\\frac{\\beta}{2} &lt; 1 - \\rho</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Follows immediately from Lemma 9.2.</p>

    <p class="text-gray-300"><strong>Lemma 9.4.</strong> For  <span class="math">k, n \\in \\mathbb{N}</span>  with  <span class="math">k \\leq n</span>  we have the upper-bound</p>

    <p class="text-gray-300"><span class="math">$\\binom{n}{k} \\leq \\frac{e^{\\frac{32}{360}}}{\\sqrt{2\\pi}} \\cdot \\sqrt{\\frac{n}{k(n-k)}} \\cdot 2^{n \\cdot H\\left(\\frac{k}{n}\\right)} \\leq \\frac{e^{\\frac{32}{360}}}{\\sqrt{\\pi}} \\cdot 2^{n \\cdot H\\left(\\frac{k}{n}\\right)} \\leq 0.61664 \\cdot 2^{n \\cdot H\\left(\\frac{k}{n}\\right)} \\ ,</span>$</p>

    <p class="text-gray-300">we have the lower-bound</p>

    <p class="text-gray-300"><span class="math">$\\binom{n}{k} \\geq \\frac{e^{-\\frac{61}{360}}}{\\sqrt{2\\pi}} \\cdot \\sqrt{\\frac{n}{k(n-k)}} \\cdot 2^{n \\cdot H\\left(\\frac{k}{n}\\right)} \\geq \\frac{\\sqrt{2} \\cdot e^{-\\frac{61}{360}}}{\\sqrt{\\pi}} \\cdot \\frac{2^{n \\cdot H\\left(\\frac{k}{n}\\right)}}{\\sqrt{n}} \\geq 0.67352 \\cdot \\frac{2^{n \\cdot H\\left(\\frac{k}{n}\\right)}}{\\sqrt{n}} \\ .</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> The proof is a simple consequence of the following strong form of Stirling's approximation, which says that for all n:</p>

    <p class="text-gray-300"><span class="math">$\\sqrt{2\\pi n} \\ \\left(\\frac{n}{e}\\right)^n e^{\\left(\\frac{1}{12n} - \\frac{1}{360n^3}\\right)} &lt; n! &lt; \\sqrt{2\\pi n} \\ \\left(\\frac{n}{e}\\right)^n e^{\\frac{1}{12n}} \\ .</span>$</p>

      <h3 id="sec-9.2" class="text-xl font-semibold mt-8">9.2 Probability First Stage Fails</h3>

    <p class="text-gray-300">In this section, we essentially bound the probability that some message vector has small weight after the first stage: namely, after (randomly) permuting and accumulating, the obtained intermediate vector has weight at most  <span class="math">n^{\\gamma}</span>  for some  <span class="math">\\gamma \\in (0,1)</span> . More precisely, we prove the following proposition, which makes use of the function</p>

    <p class="text-gray-300"><span class="math">$\\varphi_{\\ell}(x) := \\exp\\left(\\frac{x(x-1)}{2\\ell}\\right) .</span>$</p>

    <p class="text-gray-300"><strong>Proposition 9.5.</strong> Let  <span class="math">r, n \\in \\mathbb{N}</span> , r even, with  <span class="math">r \\geq 4</span> ,  <span class="math">\\delta \\in (0, 1/3)</span>  s.t.  <span class="math">d = \\delta n \\in \\mathbb{N}</span> ,  <span class="math">\\gamma = 1 - \\frac{2}{r}(1+\\varepsilon)</span>  for some  <span class="math">\\varepsilon &gt; 0</span> . If r = 4 assume further  <span class="math">\\delta &lt; 1/4</span> . Define  <span class="math">m := \\lfloor n^{\\gamma} \\rfloor</span> ,  <span class="math">v_2^* = \\frac{1+r}{2\\ln(1/\\eta)}</span>  and  <span class="math">\\eta = 4\\delta(1-\\delta)</span> . Suppose there exists  <span class="math">\\xi \\in (0,1)</span>  such that the following holds</p>

    <p class="text-gray-300"><span class="math">$n \\ge \\max\\left\\{7, 2m + r + 1, \\frac{2}{1 - \\xi}m, \\frac{(2/\\xi)^{r/\\varepsilon}}{r^{1/\\varepsilon}}\\right\\} . \\tag{7}</span>$</p>

    <p class="text-gray-300"></p>

    <p class="text-gray-300">Then:</p>

    <p class="text-gray-300"><span class="math">$\\sum_{w_1=1}^{n/r} \\sum_{w_2=1}^{m} \\sum_{w_3=1}^{d} \\binom{n/r}{w_1} \\cdot \\frac{\\binom{rw_1}{rw_1/2} \\binom{n-rw_1}{w_2-rw_1/2}}{\\binom{n}{w_2}} \\cdot \\frac{\\binom{w_2}{\\lceil w_2/2 \\rceil} \\binom{n-w_2}{w_3-\\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{rw_1/2 \\cdot \\lceil w_2/2 \\rceil}{w_2w_3}</span>$
(8)</p>

    <p class="text-gray-300"><span class="math">$\\leq \\mathbb{I}\\{r=4\\} \\cdot \\frac{3}{n-2} + \\mathbb{I}\\{r=6, \\delta \\geq 1/4\\} \\cdot \\frac{180\\delta^2(1-\\delta)}{(n-2)^2}</span>$</p>

    <p class="text-gray-300"><span class="math">$+ n^{1-r/2} \\cdot \\left\\lceil \\frac{n^{\\gamma}}{2} \\right\\rceil \\cdot \\frac{0.43603}{r} \\cdot \\left( \\frac{r}{\\frac{r}{2}} \\right) \\cdot \\varphi_n \\left( 2 \\cdot \\left\\lceil \\frac{m}{2} \\right\\rceil \\right) \\cdot \\varphi_n(r) \\cdot \\left( 2v_2^* \\right)^{\\frac{r+1}{2}} \\cdot \\eta^{v_2^*}</span>$
(9)</p>

    <p class="text-gray-300"><span class="math">$= O(n^{1+\\gamma-r/2}) .</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> We will bound the sums in (8) by replacing each sum with its largest term multiplied by the number of terms in the sum, starting out with the sum over  <span class="math">w_3</span> . To do so we first rewrite (8) to separate out the factors depending on  <span class="math">w_3</span> .</p>

    <p class="text-gray-300"><span class="math">$(8) = \\sum_{w_1 = 1}^{n/r} \\sum_{w_2 = 1}^m \\binom{n/r}{w_1} \\cdot \\frac{\\binom{rw_1}{rw_1/2} \\binom{n - rw_1}{w_2 - rw_1/2}}{\\binom{n}{w_2}} \\cdot \\binom{w_2}{\\lceil w_2/2 \\rceil} \\cdot \\frac{rw_1/2 \\cdot \\lceil w_2/2 \\rceil}{w_2} \\cdot \\sum_{w_3 = 1}^d \\frac{\\binom{n - w_2}{w_3 - \\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{1}{w_3} \\; .</span>$</p>

    <p class="text-gray-300">We claim that the above expression grows with  <span class="math">w_3</span>  as long as  <span class="math">w_2 \\ge 4</span> . To see this, we show that the ratio between the terms  <span class="math">w_3 + 1</span>  and  <span class="math">w_3</span>  term is &gt; 1, except when  <span class="math">w_2 \\le 3</span> .</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\frac{\\binom{n-w_2}{w_3+1-\\lceil w_2/2\\rceil}}{\\binom{n}{w_3+1}} \\cdot \\frac{1}{w_3+1}}{\\frac{\\binom{n-w_2}{w_3-\\lceil w_2/2\\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{1}{w_3}} = \\frac{w_3}{w_3+1} \\cdot \\frac{n-w_2-w_3+\\lceil w_2/2\\rceil}{w_3+1-\\lceil w_2/2\\rceil} \\cdot \\frac{w_3+1}{n-w_3}</span>$
<span class="math">$= \\frac{w_3}{w_3+1-\\lceil w_2/2\\rceil} \\cdot \\frac{(n-w_3)-\\lfloor w_2/2\\rfloor}{n-w_3}.</span>$</p>

    <p class="text-gray-300">The above is &gt; 1 if and only if</p>

    <p class="text-gray-300"><span class="math">$w_{3}((n-w_{3})-\\lfloor w_{2}/2\\rfloor) &gt; (n-w_{3})(w_{3}+1-\\lceil w_{2}/2\\rceil)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\iff -w_{3} \\cdot \\lfloor w_{2}/2\\rfloor &gt; (n-w_{3}) \\cdot (1-\\lceil w_{2}/2\\rceil)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\iff -n \\cdot (1-\\lceil w_{2}/2\\rceil) &gt; -w_{3} \\cdot (1-\\lceil w_{2}/2\\rceil) + w_{3} \\cdot \\lfloor w_{2}/2\\rfloor</span>$</p>

    <p class="text-gray-300"><span class="math">$\\iff n \\cdot (\\lceil w_{2}/2\\rceil - 1) &gt; w_{3} \\cdot w_{2} - w_{3}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\iff n \\left(\\frac{\\lceil w_{2}/2\\rceil - 1}{w_{2} - 1}\\right) &gt; w_{3}.</span>$</p>

    <p class="text-gray-300">The final upper-bound on w<sup>3</sup> becomes w<sup>3</sup> &lt; n/3 assuming w<sup>2</sup> &ge; 4. For w<sup>2</sup> = 2 the upper-bound becomes w<sup>3</sup> &lt; 0 and for w<sup>1</sup> = 1 it is undefined. Thus, if we are willing to settle for a minimum distance &delta; of at most 1/3, and separately account for the cases w<sup>2</sup> = 1, w<sup>2</sup> = 2 and w<sup>2</sup> = 3, then we can suppose that <a href="#page-44-1">(8)</a> grows with w3. Furthermore, we observe that if &delta; &lt; 1/4 then it in fact suffices to just deal with the case w<sup>2</sup> = 1 and w<sup>2</sup> = 2.</p>

    <p class="text-gray-300">Let us first work out the contribution of these additional cases. Recall from <a href="#page-43-1">Lemma 9.3</a> that the accumulator can at most half the weight of any vector. Note that since we consider r &ge; 4, this means that we will never obtain w<sup>2</sup> = 1, and only have to deal with w<sup>2</sup> = 2 and w<sup>2</sup> = 3. Furthermore w<sup>2</sup> = 2 can only be achieved when starting with w<sup>1</sup> = 1 while r = 4; while w<sup>2</sup> = 3 can only be achieved when starting with w<sup>1</sup> = 1 while r &isin; {4, 6}. However, for this latter case we need &delta; &ge; 1/4, which we assume is not the case when r = 4. Let's first calculate the contribution in the first case (i.e., for  <span class="math">w_1 = 1</span> ,  <span class="math">w_2 = 2</span>  and r = 4):</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathbb{I}\\{r=4\\} \\cdot \\sum_{w_1=1}^1 \\sum_{w_2=2}^2 \\binom{n/r}{w_1} \\cdot \\frac{\\binom{rw_1}{rw_1/2} \\binom{n-rw_1}{w_2-rw_1/2}}{\\binom{n}{w_2}} \\cdot \\binom{w_2}{\\lceil w_2/2 \\rceil} \\cdot \\frac{rw_1/2 \\cdot \\lceil w_2/2 \\rceil}{w_2} \\\\ \\cdot \\sum_{w_3=\\lceil w_2/2 \\rceil}^d \\frac{\\binom{n-w_2}{w_3-\\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{1}{w_3} \\\\ &amp;= \\mathbb{I}\\{r=4\\} \\cdot \\frac{n}{r} \\cdot \\frac{\\binom{r}{r} \\binom{n-r}{2-\\frac{r}{2}}}{n(n-1)} \\cdot 2 \\cdot \\frac{\\frac{r}{2} \\cdot 1}{2} \\cdot \\sum_{w_3=1}^d \\frac{\\frac{(n-2)!}{(w_3-1)!(n-w_3-1)!}}{w_3 \\cdot \\frac{n!}{w_3!(n-w_3)!}} \\\\ &amp;= \\mathbb{I}\\{r=4\\} \\cdot \\frac{3}{(n-1)} \\cdot \\sum_{w_3=1}^d \\frac{w_3 \\cdot (n-w_3)}{w_3 \\cdot n(n-1)} \\\\ &amp;= \\mathbb{I}\\{r=4\\} \\cdot \\frac{3}{(n-1)} \\cdot \\left(\\frac{n \\cdot d}{n(n-1)} - \\frac{1}{n(n-1)} \\sum_{w_3=1}^d w_3\\right) \\\\ &amp;= \\mathbb{I}\\{r=4\\} \\cdot \\frac{3}{(n-1)^2} \\cdot \\left(1 - \\frac{d+1}{2n}\\right) \\\\ &amp;= \\mathbb{I}\\{r=4\\} \\cdot \\frac{3d}{(n-1)^2} \\cdot \\left(1 - \\frac{d+1}{2n}\\right) \\\\ &amp;= \\mathbb{I}\\{r=4\\} \\cdot \\frac{3-3\\delta/2-3/n)d}{(n-1)^2} \\\\ &amp;\\leq \\mathbb{I}\\{r=4\\} \\cdot \\frac{3}{n-2} \\cdot \\end{split}</span>$</p>

    <p class="text-gray-300">We now consider the term with  <span class="math">w_1 = 1</span>  and  <span class="math">w_2 = 3</span> . We recall that this term only arises if  <span class="math">\\delta \\ge 1/4</span>  and r = 6:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathbb{I}\\{r = 6, \\delta \\geq 1/4\\} \\cdot \\sum_{w_1 = 1}^{1} \\sum_{w_2 = 3}^{3} \\binom{n/r}{w_1} \\cdot \\frac{\\binom{rw_1}{rw_1/2} \\binom{n - rw_1}{w_2 - rw_1/2}}{\\binom{n}{w_2}} \\cdot \\binom{w_2}{\\lceil w_2/2 \\rceil} \\cdot \\frac{rw_1/2 \\cdot \\lceil w_2/2 \\rceil}{w_2} \\\\ \\cdot \\sum_{w_3 = \\lceil w_2/2 \\rceil}^{d} \\frac{\\binom{n - w_2}{w_3 - \\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{1}{w_3} \\\\ &amp;= \\mathbb{I}\\{r = 6, \\delta \\geq 1/4\\} \\cdot \\binom{n/6}{1} \\cdot \\frac{\\binom{6}{3} \\binom{n - 6}{3 - 3}}{\\binom{n}{3}} \\cdot \\binom{3}{2} \\cdot \\frac{3 \\cdot 2}{3} \\cdot \\sum_{w_3 = 2}^{d} \\frac{\\frac{(n - 3)!}{(w_3 - 2)!(n - w_3 - 1)!}}{w_3 \\cdot \\frac{n!}{w_3!(n - w_3)!}} \\\\ &amp;= \\mathbb{I}\\{r = 6, \\delta \\geq 1/4\\} \\cdot \\frac{n}{6} \\cdot \\frac{20}{n(n - 1)(n - 2)} \\cdot 6 \\cdot 3 \\cdot 2 \\cdot \\sum_{w_3 = 2}^{d} \\frac{(w_3 - 1)(n - w_3)}{n(N - 1)(n - 2)} \\\\ &amp;\\leq \\mathbb{I}\\{r = 6, \\delta \\geq 1/4\\} \\cdot \\frac{120(n - 4)}{(n - 1)(n - 2)} \\cdot d^2(n - d) \\\\ &amp;\\leq \\mathbb{I}\\{r = 6, \\delta \\geq 1/4\\} \\cdot \\frac{180\\delta^2(1 - \\delta)}{(n - 2)^2} \\end{split}</span>$</p>

    <p class="text-gray-300">where the penultimate inequality uses that  <span class="math">(w_3 - 1)(n - w_3) \\le d(n - d)</span> , which is valid for all  <span class="math">w_3 \\le d = \\delta n \\le n/2</span>  (recall  <span class="math">\\delta &lt; 1/3</span> ), and the last inequality holds for  <span class="math">n \\ge 7</span> .</p>

    <p class="text-gray-300">Thus, the contribution from these terms can be bounded by</p>

    <p class="text-gray-300">
<span class="math">$\\mathbb{I}\\{r=4\\} \\cdot \\frac{3}{n-2} + \\mathbb{I}\\{r=6, \\delta \\ge 1/4\\} \\cdot \\frac{180\\delta^2(1-\\delta)}{(n-2)^2} \\ . \\tag{10}</span>$</p>

    <p class="text-gray-300">Returning to bounding the sum over  <span class="math">w_3</span>  gives us</p>

    <p class="text-gray-300"><span class="math">$(8) \\leq (10) + \\sum_{w_{1}=1}^{n/r} \\sum_{w_{2}=1}^{m} \\binom{n/r}{w_{1}} \\cdot \\frac{\\binom{rw_{1}}{rw_{1}/2} \\binom{n-rw_{1}}{w_{2}-rw_{1}/2}}{\\binom{n}{w_{2}}} \\cdot \\binom{w_{2}}{\\lceil w_{2}/2 \\rceil} \\cdot \\frac{w_{2}}{\\lceil w_{2}/2 \\rceil} \\cdot \\frac{1}{d}</span>$</p>

    <p class="text-gray-300"><span class="math">$= (10) + \\sum_{w_{2}=1}^{m} \\frac{\\binom{n-w_{2}}{d-\\lceil w_{2}/2 \\rceil}}{\\binom{n}{d}} \\cdot \\frac{1}{\\binom{n}{w_{2}}} \\cdot \\binom{w_{2}}{\\lceil w_{2}/2 \\rceil} \\cdot \\frac{1}{d}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\cdot \\frac{\\lceil w_{2}/2 \\rceil}{w_{2}} \\cdot \\sum_{w_{2}=1}^{\\lfloor \\frac{2w_{2}}{r} \\rfloor} \\binom{n/r}{w_{1}} \\binom{rw_{1}}{rw_{1}/2} \\binom{n-rw_{1}}{w_{2}-rw_{1}/2} \\cdot rw_{1}/2 . \\tag{11}</span>$</p>

    <p class="text-gray-300">We note that the rewritten upper-bound on the sum over  <span class="math">w_1</span>  follows again from the fact that the accumulator at worst halves the weight of a vector, which follows from Lemma 9.3.</p>

    <p class="text-gray-300">We now claim that the above expression decreases with  <span class="math">w_1</span> , and again argue this by showing that the ratio between the terms  <span class="math">w_1 + 1</span>  and  <span class="math">w_1</span>  is  <span class="math">\\leq 1</span> . We write out the ratio of these terms for each factor involving  <span class="math">w_1</span> . First,</p>

    <p class="text-gray-300">
<span class="math">$\\frac{\\binom{n/r}{w_1+1}}{\\binom{n/r}{w_1}} \\cdot \\frac{\\frac{r(w_1+1)}{2}}{\\frac{rw_1}{2}} = \\frac{n/r - w_1}{w_1 + 1} \\cdot \\frac{w_1 + 1}{w_1} = \\frac{n/r - w_1}{w_1} \\le \\frac{n}{r} .</span>$</p>

    <p class="text-gray-300">Next,</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\binom{r(w_1+1)}{r(w_1+1)}}{\\binom{rw_1}{rw_1/2}} = \\frac{(rw_1+r)!(rw_1/2)!^2}{(rw_1)!(rw_1/2+\\frac{r}{2})!^2} = \\prod_{j=0}^{\\frac{r}{2}-1} \\frac{(rw_1+2j+1)(rw_1+2j+2)}{(\\frac{rw_1}{2}+j+1)^2} \\ .</span>$</p>

    <p class="text-gray-300">Lastly,</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\binom{n-r(w_1+1)}{w_2-\\frac{r(w_1+1)}{2}}}{\\binom{n-rw_1}{w_2-rw_1/2}} = \\frac{(n-rw_1-r)!(w_2-rw_1/2)!(n-rw_1/2-w_2)!}{(n-rw_1)!(w_2-rw_1/2-\\frac{r}{2})!(n-rw_1/2-w_2-\\frac{r}{2})!}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\prod_{j=0}^{\\frac{r}{2}-1} \\frac{(w_2-\\frac{rw_1}{2}-j)(n-w_2-\\frac{rw_1}{2}-j)}{(n-rw_1-2j)(n-rw_1-2j-1)}.</span>$</p>

    <p class="text-gray-300">Now, we first note that for each j</p>

    <p class="text-gray-300"><span class="math">$\\frac{rw_1 + 2j + 1}{n - rw_1 - 2j - 1} \\le \\frac{rw_1 + 2j + 2}{n - rw_1 - 2j} .</span>$</p>

    <p class="text-gray-300">Indeed, calling  <span class="math">x = rw_1 + 2j + 1</span>  and y = n, we wish to show  <span class="math">\\frac{x}{y} \\leq \\frac{x+1}{y+1}</span> , which is true if and only if  <span class="math">x \\leq y</span> , which is true for our setting since we assumed  <span class="math">n \\geq 2m + r + 1</span>  and we have  <span class="math">w_1 \\leq 2w_2/r \\leq 2m/r</span> . Thus, we bound</p>

    <p class="text-gray-300"><span class="math">$\\prod_{j=0}^{\\frac{r}{2}-1} \\frac{(rw_1 + 2j + 1)(rw_1 + 2j + 2)}{(\\frac{rw_1}{2} + j + 1)^2} \\cdot \\frac{(w_2 - \\frac{rw_1}{2} - j)(n - \\frac{rw_1}{2} - j)}{(n - w_2 - rw_1 - 2j)(n - rw_1 - 2j - 1)}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\prod_{j=0}^{\\frac{r}{2}-1} \\frac{(rw_1 + 2j + 2)(rw_1 + 2j + 2)}{(\\frac{rw_1}{2} + j + 1)^2} \\cdot \\frac{(w_2 - \\frac{rw_1}{2} - j)(n - \\frac{rw_1}{2} - j)}{(n - w_2 - rw_1 - 2j)(n - rw_1 - 2j)}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\prod_{j=0}^{\\frac{r}{2}-1} 2^2 \\cdot \\frac{(w_2 - \\frac{rw_1}{2} - j)(n - w_2 - \\frac{rw_1}{2} - j)}{(n - rw_1 - 2j)^2} . \\tag{12}</span>$</p>

    <p class="text-gray-300">Now, for fixed j call  <span class="math">x = w_2 - \\frac{rw_1}{2} - j</span>  and  <span class="math">y = (n - w_2 - \\frac{rw_1}{2} - j)</span> . Observe</p>

    <p class="text-gray-300"><span class="math">$\\frac{(w_2 - \\frac{rw_1}{2} - j)(n - w_2 - \\frac{rw_1}{2} - j)}{(n - rw_1 - 2j)(n - rw_1 - 2j)} = \\frac{xy}{(x + y)^2} = \\frac{xy}{(y - x)^2 + 4xy}.</span>$</p>

    <p class="text-gray-300">Instead of upper bounding this ratio, we find it easier to lower bound its reciprocal:</p>

    <p class="text-gray-300">
<span class="math">$\\frac{(y-x)^2 + 4xy}{xy} = \\frac{(y-x)^2}{xy} + 4.</span>$</p>

    <p class="text-gray-300">Now, we have  <span class="math">xy \\leq (w_2 - \\frac{rw_1}{2})(n - w_2 - \\frac{rw_1}{2}) \\leq m(n - m) \\leq mn = n^{1+\\gamma}</span> , as  <span class="math">w_2 \\leq m \\leq n/2</span> . On the other hand,  <span class="math">(y - x) = (n - 2w_2) \\geq (n - 2m) \\geq \\xi n</span> , where this last inequality uses the assumption  <span class="math">n \\geq \\frac{2}{1-\\xi}m</span> . Hence,</p>

    <p class="text-gray-300"><span class="math">$\\frac{(y-x)^2}{xy} \\ge \\frac{\\xi^2 n^2}{n^{1-\\gamma}} = \\xi^2 n^{1-\\gamma} \\ .</span>$</p>

    <p class="text-gray-300">Thus, we have the bound</p>

    <p class="text-gray-300"><span class="math">$(12) \\le \\prod_{j=0}^{\\frac{r}{2}-1} 4 \\cdot \\frac{1}{\\xi^2 n^{1-\\gamma} + 4} = \\prod_{j=0}^{\\frac{r}{2}-1} \\frac{1}{(\\xi/2)^2 n^{1-\\gamma} + 1}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\le \\prod_{j=0}^{\\frac{r}{2}-1} (2/\\xi)^2 n^{\\gamma-1} = (2/\\xi)^r n^{\\frac{r}{2}(\\gamma-1)} = (2/\\xi)^r n^{-(1+\\varepsilon)}</span>$</p>

    <p class="text-gray-300">where we used  <span class="math">\\gamma = 1 - \\frac{2}{r}(1+\\varepsilon)</span>  in the last equality. Finally, using the assumption  <span class="math">n \\ge \\frac{(2/\\xi)^{r/\\varepsilon}}{r^{1/\\varepsilon}} \\iff n^{\\varepsilon} \\ge \\frac{(2/\\xi)^r}{r}</span> , we have</p>

    <p class="text-gray-300"><span class="math">$\\frac{n}{r} \\cdot (2/\\xi)^r n^{-(1+\\varepsilon)} = \\frac{(2/\\xi)^r}{r} n^{-\\varepsilon} \\le 1</span>$</p>

    <p class="text-gray-300">establishing that the terms in this summation over  <span class="math">w_1</span>  are indeed decreasing.</p>

    <p class="text-gray-300">Thus, we can conclude that the sum over  <span class="math">w_1</span>  in (11) is maximised by its first term  <span class="math">w_1 = 1</span> , so that we can upper-bound as follows:</p>

    <p class="text-gray-300">
<span class="math">$(8) \\leq (10) + \\sum_{w_2=1}^{m} \\frac{\\binom{n-w_2}{d-\\lceil w_2/2\\rceil}}{\\binom{n}{d}} \\frac{1}{\\binom{n}{w_2}} \\cdot \\binom{w_2}{\\lceil w_2/2\\rceil} \\cdot \\frac{\\lceil w_2/2\\rceil}{w_2} \\cdot \\lfloor \\frac{2w_2}{r} \\rfloor \\cdot \\binom{n/r}{1} \\binom{r}{\\frac{r}{2}} \\binom{n-r}{w_2-r/2} \\cdot \\frac{r}{2}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq (10) + \\frac{n}{r} \\cdot \\binom{r}{\\frac{r}{2}} \\sum_{w_2=1}^{m} \\frac{\\binom{n-w_2}{d-\\lceil w_2/2\\rceil}}{\\binom{n}{d}} \\frac{\\binom{n-r}{w_2-r/2}}{\\binom{n}{w_2}} \\cdot \\binom{w_2}{\\lceil w_2/2\\rceil} \\cdot \\lceil w_2/2\\rceil , \\qquad (13)</span>$</p>

    <p class="text-gray-300">where we upper-bounded  <span class="math">\\lfloor \\frac{2w_2}{r} \\rfloor</span>  by removing the floor. We would like to bound the final sum over  <span class="math">w_2</span>  in a similar fashion. Unfortunately, this sum isn't maximized by its first or last term, but rather by some term in between. To find this term, we first simplify the sum somewhat. Specifically, we now observe that the sum over  <span class="math">w_2</span>  grows with  <span class="math">w_2</span>  for odd  <span class="math">w_2</span> , i.e. any term for odd  <span class="math">w_2</span>  can be upper-bound by its subsequent (and thus even) term  <span class="math">w_2 + 1</span> . By simplifying the sum in this manner, we will be able to bound it in a good way. But before we do that, let us justify our claim, by once again computing the ratio between subsequent terms in the sum, this time assuming  <span class="math">w_2</span>  is odd:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\frac{\\binom{n-(w_2+1)}{d-\\lceil \\frac{w_2+1}{2} \\rceil}}{\\binom{n-w_2}{d-\\lceil \\frac{w_2+1}{2} \\rceil}} &amp;= \\frac{\\binom{n-w_2-1}{d-\\frac{w_2+1}{2}}}{\\binom{n-w_2}{d-\\lceil \\frac{w_2+1}{2} \\rceil}} = \\frac{(n-w_2-1)! \\left(d-\\frac{w_2+1}{2}\\right)! \\left(n-d-w_2/2+\\frac{1}{2}\\right)!}{(n-w_2)! \\left(d-\\frac{w_2+1}{2}\\right)! \\left(n-d-w_2/2-\\frac{1}{2}\\right)!} &amp;= \\frac{n-d-w_2/2+\\frac{1}{2}}{n-w_2} \\;, \\\\ \\frac{\\binom{n-r}{w_2+1-\\frac{r}{2}}}{\\binom{n-r}{w_2-\\frac{r}{2}}} &amp;= \\frac{(n-r)! \\left(w_2-\\frac{r}{2}\\right)! \\left(n-w_2-\\frac{r}{2}\\right)!}{(n-r)! \\left(w_2-\\frac{r}{2}+1\\right)! \\left(n-w_2-\\frac{r}{2}-1\\right)!} &amp;= \\frac{n-w_2-\\frac{r}{2}}{w_2-\\frac{r}{2}+1} \\;, \\\\ \\frac{\\binom{n}{w_2}}{\\binom{n}{w_2+1}} &amp;= \\frac{n! \\cdot (w_2+1)! (n-w_2-1)!}{n! \\cdot w_2! \\cdot (n-w_2)!} &amp;= \\frac{w_2+1}{n-w_2} \\;, \\\\ \\frac{\\binom{w_2+1}{2}}{\\binom{w_2}{2}} &amp;= \\frac{\\binom{w_2+1}{2}}{\\binom{w_2}{2}} &amp;= \\frac{(w_2+1)! \\left(\\frac{w_2+1}{2}\\right)! \\left(\\frac{w_2-1}{2}\\right)!}{w_2! \\left(\\frac{w_2+1}{2}\\right)! \\left(\\frac{w_2-1}{2}\\right)!} &amp;= \\frac{(w_2+1)!}{\\binom{w_2+1}{2}} &amp;= 2 \\;, \\\\ \\frac{\\lceil \\frac{w_2+1}{2} \\rceil}{\\lceil w_2/2 \\rceil} &amp;= \\frac{\\frac{w_2+1}{2}}{\\frac{w_2+1}{2}} &amp;= 1 \\;. \\end{split}</span>$</p>

    <p class="text-gray-300">Combining these ratios gives us the following:</p>

    <p class="text-gray-300">
<span class="math">$\\frac{n - d - w_2/2 + \\frac{1}{2}}{n - w_2} \\cdot \\frac{n - w_2 - \\frac{r}{2}}{w_2 - \\frac{r}{2} + 1} \\cdot \\frac{w_2 + 1}{n - w_2} \\cdot 2 \\cdot 1</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\frac{2(n - d) - w_2 + 1}{n - w_2} \\cdot \\frac{n - w_2 - \\frac{r}{2}}{n - w_2} \\cdot \\frac{w_2 + 1}{w_2 - \\frac{r}{2} + 1} .</span>$
(14)</p>

    <p class="text-gray-300">Recall that we need to show that the above expression (14) is &gt; 1. To do so, we will use the following fact: if  <span class="math">x, y, z \\ge 0</span>  with  <span class="math">y \\ge x &gt; z</span> , then  <span class="math">\\frac{x}{x-z} \\cdot \\frac{y-z}{y} \\ge 1</span> . Indeed, we observe</p>

    <p class="text-gray-300"><span class="math">$x(y-z) \\ge (x-z)y \\iff xy-xz \\ge xy-zy \\iff zy \\ge xz \\iff y \\ge x</span>$
.</p>

    <p class="text-gray-300">Applying this claim with  <span class="math">x := w_2 + 1</span> ,  <span class="math">y := n - w_2</span>  and  <span class="math">z := \\frac{r}{2}</span>  tells us that the product of the last two fractions in (14) are  <span class="math">\\geq 1</span> . To show that (14) &gt; 1, it therefore suffices to show that the first</p>

    <p class="text-gray-300">fraction is &gt; 1:</p>

    <p class="text-gray-300"><span class="math">$\\frac{2(n-d)-w_2+1}{n-w_2} \\ge \\frac{2(n-d)-w_2}{n-w_2} \\ge \\frac{2(n-d)}{n} &gt; 1</span>$</p>

    <p class="text-gray-300">where the second inequality follows from</p>

    <p class="text-gray-300"><span class="math">$\\frac{a-x}{b-x} \\ge \\frac{a}{b} \\iff \\frac{(a-x) \\cdot b}{a \\cdot (b-x)} \\iff ab-xb \\ge ab-xa \\iff a \\ge b</span>$</p>

    <p class="text-gray-300">and the final inequality uses  <span class="math">2(n-d)=2(1-\\delta)n&gt;n</span>  since  <span class="math">\\delta&lt;1/2</span> .</p>

    <p class="text-gray-300">Thus, we have shown that any odd  <span class="math">w_2</span>  term in the sum over  <span class="math">w_2</span>  in (13) is smaller than its subsequent even  <span class="math">w_2</span> , allowing us to bound the odd terms by the subsequent even terms. To do so, let  <span class="math">w_2 := 2v_2</span>  so that we can write:</p>

    <p class="text-gray-300"><span class="math">$(8) \\leq (10) + \\frac{n}{r} \\cdot {r \\choose \\frac{r}{2}} \\sum_{w_2=1}^{m} \\frac{\\binom{n-w_2}{d-\\lceil w_2/2 \\rceil}}{\\binom{n}{d}} \\frac{\\binom{n-r}{w_2-r/2}}{\\binom{n}{w_2}} \\cdot {w_2 \\choose \\lceil w_2/2 \\rceil} \\cdot \\lceil w_2/2 \\rceil</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq (10) + \\frac{n}{r} \\cdot {r \\choose \\frac{r}{2}} \\sum_{v_2=1}^{\\lceil \\frac{m}{2} \\rceil} \\frac{\\binom{n-2v_2}{d-v_2}}{\\binom{n}{d}} \\frac{\\binom{n-r}{w_2-r/2}}{\\binom{n}{2v_2}} \\cdot {v_2 \\choose v_2} \\cdot v_2 . \\tag{15}</span>$</p>

    <p class="text-gray-300">To bound this expression, we will write out the binomials and then apply the following bound from [KZKJ08]</p>

    <p class="text-gray-300">
<span class="math">$\\frac{N^{\\ell}}{\\varphi_N(\\ell)} \\le \\prod_{\\lambda=0}^{\\ell-1} (N-\\lambda) \\le N^{\\ell} \\tag{16}</span>$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$\\varphi_N(\\ell) := \\exp\\left(\\frac{\\ell(\\ell-1)}{2N}\\right) \\; ,</span>$</p>

    <p class="text-gray-300">which gives us the following:</p>

    <p class="text-gray-300"><span class="math">$(8) = (10) + \\frac{n}{r} \\cdot {r \\choose \\frac{r}{2}} \\sum_{v_2=1}^{\\lceil \\frac{m}{2} \\rceil} \\frac{(n-2v_2)! \\cdot d! \\cdot (n-d)!}{n! \\cdot (d-v_2)! (n-d-v_2)!} \\cdot \\frac{(n-r)!(2v_2)! (n-2v_2)!}{n! \\cdot (2v_2 - \\frac{r}{2})! (n-2v_2 - \\frac{r}{2})!} \\cdot {2v_2 \\choose v_2} \\cdot v_2</span>$</p>

    <p class="text-gray-300"><span class="math">$= (10) + \\frac{n}{r} \\cdot {r \\choose \\frac{r}{2}} \\sum_{v_2=1}^{\\lceil \\frac{m}{2} \\rceil} \\frac{\\prod_{j=0}^{v_2-1} (d-j) \\prod_{j=0}^{v_2-1} (n-d-j)}{\\prod_{j=0}^{2v_2-1} (n-j)} \\cdot \\frac{\\prod_{j=0}^{\\frac{r}{2}-1} (2v_2 - j) \\prod_{j=0}^{\\frac{r}{2}-1} (n-2v_2 - j)}{\\prod_{j=0}^{r-1} (n-j)} \\cdot {2v_2 \\choose v_2} \\cdot v_2</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq (10) + \\frac{n}{r} \\cdot {r \\choose \\frac{r}{2}} \\sum_{v_2=1}^{\\lceil \\frac{m}{2} \\rceil} \\frac{d^{v_2} \\cdot (n-d)^{v_2}}{n^{2v_2}} \\cdot \\varphi_n(2v_2) \\cdot \\frac{(2v_2)^{\\frac{r}{2}} (n-2v_2)^{\\frac{r}{2}}}{n^r} \\cdot \\varphi_n(r) \\cdot {2v_2 \\choose v_2} \\cdot v_2 .</span>$</p>

    <p class="text-gray-300">To simplify this further, we note that the factor  <span class="math">\\frac{(n-2v_2)^{\\frac{r}{2}}}{n^{r/2}}</span>  will tend to 1 from below, and be extremely close to 1 for larger n, so we remove it (this vastly simplifies finding the maximizing term). Next, we bound the binomial involving  <span class="math">v_2</span>  using Lemma 9.4. We leave out the factor  <span class="math">\\varphi_n(2v_2)</span> , simply</p>

    <p class="text-gray-300">bounding it as  <span class="math">\\varphi_n(2\\lceil m/2\\rceil)</span> . Finally, we recall that we defined  <span class="math">\\eta := 4\\delta(1-\\delta)</span> . Combing all this gives us the bound:</p>

    <p class="text-gray-300"><span class="math">$(8) \\leq (10) + n^{1-r/2} \\cdot \\frac{0.87206}{r} \\cdot \\binom{r}{\\frac{r}{2}} \\cdot \\varphi_n \\left( 2 \\cdot \\lceil \\frac{m}{2} \\rceil \\right) \\cdot \\varphi_n(r) \\sum_{v_2=1}^{\\lceil \\frac{m}{2} \\rceil} (2v_2)^{\\frac{r}{2}} \\cdot v_2 \\cdot \\frac{2^{2v_2}}{\\sqrt{2v_2}} \\cdot \\frac{d^{v_2} \\cdot (n-d)^{v_2}}{n^{2v_2}}</span>$</p>

    <p class="text-gray-300"><span class="math">$= (10) + n^{1-r/2} \\cdot \\frac{0.87206}{2r} \\cdot \\binom{r}{\\frac{r}{2}} \\cdot \\varphi_n \\left( 2 \\cdot \\lceil \\frac{m}{2} \\rceil \\right) \\cdot \\varphi_n(r) \\sum_{v_2=1}^{\\lceil \\frac{m}{2} \\rceil} (2v_2)^{\\frac{r+1}{2}} \\cdot \\eta^{v_2} .</span>$</p>

    <p class="text-gray-300">To maximize the expression depending on  <span class="math">v_2</span>  we rewrite it as</p>

    <p class="text-gray-300"><span class="math">$(2v_2)^{\\frac{r+1}{2}} \\cdot \\eta^{v_2} = \\exp\\left(\\frac{r+1}{2} \\cdot \\ln(2v_2) + v_2 \\cdot \\ln(\\eta)\\right)</span>$</p>

    <p class="text-gray-300">so that it suffices to maximize the exponent. We do this by setting its derivative to  <span class="math">v_2</span>  equal to 0:</p>

    <p class="text-gray-300"><span class="math">$\\frac{r+1}{2} \\cdot \\frac{1}{v_2} + \\ln(\\eta) = 0 \\iff v_2 = \\frac{1+r}{2\\ln(1/\\eta)}</span>$
.</p>

    <p class="text-gray-300">Call this critical point  <span class="math">v_2^*</span> . To see it is a maximizer, note that the second derivative  <span class="math">-\\frac{r+1}{2}v_2^{-2} &lt; 0</span>  for all  <span class="math">v_2 &gt; 0</span> . So,  <span class="math">v_2^*</span>  is indeed the maximizer, so the final bound becomes:</p>

    <p class="text-gray-300"><span class="math">$(8) = (10) + n^{1-r/2} \\cdot \\left\\lceil \\frac{n^{\\gamma}}{2} \\right\\rceil \\cdot \\frac{0.43603}{r} \\cdot \\binom{r}{\\frac{r}{2}} \\cdot \\varphi_n \\left( 2 \\cdot \\left\\lceil \\frac{m}{2} \\right\\rceil \\right) \\cdot \\varphi_n(r) \\cdot \\left( 2v_2^* \\right)^{\\frac{r+1}{2}} \\cdot \\eta^{v_2^*} .</span>$</p>

      <h3 id="sec-9.3" class="text-xl font-semibold mt-8">9.3 Given Successful First Stage, Probability Code has Good Distance</h3>

    <p class="text-gray-300">We now focus on the second half of (6). That is, we wish to bound</p>

    <p class="text-gray-300"><span class="math">$\\sum_{w_{1}=1}^{n/r} \\sum_{w_{2}=\\lceil n^{\\gamma} \\rceil}^{n} \\sum_{w_{3}=1}^{d} \\binom{n/r}{w_{1}} \\cdot \\frac{\\binom{rw_{1}}{rw_{1}/2} \\binom{n-rw_{1}}{w_{2}-rw_{1}/2}}{\\binom{n}{w_{2}}} \\cdot \\frac{\\binom{w_{2}}{rw_{2}/2} \\binom{n-w_{2}}{w_{3}-\\lceil w_{2}/2 \\rceil}}{\\binom{n}{w_{3}}} \\cdot \\frac{\\lceil rw_{1}/2 \\rceil \\cdot \\lceil w_{2}/2 \\rceil}{w_{2}w_{3}} . \\tag{17}</span>$</p>

    <p class="text-gray-300"></p>

    <p class="text-gray-300">To do this, we more directly exploit analysis of Kliewer et al. [KZKJ08]. In particular, we consider the following function (as they do):</p>

    <p class="text-gray-300"><span class="math">$f(\\alpha,\\beta,\\rho) := \\frac{H(\\alpha)}{r} - H(\\beta) - H(\\rho) + \\alpha + (1-\\alpha)H\\left(\\frac{\\beta - \\alpha/2}{1-\\alpha}\\right) + \\beta + (1-\\beta)H\\left(\\frac{\\rho - \\beta/2}{1-\\beta}\\right) \\ .</span>$</p>

    <p class="text-gray-300">In the above, we've used  <span class="math">H(\\cdot)</span>  to denote the binary entropy function, which we recall is defined on the interval [0,1] via</p>

    <p class="text-gray-300"><span class="math">$H(p) := -p \\log_2 p - (1-p) \\log_2 (1-p)</span>$</p>

    <p class="text-gray-300">for  <span class="math">p \\in (0,1)</span>  and extended by continuity to the endpoints: H(0) = H(1) = 0.</p>

    <p class="text-gray-300">The motivation for the definition of f stems from the following approximation. Fix  <span class="math">w_1, w_2</span>  and  <span class="math">w_3</span>  in (17), and consider the corresponding term in the sums. Set now  <span class="math">\\alpha = \\frac{rw_1}{n}</span> ,  <span class="math">\\beta = \\frac{w_2}{n}</span>  and  <span class="math">\\rho = \\frac{w_3}{n}</span> , the relative Hamming weights of the corresponding vectors (in the case of  <span class="math">w_1</span> , note this is</p>

    <p class="text-gray-300">the weight after repeating the message vector). We argue below that we can then write the term as n O(1) &middot; 2 n&middot;f(&alpha;,&beta;,&rho;) . Thus, we could hope to argue the following: suppose that f(&alpha;, &beta;, &rho;) &lt; 0 for all admissible &alpha;, &beta;, &rho;, with maximal value f &lowast; , where admissibility is determined by <a href="#page-43-1">Lemma 9.3.</a> Then the bound would be n O(1) &middot; 2 n&middot;f &lowast; , and it's reasonable to hope for the second term to overwhelm the first.</p>

    <p class="text-gray-300">So, we look to maximise f over the set of (&alpha;, &beta;, &rho;) satisfying 0 &lt; &alpha; &le; min{2&beta;, 2 &minus; 2&beta;}, 0 &lt; &beta; &le; {2&rho;, 2 &minus; 2&rho;} and 0 &lt; &rho; &le; &delta;. To do so, we start (see <a href="#page-57-0">Claim 9.9.1)</a> by showing that f grows monotonically with &rho;, so that to maximise f we can simply set &rho; := &delta; (recall that &delta; is our target minimum distance). This leaves us with the maximisation of f over &alpha;, &beta;; we visualise the admissible region R &sube; R <sup>2</sup> of points (&alpha;, &beta;) as a triangle in <a href="#page-51-1">Section 9.3.</a></p>

    <p class="text-gray-300">    <img src="_page_52_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 5: The region over which we look to maximize f, where &rho; = &delta; is fixed. In fact we assume &delta; &lt; 1/4 in this image, so that the constraints &alpha; &le; 2&minus;2&beta; and &beta; &le; 2&minus;2&delta; can be removed. However, f(0, 0, &delta;) = 0, so a na&uml;&#305;ve analysis will not work. The blue curve shows the points for which &part;f &part;&alpha; = 0 and the red curve shows the points for which &part;f &part;&beta; = 0.</p>

    <p class="text-gray-300">It was already shown by <a href="#page-81-10">[KZKJ08]</a> that all points in this region with &alpha;, &beta; &gt; 0 are indeed negative, so that for large enough n almost all codes attain this minimum distance &delta; (assuming one picks a small enough target minimum distance &delta;). However, their analysis doesn't specify which point is the maximizer. Indeed, the region R is not compact, so that finding a maximizer might not even be possible. In particular, the supremum value of f on R will be at least 0, as f(0, 0, &delta;) = 0 and (0, 0) is an accumulation point of R.</p>

    <p class="text-gray-300">Our contribution is to show that we can indeed find a maximum once we restrict the set of admissible (&alpha;, &beta;). We can then use this maximum to bound each term in the expectation <a href="#page-51-1">(17)</a> and give a concrete bound on the error probability of sampling a code with minimum distance &delta;, even for concrete n. Let us give a brief high-level overview of our argument first.</p>

    <p class="text-gray-300">Note that for fixed n the region over which we maximize does become compact: the permissible points (&alpha;, &beta;) can't be real numbers arbitrarily close to 0 anymore, but must be at least &alpha;<sup>0</sup> := r/n and &beta;<sup>0</sup> := r/(2n). Visually, this shrinks our triangle, cutting off a slice on the left, containing the ranges 0 &lt; &alpha; &lt; r/n and 0 &lt; &beta; &lt; r/(2n).</p>

    <p class="text-gray-300">This space must then be maximized by a critical point (i.e. an admissible pair  <span class="math">(\\alpha, \\beta)</span>  with  <span class="math">\\alpha \\geq r/n</span>  and  <span class="math">\\beta \\geq r/(2n)</span>  at which both  <span class="math">\\frac{\\partial f}{\\partial \\alpha}</span>  and  <span class="math">\\frac{\\partial f}{\\partial \\beta}</span>  equal 0) or a point on the boundary. Thanks to [KZKJ08], we know an algebraic relation that critical points must satisfy, which in particular implies there are only a constant number of them (and moreover they can be explicitly computed). Specifically, the red line drawn in Figure 9.3 represents the points where the derivative to  <span class="math">\\alpha</span>  is 0 and the blue line represents the points where the derivative to  <span class="math">\\beta</span>  is 0. Their points of intersection are the critical points of f.<sup>27</sup></p>

    <p class="text-gray-300">We will argue that the restrictions of f to either  <span class="math">\\alpha</span>  or  <span class="math">\\beta</span>  (i.e. horizontal or vertical restrictions of the region) are strictly concave. This means that any horizontal &quot;slice&quot; of our region will be maximized by the intersection point of the slice and the blue curve; any vertical &quot;slice&quot; will be maximized by the intersection of the slice and the red curve. We will show that for most  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span>  the red and blue curves lie strictly in the interior of the region. It follows that the boundaries (a), (b) and (c) cannot contain maximizers for f.</p>

    <p class="text-gray-300">The only exception is tiny  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span> . At the very bottom-left, the blue curve exits the interior of the triangle at  <span class="math">(\\alpha_0, \\beta_1)</span>  where  <span class="math">\\beta_1 = \\Omega(n^{-2/r})</span> . Consider now the very bottom of boundary (a) where  <span class="math">\\beta &lt; \\beta_1</span> . A horizontal slice of the region at such a  <span class="math">\\beta</span>  has a critical point on the blue curve. But since this curve is now to the left of our triangle, the maximizer instead becomes the left-most point:  <span class="math">\\alpha_0</span> . This means the points  <span class="math">(\\alpha_0, \\beta)</span>  for  <span class="math">\\beta &lt; \\beta_1</span>  are potential maximizers of f. However, we will argue that f is decreasing with  <span class="math">\\beta</span>  on this range, so that the only potential maximizer is the bottom-left corner of the triangle  <span class="math">(\\alpha_0, \\beta_0)</span> .</p>

    <p class="text-gray-300">    <img src="_page_53_Figure_3.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 6: The region  <span class="math">\\mathcal{R}&#x27;</span>  that we optimize the function f over (again for  <span class="math">\\delta &lt; 1/4</span> ). Notably, we require  <span class="math">\\alpha \\geq \\alpha_0 = r/n</span>  and  <span class="math">\\beta \\geq \\beta_0 = n^{\\gamma-1}</span> , that is, we have a little gap between the axes and the region  <span class="math">\\mathcal{R}&#x27;</span> . Furthermore the region  <span class="math">\\mathcal{R}&#x27;</span>  is now <em>compact</em>. The blue curve, representing the values for which  <span class="math">\\frac{\\partial f}{\\partial \\alpha} = 0</span> , crosses the boundary (a) at some point  <span class="math">\\beta_1 \\geq \\beta_0</span> .</p>

    <p class="text-gray-300">In short, either the bottom-left point or a critical point maximizes f. Unfortunately, the value of</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;27</sup>For r = 4 these curves are quadratic. For different r they are polynomials of differing degrees. Our drawing just serves to provide some intuition, and doesn't exactly represent the curves for any r.</p>

    <p class="text-gray-300">f at this bottom-left point is so close to 0 that it doesn't suffice to provide small error probability,<sup>28</sup> making this approach unusable as is. However, recall that we have  <span class="math">w_2 \\geq n^{\\gamma}</span>  so that  <span class="math">\\beta \\geq n^{\\gamma-1}</span> . It turns out that this increase of  <span class="math">\\beta</span>  decreases f enough to make this approach usable. Visually, this removes the left-most part of the triangle. This turns our original triangle-shaped region into a quadrilateral-shaped region. We visualise this region in Figure 6.</p>

    <p class="text-gray-300">The analysis remains as above: though we add a new boundary (e), since this boundary lies strictly below  <span class="math">\\beta_1</span>  (as  <span class="math">\\beta_0 = n^{\\gamma-1} &lt; \\beta_1 = \\Omega(n^{-2/r})</span>  for our choice of  <span class="math">\\gamma</span> ), we can still argue that the bottom-left point  <span class="math">(\\alpha_0, \\beta_0) = (r/n, n^{\\gamma-1})</span>  is the only maximizer beyond the critical points in the region. Since the critical points are independent of n, while the bottom-left point decreases with n, for large enough n the bottom-left point is always the maximizer (assuming  <span class="math">\\delta</span>  is not too large (depending on r). The final bound will be  <span class="math">n^{O(1)} \\cdot 2^{f(\\alpha_0,\\beta_0,\\delta)n} = n^{O(1)} \\cdot 2^{-\\Omega(n^{\\gamma})} = 2^{-\\Omega(n^{\\gamma})}</span> , using an estimate  <span class="math">f(\\alpha_0,\\beta_0,\\delta) = -\\Omega(n^{\\gamma})</span>  which we establish. All in all, we derive the following proposition.</p>

    <p class="text-gray-300"><strong>Proposition 9.6.</strong> Let  <span class="math">r, n \\in \\mathbb{N}</span>  with  <span class="math">r \\geq 3</span>  and  <span class="math">r \\mid n</span> ,  <span class="math">\\delta \\in (0, 1/2)</span>  s.t.  <span class="math">d := \\delta n \\in \\mathbb{N}</span> ,  <span class="math">\\gamma = 1 - \\frac{2}{r}(1 + \\varepsilon)</span>  for some  <span class="math">\\varepsilon &gt; 0</span> . Define  <span class="math">\\alpha_0 := \\frac{r}{n}</span>  and  <span class="math">\\beta_0 := n^{\\gamma - 1}</span> . Assume</p>

    <p class="text-gray-300"><span class="math">$\\beta_1 = \\frac{1}{2} - \\frac{1 - \\alpha_0}{2} \\sqrt{1 - \\left(\\frac{\\alpha_0}{1 - \\alpha_0}\\right)^{2/r}} &gt; \\beta_0 \\ , \\quad \\sqrt{4\\delta(1 - \\delta)} &lt; 1 - 2\\beta_1 - \\frac{\\alpha_0}{2\\beta_0} \\quad and \\quad n^\\gamma \\ge 101 \\ .</span>$</p>

    <p class="text-gray-300">Then</p>

    <p class="text-gray-300">$$\\sum_{w_1}^{n/r} \\sum_{w_2 = \\lfloor n^{\\gamma} \\rfloor + 1}^{n} \\sum_{w_3 = 1}^{d} \\binom{n/r}{w_1} \\cdot \\frac{\\binom{rw_1}{\\lceil rw_1/2 \\rceil} \\binom{n - rw_1}{w_2 - \\lceil rw_1/2 \\rceil}}{\\binom{n}{w_2}} \\cdot \\frac{\\binom{w_2}{\\lceil w_2/2 \\rceil} \\binom{n - w_2}{w_3 - \\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{\\lceil rw_1/2 \\rceil \\cdot \\lceil w_2/2 \\rceil}{w_2 w_3} \\
\\leq \\frac{0.80192 \\cdot \\delta}{r^{3/2}} \\cdot n^{7/2} \\cdot \\max_{(\\alpha, \\beta) \\in \\mathcal{R}'} 2^{f(\\alpha, \\beta, \\delta)n} \\
\\leq \\frac{0.80192 \\cdot \\delta}{r^{3/2}} \\cdot n^{7/2} \\cdot 2^{Bn} , \\tag{18}$$</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">$B = \\max\\{f(\\alpha_0, \\beta_0, \\delta), \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in \\mathrm{CP}(r, \\delta)\\}\\}.</span>$</p>

    <p class="text-gray-300">Above,  <span class="math">CP(r, \\delta)</span>  is the set of critical points of f in  <span class="math">\\mathcal{R}&#x27;</span>  given r and  <span class="math">\\delta</span> , i.e. the set of  <span class="math">(\\alpha, \\beta)</span>  satisfying equations (19) and (20). In particular, if f is negative on all critical points then for sufficiently large n the bound is</p>

    <p class="text-gray-300">
<span class="math">$\\frac{0.80192 \\cdot \\delta}{r^{3/2}} \\cdot n^{7/2} \\cdot 2^{f(\\alpha_0, \\beta_0, \\delta)n} \\le 2^{-\\Omega(n^{\\gamma})}.</span>$</p>

    <p class="text-gray-300"><strong>Remark 9.7.</strong> We remark that in the above we do not require r even, nor do we require  <span class="math">\\delta &lt; 1/3</span> ; only Proposition 9.5 requires these bounds.</p>

    <p class="text-gray-300">Before diving into the proof of this proposition, we quickly justify that the constraints are met for large enough n. Clearly the constraint  <span class="math">n^{\\gamma} \\geq 101</span>  just requires large enough n. Furthermore as  <span class="math">\\delta &lt; 1/2</span>  we have  <span class="math">\\sqrt{4\\delta(1-\\delta)} \\leq 1 - \\Omega(1)</span>  whereas  <span class="math">1 - 2\\beta_1 - \\frac{\\alpha_0}{2\\beta_0} = 1 - O(n^{-r/2}) - O(n^{-\\gamma})</span> , so the second requirement is met for reasonable n. For the constraint involving  <span class="math">\\beta_1</span> :</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;28</sup>We observe that  <span class="math">f(r/n, r/(2n), \\delta) \\approx -\\ln(n)/n</span> , so then  <span class="math">2^{nf(r/n, r/(2n), \\delta)} \\approx 1/n^{\\ln 2} \\approx 1/n^{0.3}</span>  which will not overcome the poly(n) overhead from the union bound.</p>

    <p class="text-gray-300">Claim 9.7.1. Let  <span class="math">r, n, \\delta, \\varepsilon, \\gamma, \\alpha_0, \\beta_0</span>  be as in Proposition 9.6. Then  <span class="math">\\beta_1 = \\Theta(n^{-2/r})</span> , so for large enough  <span class="math">n, \\beta_0 = n^{\\gamma-1} = n^{-\\frac{2}{r}(1+\\varepsilon)} &lt; \\beta_1</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> We have</p>

    <p class="text-gray-300"><span class="math">$\\beta_1 \\ge \\frac{1}{2} - \\frac{1 - r/n}{2} \\left( 1 - \\frac{1}{2} \\left( \\frac{r/n}{1 - r/n} \\right)^{2/r} \\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\frac{1}{2} - \\frac{1}{2} + \\frac{1}{2} \\left( \\frac{r/n}{1 - r/n} \\right)^{2/r} + \\frac{r}{2n} - \\frac{1}{4} \\frac{(r/n)^{1+2/r}}{(1 - r/n)^{2/r}} = \\Omega(n^{-2/r}) ,</span>$</p>

    <p class="text-gray-300">where we use  <span class="math">\\sqrt{1-x} \\le 1-x/2</span>  for all  <span class="math">x \\in [0,1]</span> . Similarly, using  <span class="math">\\sqrt{1-x} \\ge 1-x</span>  one can also establishes  <span class="math">\\beta_1 \\le O(n^{-2/r})</span> , so we conclude  <span class="math">\\beta_1 = \\Theta(n^{-2/r})</span> .</p>

    <p class="text-gray-300">We now turn to the proof of Proposition 9.6.</p>

    <p class="text-gray-300">of Proposition 9.6. We start by showing that we can indeed bound the expectation as (18). We then turn to the maximization of f, and show that it is indeed maximized by one of the points in the set B.</p>

    <p class="text-gray-300">To bound the expression inside the sums, we rewrite the binomials using Lemma 9.4, with the goal of writing this expression as  <span class="math">poly(n) \\cdot 2^{n \\cdot f(\\alpha, \\beta, \\delta)}</span> . After doing so, we work out the poly(n) factors we pick up in the process. We then write out the poly(n)-part of the binomials, and finally remove the sums. We thus write the expression in the sums as</p>

    <p class="text-gray-300"><span class="math">$\\begin{pmatrix} n/r \\\\ w_1 \\end{pmatrix} \\cdot \\frac{\\binom{rw_1}{\\lceil rw_1/2 \\rceil} \\binom{n-rw_1}{w_2 - \\lceil rw_1/2 \\rceil}}{\\binom{n}{w_2}} \\cdot \\frac{\\binom{w_2}{\\lceil w_2/2 \\rceil} \\binom{n-w_2}{w_3 - \\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{\\lceil rw_1/2 \\rceil \\cdot \\lceil w_2/2 \\rceil}{w_2 w_3}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\operatorname{poly}(n) \\cdot \\frac{2^{n/rH \\left(\\frac{w_1}{n/r}\\right)} 2^{(n-rw_1)H \\left(\\frac{w_2 - \\lceil rw_1/2 \\rceil}{n-rw_1}\\right)} 2^{rw_1H \\left(\\frac{\\lceil rw_1/2 \\rceil}{rw_1}\\right)} 2^{w_2H \\left(\\frac{\\lceil w_2/2 \\rceil}{w_2}\\right)} 2^{(n-w_2)H \\left(\\frac{w_3 - \\lceil w_2/2 \\rceil}{n-w_2}\\right)}}{2^{nH \\left(\\frac{w_3}{n}\\right)} 2^{nH \\left(\\frac{w_3}{n}\\right)}}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\operatorname{poly}(n) \\cdot \\frac{2^{n/rH(\\alpha)} 2^{n(1-\\alpha)H \\left(\\frac{w_2 - \\lceil rw_1/2 \\rceil}{n(1-\\alpha)}\\right)} 2^{n\\alpha H \\left(\\frac{\\lceil rw_1/2 \\rceil}{rw_1}\\right)} 2^{n\\beta H \\left(\\frac{\\lceil w_2/2 \\rceil}{w_2}\\right)} 2^{n(1-\\beta)H \\left(\\frac{w_3 - \\lceil w_2/2 \\rceil}{n(1-\\beta)}\\right)}}{2^{nH(\\beta)} 2^{nH(\\rho)}}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\operatorname{poly}(n) \\cdot 2^{n \\left(\\frac{H(\\alpha)}{r} + (1-\\alpha)H \\left(\\frac{w_2 - \\lceil rw_1/2 \\rceil}{n(1-\\alpha)}\\right) + \\alpha H \\left(\\frac{\\lceil rw_1/2 \\rceil}{rw_1}\\right) + \\beta H \\left(\\frac{\\lceil w_2/2 \\rceil}{w_2}\\right) + (1-\\beta)H \\left(\\frac{w_3 - \\lceil w_2/2 \\rceil}{n(1-\\beta)}\\right) - H(\\beta) - H(\\rho)}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\operatorname{poly}(n) \\cdot 2^{n \\left(\\frac{H(\\alpha)}{r} + (1-\\alpha)H \\left(\\frac{\\beta - \\frac{\\alpha}{2}}{1-\\alpha}\\right) + \\alpha + \\beta + (1-\\beta)H \\left(\\frac{\\rho - \\frac{\\beta}{2}}{1-\\beta}\\right) - H(\\beta) - H(\\rho)}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\operatorname{poly}(n) \\cdot 2^{f(\\alpha,\\beta,\\rho)n} .</span>$</p>

    <p class="text-gray-300">where the inequality follows because we can upper-bound the second and third H containing a ceiling by H(1/2). The fact that we can remove the other two ceilings is somewhat harder to see. It is not to hard to see that for  <span class="math">\\delta &lt; 1/4</span>  we can remove these ceilings safely using the following lemma.</p>

    <p class="text-gray-300"><strong>Lemma 9.8.</strong> If x &lt; 1/2 then  <span class="math">\\frac{x - \\frac{y}{2}}{1 - y} &lt; 1/2</span>  for any  <span class="math">y \\in (0, 1)</span> .</p>

    <p class="text-gray-300"><span class="math">$Proof. \\ \\frac{x-\\frac{y}{2}}{1-y} &lt; 1/2 \\iff x-\\frac{y}{2} &lt; \\frac{1-y}{2} \\iff x &lt; \\frac{1}{2} \\ . \\ \\Box</span>$</p>

    <p class="text-gray-300">The two ceiling terms we wish to bound indeed have the form  <span class="math">\\frac{x-\\frac{y}{2}}{1-y} - \\epsilon</span>  denoted in the lemma, where in the first one  <span class="math">x = w_2</span>  and in the second one  <span class="math">x = w_3</span> . Thus it follows from the lemma that if  <span class="math">\\rho &lt; 1/2</span>  and  <span class="math">\\beta &lt; 1/2</span> , the small decrease from the ceiling only makes  <span class="math">H(\\frac{x-\\frac{y}{2}}{1-y} - \\epsilon)</span>  smaller, so that we can upper-bound by just removing the ceilings as we did above. However, note that to achieve  <span class="math">\\beta &lt; 1/2</span> , we need our assumption that  <span class="math">\\rho \\le \\delta &lt; 1/4</span> .</p>

    <p class="text-gray-300">In other words, if we are willing to 'settle' for a minimum distance of at most 1/4 then we are free to remove the ceilings at no extra cost. However, if we want to go to a higher minimum distance we can't just remove the ceilings. In these cases, we might be on the right-side of the binary entropy function, where a decrease by  <span class="math">\\epsilon</span>  may increase the output of h. In those cases, we need to bound potential increase caused by the ceiling. By carefully doing this, it turns out that as long as  <span class="math">\\delta &lt; 1/2</span>  we can still remove the ceilings with minor cost.</p>

    <p class="text-gray-300">Lemma 9.9.
<span class="math">$H(a - \\epsilon) \\le H(a) + \\epsilon \\cdot \\log\\left(\\frac{a}{1-a}\\right)</span>$
.</p>

    <p class="text-gray-300"><em>Proof.</em> Note that we can suppose that a &gt; 1/2, or more specifically that  <span class="math">a &gt; \\frac{1-\\epsilon}{2}</span> , as for any smaller value of a we already know that a decrease in  <span class="math">\\epsilon</span>  will decrease h. Let  <span class="math">P_a(x)</span>  be the first-order Taylor polynomial  <span class="math">P_a(x)</span>  of H at point a, and let R(x) be the amount by which the Taylor approximation is off, i.e.  <span class="math">H(x) = P_a(x) + R(x)</span> . We can then write</p>

    <p class="text-gray-300"><span class="math">$H(a - \\epsilon) - H(a) = P_a(a - \\epsilon) - P_a(a) + R(a - \\epsilon).</span>$</p>

    <p class="text-gray-300">The Taylor polynomial  <span class="math">P_a</span>  is of course equal to</p>

    <p class="text-gray-300"><span class="math">$P_a(x) := H(a) + \\frac{h&#x27;(a)}{1!}(x-a) = H(a) + \\log\\left(\\frac{1-a}{a}\\right)(x-a)</span>$
,</p>

    <p class="text-gray-300">and the error term is equal to</p>

    <p class="text-gray-300"><span class="math">$R(x) \\le \\frac{h&#x27;&#x27;(\\xi)}{2}(x-a)^2 = \\frac{(x-a)^2}{4\\ln(2)\\xi(\\xi-1)}</span>$</p>

    <p class="text-gray-300">for some  <span class="math">\\xi \\in (a - \\epsilon, a)</span> . Since  <span class="math">\\xi - 1 &lt; 0</span> , the denominator is always negative. Since the numerator is a square it is always positive. It follows that the error term is negative, so that we are free to ignore it. This means we end up with</p>

    <p class="text-gray-300"><span class="math">$H(a - \\epsilon) - H(a) = P_a(a - \\epsilon) - P_a(a) + R(a - \\epsilon)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq P_a(a - \\epsilon) - P_a(a)</span>$</p>

    <p class="text-gray-300"><span class="math">$= H(a) + \\log\\left(\\frac{1 - a}{a}\\right)((a - \\epsilon) - a) - H(a)</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\epsilon \\cdot \\log\\left(\\frac{a}{1 - a}\\right).</span>$</p>

    <p class="text-gray-300">In our case, the expression we want to bound is  <span class="math">H\\left(\\frac{w_3-\\lceil w_2/2\\rceil}{n(1-\\beta)}\\right)</span>  (and the analogous expression where  <span class="math">w_3</span>  becomes  <span class="math">w_2</span>  and  <span class="math">w_2</span>  becomes  <span class="math">rw_1</span> ). Again, in case  <span class="math">w_2</span>  is even this expression simplifies directly to  <span class="math">H\\left(\\frac{\\rho-\\frac{\\beta}{2}}{1-\\beta}\\right)</span> . However, when  <span class="math">w_2</span>  is odd we get</p>

    <p class="text-gray-300"><span class="math">$H\\left(\\frac{w_3 - \\lceil w_2/2 \\rceil}{n(1-\\beta)}\\right) = H\\left(\\frac{w_3 - \\frac{w_2+1}{2}}{n(1-\\beta)}\\right) = H\\left(\\frac{\\rho - \\frac{\\beta}{2}}{1-\\beta} - \\frac{1}{2n(1-\\beta)}\\right).</span>$</p>

    <p class="text-gray-300">We then apply the just-proven lemma with  <span class="math">a = \\frac{\\rho - \\frac{\\beta}{2}}{1-\\beta}</span>  and  <span class="math">\\epsilon = \\frac{1}{2n(1-\\beta)}</span>  to get</p>

    <p class="text-gray-300"><span class="math">$H(a - \\epsilon) - H(a) \\le \\epsilon \\log \\left(\\frac{a}{1 - a}\\right) = \\epsilon \\log \\left(\\frac{\\frac{\\rho - \\frac{\\beta}{2}}{1 - \\beta}}{1 - \\frac{\\rho - \\frac{\\beta}{2}}{1 - \\beta}}\\right) = \\epsilon \\log \\left(\\frac{\\rho - \\frac{\\beta}{2}}{1 - \\frac{\\beta}{2} - \\rho}\\right).</span>$</p>

    <p class="text-gray-300">We would like the above to be negative, as then the ceiling causes no increase at all. The above is negative whenever the fraction inside the log is at most 1, which is true exactly when</p>

    <p class="text-gray-300"><span class="math">$\\rho - \\beta/2 &lt; 1 - \\beta/2 - \\rho \\iff 2\\rho \\le 1 \\iff \\rho &lt; 1/2 \\ .</span>$</p>

    <p class="text-gray-300">In other words, for any  <span class="math">\\delta &lt; 1/2</span>  we can safely the ceilings without suffering any additional increase. Next, we tackle the  <span class="math">\\operatorname{poly}(n)</span> -factors in the above expression. We make use of the bound  <span class="math">\\frac{\\lceil rw_1/2\\rceil \\lceil w_2/2\\rceil}{w_2w_3} = \\frac{\\lceil rw_1/2\\rceil \\lceil w_2/2\\rceil}{w_3} \\frac{\\lceil w_2/2\\rceil}{w_2} \\le \\frac{\\lceil \\frac{4w_3}{2} \\rceil}{w_3} \\cdot \\frac{101}{100} \\le \\frac{102}{100}</span> . This is true because  <span class="math">rw_1 \\le 4w_3</span> , and as long as  <span class="math">w_2 \\ge 101</span>  as  <span class="math">w_2 \\ge n^\\gamma \\ge 101</span>  by assumption. We can then write the  <span class="math">\\operatorname{poly}(n)</span> -factors as follows (for some binomials we keep the  <span class="math">\\sqrt{\\frac{n}{k(n-k)}}</span> -factor from Lemma 9.4 to help us out, while for other binomials we don't bother, as it won't help us much):</p>

    <p class="text-gray-300"><span class="math">$\\begin{pmatrix} n/r \\\\ w_1 \\end{pmatrix} \\cdot \\frac{\\binom{rw_1}{\\lceil rw_1/2 \\rceil} \\binom{n-rw_1}{w_2-\\lceil rw_1/2 \\rceil}}{\\binom{n}{w_2}} \\cdot \\frac{\\binom{w_2}{\\lceil w_2/2 \\rceil} \\binom{n-w_2}{w_3-\\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{\\lceil rw_1/2 \\rceil \\cdot \\lceil w_2/2 \\rceil}{w_2w_3}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq 2^{f(\\alpha,\\beta,\\rho)n} \\cdot \\frac{102}{100} \\cdot \\frac{0.61664^3 \\cdot 0.43603^2}{0.33675 \\cdot 0.67352} \\cdot \\frac{\\sqrt{\\frac{rw_1}{\\lceil rw_1/2 \\rceil (rw_1-\\lceil rw_1/2 \\rceil)}} \\cdot \\sqrt{\\frac{w_2}{\\lceil w_2/2 \\rceil (w_2-\\lceil w_2/2 \\rceil)}}}{\\sqrt{\\frac{n}{w_2(n-w_2)}} \\cdot \\frac{1}{\\sqrt{n}}}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\frac{102}{100} \\cdot \\frac{0.61664^3 \\cdot 0.43603^2}{0.33675 \\cdot 0.67352} \\cdot 2^{f(\\alpha,\\beta,\\rho)n} \\cdot \\sqrt{\\frac{4}{rw_1}} \\cdot \\frac{4}{w_2} \\cdot \\frac{w_2(n-w_2)}{n} \\cdot n</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\frac{102}{100} \\cdot \\frac{4 \\cdot 0.61664^3 \\cdot 0.43603^2}{0.33675 \\cdot 0.67352} \\cdot \\frac{1}{\\sqrt{r}} \\cdot 2^{f(\\alpha,\\beta,\\rho)n} \\cdot \\sqrt{n-w_2}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\frac{0.80192}{\\sqrt{r}} \\cdot \\sqrt{n} \\cdot 2^{f(\\alpha,\\beta,\\rho)n} .</span>$</p>

    <p class="text-gray-300">Putting these two bounds together gives us the proposed bound (18) on the expectation:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\sum_{w_1=1}^{n/r} \\sum_{w_2=m+1}^n \\sum_{w_3=1}^d \\binom{n/r}{w_1} \\cdot \\frac{\\binom{rw_1}{\\lceil rw_1/2 \\rceil} \\binom{n-rw_1}{w_2-\\lceil rw_1/2 \\rceil}}{\\binom{n}{w_2}} \\cdot \\frac{\\binom{w_2}{\\lceil w_2/2 \\rceil} \\binom{n-w_2}{w_3-\\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{\\lceil rw_1/2 \\rceil \\cdot \\lceil w_2/2 \\rceil}{w_2w_3} \\\\ &amp;\\leq \\sum_{w_1=1}^{n/r} \\sum_{w_2=m+1}^n \\sum_{w_3=1}^d \\frac{0.80192}{\\sqrt{r}} \\cdot \\sqrt{n} \\cdot 2^{f\\left(\\frac{rw_1}{n}, \\frac{w_2}{n}, \\frac{w_3}{n}\\right)n} \\\\ &amp;\\leq \\frac{0.80192 \\cdot \\delta}{\\sqrt{r}} \\cdot n^{3/2} \\sum_{w_1=1}^{n/r} \\sum_{w_2=m+1}^n 2^{f\\left(\\frac{rw_1}{n}, \\frac{w_2}{n}, \\delta\\right)n} \\\\ &amp;\\leq \\frac{0.80192 \\cdot \\delta}{r^{3/2}} \\cdot n^{7/2} \\cdot \\max_{(\\alpha,\\beta) \\in \\mathcal{R}&#x27;} 2^{f(\\alpha,\\beta,\\delta)n} \\; . \\end{split}</span>$</p>

    <p class="text-gray-300">Note that the second inequality uses the fact that f grows monotonically with  <span class="math">\\rho</span>  for  <span class="math">\\rho &lt; 1/2</span> , which we prove below.</p>

    <p class="text-gray-300">Claim 9.9.1. For fixed admissible &alpha;, &beta;, the function f is growing with &rho;.</p>

    <p class="text-gray-300">Proof. We show that the derivative of f with respect to &rho; is positive when &rho; &lt; 0.5:</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\partial f}{\\partial \\rho} = \\log \\left( \\frac{1 - \\rho - \\beta/2}{\\rho - \\beta/2} \\right) - \\log \\left( \\frac{1 - \\rho}{\\rho} \\right) &gt; 0</span>$</p>

    <p class="text-gray-300"><span class="math">$\\iff \\frac{1 - \\rho - \\beta/2}{\\rho - \\beta/2} &gt; \\frac{1 - \\rho}{\\rho}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\iff \\rho (1 - \\rho - \\beta/2) &gt; (1 - \\rho)(\\rho - \\beta/2)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\iff \\rho - \\rho^2 - \\rho\\beta/2 &gt; \\rho - \\rho^2 - \\beta/2 + \\rho\\beta/2</span>$</p>

    <p class="text-gray-300"><span class="math">$\\iff \\beta/2 &gt; \\rho\\beta</span>$</p>

    <p class="text-gray-300"><span class="math">$\\iff 0.5 &gt; \\rho.</span>$</p>

    <p class="text-gray-300">Having established the bound, we turn to the maximisation of f over &alpha;, &beta;, where we recall the constraints n <sup>&gamma;</sup>&minus;<sup>1</sup> &le; &beta; &le; 2&delta; and r/n &le; &alpha; &le; 2&beta;. We visualised this region R&prime; of permissible points (&alpha;, &beta;) in Figure <a href="#page-53-1">6.</a> This is a compact space, and since f is continuous it is maximized either by a critical point or some point on the boundary. As explained above, <a href="#page-81-10">[KZKJ08]</a> computed the partial derivatives of f with respect to &alpha; and &beta;, and provide us equations satisfied by the critical points:</p>

    <p class="text-gray-300">
<span class="math">$\\frac{\\partial f}{\\partial \\alpha} = 0 \\iff \\beta = \\frac{1}{2} \\pm \\frac{1 - \\alpha}{2} \\sqrt{1 - \\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{2/r}} \\tag{19}</span>$</p>

    <p class="text-gray-300">where the root using &minus; yields &beta; &lt; 1/2 and the root using + yields &beta; &gt; 1/2, and</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\partial f}{\\partial \\beta} = 0 \\iff \\delta = \\frac{1}{2} \\pm \\frac{1 - \\beta}{2} \\sqrt{1 - \\left(\\frac{1 - \\beta}{\\beta} \\cdot \\frac{\\beta - \\alpha/2}{1 - \\beta - \\alpha/2}\\right)^2} , \\tag{20}</span>$</p>

    <p class="text-gray-300">where again the root using &minus; yields &delta; &lt; 1/2 and the root using + yields &delta; &gt; 1/2.<a href="#page-58-2">29</a> Given a target minimum distance &delta; and a rate 1/r, one can solve the above system of equations to find the set of critical points CP(r, &delta;). The maximal value of f on these critical points can then be computed.</p>

    <p class="text-gray-300">It remains to deal with potential maximizers on the boundary of our region R&prime; . As explained, we will argue that the only boundary point that can maximize f is the left-bottom-most point (&alpha;0, &beta;0). To show this, we argue that f restricted to only &alpha; or only &beta; (visually, a horizontal or vertical &quot;slice&quot; of the region, recall <a href="#page-53-1">Figure 6)</a> is strictly concave. Equation <a href="#page-58-0">(19)</a> then gives the critical points for f restricted to &alpha; and <a href="#page-58-1">(20)</a> then gives the critical points for f restricted to &beta;. We then argue about the location of the critical points for the univariate restrictions, which allow us to conclude that by moving away from boundary points other than (&alpha;0, &beta;0) we can increase f's value.</p>

    <p class="text-gray-300">Lemma 9.10. Let f&beta;,&delta;(&alpha;) := f(&alpha;, &beta;, &delta;) be the restriction of f to &alpha;. For all &delta; &isin; (0, 1) and &beta; &isin; (0, min{2 &minus; 2&delta;, 2&delta;}), this function is strictly concave on its interval &alpha; &isin; (0, min{2&beta;, 2 &minus; 2&beta;}).</p>

    <p class="text-gray-300"><sup>29</sup>Since our codes can't achieve &delta; &ge; 1/2 it may seem we only need the root where &delta; &lt; 1/2. However, when we puncture these codes in a later section, we will need to bound the probability that a codeword of weight &gt; &delta;n is punctured down to small weight. In particular, we will need to talk about relative weights &delta; &gt; 1/2, and we will need this second root.</p>

    <p class="text-gray-300"><em>Proof.</em> It suffices to show that the second derivative of  <span class="math">f_{\\beta,\\delta}(\\alpha)</span>  for  <span class="math">\\alpha,\\beta,\\delta</span>  in the ranges given above is negative. The first derivative is</p>

    <p class="text-gray-300"><span class="math">$f&#x27;_{\\beta,\\delta}(\\alpha) = 1 + \\frac{1}{r} \\log \\left( \\frac{1-\\alpha}{\\alpha} \\right) + \\frac{1}{2} \\log \\left( \\frac{(1-\\beta-\\alpha/2)(\\beta-\\alpha/2)}{(1-\\alpha)^2} \\right),</span>$</p>

    <p class="text-gray-300">and therefore</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} f_{\\beta,\\delta}&#x27;&#x27;(\\alpha) &amp;= \\frac{1}{\\ln(2)} \\left( \\frac{1}{r} \\frac{\\alpha}{1-\\alpha} \\frac{-\\alpha - (1-\\alpha)}{\\alpha^2} + \\frac{1}{2} \\left( -\\frac{1/2}{1-\\beta - \\alpha/2} - \\frac{1/2}{\\beta - \\alpha/2} - \\frac{2}{1-\\alpha} \\right) \\right) \\\\ &amp;= \\frac{1}{\\ln(2)} \\left( -\\frac{1}{r \\cdot \\alpha(1-\\alpha)} - \\frac{1}{4(1-\\beta - \\alpha/2)} - \\frac{1}{4(\\beta - \\alpha/2)} - \\frac{1}{1-\\alpha} \\right) \\; . \\end{split}</span>$</p>

    <p class="text-gray-300">To see that the above is negative, note that the first and fourth terms inside the brackets are clearly negative, as their denominators can't be positive (since  <span class="math">0 &lt; \\alpha &lt; 1</span> ). That the second term is negative follows from  <span class="math">\\alpha &lt; 2 - 2\\beta</span>  and that the third term is negative follows from  <span class="math">\\alpha &lt; 2\\beta</span> .</p>

    <p class="text-gray-300"><strong>Lemma 9.11.</strong> Let  <span class="math">f_{\\alpha,\\delta}(\\beta) := f(\\alpha,\\beta,\\delta)</span>  be the restriction of f to  <span class="math">\\beta</span> . For all  <span class="math">\\delta \\in (0,1)</span>  and  <span class="math">\\alpha \\in (0,1)</span> , this function is strictly concave on its interval  <span class="math">\\beta \\in (\\alpha/2, \\min\\{2\\delta, 2-2\\delta, 1-\\alpha/2\\})</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> It suffices to show that the second derivative of  <span class="math">f_{\\alpha,\\delta}(\\beta)</span>  for  <span class="math">\\alpha,\\beta,\\delta</span>  in the ranges given above is negative. The first derivative is</p>

    <p class="text-gray-300"><span class="math">$f_{\\alpha,\\delta}(\\beta)&#x27; = \\frac{1}{\\ln(2)} \\log \\left( \\frac{\\beta(1-\\beta-\\alpha/2)\\sqrt{4(\\delta-\\beta/2)(1-\\delta-\\beta/2)}}{(1-\\beta)^2(\\beta-\\alpha/2)} \\right)</span>$</p>

    <p class="text-gray-300">Call the numerator  <span class="math">s(\\beta)</span> , the denominator  <span class="math">t(\\beta)</span> . Then we can write the second derivative as</p>

    <p class="text-gray-300"><span class="math">$f_{\\alpha,\\delta}(\\beta)&#x27;&#x27; = \\frac{s&#x27;(\\beta)t(\\beta) - s(\\beta)t&#x27;(\\beta)}{s(\\beta)t(\\beta)}.</span>$</p>

    <p class="text-gray-300">It is not hard to see that the denominator  <span class="math">s(\\beta)t(\\beta) &gt; 0</span> , as it is a product of terms that are all positive. To show that the second derivative is negative, it therefore suffices to show that the numerator is negative. For simpler notation, let  <span class="math">x := \\sqrt{4(\\delta - \\beta/2)(1 - \\delta - \\beta/2)}</span> . We can then write</p>

    <p class="text-gray-300"><span class="math">$t&#x27;(\\beta) = 2(1-\\beta)(-1)(\\beta - \\alpha/2) + (1-\\beta)^2,</span>$</p>

    <p class="text-gray-300">so that</p>

    <p class="text-gray-300"><span class="math">$-s(\\beta)t&#x27;(\\beta) = 2\\overbrace{\\beta(1-\\beta-\\alpha/2)x(1-\\beta)(\\beta-\\alpha/2)}^{a} - \\overbrace{\\beta(1-\\beta-\\alpha/2)x(1-\\beta)^{2}}^{b}.</span>$</p>

    <p class="text-gray-300">Similarly we get</p>

    <p class="text-gray-300"><span class="math">$s&#x27;(\\beta) = (1 - \\beta - \\alpha/2)x - \\beta x - \\beta(1 - \\beta - \\alpha/2)(1 - \\beta)/x.</span>$</p>

    <p class="text-gray-300">so that</p>

    <p class="text-gray-300"><span class="math">$s&#x27;(\\beta)t(\\beta) = \\underbrace{(1-\\beta)^{2}(\\beta - \\alpha/2)(1-\\beta - \\alpha/2)x}_{e} - \\underbrace{(1-\\beta)^{3}(\\beta - \\alpha/2)\\beta(1-\\beta - \\alpha/2)/x}_{e} .</span>$</p>

    <p class="text-gray-300">    <img src="_page_60_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Figure 7: The region  <span class="math">\\mathcal{R}&#x27;</span>  that we optimize the function f over (for  <span class="math">1/4 &lt; \\delta &lt; 1/2</span> ). As opposed to the regions shown earlier for  <span class="math">\\delta &lt; 1/4</span> , there is a new boundary (d). The blue curve, representing the values for which  <span class="math">\\frac{\\partial f}{\\partial \\alpha} = 0</span> , crosses the boundary (a) at some point  <span class="math">\\beta_1 \\geq \\beta_0</span> .</p>

    <p class="text-gray-300">Thus, to show that the numerator is negative, we need to show that c-d-e+2a-b is negative. We show that this is the case by noting that  <span class="math">d&gt;a,\\ e&gt;a</span>  and  <span class="math">b\\geq c</span> :</p>

    <p class="text-gray-300"><span class="math">$b = \\beta(1 - \\beta - \\alpha/2)x(1 - \\beta)^{2} &gt; (\\beta - \\alpha/2)(1 - \\beta - \\alpha/2)x(1 - \\beta)^{2} = c</span>$</p>

    <p class="text-gray-300"><span class="math">$d = (1 - \\beta)^{2}(\\beta - \\alpha/2)\\beta x &gt; (1 - \\beta)(1 - \\beta - \\alpha/2)(\\beta - \\alpha/2)\\beta x = a</span>$</p>

    <p class="text-gray-300"><span class="math">$e = (1 - \\beta)^{3}(\\beta - \\alpha/2)\\beta(1 - \\beta - \\alpha/2)/x \\ge (1 - \\beta)(\\beta - \\alpha/2)\\beta(1 - \\beta - \\alpha/2)x = a</span>$
.</p>

    <p class="text-gray-300">where the final inequality follows from  <span class="math">\\frac{(1-\\beta)^2}{x} \\ge x</span>  which is the same as</p>

    <p class="text-gray-300"><span class="math">$(1-\\beta)^2 = \\beta^2 - 2\\beta + 1 \\ge x^2 = 4(\\delta - \\beta/2)(1 - \\delta - \\beta/2) = \\beta^2 - 2\\beta + 4\\delta(1 - \\delta) \\iff 4\\delta(1 - \\delta) \\le 1</span>$
which holds for any  <span class="math">\\delta \\in (0, 1)</span> .</p>

    <p class="text-gray-300">We now consider boundaries in turn, and argue in each case that they do not yield a maximizer for f. We review the region  <span class="math">\\mathcal{R}&#x27;</span>  and its boundaries in Figure 7.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(b)  <span class="math">2\\beta_0 \\leq \\alpha \\leq \\min\\{4\\delta, 1\\}</span>  and  <span class="math">\\beta = \\alpha/2</span> . Fix some  <span class="math">\\beta</span>  and suppose that the corresponding boundary point  <span class="math">(2\\beta, \\beta)</span>  is a maximizer for f. Consider the horizontal slice  <span class="math">f_{\\beta,\\rho}(\\alpha)</span>  containing this boundary point. Recall that this function is concave over all  <span class="math">\\alpha</span>  in its domain and has a critical point satisfying (19):  <span class="math">\\beta = \\frac{1}{2} \\frac{1-\\alpha}{2}x</span>  where x &lt; 1 (recall that  <span class="math">\\beta &lt; 1/2</span> ). This means that a critical point must satisfy  <span class="math">\\beta &gt; \\frac{1}{2} \\frac{1-\\alpha}{2}</span> , or equivalently, the critical point occurs at  <span class="math">\\alpha &lt; 2\\beta</span> . But our boundary point had  <span class="math">\\alpha = 2\\beta</span> . By concavity this implies that  <span class="math">f_{\\beta,\\rho}</span>  will grow as we move to the left of our boundary point, contradicting our assumption that the boundary point is the maximizer.</li>
      <li>(d)  <span class="math">2-4\\delta \\le \\alpha \\le 1</span> ,  <span class="math">\\beta = 1-\\alpha/2</span> . Fix some  <span class="math">\\beta</span>  and suppose that the corresponding boundary point  <span class="math">(2-2\\beta,\\beta)</span>  is a maximizer for f. Consider again the horizontal slice  <span class="math">f_{\\beta,\\rho}(\\alpha)</span>  containing this</li>
    </ul>

    <p class="text-gray-300">boundary point, which now has a critical point satisfying  <span class="math">\\beta = \\frac{1}{2} + \\frac{1-\\alpha}{2}x</span>  where x &lt; 1 (note that  <span class="math">\\beta &gt; 1/2</span> ). This means that a critical point must satisfy  <span class="math">\\beta &lt; \\frac{1}{2} + \\frac{1-\\alpha}{2}</span> , or equivalently, the critical point occurs at  <span class="math">\\alpha &lt; 2 - 2\\beta</span> . But our boundary point had  <span class="math">\\alpha = 2 - 2\\beta</span> . By concavity this implies that  <span class="math">f_{\\beta,\\rho}</span>  will grow as we move to the left of our boundary point, contradicting our assumption that the boundary point is a maximizer.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(c)  <span class="math">\\alpha_0 \\leq \\alpha \\leq \\min\\{4\\delta, 2-4\\delta\\}</span> ,  <span class="math">\\beta = 2\\delta</span> . Fix some  <span class="math">\\alpha</span>  and suppose that the corresponding boundary point  <span class="math">(\\alpha, 2\\delta)</span>  is a maximizer. Consider now the vertical slice  <span class="math">f_{\\alpha,\\rho}(\\beta)</span>  containing this boundary point, which has a critical point satisfying (20):  <span class="math">\\delta = \\frac{1}{2} \\frac{1-\\beta}{2}x</span>  where x &lt; 1 (note that  <span class="math">\\delta &lt; 1/2</span> ). This means that a critical point must satisfy  <span class="math">\\delta &gt; \\frac{1}{2} \\frac{1-\\beta}{2}</span> , or equivalently, the critical point occurs at  <span class="math">\\beta &lt; 2\\delta</span> . By concavity this implies that  <span class="math">f_{\\alpha,\\rho}</span>  will grow as we move to the bottom of our boundary point, contradicting our assumption that the boundary point is the maximizer.</li>
      <li>(a) At first, we only consider the top portion of this boundary:  <span class="math">\\alpha = \\alpha_0</span> ,  <span class="math">\\beta_1 &lt; \\beta \\le 2\\delta</span> . Recall that we had defined  <span class="math">\\beta_1</span>  in the statement of the theorem. We now claim that the points where the derivative of f to  <span class="math">\\alpha</span>  is 0 (i.e. the critical points of each  <span class="math">f_{\\beta,\\rho}(\\alpha)</span> ) crosses through boundary (a) exactly at  <span class="math">\\beta_1</span> . Recall that these critical points are described by (19). We therefore enter  <span class="math">\\alpha_0 = r/n</span>  into this equation, and note that this recovers  <span class="math">\\beta_1</span> :</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\beta_1 = \\frac{1}{2} - \\frac{1 - r/n}{2} \\sqrt{1 - \\left(\\frac{r/n}{1 - r/n}\\right)^{2/r}}</span>$
.</p>

    <p class="text-gray-300">Recall we assumed  <span class="math">\\beta_1 &gt; \\beta_0</span> , so we conclude that the curve defined by (19) will indeed cross through the boundary (a).</p>

    <p class="text-gray-300">Thus, for  <span class="math">\\beta &gt; \\beta_1</span>  we can assume that the critical points of each horizontal slice lie strictly inside the region  <span class="math">\\mathcal{R}&#x27;</span> , so that an argument analogous to the ones above establishes that this top part of boundary (a) can't contain maximizers.</p>

    <p class="text-gray-300">So, if there is a maximizer on the boundary of  <span class="math">\\mathcal{R}&#x27;</span> , then it must have a  <span class="math">\\beta</span>  value at most  <span class="math">\\beta_1</span> . That is, the only maximizers on the boundary lie in the compact region  <span class="math">\\mathcal{R}&#x27;&#x27; := \\mathcal{R}&#x27; \\cap \\{(\\alpha, \\beta) : \\beta \\leq \\beta_1\\}</span> . We argue that the maximum value for f over the region  <span class="math">\\mathcal{R}&#x27;&#x27;</span>  is necessarily  <span class="math">f(\\alpha_0, \\beta_0)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>First, suppose  <span class="math">(\\alpha, \\beta) \\in \\mathcal{R}&#x27;&#x27;</span>  with  <span class="math">\\alpha &gt; \\alpha_0</span> . Suppose that  <span class="math">(\\alpha, \\beta)</span>  is a maximizer for f over  <span class="math">\\mathcal{R}&#x27;&#x27;</span> . Consider the horizontal slice  <span class="math">f_{\\beta,\\delta}</span> , and recall that it is concave for  <span class="math">0 &lt; \\alpha \\le 2\\beta</span>  and has a critical point described by (19). As shown just above, for  <span class="math">\\beta &lt; \\beta_1</span> , these critical points occur at  <span class="math">\\alpha &lt; \\alpha_0</span> , so that this holds in particular for our function  <span class="math">f_{\\beta,\\rho}</span> . But then moving  <span class="math">(\\alpha,\\beta)</span>  to the left will increase f, contradicting our assumption that this point is the maximizer of f over  <span class="math">\\mathcal{R}&#x27;&#x27;</span> .</li>
      <li>Lastly, suppose  <span class="math">(\\alpha_0, \\beta) \\in \\mathcal{R}&#x27;&#x27;</span>  with  <span class="math">\\beta &gt; \\beta_0</span>  is a maximizer for f over  <span class="math">\\mathcal{R}&#x27;&#x27;</span> . Consider the vertical slice  <span class="math">f_{\\alpha,\\delta}</span>  containing this point. We claim that this function is decreasing with  <span class="math">\\beta</span>  in this region, i.e. for  <span class="math">\\beta_0 \\leq \\beta \\leq \\beta_1</span> . It follows that moving  <span class="math">(\\alpha, \\beta)</span>  down will increase f, contradicting our assumption that this point is a maximizer for f over  <span class="math">\\mathcal{R}&#x27;&#x27;</span> .</li>
    </ul>

    <p class="text-gray-300">To see that f&alpha;0,&delta;(&beta;) is decreasing for &beta; &le; &beta;1, we compute its derivative</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} f&#x27;_{r/n,\\delta}(\\beta) &amp;= 1 + \\log\\left(\\frac{\\beta}{1-\\beta}\\right) + \\log\\left(\\frac{1-\\beta-\\alpha_0/2}{\\beta-\\alpha_0/2}\\right) + \\frac{1}{2}\\log\\left(\\frac{(\\delta-\\beta/2)(1-\\delta-\\beta/2)}{(1-\\beta)^2}\\right) \\\\ &amp;= \\log\\left(\\frac{2\\beta(1-\\beta-\\alpha_0)\\sqrt{(\\delta-\\beta/2)(1-\\delta-\\beta/2)}}{(1-\\beta)^2(\\beta-\\alpha_0/2)}\\right) \\;, \\end{split}</span>$</p>

    <p class="text-gray-300">which is &lt; 0 if and only if</p>

    <p class="text-gray-300"><span class="math">$2\\beta(1-\\beta-\\alpha_0)\\sqrt{(\\delta-\\beta/2)(1-\\delta-\\beta/2)} &lt; (1-\\beta)^2(\\beta-\\alpha_0/2)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\iff \\sqrt{4(\\delta-\\beta/2)(1-\\delta-\\beta/2)} &lt; \\frac{(1-\\beta)^2(\\beta-\\alpha_0/2)}{\\beta(1-\\beta-\\alpha_0)},</span>$</p>

    <p class="text-gray-300">where we note that the LHS is at most p 4&delta;(1 &minus; &delta;) which itself is &lt; 1 since &delta; &lt; 1/2. It therefore suffices to show that the RHS is very close to 1:</p>

    <p class="text-gray-300"><span class="math">$\\frac{(1-\\beta)^2(\\beta-\\alpha_0/2)}{\\beta(1-\\beta-\\alpha_0)} &gt; \\frac{(1-\\beta)^2(\\beta-\\alpha_0/2)}{\\beta} &gt; (1-2\\beta)(1-\\frac{\\alpha_0}{2\\beta})</span>$
<span class="math">$&gt; 1-2\\beta-\\frac{\\alpha_0}{2\\beta} &gt; 1-2\\beta_1-\\frac{\\alpha_0}{2\\beta_0} \\ .</span>$</p>

    <p class="text-gray-300">By assumption p 4&delta;(1 &minus; &delta;) &lt; 1 &minus; 2&beta;<sup>1</sup> &minus; &alpha;<sup>0</sup> 2&beta;<sup>0</sup> , so we indeed find that the derivative is negative.</p>

    <p class="text-gray-300">To conclude, we have established that f is maximized either by a critical point in CP(r, &delta;) or by the point (&alpha;0, &beta;0). Finally, we will establish that f(&alpha;0, &beta;0, &delta;) = &minus;&Theta;(&beta;0) = &minus;&Theta;(n &gamma;&minus;1 ). This implies that if max{f(&alpha;, &beta;) : (&alpha;, &beta;) &isin; CP(r, &delta;)} &lt; 0 for sufficiently large n we will have f(&alpha;0, &beta;0, &delta;) &gt; max{f(&alpha;, &beta;, &delta;) : (&alpha;, &beta;) &isin; CP(r, &delta;)}: if the right-hand side is negative, as it is independent of n, it is a negative constant, so f(&alpha;0, &beta;0, &delta;) (which tends to 0 as n grows) will be larger for large enough n.</p>

    <p class="text-gray-300">Firstly, we have</p>

    <p class="text-gray-300"><span class="math">$\\frac{1}{r}H(\\alpha_0) = \\frac{1}{r}H(r/n) \\le \\frac{(1+o(1))}{n}\\log(n/r) .</span>$</p>

    <p class="text-gray-300">Next, we consider</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\alpha_0 + (1 - \\alpha_0) H \\left( \\frac{\\beta_0 - \\alpha_0/2}{1 - \\alpha_0} \\right) - H(\\beta_0) \\\\ &amp;= \\alpha_0 + (\\beta_0 - \\alpha_0/2) \\log \\left( \\frac{1 - \\alpha_0}{\\beta_0 - \\alpha_0/2} \\right) + (1 - \\beta_0 - \\alpha_0/2) \\log \\left( \\frac{1 - \\alpha_0}{1 - \\beta_0 - \\alpha_0/2} \\right) \\\\ &amp;- \\beta_0 \\log \\frac{1}{\\beta_0} - (1 - \\beta_0) \\log \\frac{1}{1 - \\beta_0} \\\\ &amp;= \\alpha_0 + \\beta_0 \\log \\left( \\frac{(1 - \\alpha_0)\\beta_0}{\\beta_0 - \\alpha_0} \\right) + (1 - \\beta_0) \\log \\left( \\frac{(1 - \\alpha_0)(1 - \\beta_0)}{1 - \\beta_0 - \\alpha_0/2} \\right) \\\\ &amp;+ \\frac{\\alpha_0}{2} \\log \\left( \\frac{\\beta_0 - \\alpha_0/2}{1 - \\alpha_0} \\right) + \\frac{\\alpha_0}{2} \\log \\left( \\frac{1 - \\beta_0 - \\alpha_0/2}{1 - \\alpha_0} \\right) \\\\ &amp;= \\beta_0 \\log \\left( \\frac{1 - \\alpha_0}{1 - \\alpha_0/(2\\beta_0)} \\right) + (1 - \\beta_0) \\log \\left( \\frac{1 - \\alpha_0}{1 - \\alpha_0/(2(1 - \\beta_0))} \\right) \\\\ &amp;+ \\alpha_0 \\log \\left( \\frac{\\sqrt{4(\\beta_0 - \\alpha_0/2)(1 - \\beta_0 - \\alpha_0/2)}}{1 - \\alpha_0} \\right) \\,. \\end{split}</span>$</p>

    <p class="text-gray-300">Now, we first observe that</p>

    <p class="text-gray-300"><span class="math">$\\beta_0 \\log \\left( \\frac{1 - \\alpha_0}{1 - \\alpha_0 / (2\\beta_0)} \\right) + (1 - \\beta_0) \\log \\left( \\frac{1 - \\alpha_0}{1 - \\alpha_0 / (2(1 - \\beta_0))} \\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\beta_0 \\log(1 - \\alpha_0) + (1 - \\beta_0) \\log(1 - \\alpha_0)</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\log(1 - \\alpha_0) \\leq -\\frac{\\alpha_0}{\\ln 2}.</span>$</p>

    <p class="text-gray-300">Next, we claim that</p>

    <p class="text-gray-300"><span class="math">$\\log \\left( \\frac{\\sqrt{4(\\beta_0 - \\alpha_0/2)(1 - \\beta_0 - \\alpha_0/2)}}{1 - \\alpha_0} \\right) \\le 0 ,</span>$</p>

    <p class="text-gray-300">which is of course equivalent to</p>

    <p class="text-gray-300">
<span class="math">$\\frac{\\sqrt{4(\\beta_0 - \\alpha_0/2)(1 - \\beta_0 - \\alpha_0/2)}}{1 - \\alpha_0} \\le 1 . \\tag{21}</span>$</p>

    <p class="text-gray-300">And indeed, this holds as (1 &minus; &alpha;0) <sup>2</sup> = 1 &minus; 2&alpha;<sup>0</sup> + &alpha; 2 <sup>0</sup> while</p>

    <p class="text-gray-300"><span class="math">$4(\\beta_0 - \\alpha_0/2)(1 - \\beta_0 - \\alpha_0/2) = 4\\beta_0(1 - \\beta_0) - 2\\beta_0\\alpha_0 - 2(1 - \\beta_0)\\alpha_0 + \\alpha_0^2</span>$
<span class="math">$= 4(\\beta_0 - \\alpha_0/2) - 2\\alpha_0 + \\alpha_0^2,</span>$</p>

    <p class="text-gray-300"><a href="#page-63-0">(21)</a> follows from the fact that 4&beta;0(1&minus;&beta;0) &le; 1, which itself follows from the fact that 0 &le; &beta;<sup>0</sup> &le; 1/2. Hence, putting these bounds together, we find that</p>

    <p class="text-gray-300"><span class="math">$\\alpha_0 + (1 - \\alpha_0)H\\left(\\frac{\\beta_0 - \\alpha_0/2}{1 - \\alpha_0}\\right) - H(\\beta_0) \\le -\\frac{\\alpha_0}{\\ln 2}.</span>$</p>

    <p class="text-gray-300">Completely analogously, as still 4&delta;(1 &minus; &delta;) &lt; 1 we can derive that</p>

    <p class="text-gray-300"><span class="math">$\\beta_0 + (1 - \\beta_0) H\\left(\\frac{\\delta - \\beta_0/2}{1 - \\beta_0}\\right) - H(\\delta) \\le -\\frac{\\beta_0}{\\ln 2}</span>$
.</p>

    <p class="text-gray-300">Thus,</p>

    <p class="text-gray-300"><span class="math">$f(\\alpha_0, \\beta_0, \\delta) \\le \\frac{1 + o(1)}{n} \\log(n/r) - \\frac{\\alpha_0}{\\ln 2} - \\frac{\\beta_0}{\\ln 2}</span>$
.</p>

    <p class="text-gray-300">Since &beta;<sup>0</sup> = &Theta;(n &gamma;&minus;1 ) while &alpha;<sup>0</sup> = &Theta;(n &minus;1 ), we conclude that</p>

    <p class="text-gray-300"><span class="math">$f(\\alpha_0, \\beta_0, \\delta) = -\\Theta(n^{\\gamma - 1})</span>$
.</p>

    <p class="text-gray-300">Thus, we derive the claimed asymptotic bound of</p>

    <p class="text-gray-300"><span class="math">$O(n^{7/2}) \\cdot 2^{f(\\alpha_0, \\beta_0, \\delta)n} \\le 2^{-\\Omega(n^{\\gamma})}</span>$
.</p>

    <p class="text-gray-300">By combining <a href="#page-44-2">Proposition 9.5</a> and <a href="#page-54-1">Proposition 9.6,</a> we obtain our target <a href="#page-41-1">Theorem 9.1.</a></p>

      <h3 id="sec-9.4" class="text-xl font-semibold mt-8">9.4 Conditioning on Low Weight Messages Having Good First Stage</h3>

    <p class="text-gray-300">So far, we have offered a bound on the expected number of low-weight codewords, which via Markov's inequality can be translated into a bound on the probability that an RAA code fails to have good distance. We can thereby conclude that, say, a random RAA code with block length  <span class="math">n=2^{23}</span>  of rate 1/4 will have minimum distance about 0.19, except with probability about  <span class="math">2^{-12}</span> . As mentioned in the introduction, we consider a generation procedure for RAA codes that runs certain tests and, conditioned on the tests passing, we show that the failure probability provably decreases.</p>

    <p class="text-gray-300">Looking at the expectation in (6), we note that a large contribution comes from weight 1 messages. Even the individual case  <span class="math">w_1 = 1</span>  and  <span class="math">w_2 = 2</span> , which we separated out into (10), contributes  <span class="math">\\Omega(1/n)</span>  to the expectation, limiting the overall error probability to be at best inverse linear. This motivates us to test low weight messages, and ensure that they all have sufficiently high weight encodings (i.e., of weight at least  <span class="math">d = \\delta n</span> ). If we test all nonzero messages of weight at most w, the test takes time  <span class="math">O(n^{w+1})</span>  (recall every message vector can be encoded in linear time).</p>

    <p class="text-gray-300">We can show that this test almost always passes, and that conditioned on it passing, the error probability for rate 1/4 improves from roughly inverse linear to roughly  <span class="math">1/n^w</span> . To back this up, define the event  <span class="math">E_{\\leq w}</span>  to be the event that some nonzero message of a weight  <span class="math">\\leq w</span>  is encoded by the RAA code into a codeword of weight  <span class="math">\\leq d</span> . Similarly, let  <span class="math">E_{&gt;w}</span>  denote the event that some nonzero message of weight &gt; w has encoding of weight  <span class="math">\\leq d</span> . Then, if E is the event that the RAA code has minimum distance  <span class="math">\\leq \\delta</span> , we have</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[E|\\neg E_{\\leq w}\\right] = \\frac{\\Pr[E \\land \\neg E_{\\leq w}]}{\\Pr[\\neg E_{\\leq w}]} = \\frac{\\Pr[E_{&gt;w}]}{\\Pr[\\neg E_{\\leq w}]}.</span>$
(22)</p>

    <p class="text-gray-300">Below (see Proposition 9.12) we show roughly that  <span class="math">\\Pr[E_{&gt;w}] = O(n^{-(w+1)(\\frac{r}{2}-1)+\\gamma})</span>  (assuming the targeted minimum distance  <span class="math">\\delta</span>  is not too large). As  <span class="math">\\Pr[\\neg E_{\\leq w}]</span>  is very small (definitely  <span class="math">\\leq 1/2</span> , see Proposition 9.13), we essentially boost the failure probability from  <span class="math">O(n^{-\\frac{r}{2}+1+\\gamma})</span>  to  <span class="math">O(n^{-(w+1)(\\frac{r}{2}-1)+\\gamma})</span>  (i.e., ignoring  <span class="math">\\gamma \\in (0,1)</span> , the exponent is multiplied by w+1). Thus, the generation procedure without tests is analogous to the setting of w=0.</p>

    <p class="text-gray-300">We actually consider the following faster test: for nonzero messages of weight at most w-1 we still check if they have encodings of weight at least d, but for messages of weight exactly w we only check if their weight after the first accumulation round is at least  <span class="math">n^{\\kappa}</span> , where  <span class="math">\\kappa \\in (0,1)</span>  is again a tunable parameter. For w = O(1) checking the weight of the vector after one round of accumulation requires only  <span class="math">O(\\log k)</span>  time: if its support after permuting is  <span class="math">\\{i_1, i_2, \\ldots, i_{wr}\\}</span> , after reordering the support  <span class="math">j_1 &lt; j_2 &lt; \\cdots &lt; j_{wr}</span>  we can compute the weight of the accumulated vector as  <span class="math">(j_2 - j_1) + (j_4 - j_3) + \\cdots + (j_{wr} - j_{wr-1})</span> . This test can then be implemented in  <span class="math">\\tilde{O}(k^w)</span>  time, and moreover conditioning on this faster test passing the probability decreases almost as much as if we had conditioned on the slower  <span class="math">O(k^{w+1})</span> -time test passing.</p>

    <p class="text-gray-300">Concretely, let  <span class="math">\\tilde{E}_{\\leq w}</span>  denote the event that some nonzero message of weight at most w-1 has an RAA encoding of weight at most d or that some message of weight w has weight at most  <span class="math">n^{\\kappa}</span>  after one round of accumulation. With E,  <span class="math">E_{\\leq w}</span>  and  <span class="math">E_{&gt;w}</span>  as before, we find</p>

    <p class="text-gray-300">
<span class="math">$\\Pr[E|\\neg \\tilde{E}_{\\leq w}] = \\frac{\\Pr[E \\wedge \\neg \\tilde{E}_{\\leq w}]}{\\Pr[\\neg \\tilde{E}_{\\leq w}]}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\frac{\\Pr[E \\wedge \\neg \\tilde{E}_{\\leq w} \\wedge \\neg E_{\\leq w}]}{\\Pr[\\neg \\tilde{E}_{\\leq w}]} + \\frac{\\Pr[E \\wedge \\neg \\tilde{E}_{\\leq w} \\wedge E_{\\leq w}]}{\\Pr[\\neg \\tilde{E}_{\\leq w}]}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\frac{\\Pr[E \\wedge \\neg E_{\\leq w}]}{\\Pr[\\neg \\tilde{E}_{\\leq w}]} + \\frac{\\Pr[E_{\\leq w} \\wedge \\neg \\tilde{E}_{\\leq w}]}{\\Pr[\\neg \\tilde{E}_{\\leq w}]}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\frac{\\Pr[E_{&gt;w}]}{\\Pr[\\neg \\tilde{E}_{&lt; w}]} + \\frac{\\Pr[E_{\\leq w} \\wedge \\neg \\tilde{E}_{\\leq w}]}{\\Pr[\\neg \\tilde{E}_{&lt; w}]}.</span>$
(23)</p>

    <p class="text-gray-300">We will still find that the new dominant term in the above expression will be  <span class="math">\\Pr[E_{&gt;w}]</span> , of the order  <span class="math">n^{(w+1)(1-r/2)+\\gamma}</span>  (at least, for reasonable choices of  <span class="math">\\kappa</span> , say  <span class="math">\\kappa=0.4</span> . In particular, assuming n large we will find that  <span class="math">\\Pr[E_{\\leq w} \\land \\neg \\tilde{E}_{\\leq w}]</span>  &mdash; which is the probability that some vector of weight w has weight at least  <span class="math">n^{\\kappa}</span>  after one round but weight at most d after two rounds &mdash; is at most  <span class="math">2^{-\\Omega(n^{\\kappa})}</span>  (see Proposition 9.15). And again,  <span class="math">\\Pr[\\tilde{E}_{\\leq w}]</span>  will be shown to be very small (definitely  <span class="math">\\leq 1/2</span> ; see Proposition 9.14), so the</p>

    <p class="text-gray-300">Regarding how to set  <span class="math">\\kappa</span> , note that  <span class="math">\\Pr[\\tilde{E}_{\\leq w}]</span>  is the event that <em>some</em> message of weight w has weight w after one round or some nonzero message of weight w as RAA encoding of weight at most w. We should expect this probability to increase with w, as this makes it easier to obtain weight w. This implies we want to make w small so that the denominator is close to 1. Conversely, note that  <span class="math">\\Pr[E_{\\leq w} \\wedge \\neg \\tilde{E}_{\\leq w}]</span>  is the event that some nonzero message of weight w is mapped to weight w and then mapped to weight w. We should expect this to decrease with w, as having a larger weight after one round is likely to increase your weight after two rounds, making it harder to get a small weight w. In practice we find that any w as a reasonable choice.</p>

    <p class="text-gray-300">First, we analyze the probability that the slower test passes, and argue that it is very close to 1. We note that this is not required for our main result Theorem 9.16, but we still provide it for intuition.</p>

    <p class="text-gray-300"><strong>Proposition 9.12.</strong> Let  <span class="math">r, n, \\delta, d, \\varepsilon, \\gamma, \\alpha_0</span>  and  <span class="math">\\beta_0</span>  be as in Theorem 9.1. Let</p>

    <p class="text-gray-300"><span class="math">$B&#x27; := \\max\\{f(\\alpha_0, \\beta_0, \\delta), \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in \\operatorname{CP}(r, \\delta), \\ \\alpha \\le w/n\\}\\}</span>$</p>

    <p class="text-gray-300">Let  <span class="math">E_{\\leq w}</span>  be the event that some message of weight  <span class="math">\\leq w = O(1)</span>  is encoded by an RAA code into a codeword of weight  <span class="math">\\leq d</span> . Let  <span class="math">v_2^* = \\frac{r-1}{2\\ln(1/\\eta)}</span> . Then</p>

    <p class="text-gray-300"><span class="math">$\\Pr[E_{\\leq w}] \\leq \\mathbb{I}\\{r = 4\\} \\cdot \\frac{3}{n-2} + \\mathbb{I}\\{r = 6, \\delta \\geq 1/4\\} \\cdot \\frac{180\\delta^{2}(1-\\delta)}{(n-2)^{2}} + n^{1-r/2} \\cdot \\lceil \\frac{n^{\\gamma}}{2} \\rceil \\cdot w \\cdot 0.43603 \\cdot \\binom{r}{\\frac{r}{2}} \\cdot \\varphi_{n} \\left(2 \\cdot \\lceil \\frac{m}{2} \\rceil\\right) \\cdot \\varphi_{n}(r) \\cdot (2v_{2}^{*})^{\\frac{r+1}{2}} \\cdot \\eta^{v_{2}^{*}} + \\frac{0.80192 \\cdot \\delta \\cdot w}{\\sqrt{r}} \\cdot n^{5/2} \\cdot 2^{B&#x27;n} .</span>$
(24)</p>

    <p class="text-gray-300">Moreover, assuming B'&lt;0 for sufficiently large n we will have  <span class="math">B&#x27;=f(\\alpha_0,\\beta_0,\\delta)=-\\Omega(n^{-\\gamma})</span>  yielding the asymptotic bound</p>

    <p class="text-gray-300"><span class="math">O(n^{1+\\gamma-r/2}) + 2^{-\\Omega(n^{\\gamma})} .</span></p>

    <p class="text-gray-300"><em>Proof.</em> By Markov's inequality, we can bound  <span class="math">Pr[E_{\\leq w}]</span>  as follows</p>

    <p class="text-gray-300"><span class="math">$\\Pr[E_{\\leq w}] \\leq \\sum_{w_1=1}^w \\sum_{w_2=1}^n \\sum_{w_3=1}^d \\binom{n/r}{w_1} \\cdot \\frac{\\binom{rw_1}{rw_1/2} \\binom{n-rw_1}{w_2-rw_1/2}}{\\binom{n}{w_2}} \\cdot \\frac{\\binom{w_2}{\\lceil w_2/2 \\rceil} \\binom{n-w_2}{w_3-\\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{rw_1/2 \\cdot \\lceil w_2/2 \\rceil}{w_2w_3} \\ .</span>$</p>

    <p class="text-gray-300">We split up the sum over  <span class="math">w_2</span> , treating the  <span class="math">w_2 \\leq n^{\\gamma}</span> -part analogous to Proposition 9.5, and treating the  <span class="math">w_2 &gt; n^{\\gamma}</span>  part analogous to Proposition 9.6.</p>

    <p class="text-gray-300">For the first part, note that the expression we have here is almost the same as the expression that we bounded in Proposition 9.5, with the only difference that here  <span class="math">w_1 = 1, ..., w</span>  while there we had  <span class="math">w_1 = 1, ..., \\lfloor \\frac{2w_2}{r} \\rfloor</span> . In that proposition, we observed that the expression grew with  <span class="math">w_3</span> , so that we could bound the sum over  <span class="math">w_3</span>  by setting  <span class="math">w_3 = d</span>  (except for two cases with small  <span class="math">w_2</span> ). We then observed that the sum over  <span class="math">w_1</span>  decreased with  <span class="math">w_1</span> , so that we could bound the sum over  <span class="math">w_1</span>  by setting  <span class="math">w_1 = 1</span> . This gave us the final expression (13). But since we set  <span class="math">w_1 = 1</span>  this means that we can use (13) as bound for our current expression, as long as we remember to remove the  <span class="math">\\lfloor \\frac{2w_2}{r} \\rfloor</span>  factor that counted the number of iterations over  <span class="math">w_1</span> , and add in a factor w to count the number of iterations in our sum.</p>

    <p class="text-gray-300">This leaves bounding the sum over  <span class="math">w_2</span> . We again follow the same strategy: we first substitute  <span class="math">w_2 := 2v_2</span>  (showing that we can indeed bound each odd  <span class="math">w_2</span>  entry by the subsequent even entry is analogous to before), and then maximize by setting the derivative to  <span class="math">v_2</span>  equal to 0. Since our current expression is exactly a factor  <span class="math">\\frac{2w_2}{r}</span>  smaller than the expression we had before, it simple to see that this changes the maximizer from  <span class="math">v_2^* = \\frac{r+1}{2\\ln(1/\\eta)}</span>  to  <span class="math">v_2^* = \\frac{r-1}{2\\ln(1/\\eta)}</span> , and changes the final bound from (9) to</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathbb{I}\\{r=4\\} \\cdot \\frac{3}{n-2} + \\mathbb{I}\\{r=6, \\delta \\geq 1/4\\} \\cdot \\frac{180\\delta^2(1-\\delta)}{(n-2)^2} \\\\ + n^{1-r/2} \\cdot \\lceil \\frac{n^{\\gamma}}{2} \\rceil \\cdot w \\cdot 0.43603 \\cdot \\binom{r}{\\frac{r}{2}} \\cdot \\varphi_n \\left(2 \\cdot \\lceil \\frac{m}{2} \\rceil\\right) \\cdot \\varphi_n(r) \\cdot \\left(2v_2^*\\right)^{\\frac{r+1}{2}} \\cdot \\eta^{v_2^*} \\end{split}</span>$</p>

    <p class="text-gray-300">Next we consider the large  <span class="math">w_2</span>  part of the expectation. Again, the only change with Proposition 9.6 is the fact that  <span class="math">w_1</span>  only has a constant number of terms. This causes two changes. First, we lose a factor n/r in the final bound (which we originally picked up to count the number of iterations in the sum over  <span class="math">w_1</span> ) and obtain a factor w. Second, we now only optimize over the region  <span class="math">\\mathcal{R}&#x27; \\cap \\{(\\alpha, \\beta) : \\alpha \\leq w/n\\}</span> . So we get the bound of</p>

    <p class="text-gray-300"><span class="math">$\\frac{0.80192 \\cdot \\delta \\cdot (w-1)}{\\sqrt{r}} \\cdot n^{5/2} \\cdot 2^{B&#x27; \\cdot n} .</span>$</p>

    <p class="text-gray-300">The reasoning for the &quot;moreover&quot; portion is analogous to that of Theorem 9.1.</p>

    <p class="text-gray-300">Next, we bound the probability that a message vector of weight above w has a low weight encoding.</p>

    <p class="text-gray-300"><strong>Proposition 9.13.</strong> Let  <span class="math">r, n, \\delta, d, \\varepsilon, \\gamma, \\alpha_0</span>  and  <span class="math">\\beta_0</span>  be as in Theorem 9.1. Let</p>

    <p class="text-gray-300"><span class="math">$B&#x27; := \\max\\{f(\\alpha_0, \\beta_0, \\delta), \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in \\operatorname{CP}(r, \\delta), \\ \\alpha \\ge (w+1)/n\\}\\}</span>$</p>

    <p class="text-gray-300">Let  <span class="math">E_{&gt;w}</span>  be the event that some message of weight &gt; w is encoded by an RAA code into a codeword of weight  <span class="math">\\leq d</span> . Let  <span class="math">v_2^* = \\frac{r(w+1)+1}{2\\ln(1/\\eta)}</span> . Then</p>

    <p class="text-gray-300"><span class="math">$\\Pr[E_{&gt;w}] \\le n^{-r(w+1)/2} \\cdot \\binom{n/r}{w+1} \\cdot \\lceil \\frac{n^{\\gamma}}{2} \\rceil \\cdot 0.43603 \\cdot \\binom{r(w+1)}{r(w+1)/2} \\\\ \\cdot r(w+1)\\varphi_n \\left( 2 \\cdot \\lceil \\frac{m}{2} \\rceil \\right) \\varphi_n(r(w+1)) \\cdot \\left( 2v_2^* \\right)^{\\frac{r(w+1)+1}{2}} \\cdot \\eta^{v_2^*} \\\\ + \\frac{0.80192 \\cdot \\delta}{r^{1.5}} \\cdot n^{7/2} \\cdot 2^{B&#x27;n} .</span>$</p>

    <p class="text-gray-300">Moreover, assuming B' &lt; 0, for sufficently large n this bound is asymptotically</p>

    <p class="text-gray-300"><span class="math">$O(n^{w+1+\\gamma-\\frac{r}{2}(w+1)}) + 2^{-\\Omega(n^{\\gamma})} = O(n^{-(w+1)(\\frac{r}{2}-1)+\\gamma})</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> By Markov's inequality, we can bound  <span class="math">Pr[E_{&gt;w}]</span>  as follows</p>

    <p class="text-gray-300"><span class="math">$\\Pr[E_{&gt;w}] \\leq \\sum_{w_1 = w+1}^{n/r} \\sum_{w_2 = 1}^{n} \\sum_{w_3 = 1}^{d} \\binom{n/r}{w_1} \\cdot \\frac{\\binom{rw_1}{rw_1/2} \\binom{n - rw_1}{w_2 - rw_1/2}}{\\binom{n}{w_2}} \\cdot \\frac{\\binom{w_2}{\\lceil w_2/2 \\rceil} \\binom{n - w_2}{w_3 - \\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{rw_1/2 \\cdot \\lceil w_2/2 \\rceil}{w_2w_3} \\ .</span>$</p>

    <p class="text-gray-300">We again split up the sum over  <span class="math">w_2</span> , treating the  <span class="math">w_2 \\leq n^{\\gamma}</span> -part analogous to Proposition 9.5, and treating the  <span class="math">w_2 &gt; n^{\\gamma}</span>  part analogous to Proposition 9.6.</p>

    <p class="text-gray-300">We start with the first case. What changes when we drop the terms with  <span class="math">w_1 = 1, 2, ..., w</span> ? First, the separate terms (which arose for r = 4 or r = 6) don't arise (they required  <span class="math">w_1 = 1</span> ). Second, recall that we bounded the sum over  <span class="math">w_1</span>  by arguing that it is decreasing with  <span class="math">w_1</span> , so that it's maximized by its first term. By dropping the first w terms, the new maximizing term becomes  <span class="math">w_1 = w + 1</span> . Let's see what the effect of this is. Recall that earlier we took the expression (11) and bounded it by setting  <span class="math">w_1 = 1</span>  giving us (13). The factors involving  <span class="math">w_1</span>  are</p>

    <p class="text-gray-300"><span class="math">$\\binom{n/r}{w_1} \\binom{rw_1}{rw_1/2} \\binom{n-rw_1}{w_2-rw_1/2} \\cdot rw_1/2 .</span>$</p>

    <p class="text-gray-300">and so the factors  <span class="math">\\frac{n}{r} \\cdot \\binom{r}{r/2} \\cdot r/2 = \\text{change to } \\binom{n/r}{w+1} \\cdot \\binom{2r(w+1)}{r(w+1)} \\cdot r(w+1)/2</span> . More importantly, the factor  <span class="math">\\binom{n-r}{w_2-r/2}</span>  changes to  <span class="math">\\binom{n-r(w+1)}{w_2-r(w+1)/2}</span> . Again, one can demonstrate that the terms in the sum are maximized by an even  <span class="math">w_2</span> , so we consider even  <span class="math">2v_2</span>  values. Recall that we bounded</p>

    <p class="text-gray-300"><span class="math">$\\binom{n-r}{2v_2 - r/2} \\le \\frac{(2v_2)^{\\frac{r}{2}}(n-2v_2)^{\\frac{r}{2}}}{n^r} \\cdot \\varphi_n(r) ;</span>$</p>

    <p class="text-gray-300">similar reasoning leads to the bound</p>

    <p class="text-gray-300"><span class="math">$\\binom{n - r(w+1)}{2v_2 - r(w+1)/2} \\le \\frac{(2v_2)^{r(w+1)/2}(n - 2v_2)^{r(w+1)/2}}{n^{r(w+1)}} \\cdot \\varphi_n(r(w+1)) .</span>$</p>

    <p class="text-gray-300">This changes the factor  <span class="math">(2v_2/n)^{r/2}</span>  in the bound to  <span class="math">(2v_2/n)^{r(w+1)}</span> . Moreover, this changes the maximizing value of  <span class="math">v_2</span>  from  <span class="math">\\frac{r+1}{2\\ln(1/\\eta)}</span>  to  <span class="math">v_2^* = \\frac{r(w+1)+1}{2\\ln(1/\\eta)}</span> . The final bound then becomes</p>

    <p class="text-gray-300"><span class="math">$n^{-r(w+1)/2} \\cdot \\binom{n/r}{w+1} \\cdot \\lceil \\frac{n^{\\gamma}}{2} \\rceil \\cdot 0.43603 \\cdot \\binom{r(w+1)}{r(w+1)/2} \\\\ \\cdot r(w+1)\\varphi_n \\left( 2 \\cdot \\lceil \\frac{m}{2} \\rceil \\right) \\varphi_n(r(w+1)) \\cdot \\left( 2v_2^* \\right)^{\\frac{r(w+1)+1}{2}} \\cdot \\eta^{v_2^*}</span>$</p>

    <p class="text-gray-300">We then move to the second case. The contribution of this case to the error probability was summarised in Proposition 9.6. The effect of  <span class="math">w_1 = 1</span>  messages lies in  <span class="math">\\alpha_0 = r/n</span>  being the smallest allowed value for  <span class="math">\\alpha</span> . By moving to  <span class="math">w_1 \\geq w</span> , the minimum value for  <span class="math">\\alpha</span>  increases to  <span class="math">w \\cdot \\alpha_0 = r \\cdot w/n</span> . Recall that either  <span class="math">(\\alpha_0, \\beta_0)</span>  or a critical point maximized the function f. It follows directly from our argument that this first maximizer changes to  <span class="math">(w \\cdot \\alpha_0, \\beta_0)</span>  (recall that the restriction  <span class="math">f_{\\beta_0, \\delta}(\\alpha)</span>  of f to  <span class="math">\\alpha</span>  was strictly concave for  <span class="math">\\alpha &gt; 0</span>  and  <span class="math">\\alpha \\leq 2\\beta_0</span>  and has a critical point strictly smaller than r/n).</p>

    <p class="text-gray-300">We now move to analyzing the faster test. We first argue it is likely to pass.</p>

    <p class="text-gray-300"><strong>Proposition 9.14.</strong> Let  <span class="math">r, n, \\delta, d, \\varepsilon, \\gamma, \\alpha_0</span>  and  <span class="math">\\beta_0</span>  be as in Theorem 9.1. Let</p>

    <p class="text-gray-300"><span class="math">$B&#x27; := \\max\\{f(\\alpha_0, \\beta_0, \\delta), \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in \\operatorname{CP}(r, \\delta), \\ \\alpha \\le (w - 1)/n\\}\\}\\</span>$</p>

    <p class="text-gray-300">Let  <span class="math">\\tilde{E}_{\\leq w}</span>  be the event that some message of weight  <span class="math">\\leq w = O(1)</span>  is encoded by an RAA code into a codeword of weight  <span class="math">\\leq d</span> , or that some message of weight w is encoded by the first round of permuting and accumulating into a vector of weight  <span class="math">\\leq n^{\\kappa}</span> , where  <span class="math">\\kappa \\in (0,1)</span> . Assume  <span class="math">n^{\\kappa} \\leq \\frac{rw/2-1}{rw-1}n</span> . Then</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\Pr[\\tilde{E}_{\\leq w}] &amp;\\leq \\binom{n/r}{w} \\frac{rw}{2} \\binom{rw}{\\frac{rw}{2}} \\frac{\\binom{n-rw}{n^{\\kappa} - \\frac{rw}{2}}}{\\binom{n}{n^{\\kappa}}} \\\\ &amp;+ \\mathbb{I}\\{r=4\\} \\cdot \\frac{3}{n-2} + \\mathbb{I}\\{r=6, \\delta \\geq 1/4\\} \\cdot \\frac{180\\delta^2(1-\\delta)}{(n-2)^2} \\\\ &amp;+ n^{1-r/2} \\cdot \\lceil \\frac{n^{\\gamma}}{2} \\rceil \\cdot w \\cdot 0.43603 \\cdot \\binom{r}{\\frac{r}{2}} \\cdot \\varphi_n \\left(2 \\cdot \\lceil \\frac{m}{2} \\rceil\\right) \\cdot \\varphi_n(r) \\cdot \\left(2v_2^*\\right)^{\\frac{r+1}{2}} \\cdot \\eta^{v_2^*} \\\\ &amp;+ \\frac{0.80192 \\cdot \\delta \\cdot w}{\\sqrt{r}} \\cdot n^{5/2} \\cdot 2^{B&#x27;n} \\ . \\end{split}</span>$</p>

    <p class="text-gray-300">Moreover, assuming  <span class="math">\\kappa &lt; 1/2</span>  we have</p>

    <p class="text-gray-300"><span class="math">$\\binom{n/r}{w} \\frac{rw}{2} \\binom{rw}{\\frac{rw}{2}} \\frac{\\binom{n-rw}{n^{\\kappa} - \\frac{rw}{2}}}{\\binom{n}{n^{\\kappa}}} \\le \\binom{n/r}{w} \\frac{rw}{2} \\binom{rw}{\\frac{rw}{2}} n^{\\frac{rw}{2}(\\kappa-1)} \\varphi_n(n^{\\kappa})</span>$</p>

    <p class="text-gray-300">so assuming B' &lt; 0 the overall bound is  <span class="math">O(n^{1+\\gamma-r/2}) + O(n^{w(1+\\frac{r}{2}(\\kappa-1))})</span> , which as  <span class="math">\\kappa &lt; 1/2 \\le 1 - \\frac{2}{r}</span>  is indeed decreasing with n.</p>

    <p class="text-gray-300"><em>Proof.</em> If  <span class="math">\\tilde{E}_w</span>  is the event that some message of weight w is encoded by the first round of permuting and accumulating into a vector of weight  <span class="math">\\leq n^{\\kappa}</span> , then  <span class="math">\\tilde{E}_{\\leq w} = E_{\\leq w-1} \\cup \\tilde{E}_w</span> . By a union bound  <span class="math">\\Pr[\\tilde{E}_{\\leq w}] \\leq \\Pr[E_{\\leq w-1}] + \\Pr[\\tilde{E}_w]</span> . Proposition 9.12 provides a bound on the first term, and so it suffices for us to bound  <span class="math">\\Pr[\\tilde{E}_w]</span> .</p>

    <p class="text-gray-300">By Markov's inequality it suffices to bound the expect number of messages of weight w that have weight  <span class="math">\\leq n^{\\kappa}</span>  after one round, that is,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\tilde{E}_w] \\le \\binom{n/r}{w} \\frac{rw}{2} \\binom{rw}{\\frac{rw}{2}} \\sum_{w=1}^{n^{\\kappa}} \\frac{\\binom{n-rw}{w_2 - \\frac{rw}{2}}}{\\binom{n}{w_2} w_2}</span>$</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;30</sup>Although this doesn't change the asymptotic characterisation  <span class="math">2^{\\Omega(n^{\\gamma})}</span>  (as we always have  <span class="math">n^{\\gamma-1} &lt; w_1 \\cdot n^{-1}</span>  for large enough n), it does improve the bound somewhat. However, recall that the bottleneck is the  <span class="math">w_2 \\leq n^{\\gamma}</span>  part of the analysis, so the overall effect is not so significant.</p>

    <p class="text-gray-300">We now note that the expression in the sum over  <span class="math">w_2</span>  is analogous to the expression in the sum over  <span class="math">w_3</span>  in (8). We had argued that (8) grew with  <span class="math">w_3</span>  if and only if  <span class="math">w_3 \\leq n \\left(\\frac{\\lceil w_2/2 \\rceil}{w_2 - 1}\\right)</span> . Our case is analogous, except we replace  <span class="math">w_2</span>  with rw and  <span class="math">w_3</span>  with  <span class="math">w_2</span> , giving the condition that our expression grows with  <span class="math">w_2</span>  if and only if  <span class="math">w_2 \\leq \\frac{rw/2 - 1}{rw - 1}n</span> . As we assume  <span class="math">n^{\\kappa} \\leq \\frac{rw/2 - 1}{rw - 1}n</span>  and  <span class="math">w_2 \\leq n^{\\kappa}</span> , it follows these terms indeed are increasing in  <span class="math">w_2</span> . So, we obtain the bound</p>

    <p class="text-gray-300"><span class="math">$\\binom{n/r}{w}\\frac{rw}{2}\\binom{rw}{\\frac{rw}{2}}\\frac{\\binom{n-rw}{n^\\kappa-\\frac{rw}{2}}}{\\binom{n}{n^\\kappa}}\\ .</span>$</p>

    <p class="text-gray-300">For the moreover part of the statement we can rewrite the fraction of the two binomials as follows</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\binom{n-rw}{n^{\\kappa}-rw/2}}{\\binom{n}{n^{\\kappa}}} = \\frac{(n-rw)!}{(n-rw-n^{\\kappa}+rw/2)} \\cdot \\frac{n^{\\kappa}!}{(n^{\\kappa}-rw/2)!} \\cdot \\frac{(n-n^{\\kappa})!}{n!}</span>$
<span class="math">$= \\frac{\\prod_{i=0}^{rw/2-1} (n^{\\kappa}-i) \\cdot \\prod_{i=0}^{n^{\\kappa}-rw/2-1} (n-rw-i)}{\\prod_{i=1}^{n^{\\kappa}} (n-i)},</span>$</p>

    <p class="text-gray-300">to which we can apply (16) and obtain</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\binom{n-rw}{n^{\\kappa}-rw/2}}{\\binom{n}{n^{\\kappa}}} \\le n^{\\frac{rw}{2}(\\kappa-1)} \\varphi_n(n^{\\kappa})</span>$</p>

    <p class="text-gray-300">Thus, we have the final bound on this term as</p>

    <p class="text-gray-300"><span class="math">$\\binom{n/r}{w} \\frac{rw}{2} \\binom{rw}{\\frac{rw}{2}} \\frac{\\binom{n-rw}{n^{\\kappa} - \\frac{rw}{2}}}{\\binom{n}{n^{\\kappa}}} \\le \\binom{n/r}{w} \\frac{rw}{2} \\binom{rw}{\\frac{rw}{2}} n^{\\frac{rw}{2}(\\kappa-1)} \\varphi_n(n^{\\kappa})</span>$</p>

    <p class="text-gray-300">As we now assume  <span class="math">\\kappa &lt; 1/2</span> ,  <span class="math">\\varphi_n(n^{\\kappa}) = \\exp(n^{\\kappa}(n^{\\kappa}-1)/(2n)) = O(1)</span> , and so this term is</p>

    <p class="text-gray-300"><span class="math">$O(n^w \\cdot n^{\\frac{rw}{2}(\\kappa-1)}) = O(n^{w(1+\\frac{r}{2}(\\kappa-1))})</span>$
.</p>

    <p class="text-gray-300">Finally, we consider the event that every message of weight w has weight at least  <span class="math">n^{\\kappa}</span>  after the first round, but nonetheless some message of weight w has an encoding of weight &lt; d.</p>

    <p class="text-gray-300"><strong>Proposition 9.15.</strong> Let  <span class="math">n, r, \\delta, d, \\alpha_0</span>  be as in Theorem 9.1. Let  <span class="math">w \\in \\mathbb{N}</span>  and define the events  <span class="math">E_{\\leq w}</span>  and  <span class="math">\\tilde{E}_{\\leq w}</span>  as before. Let</p>

    <p class="text-gray-300"><span class="math">$B&#x27; := \\max\\{f(\\alpha_0, n^{\\kappa-1}, \\delta), \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in \\mathrm{CP}(r, \\delta), \\ \\beta \\ge n^{\\kappa-1}\\}\\} \\ .</span>$</p>

    <p class="text-gray-300">Then</p>

    <p class="text-gray-300"><span class="math">$\\Pr[E_{\\leq w} \\land \\neg \\tilde{E}_{\\leq w}] \\leq \\frac{0.80192 \\cdot \\delta \\cdot (w-1)}{\\sqrt{r}} \\cdot n^{5/2} \\cdot 2^{B&#x27;n}</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> It suffices to bound the expected number of weight w messages that are mapped to a weight  <span class="math">&gt; n^{\\kappa}</span>  vector after one round, and then mapped to a weight  <span class="math">\\leq d</span>  codeword after the second round. That is:</p>

    <p class="text-gray-300"><span class="math">$\\sum_{w_2=n^{\\kappa}+1}^{2d} \\sum_{w_3=1}^{d} \\binom{n/r}{w} \\cdot \\frac{\\binom{rw}{rw_1/2} \\binom{n-rw}{w_2-rw/2}}{\\binom{n}{w_2}} \\cdot \\frac{\\binom{w_2}{\\lceil w_2/2 \\rceil} \\binom{n-w_2}{w_3-\\lceil w_2/2 \\rceil}}{\\binom{n}{w_3}} \\cdot \\frac{rw_1/2 \\cdot \\lceil w_2/2 \\rceil}{w_2w_3}</span>$</p>

    <p class="text-gray-300">We can leverage the analysis from Proposition 9.6 as we have a good enough lower-bound on  <span class="math">w_2</span>  (recall that for  <span class="math">w_1, w_2 = O(1)</span>  that analysis was not sufficient to prove decent error probability). That is, we can bound the above as</p>

    <p class="text-gray-300"><span class="math">$\\frac{0.80192 \\cdot \\delta \\cdot (w-1)}{\\sqrt{r}} \\cdot n^{5/2} \\cdot 2^{B&#x27;n} . \\qquad \\Box</span>$</p>

    <p class="text-gray-300">The conclusion of all these bounds is the following theorem.</p>

    <p class="text-gray-300"><strong>Theorem 9.16.</strong> Let  <span class="math">r, n, \\delta, d, \\varepsilon, \\gamma, \\alpha_0, \\beta_0</span>  and  <span class="math">CP(r, \\delta)</span>  be as in Theorem 9.1. Let  <span class="math">\\kappa \\in (0, 1)</span>  and  <span class="math">w \\in \\mathbb{N}</span> . Let  <span class="math">v_2^*</span>  be as in Proposition 9.13. There is  <span class="math">\\tilde{O}(n^w)</span>  generation procedure procedure outputting rate 1/r RAA codes with minimum distance  <span class="math">\\delta</span>  except with probability at most  <span class="math">\\frac{p_{&gt;w}}{1-\\tilde{p}_{&lt;w}} + \\frac{q_w}{1-\\tilde{p}_{&lt;w}}</span> , where</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} p_{&gt;w} &amp;:= n^{-r(w+1)/2} \\cdot \\binom{n/r}{w+1} \\cdot \\lceil \\frac{n^{\\gamma}}{2} \\rceil \\cdot 0.43603 \\cdot \\binom{r(w+1)}{r(w+1)/2} \\\\ &amp; \\cdot r(w+1) \\varphi_n \\left( 2 \\cdot \\lceil \\frac{m}{2} \\rceil \\right) \\varphi_n(r(w+1)) \\cdot \\left( 2v_2^* \\right)^{\\frac{r(w+1)+1}{2}} \\cdot \\eta^{v_2^*} \\\\ &amp; + \\frac{0.80192 \\cdot \\delta}{r^{1.5}} \\cdot n^{7/2} \\cdot 2^{B_1 n} \\\\ \\tilde{p}_{\\leq w} &amp;= \\binom{n/r}{w} \\frac{rw}{2} \\binom{rw}{\\frac{rw}{2}} \\frac{\\binom{n-rw}{n^{\\kappa} - \\frac{rw}{2}}{\\binom{n}{n^{\\kappa}}}}{\\binom{n}{n^{\\kappa}}} \\\\ &amp; + \\mathbb{I}\\{r=4\\} \\cdot \\frac{3}{n-2} + \\mathbb{I}\\{r=6, \\delta \\geq 1/4\\} \\cdot \\frac{180\\delta^2(1-\\delta)}{(n-2)^2} \\\\ &amp; + n^{1-r/2} \\cdot \\lceil \\frac{n^{\\gamma}}{2} \\rceil \\cdot w \\cdot 0.43603 \\cdot \\binom{r}{\\frac{r}{2}} \\cdot \\varphi_n \\left( 2 \\cdot \\lceil \\frac{m}{2} \\rceil \\right) \\cdot \\varphi_n(r) \\cdot \\left( 2v_2^* \\right)^{\\frac{r+1}{2}} \\cdot \\eta^{v_2^*} \\\\ &amp; + \\frac{0.80192 \\cdot \\delta \\cdot w}{\\sqrt{r}} \\cdot n^{5/2} \\cdot 2^{B_2 n} \\ , \\\\ q_w &amp;:= \\frac{0.80192 \\cdot \\delta \\cdot (w-1)}{\\sqrt{r}} \\cdot n^{5/2} \\cdot 2^{B_3 n} \\ . \\end{split}</span>$</p>

    <p class="text-gray-300">Above,</p>

    <p class="text-gray-300"><span class="math">$B_1 := \\max\\{f(\\alpha_0, \\beta_0, \\delta), \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in \\operatorname{CP}(r, \\delta), \\ \\alpha \\ge (w+1)/n\\}\\}</span>$</p>

    <p class="text-gray-300"><span class="math">$B_2 := \\max\\{f(\\alpha_0, \\beta_0, \\delta), \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in \\operatorname{CP}(r, \\delta), \\ \\alpha \\le (w-1)/n\\}\\}</span>$</p>

    <p class="text-gray-300"><span class="math">$B_3 := \\max\\{f(\\alpha_0, n^{\\kappa-1}, \\delta), \\max\\{f(\\alpha, \\beta, \\delta) : (\\alpha, \\beta) \\in \\operatorname{CP}(r, \\delta), \\ \\beta \\ge n^{\\kappa-1}\\}\\}.</span>$</p>

    <p class="text-gray-300">Assuming  <span class="math">\\max\\{f(\\alpha,\\beta): (\\alpha,\\beta) \\in \\operatorname{CP}(r,\\delta)\\}\\</span>  &lt; 0, then the bound is asymptotically  <span class="math">O(n^{-(w+1)(\\frac{r}{2}-1)+\\gamma}+2^{-\\Omega(n^{\\gamma})}+2^{-\\Omega(n^{\\kappa})})</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> We use the fast test for weight w: namely, check that all nonzero messages of weight  <span class="math">\\leq w-1</span>  have encodings of weight at least d, and that all messages of weight w have weight at least  <span class="math">n^{\\kappa}</span>  after one round. As discussed earlier, this test is implementable in  <span class="math">\\tilde{O}(k^w)</span>  time, and by Proposition 9.14 a random RAA is very likely to pass.</p>

    <p class="text-gray-300">Recalling (23), we have that conditioned on the test pass the failure probability is at most</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\Pr[E_{&gt;w}]}{\\Pr[\\neg \\tilde{E}_w]} + \\frac{\\Pr[E_{\\leq w} \\wedge \\neg \\tilde{E}_{\\leq w}]}{\\Pr[\\neg \\tilde{E}_w]} .</span>$</p>

    <p class="text-gray-300">That  <span class="math">\\Pr[E_{&gt;w}] \\leq p_{&gt;w}</span> ,  <span class="math">\\Pr[\\neg \\tilde{E}_w] \\geq 1 - \\tilde{p}_{\\leq w}</span>  and  <span class="math">\\Pr[E_{\\leq w} \\land \\neg \\tilde{E}_{\\leq w}] \\leq q_w</span>  follow from Proposition 9.13, Proposition 9.14 and Proposition 9.15, respectively.</p>

      <h3 id="sec-9.5" class="text-xl font-semibold mt-8">9.5 Puncturing</h3>

    <p class="text-gray-300">Lastly, we consider the possibility of puncturing an RAA code so as to obtain a higher rate code while still (mostly) preserving the encoding time. Specifically, suppose we start with a (randomly sampled) RAA code with repetition factor r and block-length n, and then we puncture down to keep only  <span class="math">\\omega n</span>  coordinates for some  <span class="math">\\omega \\in (0,1)</span>  (hence, the final rate will be  <span class="math">1/(r\\omega)</span> ).</p>

    <p class="text-gray-300">We were not able to provide a completely satisfactory analysis of the failure probability in this case. However, based on a conjecture &ndash; which we consider believable given our analysis of (unpunctured) RAA codes &ndash; we can obtain good bounds on the failure probability. We sketch this analysis below.</p>

    <p class="text-gray-300">Our strategy is to once again bound the expected number of codewords with weight at most  <span class="math">\\delta&#x27; n&#x27;</span> , where  <span class="math">\\delta&#x27;</span>  is the target minimum distance of our punctured code. We can write the probability that a weight  <span class="math">w_3</span>  string of length n is punctured into a weight  <span class="math">w_4</span>  string of length n' as</p>

    <p class="text-gray-300">
<span class="math">$\\frac{\\binom{w_3}{w_4}\\binom{n-w_3}{n&#x27;-w_4}}{\\binom{n}{n&#x27;}}.</span>$</p>

    <p class="text-gray-300">This means we can write the expectation we need to bound as</p>

    <p class="text-gray-300"><span class="math">$\\sum_{w_{1}}^{n/r} \\sum_{w_{2}=1}^{n} \\sum_{w_{3}=1}^{n} \\sum_{w_{4}=1}^{d&#x27;} \\binom{n/r}{w_{1}} \\cdot \\frac{\\binom{rw_{1}}{\\lceil rw_{1}/2 \\rceil} \\binom{n-rw_{1}}{w_{2}-\\lceil rw_{1}/2 \\rceil}}{\\binom{n}{w_{2}}} \\cdot \\frac{\\binom{w_{2}}{\\lceil w_{2}/2 \\rceil} \\binom{n-w_{2}}{w_{3}-\\lceil w_{2}/2 \\rceil}}{\\binom{n}{w_{3}}} \\cdot \\frac{\\binom{rw_{1}/2}{\\lceil w_{2}/2 \\rceil} \\binom{rw_{3}}{m_{2}/2}}{\\binom{n}{w_{4}} \\binom{n-w_{3}}{n&#x27;-w_{4}}}}{\\binom{n}{m&#x27;}},</span>$
(25)</p>

    <p class="text-gray-300">where  <span class="math">d&#x27; = \\delta&#x27; n&#x27; = \\delta&#x27; \\eta n</span> .</p>

    <p class="text-gray-300">We will split this sum up based on the value of  <span class="math">w_3</span>  (the weight of the rate 1/r RAA code, just before puncturing), specifically we separately consider  <span class="math">w_3 \\leq d</span>  and  <span class="math">w_3 &gt; d</span> .<sup>31</sup> For the former case, we can re-use our bound on the error probability of sampling an unpunctured RAA code from Theorem Eq. (18), as this exactly bounded the contribution of  <span class="math">w_3 \\leq d</span>  to the expectation. For the latter, we need to do some more work. Specifically, inspired again by [KZKJ08], we will do something similar to the proof of Proposition 9.6, where we rewrite the expression in the sum as some function  <span class="math">F(\\alpha, \\beta, \\rho, \\rho&#x27;)</span>  over the relative weights, and we attempt to maximize F over the legal range of these weights. Note that we can get away with this since we have a linear lower-bound on  <span class="math">w_3</span> ; as we noted before, in case all weights are constant, the maximization of F will be too large to obtain a small error probability.</p>

    <p class="text-gray-300">Specifically, recall from the proof of Proposition 9.6 that we can write the contribution of the first three fractions of the expression inside the sums in (25) as  <span class="math">poly(n) \\cdot 2^{n \\cdot f(\\alpha,\\beta,\\rho)}</span>  where</p>

    <p class="text-gray-300"><span class="math">$f(\\alpha,\\beta,\\rho) := \\frac{H(\\alpha)}{r} + (1-\\alpha)H\\left(\\frac{\\beta - \\frac{\\alpha}{2}}{1-\\alpha}\\right) + \\alpha + \\beta + (1-\\beta)H\\left(\\frac{\\rho - \\frac{\\beta}{2}}{1-\\beta}\\right) - H(\\beta) - H(\\rho) .</span>$</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;\\&lt;/sup&gt;overline{^{31}}</span> In fact, one could potentially a threshold t potentially below d, as long as  <span class="math">\\omega t &gt; d&#x27;</span> .</p>

    <p class="text-gray-300">Looking at Equation (39) in [KZKJ08], we can write the contribution of the fourth fraction (accounting for the puncturing step) as  <span class="math">poly(n) \\cdot 2^{n \\cdot \\varphi(\\rho, \\rho&#x27;)}</span>  where</p>

    <p class="text-gray-300"><span class="math">$\\varphi(\\rho, \\rho&#x27;) := H\\left(\\omega \\frac{\\rho&#x27;}{\\rho}\\right) \\rho + H\\left((1 - \\omega) \\frac{1 - \\rho&#x27;}{1 - \\rho}\\right) (1 - \\rho) - H(\\omega) .</span>$</p>

    <p class="text-gray-300">The crux of the argument for the case  <span class="math">w_3 &gt; d</span>  is now to maximize the following function</p>

    <p class="text-gray-300"><span class="math">$F(\\alpha, \\beta, \\rho, \\rho&#x27;) := f(\\alpha, \\beta, \\rho) + \\varphi(\\rho, \\rho&#x27;)</span>$
.</p>

    <p class="text-gray-300">where as before  <span class="math">\\alpha = rw_1/n</span> ,  <span class="math">\\beta = w_2/n</span> ,  <span class="math">\\rho = w_3/n</span> , and now we think of  <span class="math">\\rho&#x27; = w_4/n</span> . In particular, note that the maximum value of  <span class="math">\\rho&#x27;</span>  is  <span class="math">d&#x27;/n = \\omega \\delta</span> .</p>

    <p class="text-gray-300">To do this in a manageable way, we will start by arguing that F is increasing on  <span class="math">\\rho&#x27;</span> , so that we can simply set  <span class="math">\\rho&#x27; := \\omega \\delta&#x27;</span> . Specifically, we prove the lemma below, and this will imply that for all  <span class="math">\\alpha, \\beta, \\rho \\in (0, 1)</span>  and  <span class="math">\\rho&#x27; \\in [0, \\delta&#x27;]</span> ,</p>

    <p class="text-gray-300"><span class="math">$F(\\alpha, \\beta, \\rho, \\rho&#x27;) \\leq F(\\alpha, \\beta, \\rho, \\delta&#x27;)</span>$
.</p>

    <p class="text-gray-300"><strong>Lemma 9.17.</strong> Fix  <span class="math">\\rho \\in (0,1)</span> , and consider the univariate function</p>

    <p class="text-gray-300"><span class="math">$\\psi = \\psi_{\\rho} : [0, \\delta&#x27;] \\to \\mathbb{R}, \\quad \\rho&#x27; \\mapsto \\varphi(\\rho, \\rho&#x27;)</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\rho &gt; \\frac{\\omega \\delta&#x27;}{1 - (1 - \\omega)(1 - \\delta&#x27;)}</span>  and  <span class="math">1 - \\frac{1}{2}(1 - \\omega) &gt; \\delta&#x27;</span> . The function  <span class="math">\\psi</span>  is increasing on its domain.</p>

    <p class="text-gray-300"><em>Proof.</em> We begin by considering the derivative of  <span class="math">\\varphi</span>  with respect to  <span class="math">\\rho&#x27;</span> , which is</p>

    <p class="text-gray-300"><span class="math">$\\omega \\log \\left( \\frac{(\\rho - \\omega \\rho&#x27;) \\cdot (1 - (1 - \\omega)(1 - \\rho&#x27;))}{\\omega \\rho&#x27;(1 - \\omega)(1 - \\rho&#x27;)} \\right) - \\log \\left( \\frac{1 - (1 - \\omega)(1 - \\rho&#x27;)}{(1 - \\omega)(1 - \\rho&#x27;)} \\right) .</span>$</p>

    <p class="text-gray-300">We claim this expression is always &gt; 0, i.e., that</p>

    <p class="text-gray-300"><span class="math">$\\omega \\log \\left( \\frac{(\\rho - \\omega \\rho&#x27;) \\cdot (1 - (1 - \\omega)(1 - \\rho&#x27;))}{\\omega \\rho&#x27;(1 - \\omega)(1 - \\rho&#x27;)} \\right) &gt; \\log \\left( \\frac{1 - (1 - \\omega)(1 - \\rho&#x27;)}{(1 - \\omega)(1 - \\rho&#x27;)} \\right) . \\tag{26}</span>$</p>

    <p class="text-gray-300">We first observe that the RHS above is negative, which is equivalent to</p>

    <p class="text-gray-300">
<span class="math">$1 - (1 - \\omega)(1 - \\rho&#x27;) &gt; (1 - \\omega)(1 - \\rho&#x27;)</span>$
.</p>

    <p class="text-gray-300">Straightforward algebraic manipulations show that the above condition is equivalent to  <span class="math">1 - \\frac{1}{2}(1 - \\omega) &gt; \\rho&#x27;</span> , which follows from one of our assumptions on  <span class="math">\\delta&#x27;</span>  (recall  <span class="math">\\rho&#x27; \\leq \\delta&#x27;</span> ). Hence, it now suffices to argue that the LHS of (26) is positive, which is itself equivalent to</p>

    <p class="text-gray-300"><span class="math">$(\\rho - \\omega \\rho&#x27;) \\cdot (1 - (1 - \\omega)(1 - \\rho&#x27;)) &gt; \\omega \\rho&#x27;(1 - \\omega)(1 - \\rho&#x27;).</span>$</p>

    <p class="text-gray-300">Expanding the LHS above yields</p>

    <p class="text-gray-300"><span class="math">$\\rho - \\omega \\rho&#x27; - \\rho (1 - \\omega)(1 - \\rho&#x27;) + \\omega \\rho&#x27; (1 - \\omega)(1 - \\rho&#x27;)</span>$</p>

    <p class="text-gray-300">and so it suffices to argue</p>

    <p class="text-gray-300"><span class="math">$\\rho - \\omega \\rho&#x27; - \\rho (1 - \\omega)(1 - \\rho&#x27;) &gt; 0 \\iff \\rho &gt; \\frac{\\omega \\rho&#x27;}{1 - (1 - \\omega)(1 - \\rho&#x27;)}.</span>$</p>

    <p class="text-gray-300">As we assumed  <span class="math">\\rho &gt; \\frac{\\omega \\delta&#x27;}{1-(1-\\omega)(1-\\delta&#x27;)}</span>  and the function  <span class="math">\\rho&#x27; \\mapsto \\frac{\\omega \\rho&#x27;}{1-(1-\\omega)(1-\\rho&#x27;)}</span>  is increasing on the interval  <span class="math">[0,\\delta&#x27;]</span>  (the derivative  <span class="math">\\frac{\\omega(1-(1-\\omega)(1-\\rho&#x27;))+\\omega\\rho&#x27;(1-\\omega)}{(1-(1-\\omega)(1-\\rho&#x27;))^2}</span>  is manifestly positive on this domain), our desired conclusion follows.</p>

    <p class="text-gray-300">Upon fixing  <span class="math">\\rho&#x27;</span>  to  <span class="math">\\delta&#x27;</span> , we are now reduced to considering a trivariate function. We now consider fixing  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span> , and observe that the resulting function is <em>concave</em>. This is analogous to Lemma 9.10 and Lemma 9.11.</p>

    <p class="text-gray-300"><strong>Lemma 9.18.</strong> Fix  <span class="math">\\alpha, \\beta \\in (0,1)</span> , and consider the univariate function</p>

    <p class="text-gray-300"><span class="math">$\\tau = \\tau_{\\alpha,\\beta} : (\\max\\{\\delta,\\beta/2\\}, \\min\\{\\omega(1+\\delta&#x27;-\\omega\\delta&#x27;), 1-\\beta/2\\}) \\to \\mathbb{R}, \\quad \\rho \\mapsto F(\\alpha,\\beta,\\rho,\\omega\\delta&#x27;) .</span>$</p>

    <p class="text-gray-300">The function  <span class="math">\\tau</span>  is concave on its domain.</p>

    <p class="text-gray-300">It thus makes sense to find values  <span class="math">\\rho</span>  maximizing F by looking for critical points, i.e., points where  <span class="math">\\frac{\\partial F}{\\partial \\rho} = 0</span> . Looking at Equation (42) in [KZKJ08], this is true exactly when we have</p>

    <p class="text-gray-300">
<span class="math">$\\rho&#x27; = \\frac{\\rho(c+1) - 1/2}{1+c} \\quad \\text{where} \\quad c = \\frac{(1-\\rho)^2(\\rho - \\beta/2)}{\\rho^2(1-\\rho - \\beta/2)} \\,, \\tag{27}</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> We can first compute the derivative (following [KZKJ08, Equation (41)])</p>

    <p class="text-gray-300">
<span class="math">$\\frac{d\\tau}{d\\rho} = \\log\\left(\\frac{\\rho^2(1-\\rho-\\beta/2)((1-\\rho)-(1-\\omega)(1-\\omega\\delta&#x27;))}{(1-\\rho)^2(\\rho-\\beta/2)(\\rho-\\omega\\delta&#x27;)}\\right).</span>$</p>

    <p class="text-gray-300">Calling the numerator inside the logarithm  <span class="math">s(\\rho)</span>  and the denominator  <span class="math">t(\\rho)</span> , it follows that</p>

    <p class="text-gray-300"><span class="math">$\\frac{d^2\\tau}{d\\rho^2} = \\frac{1}{\\ln 2} \\frac{t(\\rho)}{s(\\rho)} \\cdot \\frac{t(\\rho)s&#x27;(\\rho) - s(\\rho)t&#x27;(\\rho)}{(t(\\rho))^2} = \\frac{1}{\\ln 2} = \\frac{t(\\rho)s&#x27;(\\rho) - s(\\rho)t&#x27;(\\rho)}{s(\\rho)t(\\rho)} . \\tag{28}</span>$</p>

    <p class="text-gray-300">First, we note that  <span class="math">\\frac{1}{\\ln 2} &gt; 0</span> , and similarly that  <span class="math">s(\\rho)t(\\rho) &gt; 0</span> . Indeed,</p>

    <p class="text-gray-300"><span class="math">$s(\\rho)t(\\rho) = \\rho^{2}(1 - \\rho - \\beta/2)(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))(1 - \\rho)^{2}(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;)</span>$</p>

    <p class="text-gray-300">and it is immediate to verify that for  <span class="math">\\delta \\in (\\max\\{\\delta, \\beta/2\\}, \\min\\{\\omega(1+\\delta&#x27;-\\omega\\delta&#x27;), 1-\\beta/2\\})</span>  all the terms appearing above are positive (using that  <span class="math">\\rho &gt; \\delta \\ge \\omega\\delta&#x27;</span> ). Hence, it suffices to argue that the numerator of (28) is negative.</p>

    <p class="text-gray-300">We have</p>

    <p class="text-gray-300"><span class="math">$t(\\rho)s&#x27;(\\rho) - s(\\rho)t&#x27;(\\rho)</span>$</p>

    <p class="text-gray-300"><span class="math">$= (1 - \\rho)^{2}(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;) \\left[ 2\\rho(1 - \\rho - \\beta/2)(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;)) - \\rho^{2}(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;)) - \\rho^{2}(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;)) \\right]</span>$</p>

    <p class="text-gray-300"><span class="math">$- \\rho^{2}(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;)) \\left[ -2(1 - \\rho)(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;) + (1 - \\rho)^{2}(\\rho - \\omega\\delta&#x27;) + (1 - \\rho)^{2}(\\rho - \\omega\\delta&#x27;) + (1 - \\rho)^{2}(\\rho - \\beta/2) \\right]</span>$</p>

    <p class="text-gray-300"><span class="math">$= 2(1 - \\rho)^{2}(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;)\\rho(1 - \\rho - \\beta/2)(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))</span>$</p>

    <p class="text-gray-300"><span class="math">$+ 2\\rho^{2}(1 - \\rho - \\beta/2)(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))(1 - \\rho)(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;)</span>$</p>

    <p class="text-gray-300"><span class="math">$- (1 - \\rho)^{2}(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;)\\rho^{2}(1 - \\rho - \\beta/2)</span>$</p>

    <p class="text-gray-300"><span class="math">$- (1 - \\rho)^{2}(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;)\\rho^{2}(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))</span>$</p>

    <p class="text-gray-300"><span class="math">$- \\rho^{2}(1 - \\rho - \\beta/2)(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))(1 - \\rho)^{2}(\\rho - \\beta/2)</span>$</p>

    <p class="text-gray-300"><span class="math">$- \\rho^{2}(1 - \\rho - \\beta/2)(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))(1 - \\rho)^{2}(\\rho - \\omega\\delta&#x27;)</span>$</p>

    <p class="text-gray-300">That the above is negative follows from the following four inequalities, which are all easily derived:</p>

    <p class="text-gray-300">&bull; First,</p>

    <p class="text-gray-300"><span class="math">$(1 - \\rho)^{2}(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;)\\rho(1 - \\rho - \\beta/2)(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))</span>$</p>

    <p class="text-gray-300"><span class="math">$&lt; \\rho^{2}(1 - \\rho - \\beta/2)(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))(1 - \\rho)^{2}(\\rho - \\beta/2)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\iff \\rho - \\omega\\delta&#x27; &lt; \\rho ,</span>$</p>

    <p class="text-gray-300">which holds since &omega;&delta;&prime; &gt; 0.</p>

    <p class="text-gray-300">&bull; Second,</p>

    <p class="text-gray-300"><span class="math">$(1-\\rho)^2(\\rho-\\beta/2)(\\rho-\\omega\\delta&#x27;)\\rho(1-\\rho-\\beta/2)(1-\\rho-(1-\\omega)(1-\\omega\\delta&#x27;))</span>$</p>

    <p class="text-gray-300"><span class="math">$&lt;\\rho^2(1-\\rho-\\beta/2)(1-\\rho-(1-\\omega)(1-\\omega\\delta&#x27;))(1-\\rho)^2(\\rho-\\omega\\delta&#x27;)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\iff \\rho-\\beta/2&lt;\\rho \\ ,</span>$</p>

    <p class="text-gray-300">which holds since &beta; &gt; 0.</p>

    <p class="text-gray-300">&bull; Third,</p>

    <p class="text-gray-300"><span class="math">$\\rho^{2}(1 - \\rho - \\beta/2)(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))(1 - \\rho)(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;)</span>$</p>

    <p class="text-gray-300"><span class="math">$&lt; (1 - \\rho)^{2}(\\rho - \\beta/2)(\\rho - \\delta&#x27;)\\rho^{2}(1 - \\rho - \\beta/2)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\iff 1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;) &lt; 1 - \\rho ,</span>$</p>

    <p class="text-gray-300">which holds since (1 &minus; &omega;)(1 &minus; &omega;&delta;&prime; ) &gt; 0.</p>

    <p class="text-gray-300">&bull; Lastly,</p>

    <p class="text-gray-300"><span class="math">$\\rho^{2}(1 - \\rho - \\beta/2)(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))(1 - \\rho)(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;)</span>$</p>

    <p class="text-gray-300"><span class="math">$&lt; (1 - \\rho)^{2}(\\rho - \\beta/2)(\\rho - \\omega\\delta&#x27;)\\rho^{2}(1 - \\rho - (1 - \\omega)(1 - \\omega\\delta&#x27;))</span>$</p>

    <p class="text-gray-300"><span class="math">$\\iff 1 - \\rho - \\beta/2 &lt; 1 - \\rho,</span>$</p>

    <p class="text-gray-300">which again holds since &beta; &gt; 0.</p>

    <p class="text-gray-300">Thus, the second derivative of &tau; is negative on the domain (max{&delta;, &beta;/2}, min{&omega;(1 + &delta; &prime; &minus; &omega;&delta;&prime; ), 1 &minus; &beta;/2}), implying that &tau; is concave, as claimed.</p>

    <p class="text-gray-300">The idea now is to provide an argument analogous to the end of the proof of <a href="#page-54-1">Proposition 9.6.</a> Namely, we argue that either a maximizer for F (with &rho; &prime; fixed to &omega;&delta;&prime; ) on the relevant domain occurs at a critical point (in which case we have either set &delta; or &delta; &prime; too large), or that the &quot;smallest&quot; point is the maximizer. In our case, since &rho; &ge; &delta;, this minimum value would be (r/n, r/(2n), &delta;,). However, we cannot fully establish this, so we leave the following conjecture.</p>

    <p class="text-gray-300">Conjecture 9.19. The maximum value for F over the set of all (&alpha;, &beta;, &rho;, &omega;&delta;&prime; ) for which</p>

    <p class="text-gray-300"><span class="math">$\\beta \\le \\alpha/2, \\ \\frac{\\alpha}{2} \\le 1 - \\beta, \\ \\frac{\\beta}{2} \\le \\rho, \\ \\frac{\\beta}{2} &lt; 1 - \\rho\\delta</span>$
<span class="math">\\le \\rho, \\ \\rho \\le (1 - \\omega) + \\omega\\delta&#x27;</span> .</p>

    <p class="text-gray-300">either occurs at a critical point, i.e., a point (&alpha;, &beta;, &rho;, &omega;&delta;) for which <a href="#page-58-0">(19)</a>, <a href="#page-58-1">(20)</a>, and <a href="#page-73-1">(27)</a> holds; or at the point (r/n, r/(2n), &delta;, &omega;&delta;&prime; ).</p>

    <p class="text-gray-300">Assuming this conjecture, we can bound the failure probability of this second term quite naturally: namely, it will be of the form  <span class="math">\\operatorname{poly}(n)2^{Bn}</span> , where, assuming F is negative at all critical points, will be  <span class="math">F(r/n, r/(2n), \\delta, \\omega \\delta&#x27;)</span>  for large enough n. This term is actually of the order  <span class="math">-\\Omega(1)</span> , so the failure probability would be something like  <span class="math">2^{-\\Omega(n)}</span> . By combining this with the bound from the RAA code generation procedure &ndash; i.e., the probability that the RAA code prior to puncturing has minimum distance less than d &ndash; we can obtain meaningful bounds on the probability that a random punctured RAA code has minimum distance at most  <span class="math">\\delta&#x27;</span> , which we recorded in Figure 2.</p>

    <p class="text-gray-300">Lastly, we indicate that we can still run tests on the sampled RAA code, and correspondingly decrease the value of the first term. Thus, with an  <span class="math">\\tilde{O}(n^w)</span>  generation procedure, the failure probability will thus be  <span class="math">O(n^{-(w+1)(\\frac{r}{2}-1)+\\gamma})</span> .</p>

    <p class="text-gray-300">We thank Alex Block for helpful clarifications about [BGK<sup>+</sup>23] and Yuval Ishai for useful discussions on RAA codes. B. Chen was funded by DARPA, the Simons Foundation, UBRI, and NTT Research. Opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of DARPA. N. Resch is supported by an NWO (Dutch Research Council) grant with number C.2324.0590. This work was done in part while N. Resch was visiting the Simons Institute for the Theory of Computing, supported by DOE grant #DE-SC0024124.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">[ACFY24] Gal Arnon, Alessandro Chiesa, Giacomo Fenzi, and Eylon Yogev. STIR: Reed-Solomon proximity testing with fewer queries. In Leonid Reyzin and Douglas Stebila, editors, Advances in Cryptology - CRYPTO 2024 - 44th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 18-22, 2024, Proceedings, Part X, volume 14929 of Lecture Notes in Computer Science, pages 380-413. Springer, 2024. 1, 11</p></li>
      <li><p class="text-gray-300">[AER24] Guillermo Angeris, Alex Evans, and Gyumin Roh. A note on Ligero and logarithmic randomness. Cryptology ePrint Archive, Paper 2024/1399, 2024. 33</p></li>
      <li><p class="text-gray-300">[AFLN24] Martin R Albrecht, Giacomo Fenzi, Oleksandra Lapiha, and Ngoc Khanh Nguyen. Slap: succinct lattice-based polynomial commitments from standard assumptions. In Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages 90&ndash;119. Springer, 2024. 12</p></li>
      <li><p class="text-gray-300">[AHIV23] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. Ligero: lightweight sublinear arguments without a trusted setup. <em>Des. Codes Cryptogr.</em>, 91(11):3379&ndash;3424, 2023. 4, 5, 6, 10, 11, 15</p></li>
      <li><p class="text-gray-300">[AS92] Sanjeev Arora and Shmuel Safra. Probabilistic checking of proofs; A new characterization of NP. In 33rd Annual Symposium on Foundations of Computer Science, Pittsburgh, Pennsylvania, USA, 24-27 October 1992, pages 2&ndash;13. IEEE Computer Society, 1992. 11</p></li>
      <li><p class="text-gray-300">[AST24] Arasu Arun, Srinath T. V. Setty, and Justin Thaler. Jolt: SNARKs for virtual machines via lookups. In Marc Joye and Gregor Leander, editors, Advances in Cryptology - EUROCRYPT 2024 - 43rd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zurich, Switzerland, May 26-30, 2024, Proceedings, Part VI, volume 14656 of Lecture Notes in Computer Science, pages 3&ndash;33. Springer, 2024. <a href="#page-0-0">1</a></p></li>
      <li><p class="text-gray-300">[BBB+18] Benedikt B&uml;unz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Gregory Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In 2018 IEEE Symposium on Security and Privacy, SP 2018, Proceedings, 21-23 May 2018, San Francisco, California, USA, pages 315&ndash;334. IEEE Computer Society, 2018. <a href="#page-12-0">11</a></p></li>
      <li><p class="text-gray-300">[BBHR18a] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Fast Reed-Solomon interactive oracle proofs of proximity. In Ioannis Chatzigiannakis, Christos Kaklamanis, D&acute;aniel Marx, and Donald Sannella, editors, 45th International Colloquium on Automata, Languages, and Programming, ICALP 2018, July 9-13, 2018, Prague, Czech Republic, volume 107 of LIPIcs, pages 14:1&ndash;14:17. Schloss Dagstuhl - Leibniz-Zentrum f&uml;ur Informatik, 2018. <a href="#page-0-0">1,</a> <a href="#page-37-2">36</a></p></li>
      <li><p class="text-gray-300">[BBHR18b] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. IACR Cryptol. ePrint Arch., page 46, 2018. <a href="#page-0-0">1</a></p></li>
      <li><p class="text-gray-300">[BBHV22] Laasya Bangalore, Rishabh Bhadauria, Carmit Hazay, and Muthuramakrishnan Venkitasubramaniam. On black-box constructions of time and space efficient sublinear arguments from symmetric-key primitives. In Eike Kiltz and Vinod Vaikuntanathan, editors, Theory of Cryptography - 20th International Conference, TCC 2022, Chicago, IL, USA, November 7-10, 2022, Proceedings, Part I, volume 13747 of Lecture Notes in Computer Science, pages 417&ndash;446. Springer, 2022. <a href="#page-13-4">12</a></p></li>
      <li><p class="text-gray-300">[BC24] Dan Boneh and Binyi Chen. LatticeFold: A lattice-based folding scheme and its applications to succinct proof systems. Cryptology ePrint Archive, Paper 2024/257, 2024. <a href="#page-13-4">12</a></p></li>
      <li><p class="text-gray-300">[BCC+16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In Marc Fischlin and Jean-S&acute;ebastien Coron, editors, Advances in Cryptology - EURO-CRYPT 2016 - 35th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Vienna, Austria, May 8-12, 2016, Proceedings, Part II, volume 9666 of Lecture Notes in Computer Science, pages 327&ndash;357. Springer, 2016. <a href="#page-12-0">11</a></p></li>
      <li><p class="text-gray-300">[BCG+17] Jonathan Bootle, Andrea Cerulli, Essam Ghadafi, Jens Groth, Mohammad Hajiabadi, and Sune K. Jakobsen. Linear-time zero-knowledge proofs for arithmetic circuit satisfiability. In Tsuyoshi Takagi and Thomas Peyrin, editors, Advances in Cryptology - ASIACRYPT 2017 - 23rd International Conference on the Theory and Applications of Cryptology and Information Security, Hong Kong, China, December 3-7, 2017, Proceedings, Part III, volume 10626 of Lecture Notes in Computer Science, pages 336&ndash;365. Springer, 2017. <a href="#page-5-3">4</a></p></li>
      <li><p class="text-gray-300">[BCG20] Jonathan Bootle, Alessandro Chiesa, and Jens Groth. Linear-time arguments with sublinear verification from tensor codes. In Rafael Pass and Krzysztof Pietrzak, editors, Theory of Cryptography - 18th International Conference, TCC 2020, Durham, NC, USA, November 16-19, 2020, Proceedings, Part II, volume 12551 of Lecture Notes in Computer Science, pages 19&ndash;46. Springer, 2020. <a href="#page-1-0">2,</a> <a href="#page-5-3">4,</a> <a href="#page-15-2">14</a></p></li>
      <li><p class="text-gray-300">[BCG+22] Elette Boyle, Geoffroy Couteau, Niv Gilboa, Yuval Ishai, Lisa Kohl, Nicolas Resch, and Peter Scholl. Correlated pseudorandomness from expand-accumulate codes. In Yevgeniy Dodis and Thomas Shrimpton, editors, Advances in Cryptology - CRYPTO 2022 - 42nd Annual International Cryptology Conference, CRYPTO 2022, Santa Barbara, CA, USA, August 15-18, 2022, Proceedings, Part II, volume 13508 of Lecture Notes in Computer Science, pages 603&ndash;633. Springer, 2022. <a href="#page-1-0">2,</a> <a href="#page-5-3">4,</a> <a href="#page-9-3">8,</a> <a href="#page-11-1">10</a></p></li>
      <li><p class="text-gray-300">[BCG+23] Elette Boyle, Geoffroy Couteau, Niv Gilboa, Yuval Ishai, Lisa Kohl, Nicolas Resch, and Peter Scholl. Oblivious transfer with constant computational overhead. In Carmit Hazay and Martijn Stam, editors, Advances in Cryptology - EUROCRYPT 2023 - 42nd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Lyon, France, April 23-27, 2023, Proceedings, Part I, volume 14004 of Lecture Notes in Computer Science, pages 271&ndash;302. Springer, 2023. <a href="#page-1-0">2</a></p></li>
      <li><p class="text-gray-300">[BCHO22] Jonathan Bootle, Alessandro Chiesa, Yuncong Hu, and Michele Orr\`u. Gemini: Elastic SNARKs for diverse environments. In Orr Dunkelman and Stefan Dziembowski, editors, Advances in Cryptology - EUROCRYPT 2022 - 41st Annual International Conference on the Theory and Applications of Cryptographic Techniques, Trondheim, Norway, May 30 - June 3, 2022, Proceedings, Part II, volume 13276 of Lecture Notes in Computer Science, pages 427&ndash;457. Springer, 2022. <a href="#page-13-4">12</a></p></li>
      <li><p class="text-gray-300">[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In Martin Hirt and Adam D. Smith, editors, Theory of Cryptography - 14th International Conference, TCC 2016-B, Beijing, China, October 31 - November 3, 2016, Proceedings, Part II, volume 9986 of Lecture Notes in Computer Science, pages 31&ndash;60, 2016. <a href="#page-4-2">3,</a> <a href="#page-6-0">5,</a> <a href="#page-14-2">13,</a> <a href="#page-20-2">19</a></p></li>
      <li><p class="text-gray-300">[BFK+24] Alexander R Block, Zhiyong Fang, Jonathan Katz, Justin Thaler, Hendrik Waldner, and Yupeng Zhang. Field-agnostic SNARKs from expand-accumulate codes. In Annual International Cryptology Conference, pages 276&ndash;307. Springer, 2024. <a href="#page-1-0">2,</a> <a href="#page-10-0">9,</a> <a href="#page-11-1">10,</a> <a href="#page-12-0">11,</a> <a href="#page-42-3">41</a></p></li>
      <li><p class="text-gray-300">[BFS20] Benedikt B&uml;unz, Ben Fisch, and Alan Szepieniec. Transparent SNARKs from DARK compilers. In Anne Canteaut and Yuval Ishai, editors, Advances in Cryptology - EURO-CRYPT 2020 - 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zagreb, Croatia, May 10-14, 2020, Proceedings, Part I, volume 12105 of Lecture Notes in Computer Science, pages 677&ndash;706. Springer, 2020. <a href="#page-15-2">14</a></p></li>
      <li><p class="text-gray-300">[BGG+88] Michael Ben-Or, Oded Goldreich, Shafi Goldwasser, Johan H&#730;astad, Joe Kilian, Silvio Micali, and Phillip Rogaway. Everything provable is provable in zero-knowledge. In Shafi Goldwasser, editor, Advances in Cryptology - CRYPTO '88, 8th Annual International Cryptology Conference, Santa Barbara, California, USA, August 21-25, 1988,</p></li>
      <li><p class="text-gray-300">Proceedings, volume 403 of Lecture Notes in Computer Science, pages 37&ndash;56. Springer, 1988. <a href="#page-4-2">3</a></p></li>
      <li><p class="text-gray-300">[BGH+06] Eli Ben-Sasson, Oded Goldreich, Prahladh Harsha, Madhu Sudan, and Salil P. Vadhan. Robust PCPs of proximity, shorter PCPs, and applications to coding. SIAM J. Comput., 36(4):889&ndash;974, 2006. <a href="#page-12-0">11</a></p></li>
      <li><p class="text-gray-300">[BGK+23] Alexander R. Block, Albert Garreta, Jonathan Katz, Justin Thaler, Pratyush Ranjan Tiwari, and Michal Zajac. Fiat-Shamir security of FRI and related SNARKs. In Advances in Cryptology - ASIACRYPT 2023 - 29th International Conference on the Theory and Application of Cryptology and Information Security, Guangzhou, China, December 4-8, 2023, Proceedings, Part II, volume 14439, pages 3&ndash;40. Springer, 2023. <a href="#page-75-5">74,</a> <a href="#page-85-1">84</a></p></li>
      <li><p class="text-gray-300">[BGKS20] Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, and Shubhangi Saraf. DEEP-FRI: sampling outside the box improves soundness. In Thomas Vidick, editor, 11th Innovations in Theoretical Computer Science Conference, ITCS 2020, January 12-14, 2020, Seattle, Washington, USA, volume 151 of LIPIcs, pages 5:1&ndash;5:32. Schloss Dagstuhl - Leibniz-Zentrum f&uml;ur Informatik, 2020. <a href="#page-0-0">1,</a> <a href="#page-40-1">39</a></p></li>
      <li><p class="text-gray-300">[BHR+20] Alexander R. Block, Justin Holmgren, Alon Rosen, Ron D. Rothblum, and Pratik Soni. Public-coin zero-knowledge arguments with (almost) minimal time and space overheads. In Rafael Pass and Krzysztof Pietrzak, editors, Theory of Cryptography - 18th International Conference, TCC 2020, Durham, NC, USA, November 16-19, 2020, Proceedings, Part II, volume 12551 of Lecture Notes in Computer Science, pages 168&ndash;197. Springer, 2020. <a href="#page-13-4">12</a></p></li>
      <li><p class="text-gray-300">[BHR+21] Alexander R. Block, Justin Holmgren, Alon Rosen, Ron D. Rothblum, and Pratik Soni. Time- and space-efficient arguments from groups of unknown order. In Tal Malkin and Chris Peikert, editors, Advances in Cryptology - CRYPTO 2021 - 41st Annual International Cryptology Conference, CRYPTO 2021, Virtual Event, August 16-20, 2021, Proceedings, Part IV, volume 12828 of Lecture Notes in Computer Science, pages 123&ndash;152. Springer, 2021. <a href="#page-13-4">12</a></p></li>
      <li><p class="text-gray-300">[BKS18] Eli Ben-Sasson, Swastik Kopparty, and Shubhangi Saraf. Worst-case to average case reductions for the distance to a code. In Rocco A. Servedio, editor, 33rd Computational Complexity Conference, CCC 2018, June 22-24, 2018, San Diego, CA, USA, volume 102 of LIPIcs, pages 24:1&ndash;24:23. Schloss Dagstuhl - Leibniz-Zentrum f&uml;ur Informatik, 2018. <a href="#page-11-1">10,</a> <a href="#page-16-4">15</a></p></li>
      <li><p class="text-gray-300">[BMS08] Louay Bazzi, Mohammad Mahdian, and Daniel A Spielman. The minimum distance of turbo-like codes. IEEE Transactions on Information Theory, 55(1):6&ndash;15, 2008. <a href="#page-4-2">3,</a> <a href="#page-8-2">7,</a> <a href="#page-9-3">8,</a> <a href="#page-43-3">42</a></p></li>
      <li><p class="text-gray-300">[BS23] Ward Beullens and Gregor Seiler. Labrador: compact proofs for r1cs from module-sis. In Annual International Cryptology Conference - CRYPTO, pages 518&ndash;548. Springer, 2023. <a href="#page-13-4">12</a></p></li>
      <li><p class="text-gray-300">[BSCI+20] Eli Ben-Sasson, Dan Carmon, Yuval Ishai, Swastik Kopparty, and Shubhangi Saraf. Proximity gaps for Reed&ndash;Solomon codes. In 2020 IEEE 61st Annual Symposium on Foundations of Computer Science (FOCS), pages 900&ndash;909. IEEE, 2020. <a href="#page-7-2">6,</a> <a href="#page-12-0">11,</a> <a href="#page-23-4">22,</a> <a href="#page-40-1">39</a></p></li>
      <li><p class="text-gray-300">[CBBZ23] Binyi Chen, Benedikt B&uml;unz, Dan Boneh, and Zhenfei Zhang. Hyperplonk: Plonk with linear-time prover and high-degree custom gates. In 42nd Annual International Conference on Theory and Applications of Cryptographic Techniques, EUROCRYPT 2023, pages 499&ndash;530. Springer Science and Business Media Deutschland GmbH, 2023. <a href="#page-0-0">1,</a> <a href="#page-10-0">9,</a> <a href="#page-12-0">11,</a> <a href="#page-14-2">13,</a> <a href="#page-23-4">22,</a> <a href="#page-28-3">27,</a> <a href="#page-84-1">83</a></p></li>
      <li><p class="text-gray-300">[CCH+19] Ran Canetti, Yilei Chen, Justin Holmgren, Alex Lombardi, Guy N Rothblum, Ron D Rothblum, and Daniel Wichs. Fiat-Shamir: from practice to theory. In Proceedings of the 51st Annual ACM SIGACT Symposium on Theory of Computing, pages 1082&ndash;1090, 2019. <a href="#page-21-4">20,</a> <a href="#page-83-7">82,</a> <a href="#page-84-1">83,</a> <a href="#page-85-1">84</a></p></li>
      <li><p class="text-gray-300">[CFFZ24] Alessandro Chiesa, Elisabetta Fedele, Giacomo Fenzi, and Andrew Zitek-Estrada. A time-space tradeoff for the sumcheck prover. IACR Cryptol. ePrint Arch., page 524, 2024. <a href="#page-13-4">12</a></p></li>
      <li><p class="text-gray-300">[CHM+20] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas Ward. Marlin: Preprocessing zkSNARKs with universal and updatable SRS. In Advances in Cryptology&ndash;EUROCRYPT 2020: 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zagreb, Croatia, May 10&ndash;14, 2020, Proceedings, Part I 39, pages 738&ndash;768. Springer, 2020. <a href="#page-15-2">14</a></p></li>
      <li><p class="text-gray-300">[CMNW24] Valerio Cini, Giulio Malavolta, Ngoc Khanh Nguyen, and Hoeteck Wee. Polynomial commitments from lattices: post-quantum security, fast verification and transparent setup. In Annual International Cryptology Conference - CRYPTO, pages 207&ndash;242. Springer, 2024. <a href="#page-13-4">12</a></p></li>
      <li><p class="text-gray-300">[CMS19] Alessandro Chiesa, Peter Manohar, and Nicholas Spooner. Succinct arguments in the quantum random oracle model. In Theory of Cryptography: 17th International Conference, TCC 2019, Nuremberg, Germany, December 1&ndash;5, 2019, Proceedings, Part II 17, pages 1&ndash;29. Springer, 2019. <a href="#page-20-2">19,</a> <a href="#page-21-4">20,</a> <a href="#page-83-7">82</a></p></li>
      <li><p class="text-gray-300">[COS20] Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. Fractal: Post-quantum and transparent recursive proofs from holography. In Advances in Cryptology&ndash;EUROCRYPT 2020: 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zagreb, Croatia, May 10&ndash;14, 2020, Proceedings, Part I 39, pages 769&ndash;793. Springer, 2020. <a href="#page-14-2">13,</a> <a href="#page-20-2">19,</a> <a href="#page-83-7">82</a></p></li>
      <li><p class="text-gray-300">[CY24] Alessandro Chiesa and Eylon Yogev. Building Cryptographic Proofs from Hash Functions. 2024. <a href="#page-4-2">3</a></p></li>
      <li><p class="text-gray-300">[dHS24] Thomas den Hollander and Daniel Slamanig. A crack in the firmament: Restoring soundness of the Orion proof system and more. Cryptology ePrint Archive, Paper 2024/1164, 2024. <a href="#page-12-0">11</a></p></li>
      <li><p class="text-gray-300">[DJM98] Dariush Divsalar, Hui Jin, and Robert J McEliece. Coding theorems for &quot;turbo-like&quot; codes. In Proceedings of the annual Allerton Conference on Communication control and Computing, volume 36, pages 201&ndash;210. University Of Illinois, 1998. <a href="#page-8-2">7,</a> <a href="#page-42-3">41</a></p></li>
      <li><p class="text-gray-300">[DP23] Benjamin E. Diamond and Jim Posen. Succinct arguments over towers of binary fields. IACR Cryptol. ePrint Arch., page 1784, 2023. <a href="#page-0-0">1,</a> <a href="#page-10-0">9,</a> <a href="#page-11-1">10,</a> <a href="#page-12-0">11</a></p></li>
      <li><p class="text-gray-300">[DP24a] Benjamin E. Diamond and Jim Posen. Polylogarithmic proofs for multilinears over binary towers. Cryptology ePrint Archive, Paper 2024/504, 2024. <a href="https://eprint.iacr.org/2024/504" target="_blank" rel="noopener noreferrer">https://eprint.</a> <a href="https://eprint.iacr.org/2024/504" target="_blank" rel="noopener noreferrer">iacr.org/2024/504</a>. <a href="#page-0-0">1,</a> <a href="#page-6-0">5,</a> <a href="#page-10-0">9,</a> <a href="#page-12-0">11,</a> <a href="#page-21-4">20,</a> <a href="#page-38-4">37</a></p></li>
      <li><p class="text-gray-300">[DP24b] Benjamin E. Diamond and Jim Posen. Proximity testing with logarithmic randomness. IACR Commun. Cryptol., 1(1):2, 2024. <a href="#page-34-2">33</a></p></li>
      <li><p class="text-gray-300">[FPP24] Cody Freitag, Omer Paneth, and Rafael Pass. Public-coin, complexity-preserving, succinct arguments of knowledge for NP from collision-resistance. In Marc Joye and Gregor Leander, editors, Advances in Cryptology - EUROCRYPT 2024 - 43rd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zurich, Switzerland, May 26-30, 2024, Proceedings, Part IV, volume 14654 of Lecture Notes in Computer Science, pages 112&ndash;141. Springer, 2024. <a href="#page-13-4">12</a></p></li>
      <li><p class="text-gray-300">[FS86] Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Andrew M. Odlyzko, editor, Advances in Cryptology - CRYPTO '86, Santa Barbara, California, USA, 1986, Proceedings, volume 263 of Lecture Notes in Computer Science, pages 186&ndash;194. Springer, 1986. <a href="#page-0-0">1,</a> <a href="#page-4-2">3</a></p></li>
      <li><p class="text-gray-300">[GKR15] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. Delegating computation: Interactive proofs for muggles. J. ACM, 62(4):27:1&ndash;27:64, 2015. <a href="#page-0-0">1,</a> <a href="#page-32-2">31</a></p></li>
      <li><p class="text-gray-300">[GLS+23] Alexander Golovnev, Jonathan Lee, Srinath Setty, Justin Thaler, and Riad S Wahby. Brakedown: Linear-time and field-agnostic SNARKs for R1CS. In Annual International Cryptology Conference, pages 193&ndash;226, 2023. <a href="#page-1-0">2,</a> <a href="#page-4-2">3,</a> <a href="#page-5-3">4,</a> <a href="#page-6-0">5,</a> <a href="#page-11-1">10,</a> <a href="#page-12-0">11,</a> <a href="#page-37-2">36</a></p></li>
      <li><p class="text-gray-300">[GMR89] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof systems. SIAM J. Comput., 18(1):186&ndash;208, 1989. <a href="#page-13-4">12</a></p></li>
      <li><p class="text-gray-300">[GR17] Tom Gur and Ron D. Rothblum. A hierarchy theorem for interactive proofs of proximity. In Christos H. Papadimitriou, editor, 8th Innovations in Theoretical Computer Science Conference, ITCS 2017, January 9-11, 2017, Berkeley, CA, USA, volume 67 of LIPIcs, pages 39:1&ndash;39:43. Schloss Dagstuhl - Leibniz-Zentrum f&uml;ur Informatik, 2017. <a href="#page-14-2">13</a></p></li>
      <li><p class="text-gray-300">[HLP24] Ulrich Hab&uml;ock, David Levit, and Shahar Papini. Circle STARKs. IACR Cryptol. ePrint Arch., page 278, 2024. <a href="#page-0-0">1,</a> <a href="#page-12-0">11</a></p></li>
      <li><p class="text-gray-300">[HR18] Justin Holmgren and Ron D. Rothblum. Delegating computations with (almost) minimal time and space overhead. In Mikkel Thorup, editor, 59th IEEE Annual Symposium on Foundations of Computer Science, FOCS 2018, Paris, France, October 7-9, 2018, pages 124&ndash;135. IEEE Computer Society, 2018. <a href="#page-27-1">26</a></p></li>
      <li><p class="text-gray-300">[HR22] Justin Holmgren and Ron D. Rothblum. Faster sounder succinct arguments and IOPs. In Yevgeniy Dodis and Thomas Shrimpton, editors, Advances in Cryptology - CRYPTO 2022 - 42nd Annual International Cryptology Conference, CRYPTO 2022, Santa Barbara, CA, USA, August 15-18, 2022, Proceedings, Part I, volume 13507 of Lecture Notes in Computer Science, pages 474&ndash;503. Springer, 2022. <a href="#page-5-3">4</a></p></li>
      <li><p class="text-gray-300">[HSS24] Intak Hwang, Jinyeong Seo, and Yongsoo Song. Concretely efficient lattice-based polynomial commitment from standard assumptions. In Annual International Cryptology Conference - CRYPTO, pages 414&ndash;448. Springer, 2024. <a href="#page-13-4">12</a></p></li>
      <li><p class="text-gray-300">[Kil92] Joe Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In S. Rao Kosaraju, Mike Fellows, Avi Wigderson, and John A. Ellis, editors, Proceedings of the 24th Annual ACM Symposium on Theory of Computing, May 4-6, 1992, Victoria, British Columbia, Canada, pages 723&ndash;732. ACM, 1992. <a href="#page-4-2">3</a></p></li>
      <li><p class="text-gray-300">[KPV22] Assimakis A Kattis, Konstantin Panarin, and Alexander Vlasov. RedShift: transparent SNARKs from list polynomial commitments. In Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security, 2022. <a href="#page-6-0">5</a></p></li>
      <li><p class="text-gray-300">[KT23] Tohru Kohrita and Patrick Towa. Zeromorph: Zero-knowledge multilinear-evaluation proofs from homomorphic univariate commitments. Cryptology ePrint Archive, 2023:917, 2023. <a href="#page-37-2">36</a></p></li>
      <li><p class="text-gray-300">[KZCJ07] J&uml;org Kliewer, Kamil S Zigangirov, and Daniel J Costello Jr. New results on the minimum distance of repeat multiple accumulate codes. In Proc. 45th Annual Allerton Conf. Commun., Control, and Computing, 2007. <a href="#page-4-2">3,</a> <a href="#page-8-2">7,</a> <a href="#page-9-3">8,</a> <a href="#page-18-3">17,</a> <a href="#page-43-3">42</a></p></li>
      <li><p class="text-gray-300">[KZG10] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-size commitments to polynomials and their applications. In Masayuki Abe, editor, Advances in Cryptology - ASIACRYPT 2010 - 16th International Conference on the Theory and Application of Cryptology and Information Security, Singapore, December 5-9, 2010. Proceedings, volume 6477 of Lecture Notes in Computer Science, pages 177&ndash;194. Springer, 2010. <a href="#page-12-0">11</a></p></li>
      <li><p class="text-gray-300">[KZKJ08] J&uml;org Kliewer, Kamil S. Zigangirov, Christian Koller, and Daniel J. Costello Jr. Coding theorems for repeat multiple accumulate codes, 2008. <a href="#page-18-3">17,</a> <a href="#page-43-3">42,</a> <a href="#page-50-1">49,</a> <a href="#page-51-2">50,</a> <a href="#page-52-0">51,</a> <a href="#page-53-2">52,</a> <a href="#page-58-4">57,</a> <a href="#page-71-3">70,</a> <a href="#page-72-1">71,</a> <a href="#page-73-2">72</a></p></li>
      <li><p class="text-gray-300">[Lee20] Jonathan Lee. Dory: Efficient, transparent arguments for generalised inner products and polynomial commitments. IACR Cryptol. ePrint Arch., page 1274, 2020. <a href="#page-12-0">11</a></p></li>
      <li><p class="text-gray-300">[LF80] Richard E. Ladner and Michael J. Fischer. Parallel prefix computation. J. ACM, 27(4):831&ndash;838, 1980. <a href="#page-8-2">7</a></p></li>
      <li><p class="text-gray-300">[LFKN92] Carsten Lund, Lance Fortnow, Howard J. Karloff, and Noam Nisan. Algebraic methods for interactive proof systems. J. ACM, 39(4):859&ndash;868, 1992. <a href="#page-5-3">4,</a> <a href="#page-14-2">13</a></p></li>
      <li><p class="text-gray-300">[Mei13] Or Meir. IP = PSPACE using error-correcting codes. SIAM J. Comput., 42(1):380&ndash; 403, 2013. <a href="#page-5-3">4</a></p></li>
      <li><p class="text-gray-300">[Mic00] Silvio Micali. Computationally sound proofs. SIAM J. Comput., 30(4):1253&ndash;1298, 2000. <a href="#page-4-2">3</a></p></li>
      <li><p class="text-gray-300">[NS24] Ngoc Khanh Nguyen and Gregor Seiler. Greyhound: Fast polynomial commitments from lattices. In Annual International Cryptology Conference - CRYPTO, pages 243&ndash; 275. Springer, 2024. <a href="#page-13-4">12</a></p></li>
      <li><p class="text-gray-300">[Rot24] Ron D. Rothblum. A note on efficient computation of the multilinear extension. Cryptology ePrint Archive, Paper 2024/1103, 2024. <a href="https://eprint.iacr.org/2024/1103" target="_blank" rel="noopener noreferrer">https://eprint.iacr.org/2024/</a> <a href="https://eprint.iacr.org/2024/1103" target="_blank" rel="noopener noreferrer">1103</a>. <a href="#page-13-4">12</a></p></li>
      <li><p class="text-gray-300">[RR22] Noga Ron-Zewi and Ron D. Rothblum. Proving as fast as computing: succinct arguments with constant prover overhead. In Stefano Leonardi and Anupam Gupta, editors, STOC '22: 54th Annual ACM SIGACT Symposium on Theory of Computing, Rome, Italy, June 20 - 24, 2022, pages 1353&ndash;1363. ACM, 2022. <a href="#page-5-3">4</a></p></li>
      <li><p class="text-gray-300">[RR24] Noga Ron-Zewi and Ron Rothblum. Local proofs approaching the witness length. J. ACM, 71(3):18, 2024. <a href="#page-0-0">1,</a> <a href="#page-5-3">4,</a> <a href="#page-14-2">13</a></p></li>
      <li><p class="text-gray-300">[RRR16] Omer Reingold, Ron D. Rothblum, and Guy N. Rothblum. Constant-round interactive proofs for delegating computation. Electron. Colloquium Comput. Complex., TR16- 061, 2016. <a href="#page-6-0">5,</a> <a href="#page-14-2">13,</a> <a href="#page-15-2">14</a></p></li>
      <li><p class="text-gray-300">[RVW13] Guy N. Rothblum, Salil P. Vadhan, and Avi Wigderson. Interactive proofs of proximity: delegating computation in sublinear time. In Dan Boneh, Tim Roughgarden, and Joan Feigenbaum, editors, Symposium on Theory of Computing Conference, STOC'13, Palo Alto, CA, USA, June 1-4, 2013, pages 793&ndash;802. ACM, 2013. <a href="#page-7-2">6,</a> <a href="#page-16-4">15</a></p></li>
      <li><p class="text-gray-300">[Set20] Srinath T. V. Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In Daniele Micciancio and Thomas Ristenpart, editors, Advances in Cryptology - CRYPTO 2020 - 40th Annual International Cryptology Conference, CRYPTO 2020, Santa Barbara, CA, USA, August 17-21, 2020, Proceedings, Part III, volume 12172 of Lecture Notes in Computer Science, pages 704&ndash;737. Springer, 2020. <a href="#page-0-0">1</a></p></li>
      <li><p class="text-gray-300">[SL20] Srinath T. V. Setty and Jonathan Lee. Quarks: Quadruple-efficient transparent zk-SNARKs. IACR Cryptol. ePrint Arch., page 1275, 2020. <a href="#page-10-0">9,</a> <a href="#page-28-3">27</a></p></li>
      <li><p class="text-gray-300">[Spi96] Daniel A. Spielman. Linear-time encodable and decodable error-correcting codes. IEEE Trans. Inf. Theory, 42(6):1723&ndash;1731, 1996. <a href="#page-1-0">2</a></p></li>
      <li><p class="text-gray-300">[Sta23] StarkWare. ethSTARK documentation. Cryptology ePrint Archive, Paper 2021/582, 2023. <a href="#page-85-1">84</a></p></li>
      <li><p class="text-gray-300">[STW24] Srinath T. V. Setty, Justin Thaler, and Riad S. Wahby. Unlocking the lookup singularity with Lasso. In Marc Joye and Gregor Leander, editors, Advances in Cryptology - EUROCRYPT 2024 - 43rd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zurich, Switzerland, May 26-30, 2024, Proceedings, Part VI, volume 14656 of Lecture Notes in Computer Science, pages 180&ndash;209. Springer, 2024. <a href="#page-0-0">1</a></p></li>
      <li><p class="text-gray-300">[Tha13] Justin Thaler. Time-optimal interactive proofs for circuit evaluation. In Ran Canetti and Juan A. Garay, editors, Advances in Cryptology - CRYPTO 2013 - 33rd Annual Cryptology Conference, Santa Barbara, CA, USA, August 18-22, 2013. Proceedings, Part II, volume 8043 of Lecture Notes in Computer Science, pages 71&ndash;89. Springer, 2013. <a href="#page-14-2">13</a></p></li>
      <li><p class="text-gray-300">[Tha22] Justin Thaler. Proofs, arguments, and zero-knowledge. Found. Trends Priv. Secur., 4(2-4):117&ndash;660, 2022. <a href="#page-13-4">12,</a> <a href="#page-32-2">31</a></p></li>
      <li><p class="text-gray-300">[VSBW13] Victor Vu, Srinath T. V. Setty, Andrew J. Blumberg, and Michael Walfish. A hybrid architecture for interactive verifiable computation. In 2013 IEEE Symposium on Security and Privacy, SP 2013, Berkeley, CA, USA, May 19-22, 2013, pages 223&ndash;237. IEEE Computer Society, 2013. <a href="#page-13-4">12</a></p></li>
      <li><p class="text-gray-300">[WTS+18] Riad S. Wahby, Ioanna Tzialla, Abhi Shelat, Justin Thaler, and Michael Walfish. Doubly-efficient zkSNARKs without trusted setup. In 2018 IEEE Symposium on Security and Privacy, SP 2018, Proceedings, 21-23 May 2018, San Francisco, California, USA, pages 926&ndash;943. IEEE Computer Society, 2018. <a href="#page-12-0">11</a></p></li>
      <li><p class="text-gray-300">[XZS22] Tiancheng Xie, Yupeng Zhang, and Dawn Song. Orion: Zero knowledge proof with linear prover time. In Yevgeniy Dodis and Thomas Shrimpton, editors, Advances in Cryptology - CRYPTO 2022 - 42nd Annual International Cryptology Conference, CRYPTO 2022, Santa Barbara, CA, USA, August 15-18, 2022, Proceedings, Part IV, volume 13510 of Lecture Notes in Computer Science, pages 299&ndash;328. Springer, 2022. <a href="#page-1-0">2,</a> <a href="#page-4-2">3,</a> <a href="#page-12-0">11</a></p></li>
      <li><p class="text-gray-300">[ZCF24] Hadas Zeilberger, Binyi Chen, and Ben Fisch. Basefold: Efficient field-agnostic polynomial commitment schemes from foldable codes. In Leonid Reyzin and Douglas Stebila, editors, Advances in Cryptology - CRYPTO 2024 - 44th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 18-22, 2024, Proceedings, Part X, volume 14929 of Lecture Notes in Computer Science, pages 138&ndash;169. Springer, 2024. <a href="#page-0-0">1,</a> <a href="#page-6-0">5,</a> <a href="#page-10-0">9,</a> <a href="#page-12-0">11,</a> <a href="#page-21-4">20,</a> <a href="#page-37-2">36</a></p></li>
    </ul>

    <p class="text-gray-300">In this section, we sketch the proof idea of the round-by-round soundness of the IOPP for RMLE[PRAA<sup>t</sup> ]. As discussed in <a href="#page-20-0">Section 4,</a> after compiling the IOPP with Merkle commitments and the Fiat-Shamir transformation, the resulting argument preserves soundness and is therefore a polynomial commitment <a href="#page-79-8">[CMS19,</a><a href="#page-79-6">COS20]</a>.</p>

    <p class="text-gray-300">We begin by briefly reviewing the concept of round-by-round (RBR) soundness <a href="#page-79-9">[CCH</a>+19]. A public-coin interactive protocol for a language L is round-by-round sound if there exists a state function over (partial) transcripts that satisfies the following three properties. (i) If the instance x is not in L, then the initial state of the protocol is doomed, i.e., State(x, &empty;) = reject. (ii) In each round, if the current transcript is already in a doomed state, no matter how a malicious prover chooses its next message, with overwhelming probability over the verifier's challenge, the protocol state will remain doomed. (iii) If the full transcript is in a doomed state, the verifier will reject.</p>

    <p class="text-gray-300">We establish the RBR soundness of the IOPP for RMLE[PRAA<sup>t</sup> ] via the following steps:</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>1. We start by arguing the RBR soundness of the key building blocks, which include the evaluation batching protocol from Hyperplonk, the BaseFold IOPP for RMLE[RS], and the MLIOP for RMLE[PRAA] as described in <a href="#page-25-0">Section 5.</a></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Next, we argue that the MLIOP-to-IOPP transformation from <a href="#page-21-0">Section 4.1</a> preserves RBR soundness, assuming that the underlying evaluation batching protocol and the building block IOPP for RMLE[C] are RBR sound. By <a href="#page-21-3">Lemma 4.2</a> and the result in Step 1, we conclude that our IOPP for RMLE[PRAA] is RBR sound.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Finally, we show that the interleaving IOPP for RMLE[C t ] (from <a href="#page-32-1">Section 6)</a> preserves RBR soundness if the underlying IOPP for RMLE[C] is RBR sound. Building on the conclusion from Step 2, this yields the desired result that the IOPP for RMLE[PRAA<sup>t</sup> ] is RBR sound.</li>
    </ul></li>
    </ul>

      <h3 id="app-a.1" class="text-xl font-semibold mt-8">A.1 RBR Soundness of the Building Block Protocols</h3>

    <p class="text-gray-300">Evaluation batching. The evaluation batching protocol from Hyperplonk reduces t = 2<sup>&#8467;</sup> &gt; 1 multilinear evaluation claims into a single one. Let m denote the number of variables in each multilinear polynomial. The protocol begins with the verifier sampling and sending a random challenge vector r &isin; F &#8467; . This challenge reduces the t multilinear evaluation claims into a single sumcheck claim over an (m+&#8467;)-variate polynomial. The prover and the verifier then run a sumcheck protocol, which ultimately reduces the sumcheck claim to a single multilinear evaluation claim.</p>

    <p class="text-gray-300">Recall that we define the initial state as doomed if the instance x is not in L, meaning that one of the multilinear evaluation claims is false. After the verifier sends the first challenge vector r, we say that the partial transcript is doomed if and only if the resulting sumcheck claim is false wrt r and the t multilinear polynomials. It is straightforward to see that, if x /&isin; L, then with overwhelming probability over r, the sumcheck claim will be false and state remains doomed. The protocol then proceeds with the sumcheck protocol, and the round-by-round soundness follows naturally from the RBR soundness of the sumcheck protocol <a href="#page-79-9">[CCH</a>+19].</p>

    <p class="text-gray-300">The MLIOP for RMLE[PRAA]. Given the instance x := (z, v, y), the MLIOP for RMLE[PRAA] <a href="#page-25-0">(Section 5)</a> proceeds as follows:</p>

    <p class="text-gray-300">First, the prover sends polynomials &circ;m, &circ;u2, &circ;u<sup>3</sup> and &circ;u<sup>4</sup> to the verifier. Let &circ;u<sup>1</sup> denote the polynomial representing r copies of m. We define a partial transcript state as doomed if either &circ;m(z) &#824;= v or any of the equations below is not satisfied. Note that the state will be doomed if x /&isin; L(RMLE[PRAA]).</p>

    <p class="text-gray-300"><span class="math">$u_2 = M_{\\pi_1} \\cdot u_1</span>$</p>

    <p class="text-gray-300"><span class="math">u_3 = A \\cdot u_2</span>
<span class="math">u_4 = M_{\\pi_2} \\cdot u_3</span>
<span class="math">y = A \\cdot u_4</span> .</p>

    <p class="text-gray-300">Next, the verifier samples and sends random challenges &alpha;, &beta; &isin; F, reducing the permutation relations to checking the existence of polynomials f1, g1, f2, g<sup>2</sup> that satisfy certain zero-check (or Hadamard check) relations&mdash;i.e., certain expressions evaluates to zero at every point in the boolean hypercube. The prover then provides oracles for f1, g1, f2, and g2. The doomed transcript states are redefined similarly to before, except that permutation checks are replaced by zero-checks. By the argument from <a href="#page-79-0">[CBBZ23,</a> Section 3.5], with overwhelming probability over &alpha;, &beta;, the state will remain doomed if it was initially doomed.</p>

    <p class="text-gray-300">After this, the verifier samples and sends a random challenge  <span class="math">r \\in \\mathbb{F}^{\\log n}</span>  that reduces the zero-check claims to a bunch of evaluation and sumcheck claims. The doomed transcript states are again defined similarly, now replacing the zero-checks with evaluation and sumcheck checks. By the Schwartz-Zippel lemma, with overwhelming probability over r, the state will remain doomed.</p>

    <p class="text-gray-300">Finally, the prover and the verifier run a sumcheck protocol to reduce the sumcheck claims to a single evaluation claim. The final transcript is doomed if  <span class="math">\\hat{m}(z) \\neq v</span>  or any of the evaluation claims fails. Recall that the sumcheck protocol is RBR sound, and the verifier indeed check  <span class="math">\\hat{m}(z) = v</span>  and the rest of the evaluations, thus rejecting if the final transcript is doomed. This finishes the proof.</p>

    <p class="text-gray-300">The BaseFold IOPP for  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{RS}]</span> . The BaseFold IOPP for  <span class="math">R_{\\mathsf{MLE}}[\\mathsf{RS}]</span>  works by interleaving a sumcheck protocol with a FRI-like proximity check. The proximity check ensures that the implicit input y is close to an encoding of a message m, while the sumcheck guarantees that the evaluation claim regarding m holds. This evaluation claim can be equivalently expressed as a sumcheck statement. Crucially, in each round of the BaseFold IOPP, the verifier's challenge  <span class="math">r_i</span>  serves as both the sumcheck challenge and the folding challenge in the FRI protocol, which is essential for security.</p>

    <p class="text-gray-300">We prove the RBR soundness of BaseFold by combining the strategies for proving that of sumcheck  <span class="math">[CCH^+19]</span>  and FRI  <span class="math">[BGK^+23, Sta23]</span> .</p>

    <p class="text-gray-300">For any instance  <span class="math">(z, v, y) \\notin \\mathcal{L}(R_{\\mathsf{MLE}}[\\mathsf{RS}])</span> , note that either  <span class="math">\\pi_0 := y</span>  is  <span class="math">\\delta</span> -far from codewords, or the decoded message  <span class="math">m \\in \\mathbb{F}^{2^\\ell}</span>  of y doesn't satisfy the evaluation claim  <span class="math">\\hat{m}(z) = v</span> . Here, the claim  <span class="math">\\hat{m}(z) = v</span>  can be viewed as a sumcheck statement  <span class="math">v = \\sum_b \\hat{m}(b) \\cdot \\hat{eq}_z(b)</span> .</p>

    <p class="text-gray-300">For each round  <span class="math">i \\in [1, \\ell]</span> , let  <span class="math">\\pi&#x27;_1, \\ldots, \\pi&#x27;_i</span>  denote the oracle strings sent by the prover, let  <span class="math">r_0, \\ldots, r_i</span>  be the verifier's challenges, and  <span class="math">\\pi_1, \\ldots, \\pi_i</span>  denote the honestly folded proof oracles derived from  <span class="math">\\pi_0 = y</span>  and  <span class="math">r_0, \\ldots, r_{i-1}</span> . (Note that  <span class="math">\\pi_0</span>  is  <span class="math">\\delta</span> -far by assumption.) Let  <span class="math">m_i</span>  denote the decoding of  <span class="math">\\pi&#x27;_i</span>  (or  <span class="math">\\perp</span>  if  <span class="math">\\pi&#x27;_i</span>  is  <span class="math">\\delta</span> -far). We define the partial transcript state for round i as doomed if any of the following hold: (i) fold( <span class="math">\\pi_i, r_i</span> ) is  <span class="math">\\delta</span> -far from codewords; or (ii) for some  <span class="math">j \\in [1, i]</span>  where  <span class="math">\\pi_j := \\text{fold}(\\pi_{j-1}, r_{j-1})</span>  is  <span class="math">\\delta</span> -far from codewords, it holds that  <span class="math">\\pi&#x27;_j \\neq \\pi_j</span> ; or (iii) the reduced sumcheck claim (with respect to  <span class="math">m_i</span> ) fails. By sumcheck soundness and Theorem 2.5, with overwhelming probability over the verifier's challenge, the transcript remains doomed if it initially was.</p>

    <p class="text-gray-300">At the query phase, the verifier checks the final evaluation claim and performs consistency checks as required by the FRI and sumcheck protocols. Given the FRI query challenges, we modify the definition of doomed state for the final transcript (that includes the query challenges). In particular, we additionally check the consistency of  <span class="math">\\{\\pi&#x27;_j\\}_j</span>  over the query sets. The state is also doomed if any evaluation checks fail, or if the final proof string  <span class="math">\\pi&#x27;_\\ell</span>  sent by the prover is not an RS codeword. Using similar arguments as in Lemma 5.3 and Lemma 5.4 from [BGK<sup>+</sup>23], we can show that the final transcript is doomed with overwhelming probability if it was the case previously. This concludes the proof as the verifier will reject any doomed final state.</p>

      <h3 id="app-a.2" class="text-xl font-semibold mt-8">A.2 RBR Soundness of the MLIOP-to-IOPP Transformation</h3>

    <p class="text-gray-300">We establish the RBR soundness of the MLIOP-to-IOPP transformation from Section 4, assuming that the underlying MLIOP for  <span class="math">\\mathcal{R}</span> , the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span> , and the batch evaluation protocol  <span class="math">\\Pi_{\\mathsf{batch}}</span>  are all RBR sound. To proceed, we define the set of doomed states and bound the probability of escaping the doomed set. Here, let  <span class="math">\\delta</span>  denote the proximity parameter for the building block IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span> , and set  <span class="math">\\delta&#x27; = c\\delta</span> , where c is the rate of code C.</p>

    <p class="text-gray-300">At the start of the protocol, when the transcript is empty, the state is considered doomed if the instance inst = (i, x, y) is  <span class="math">\\delta&#x27;</span> -far from any  <span class="math">(i, x, y^*) \\in \\mathcal{L}(\\mathcal{R})</span> . Initially, given the first oracle  <span class="math">\\tilde{y}</span>  sent</p>

    <p class="text-gray-300">by the prover, denote  <span class="math">\\pi_y = (y||\\tilde{y})</span> , and set y' as the decoded message of  <span class="math">\\pi_y</span>  if  <span class="math">\\pi_y</span>  is  <span class="math">\\delta</span> -close to C (otherwise, set  <span class="math">y&#x27; = \\bot</span> ). We append  <span class="math">\\pi_y</span>  to the current transcript  <span class="math">\\tau</span>  and define the state as doomed if either  <span class="math">y&#x27; = \\bot</span>  or State'(inst',  <span class="math">\\emptyset</span> ) = reject, where inst' = (i, x, y') and State' is the state function in the RBR soundness proof for the MLIOP. Clearly, if (i, x, y) is  <span class="math">\\delta&#x27;</span> -far from any  <span class="math">(i, x, y^*) \\in \\mathcal{L}(\\mathcal{R})</span>  while  <span class="math">\\pi_y</span>  is  <span class="math">\\delta</span> -close to C, then y is  <span class="math">\\delta&#x27;</span> -close to y' and inst' =  <span class="math">(i, x, y&#x27;) \\notin \\mathcal{L}(\\mathcal{R})</span> . Thus the state in the MLIOP will be doomed.</p>

    <p class="text-gray-300">For each subsequent MLIOP verifier challenge r, we append it to both the transcript  <span class="math">\\tau</span>  and the simulated transcript  <span class="math">\\tau&#x27;</span>  for the MLIOP. For every oracle  <span class="math">\\pi</span>  sent by the prover, let m be the decoded message of  <span class="math">\\pi</span>  if it is  <span class="math">\\delta</span> -close to C (set  <span class="math">m=\\bot</span>  otherwise). We append  <span class="math">\\pi</span>  to the transcript  <span class="math">\\tau</span>  and append m to the simulated transcript  <span class="math">\\tau&#x27;</span> . We say that (inst,  <span class="math">\\tau</span> ) is in a doomed state if State'(inst',  <span class="math">\\tau&#x27;</span> ) = reject. Wlog we assume that State'(inst',  <span class="math">\\tau&#x27;</span> ) is always doomed if  <span class="math">\\tau&#x27;</span>  includes any  <span class="math">\\bot</span>  symbols. By the RBR soundness of the MLIOP, the probability that a doomed transcript state escapes from the doomed set is negligible.</p>

    <p class="text-gray-300">Next, the prover and verifier run a batch evaluation protocol  <span class="math">\\Pi_{\\text{batch}}</span>  to reduce multiple evaluation claims to a single claim. We append the set of evaluation claims  <span class="math">\\text{inst}_{\\text{batch}}</span>  and the transcript  <span class="math">\\tau_{\\text{batch}}</span>  of  <span class="math">\\Pi_{\\text{batch}}</span>  to  <span class="math">\\tau</span> . We consider the transcript to be in a doomed state if  <span class="math">\\text{State}_{\\text{batch}}(\\text{inst}_{\\text{batch}}, \\tau_{\\text{batch}}) = \\text{reject}</span> , where  <span class="math">\\text{State}_{\\text{batch}}</span>  is the state function used in the proof of RBR soundness for  <span class="math">\\Pi_{\\text{batch}}</span> . By the RBR soundness of the batching protocol, the probability that a doomed transcript state escapes from the doomed set is negligible.</p>

    <p class="text-gray-300">Finally, the prover and verifier run a single IOPP  <span class="math">\\Sigma_C</span>  for  <span class="math">R_{\\mathsf{MLE}}[C]</span>  to check the reduced multilinear evaluation statement. We append this statement and the transcript of  <span class="math">\\Sigma_C</span>  to  <span class="math">\\tau</span> , and define the state according to the state function used in the proof of RBR soundness for  <span class="math">\\Sigma_C</span> . The RBR soundness of the transformation follows naturally from the RBR soundness of the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span> .</p>

    <p class="text-gray-300">We establish the RBR soundness of the IOPPs for interleaved codes from Section 6. Assume that the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span>  is RBR sound, where C is a base code over the alphabet  <span class="math">\\mathbb{F}</span> . To prove the RBR soundness of the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C^t]</span> , where  <span class="math">C^t</span>  is over the alphabet  <span class="math">\\mathbb{K} = \\mathbb{F}^t</span> , we define the set of doomed states and bound the probability of escaping from this set.</p>

    <p class="text-gray-300">Consider an instance  <span class="math">x = (i, z \\in \\mathbb{F}, v \\in \\mathbb{F}, c \\in \\mathbb{K}^n) \\notin \\mathcal{L}(R_{\\mathsf{MLE}}[C^t])</span> . We define m as the decoded message of c if c is  <span class="math">\\delta</span> -close to  <span class="math">C^t</span> ; otherwise we set  <span class="math">m = \\bot</span> . Since  <span class="math">x \\notin \\mathcal{L}(R_{\\mathsf{MLE}}[C^t])</span> , it follows that either  <span class="math">m = \\bot</span> , or  <span class="math">\\hat{m}(z) \\neq v</span> , where  <span class="math">\\hat{m}</span>  is the multilinear extension of m. Here, m is viewed as a t-by-k matrix over  <span class="math">\\mathbb{F}</span>  instead of  <span class="math">\\mathbb{K}</span> . In what follows, we decompose z into  <span class="math">(z_1, z_2) \\in \\mathbb{F}^{\\log t} \\times \\mathbb{F}^{\\log k}</span> .</p>

    <p class="text-gray-300">At the start of the protocol, the prover sends an oracle  <span class="math">u \\in \\mathbb{F}^t</span> , claimed to be the list of evaluations  <span class="math">\\{\\hat{m}_i(z_2)\\}_{i \\in [t]}</span> , where  <span class="math">m_i</span>  is the <em>i</em>-th row of the matrix m. We append u to the transcript and define the state as doomed if one of the following holds: (i)  <span class="math">m = \\bot</span>  (i.e., c is far from  <span class="math">C^t</span> ),(ii)  <span class="math">\\hat{u}(z_1) \\neq v</span> , or (iii)  <span class="math">u_i \\neq \\hat{m}_i(z_2)</span>  for some  <span class="math">i \\in [t]</span> . Importantly, if the instance  <span class="math">x \\notin \\mathcal{L}(R_{\\mathsf{MLE}}[C^t])</span> , the state will always be doomed.</p>

    <p class="text-gray-300">Next, the verifier samples a challenge  <span class="math">r \\in \\mathbb{F}^t</span>  and the prover folds both  <span class="math">c \\in \\mathbb{K}^n</span>  and u to  <span class="math">c_{\\mathsf{combo}} = r^\\top y \\in \\mathbb{F}^n</span>  and  <span class="math">v&#x27; = \\langle u, r \\rangle \\in \\mathbb{F}</span> . The state is then set as doomed if one of the following holds: (i)  <span class="math">c_{\\mathsf{combo}}</span>  is  <span class="math">(\\delta&#x27; = 0.99\\delta)</span> -far from C, or (ii)  <span class="math">\\hat{m}_{\\mathsf{combo}}(z_2) \\neq v&#x27;</span> , where  <span class="math">\\hat{m}_{\\mathsf{combo}}</span>  is the decoding of  <span class="math">c_{\\mathsf{combo}}</span> . Equivalently, it is doomed if and only if  <span class="math">(i, z_2, v&#x27;, c_{\\mathsf{combo}}) \\notin R_{\\mathsf{MLE}}[C]</span> . By Corollary 2.6 and Claim 6.1.1, the state remains doomed with high probability if it was doomed previously.</p>

    <p class="text-gray-300">Finally, the prover and verifier engage in the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span>  on the instance  <span class="math">x&#x27; = (i, z_2, v&#x27;, c_{\\mathsf{combo}})</span> . The RBR soundness of the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C^t]</span>  follows naturally from that of the IOPP for  <span class="math">R_{\\mathsf{MLE}}[C]</span> .</p>

    </section>
`;
---

<BaseLayout title="Blaze: Fast SNARKs from Interleaved RAA Codes (2024/1609)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/1609
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#abstract" class="hover:text-white">Abstract</a></li>
        <li>
          <a href="#sec-1" class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-1.1" class="hover:text-white">Our Results</a></li>
            <li><a href="#sec-1.2" class="hover:text-white">Technical Overview</a></li>
            <li><a href="#sec-1.2.1" class="hover:text-white">IOPP for Multilinear Evaluation</a></li>
            <li><a href="#sec-1.2.2" class="hover:text-white">Choosing the Right Code</a></li>
            <li><a href="#sec-1.2.3" class="hover:text-white">Summary and Open Problems</a></li>
            <li><a href="#sec-1.3" class="hover:text-white">Comparison with Prior Work</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-2" class="hover:text-white">Preliminaries</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Multilinear Extension</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Interactive Proofs and IOPs</a></li>
            <li><a href="#sec-2.2.1" class="hover:text-white">Interactive Proofs and Sumcheck</a></li>
            <li><a href="#sec-2.2.2" class="hover:text-white">Interactive Oracle Proofs</a></li>
            <li><a href="#sec-2.3" class="hover:text-white">Coding Background</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">The RAA Code</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.1" class="hover:text-white">Adding Tests</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">Puncturing</a></li>
            <li><a href="#sec-3.3" class="hover:text-white">Concrete Numbers</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">IOPs for Multilinear Evaluation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">From MLIOP to IOPP</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-5" class="hover:text-white">Multilinear Evaluation for the (Packed) RAA Code</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">Checking Simple Linear Operations</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">Checking Permutations</a></li>
            <li><a href="#sec-5.3" class="hover:text-white">MLIOP for R_&#123;\mathsf&#123;MLE&#125;&#125;[\mathsf&#123;PRAA&#125;]</a></li>
            <li><a href="#sec-5.4" class="hover:text-white">Puncturing</a></li>
          </ol>
        </li>
        <li><a href="#sec-6" class="hover:text-white">IOPs for Interleaved Codes</a></li>
        <li><a href="#sec-7" class="hover:text-white">Multilinear Evaluation for Interleaved RAA</a></li>
        <li>
          <a href="#sec-8" class="hover:text-white">Experiments and Results</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-8.1" class="hover:text-white">Prover and Verifier Runtimes</a></li>
            <li><a href="#sec-8.2" class="hover:text-white">Communication Complexity</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-9" class="hover:text-white">Distance Analysis of RAA code</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-9.1" class="hover:text-white">Setup of RAA Analysis</a></li>
            <li><a href="#sec-9.2" class="hover:text-white">Probability First Stage Fails</a></li>
            <li><a href="#sec-9.3" class="hover:text-white">Given Successful First Stage, Probability Code has Good Distance</a></li>
            <li><a href="#sec-9.4" class="hover:text-white">Conditioning on Low Weight Messages Having Good First Stage</a></li>
            <li><a href="#sec-9.5" class="hover:text-white">Puncturing</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li>
          <a href="#app-a" class="hover:text-white">Round-by-Round Soundness of the Protocols</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#app-a.1" class="hover:text-white">RBR Soundness of the Building Block Protocols</a></li>
            <li><a href="#app-a.2" class="hover:text-white">RBR Soundness of the MLIOP-to-IOPP Transformation</a></li>
            <li><a href="#app-a.3" class="hover:text-white">RBR Soundness of the Interleaving IOPP</a></li>
          </ol>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#acknowledgements" class="hover:text-white">Acknowledgements</a></li>
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="blaze-fast-snarks-from-interleaved-raa-codes-2024" />
  </article>
</BaseLayout>
