---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/367';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Interpolation Cryptanalysis of Unbalanced Feistel Networks with Low Degree Round Functions';
const AUTHORS_HTML = 'Arnab Roy, Elena Andreeva, Jan Ferdinand Sauer';

const CONTENT = `    <p class="text-gray-300">Arnab Roy^{1}, Elena Andreeva^{2}, and Jan Ferdinand Sauer^{3}</p>

    <p class="text-gray-300">^{1} University of Klagenfurt, Austria arnab.roy@aau.at ^{2} Technical University of Vienna, Austria elena.andreeva@tuwien.ac.at ^{3} KU Leuven, Belgium and KIT, Germany ferdinand.sauer@posteo.de</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">In recent years a new type of block ciphers and hash functions over a (large) field, such as MiMC and GMiMC, have been designed. Their security, particularly over a prime field, is mainly determined by algebraic cryptanalysis techniques, such as Gröbner basis and interpolation attacks. In SAC 2019, Li and Preneel presented low memory interpolation attack against the MiMC and Feistel-MiMC designs.</p>

    <p class="text-gray-300">In this work we answer the open question posed in their work and show that low memory interpolation attacks can be extended to unbalanced Feistel networks (UFN) with low degree functions, and in particular to the GMiMC design. Our attack applies to UFNs with expanding and contracting round functions keyed either via identical (univariate) or distinct round keys (multivariate). Since interpolation attacks do not necessarily yield the best possible attacks over a binary extension field, we focus our analysis on prime fields <span class="math">\\mathbb{F}_{p}</span>.</p>

    <p class="text-gray-300">Our next contribution is to develop an improved technique for a more efficient key recovery against UFNs with expanding round function. We show that the final key recovery step can be reduced not only to the gcd but also to the root finding problem. Despite its higher theoretical complexity, we show that our approach has a particularly interesting application on Sponge hash functions based on UFNs, such as GMiMCHash.</p>

    <p class="text-gray-300">We illustrate for the first time how our root finding technique can be used to find collision, second preimage and preimage attacks on (reduced round) members of the GMiMCHash family. In addition, we support our theoretical analysis with small-scale experimental results.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">In recent years we have seen the advent of novel symmetric cryptographic primitives that aim to facilitate efficiency optimizations for higher level Multi-Party Computation (MPC), Zero-Knowledge (ZK) proofs, or Fully Homomorphic Encryption (FHE) protocols. Examples of such primitives are the LowMC <em>[5]</em> block</p>

    <p class="text-gray-300">cipher, MiMC <em>[4]</em>, GMiMC <em>[2, 3]</em>, Starkard and Poseidon <em>[12]</em>, MARVELlous <em>[6, 7]</em> families of primitives, Kreyvium <em>[10]</em>, FLIP <em>[17]</em>, and Rasta <em>[11]</em> stream ciphers.</p>

    <p class="text-gray-300">The main design goals of these novel primitives are to reduce the number of multiplications in the (arithmetic) circuit and/or to reduce the multiplicative depth of the circuit corresponding to the underlying block cipher or hash function. These objectives often mean that the primitives must be designed over one (possibly large) finite field and more generally, require thorough rethinking of the way traditional block ciphers (and hash functions) are designed and cryptanalyzed. A recent effort in that direction was the public STARK-Friendly hash challenge <em>[18]</em> which aimed at the evaluation and developing better understanding of the security of the ZK-friendly hash function families Feistel-MiMC, GMiMC, Starkard and Poseidon, and MARVELlous.</p>

    <p class="text-gray-300">The MiMC and Feistel-MiMC (over <span class="math">\\mathbb{F}_{p}</span>) family of block ciphers and hash functions are the first ZKP-friendly dedicated symmetric designs. The MiMC block cipher introduced a novel approach towards designing an ZK/MPC-friendly primitive. Unlike previously existing designs, MiMC iterates a low-degree function sufficiently many times to achieve the target security. Both Feistel-MiMC and GMiMC rely on the Feistel iterative structure which builds a permutation from a low degree polynomial round function(s).</p>

    <p class="text-gray-300">The first third party cryptanalysis on the MiMC construction has been conducted by Li and Preneel <em>[15]</em>. Their main idea of retrieving a key dependent coefficient of interpolating polynomial stems from <em>[20]</em>. Li and Preneel apply algebraic cryptanalysis based on Lagrange interpolation with low memory complexity against MiMC. In essence, their cryptanalysis boils down to finding a key recovery “shortcut” by reconstructing and evaluating the second highest coefficient in the cipher polynomial representation. In their work the authors left the <em>open question</em> whether a similar cryptanalysis approach applies to the GMiMC design. The main reason behind this question we speculate is – it is not obvious how to extend the algebraic analysis in <em>[15]</em> to generalized Feistel networks. Our technical contribution in this article starts with the analytical results that solve this problem.</p>

    <p class="text-gray-300">GMiMC or Generalized MiMC family is an extension of the Feistel-MiMC family and uses generalized Feistel structures with <span class="math">t&gt;2</span> branches. GMiMC is proposed for <em>both</em> balanced and unbalanced Feistel networks. In particular, two unbalanced Feistel networks (UFN) are investigated: with expanding round function (ERF); and with contracting round function (CRF). For both ZKSNARK and MPC applications, the UFN with ERF was found to be more efficient compared to balanced Feistel networks. The GMiMC designers also use a fixed-key GMiMC permutation in a Sponge hashing mode to construct the hash function GMiMCHash. Since the general design principle in GMiMC family relies on a Feistel network with a low degree round function, in this work we focus on the (interpolation) cryptanalysis of UFN with low degree round function over <span class="math">\\mathbb{F}_{p}</span>.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Related work</h3>

    <p class="text-gray-300">The MiMC and GMiMC constructions use an APN function to instantiate the round function in the Feistel network. Traditional differential cryptanalysis tech</p>

    <p class="text-gray-300">niques are ineffective against those designs <em>[2, 4]</em>. The design rationale and cryptanalysis of these constructions thus, heavily relies on the algebraic analysis of the keyed permutation. Known algebraic cryptanalysis is mainly based on Gröbner basis, interpolation, greatest common divisor (GCD), and higher-order differential analysis. We point out that higher-order differential analysis exploits simply the degree of a keyed function over a field.</p>

    <p class="text-gray-300">In CRYPTO 2020, a higher order differential cryptanalysis against the full (round) GMiMC permutation was proposed <em>[8]</em>. More specifically, the authors showed a zero-sum distinguisher against the GMiMC fixed-key permutation. Yet, they do not provide a collision on the full GMiMCHash using this distinguisher, and to the best of our knowledge no result on finding collision using such distinguisher exists to date. A collision on the reduced round GMiMCHash was given via (algebraic) differential analysis of UFNs. Compared to this our analysis is based on purely algebraic techniques such as polynomial interpolation, GCD computation and root finding.</p>

    <p class="text-gray-300">Bonnetain showed an attack <em>[9]</em> on the Feistel-MiMC and GMiMC <span class="math">n</span>-bit key block ciphers with complexity <span class="math">2^{n/2}</span>. The attack followed due to a key schedule weakness and is comparable with the slide attack.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">Our results</h3>

    <p class="text-gray-300">In this article we analyze UFN constructions over <span class="math">\\mathbb{F}_{p}</span>, and the concrete GMiMC instantiation. More specifically, we focus on the interpolation cryptanalysis of UFNs with low degree round functions. Thereafter, we apply our analysis to the GMiMC block cipher over <span class="math">\\mathbb{F}_{p}</span>. We further use these ideas to cryptanalyze GMiMCHash ERF and CRF instances.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We exhibit a low memory interpolation attack on UFNs with both contracting and expanding round functions. Then, we apply our analysis to GMiMC<span class="math">{}_{\\textsf{erf}}</span> and GMiMC<span class="math">{}_{\\textsf{crf}}</span> which are UFNs instantiated with the APN function <span class="math">x\\mapsto x^{3}</span>. This answers the open question of Li and Preneel <em>[15]</em> – how to extend the low memory interpolation attack against GMiMC. The main idea starts with an extension of their low memory (LM) interpolation analysis. Namely, we first construct the key-dependent coefficient of the interpolation polynomial and then recover the coefficient with constant memory. To extend Li and Preneel’s cryptanalysis to our setting we also need to first fix all but one input to a UFN, such that for both ERF and CRF UFNs we can obtain key-dependent polynomial terms with algebraic degree as low as possible. While the method bears similarity with the main idea of <em>[15]</em>, we show that a more in-depth analysis (section 3.2) is required to extend the low memory interpolation attacks for UFNs with <span class="math">t&gt;2</span> branches compared to the two branch FN used to construct Feistel-MiMC. We present a new attack (in section 5.4) which demonstrates how the multiple output branches in UFN<span class="math">{}_{\\textsf{erf}}</span> can be combined to improve the complexity of the low memory interpolation attack.</li>

      <li>We show how root finding algorithms for polynomials over finite fields can be used instead of the GCD technique. For the target (MPC and ZKP) applications of GMiMC<span class="math">{}_{\\textsf{erf}}</span> and GMiMC<span class="math">{}_{\\textsf{crf}}</span> block ciphers and hash functions this</li>

    </ul>

    <p class="text-gray-300">method has roughly the same complexity as the GCD one. This is due to the fact that for these applications the size of the prime field is bounded.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Another important contribution of this work is that we show for the first time how the interpolation analysis together with the root finding technique can be utilized to attack a <em>hash function</em> constructed with UFNs of low degree round function in a Sponge hashing mode, such as the GMiMC_{erf} and GMiMC_{crf} hash functions. Using this technique we mount collision, second preimage and preimage attacks (in section 7) against these hash functions.</li>

      <li>As a proof-of-concept we apply our cryptanalysis against a few small-scale instantiations of GMiMC_{erf} and GMiMC_{crf} block ciphers and provide the experimental results in tables 2 and 3.</li>

    </ul>

    <p class="text-gray-300">For second preimage, preimage and for collision attacks against round reduced GMiMCHash we provide small-scale experiments, the results of which are presented in tables 5 and 6 and figs. 4 and 5.</p>

    <h2 id="sec-6" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300"><span class="math">\\mathbb{F}_{p}</span> denotes the finite field where <span class="math">p</span> is prime. Let <span class="math">k_{i}</span> denote the rounds keys, while round constants are denoted by <span class="math">c_{i}</span> for <span class="math">i\\geqslant 0</span>. We denote the tuple of all subkeys by <span class="math">K=(k_{0},\\ldots,k_{r-1})</span>. When working with fix but unknown key we denote it by <span class="math">\\bar{k}_{i}</span> or <span class="math">\\bar{K}</span>. The monic polynomial <span class="math">f(x)=\\sum_{j=0}^{d-1}a_{j}x^{j}+x^{d}</span> with degree <span class="math">d</span> is used to define the round function in a UFN. We denote the output of <span class="math">f(x)</span> in round <span class="math">i</span> by <span class="math">\\sigma_{i}</span>. <span class="math">(x_{0},\\ldots,x_{t-1})\\in\\mathbb{F}_{p}^{t}</span> is the plaintext or input to a UFN with <span class="math">t</span> (<span class="math">&gt;2</span>) branches. <span class="math">P_{j}^{(i)}</span> denotes the polynomial corresponding to branch <span class="math">j</span> after the <span class="math">i</span>-th round, and <span class="math">P_{j}^{(0)}=x_{j}</span> for <span class="math">0\\leqslant j&lt;t</span>. For the inputs analyzed in section 3 and because <span class="math">f(x)</span> is monic, we have <span class="math">P_{j}^{(i)}=x^{d^{y}}+q(K)x^{d^{y}-1}+\\ldots</span> where <span class="math">y</span> depends on <span class="math">r</span> and <span class="math">t</span>. We call the polynomial <span class="math">q(K)</span> in the key <span class="math">K</span> the “second highest coefficient”. We illustrate one-round UFNs with ERF and CRF in fig. 1.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.1 Background</h3>

    <p class="text-gray-300">We will consider UFNs with the above polynomial round function <span class="math">f(x)</span>. The round function UFN_{erf} is defined as <span class="math">\\sigma_{i}=f(P_{0}^{(i)}+k_{i}+c_{i})</span> where <span class="math">i\\geqslant 0</span> and <span class="math">P_{j}^{(i)}=x_{j}</span> for <span class="math">i=0</span>, <span class="math">0\\leqslant j&lt;t</span>. Each round is viewed as a mapping</p>

    <p class="text-gray-300"><span class="math">(P_{0}^{(i+1)},\\ldots,P_{t-1}^{(i+1)})\\leftarrow(P_{1}^{(i)}+\\sigma_{i},\\ldots,P_{t-1}^{(i)}+\\sigma_{i},P_{0}^{(i)})</span> (1)</p>

    <p class="text-gray-300">in <span class="math">\\mathbb{F}_{p}^{t}</span>.</p>

    <p class="text-gray-300">The round function of an UFN_{crf} is defined as <span class="math">\\sigma_{i}=f(\\sum_{j=1}^{t-1}P_{j}^{(i)}+k_{i}+c_{i})</span>. Each round of UFN_{crf} is a mapping defined as</p>

    <p class="text-gray-300"><span class="math">(P_{0}^{(i+1)},\\ldots,P_{t-1}^{(i+1)})\\leftarrow(P_{1}^{(i)},\\ldots,P_{t-1}^{(i)},P_{0}^{(i)}+\\sigma_{i})</span> (2)</p>

    <p class="text-gray-300">We will use the notations UFN_{erf}[<span class="math">p,r,t</span>] and UFN_{crf}[<span class="math">p,r,t</span>] to indicate the number of rounds <span class="math">r</span> and number of branches <span class="math">t</span> for UFNs over <span class="math">\\mathbb{F}_{p}</span>.</p>

    <p class="text-gray-300">Title Suppressed Due to Excessive Length</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> (a) UFN with ERF</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> (b) UFN with CRF Fig. 1: One round UFN with ERF(left) and CRF(right)</p>

    <p class="text-gray-300">GMiMC uses the monomial round function  <span class="math">f(x) \\coloneqq x^3</span> . Typically, GMiMC is defined for primes of size 128 bit or more for their target MPC or ZK applications. The key scheduling in the GMiMC proposal is defined as  <span class="math">k_{i} = k</span>  for  <span class="math">i \\geqslant 0</span>  and  <span class="math">k \\in \\mathbb{F}_p</span> . However, following the recent attack [9] against  <span class="math">\\mathrm{GMiMC}_{\\mathrm{erf}}</span> , certain types of  <span class="math">\\mathrm{GMiMC}_{\\mathrm{crf}}</span> , and Feistel-MiMC, the round key scheduling is updated [16]. The new key schedule defines  <span class="math">k_{i} \\coloneqq (i + 1)k</span>  for  <span class="math">i \\geqslant 0</span> . To the best of our knowledge this thwarts the attack of [9]. Using the new key schedule, the round function for  <span class="math">\\mathrm{GMiMC}_{\\mathrm{erf}}</span>  is defined as  <span class="math">\\sigma_{i} = (P_{0}^{(i)} + (i + 1)k_{i} + c_{i})^{3}</span> , and for  <span class="math">\\mathrm{GMiMC}_{\\mathrm{crf}}</span>  it is defined as  <span class="math">\\sigma_{i} = (\\sum_{j=1}^{t-1} P_{j}^{(i)} + (i + 1)k_{i} + c_{i})^{3}</span> .</p>

    <p class="text-gray-300">We will also use the notations  <span class="math">\\mathrm{GMiMC}_{\\mathrm{erf}}[p,r,t]</span>  and  <span class="math">\\mathrm{GMiMC}_{\\mathrm{crf}}[p,r,t]</span>  to indicate the number of rounds and number of branches when necessary or GMiMC.</p>

    <p class="text-gray-300">The interpolation attack [13] on block ciphers was introduced by Jakobsen and Knudsen in 1997. In this attack, the output of a block cipher  <span class="math">E_{k}</span>  is viewed as a polynomial in the input of the cipher. The adversary first estimates the degree  <span class="math">d</span>  of the polynomial and then gathers at least  <span class="math">(d + 1)</span>  pairs of plaintext and ciphertext. This allows reconstruction of  <span class="math">E_{k}</span>  without the knowledge of  <span class="math">k</span> . The time complexity for reconstructing the polynomial corresponding to  <span class="math">E_{k}</span>  is  <span class="math">\\mathcal{O}(d\\log d)</span>  [19] and the space complexity is  <span class="math">\\mathcal{O}(d)</span> .</p>

    <p class="text-gray-300">For polynomials of large degree, the amount of required memory can make interpolation impractical. If the involvement of subkeys in a specific coefficient of the polynomial is "well-understood", a partial recovery of the polynomial can be sufficient to recover the key or reconstruct a decryption oracle. In [15], for example, the reconstruction of only a single coefficient allows the recovery of two subkeys.</p>

    <p class="text-gray-300">This lowers the space complexity to  <span class="math">\\mathcal{O}(1)</span> , meaning that the memory constraints are not an issue with this form of low memory interpolation. One such enabling technique is choosing the polynomials' evaluation points. Concretely, when interpolating  <span class="math">f: \\mathbb{F}_p \\to \\mathbb{F}_p</span> , points  <span class="math">(x_j, y_j) = (\\alpha^j, f(\\alpha^j))</span>  are used, where  <span class="math">\\alpha \\in \\mathbb{F}_p</span>  is a primitive element. The  <span class="math">y_j</span>  are retrieved in an online manner, i.e. "on the fly". This removes the need to store a list of  <span class="math">(d + 1)</span>  coordinates.</p>

    <p class="text-gray-300">The low memory interpolation algorithm is developed by rearranging the equation for Lagrange interpolation, which is revisited in eq. (3).</p>

    <p class="text-gray-300">\\[ L(x)=\\sum_{j=0}^{d}y_{j}\\prod_{\\begin{subarray}{c}0\\leq i\\leq d\\\\ i\\neq j\\end{subarray}}\\frac{x-x_{i}}{x_{j}-x_{i}}=\\sum_{j=0}^{d}f(\\alpha^{j})\\prod_{\\begin{subarray}{c}0\\leq i\\leq d\\\\ i\\neq j\\end{subarray}}\\frac{x-\\alpha^{i}}{\\alpha^{j}-\\alpha^{i}}=\\sum_{j=0}^{d}b_{j}x^{j} \\] (3)</p>

    <p class="text-gray-300">Solving for the coefficient <span class="math">b_{d-1}</span>, the authors of <em>[15]</em> arrive at</p>

    <p class="text-gray-300">\\[ b_{d-1}=\\sum_{j=0}^{d}f(\\alpha^{j})\\frac{\\beta_{j}}{\\gamma_{j}},\\quad\\gamma_{j}=\\prod_{\\begin{subarray}{c}0\\leq i\\leq d\\\\ i\\neq j\\end{subarray}}(\\alpha^{j}-\\alpha^{i}),\\quad\\beta_{j}=\\alpha^{j}-\\sum_{i=0}^{d}\\alpha^{i} \\] (4)</p>

    <p class="text-gray-300">The recursive form of <span class="math">\\gamma_{j+1}=\\gamma_{j}\\cdot\\alpha^{d}\\cdot^{\\alpha^{j}-\\alpha^{-1}}/\\alpha^{j}-\\alpha^{d}</span> allows its iterative construction. Low memory interpolation can now be achieved by iteratively constructing the summands of eq. (4). Only current values of variables <span class="math">\\alpha^{j}</span>, <span class="math">\\beta_{j}</span>, <span class="math">\\gamma_{j}</span>, and the partial result are stored across iterations, resulting in space requirements of <span class="math">\\mathcal{O}(1)</span>. Despite the improvements on space complexity, interpolation of even one coefficient amounts to time complexity <span class="math">\\mathcal{O}(d\\log d)</span>.</p>

    <h2 id="sec-9" class="text-2xl font-bold">3 Analysis of output polynomials</h2>

    <p class="text-gray-300">In this section we will first analyze common properties of the output of Unbalanced Feistel Networks (UFNs) when seen as polynomials of the input and key variable(s). We take output branch <span class="math">j</span> of a UFN<span class="math">{}_{\\textsf{erf}}[p,r,t]</span> where the key <span class="math">K=(k_{0},\\ldots,k_{r-1})</span> values are regarded as indeterminates. Given inputs of the form <span class="math">(x_{0},x_{1},\\ldots,x_{t-1})</span>, output branch <span class="math">j</span> can be interpreted as a multivariate polynomial in <span class="math">\\mathbb{F}_{p}[x_{0},\\ldots,x_{t-1},k_{0},\\ldots,k_{r-1}]</span>.</p>

    <p class="text-gray-300">Fixing all but one of the input variables to an arbitrary constant will give a polynomial <span class="math">\\mathbb{F}_{p}[x,k_{0},\\ldots,k_{r-1}]</span> corresponding to any output branch.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">3.1 ERF analysis</h3>

    <p class="text-gray-300">We analyze the output polynomials corresponding to different branches after <span class="math">r</span> rounds of a UFN<span class="math">{}_{\\textsf{erf}}</span>. For simplicity we start with the analysis for UFN<span class="math">{}_{\\textsf{erf}}[p,r,3]</span>. To give a clear idea of the analysis throughout this section, we progressively generalize it. The first generalization is for the number of rounds <span class="math">r</span> in Proposition 1 and then for <span class="math">t</span> branches in Proposition 2. We simplify the analysis by combining actual round key <span class="math">k^{\\prime}_{i}</span> and round constant <span class="math">c_{i}</span> i. e. , <span class="math">k_{i}:=k^{\\prime}_{i}+c_{i}</span>. Furthermore, we assume <span class="math">\\textsf{deg}(f)\\geqslant 3</span>.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Proposition 1</h6>

    <p class="text-gray-300">Given an input of the form <span class="math">(b,b,x)</span> to the UFN<span class="math">{}_{\\textsf{erf}}[p,r,3]</span>, after <span class="math">r\\geqslant 4</span> rounds, the output polynomials <span class="math">P_{0}^{(r)},P_{1}^{(r)},P_{2}^{(r)}\\in\\mathbb{F}_{p}[x,k_{0},\\ldots,k_{r-1}]</span> for the <span class="math">3</span> branches have the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\textsf{deg}(P_{0}^{(r)})=\\textsf{deg}(P_{1}^{(r)})=d^{r-2}</span> and <span class="math">\\textsf{deg}(P_{2})=d^{r-3}</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{coeff}(P_{0}^{(r)},x^{d^{r-2}})=\\mathsf{coeff}(P_{1}^{(r)},x^{d^{r-2}})=1</span></li>

      <li><span class="math">\\mathsf{coeff}(P_{0}^{(r)},x^{d^{r-2}-1})=\\mathsf{coeff}(P_{1}^{(r)},x^{d^{r-2}-1})=d^{r-3}(a_{d-1}+d\\beta)</span></li>

    </ol>

    <p class="text-gray-300">where <span class="math">\\beta=f(b+k_{0})+f\\left(b+f(b+k_{0})+k_{1}\\right)+k_{2}=\\sigma_{0}+\\sigma_{1}+k_{2}</span>.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof is detailed in appendix A.1.</p>

    <p class="text-gray-300">We further generalize the result for <span class="math">t</span> branches in the following proposition:</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Proposition 2</h6>

    <p class="text-gray-300">Given an input of the form <span class="math">(b,\\ldots,b,x)</span> to the <span class="math">\\mathrm{UFN}_{\\mathsf{erf}}[p,r,t]</span>, let <span class="math">r&gt;t\\geqslant 3</span>, then after <span class="math">r</span> rounds, the output polynomials <span class="math">P_{0}^{(r)},P_{1}^{(r)},\\ldots,P_{t-1}^{(r)}\\in\\mathbb{F}_{p}[x,k_{0},\\ldots,k_{r-1}]</span> have the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{deg}(P_{0}^{(r)})=\\ldots=\\mathsf{deg}(P_{t-2}^{(r)})=d^{r-(t-1)}</span> and <span class="math">\\mathsf{deg}(P_{t-1}^{(r)})=d^{r-t}</span></li>

      <li><span class="math">\\mathsf{coeff}(P_{0}^{(r)},x^{d^{r-(t-1)}})=\\ldots=\\mathsf{coeff}(P_{t_{2}}^{(r)},x^{d^{r-(t-1)}})=1</span></li>

      <li><span class="math">\\mathsf{coeff}(P_{0}^{(r)},x^{d^{r-(t-1)}-1})=\\ldots=\\mathsf{coeff}(P_{t-2}^{(r)},x^{d^{r-(t-1)}-1})=d^{r-t-1}(a_{d-1}+d\\beta)</span></li>

    </ol>

    <p class="text-gray-300">where <span class="math">\\beta=\\sum_{i=0}^{t-2}\\sigma_{i}+k_{t-1}</span>.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof is detailed in appendix A.2.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Corollary 1</h6>

    <p class="text-gray-300">From Proposition 2 we summarize and can further conclude</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{deg}(P_{t}^{(r)})=\\mathsf{deg}(P_{1}^{(r-1)})=d^{r-t}</span></li>

      <li><span class="math">\\mathsf{coeff}(P_{t}^{(r)},x^{d^{r-t}-1})=\\mathsf{coeff}(P_{1}^{(r-1)},x^{d^{r-t}-1})=d^{r-t-1}(a_{d-1}+d\\beta)</span></li>

    </ol>

    <p class="text-gray-300">Corollary 1 gives us the algebraic expression of the coefficient of the second highest degree term in the output polynomial <span class="math">P_{t-1}^{(r)}</span>. In the remainder of this article, we will informally refer to this coefficient as the “second highest coefficient.” Lastly, we generalize the result for the position of the indeterminate <span class="math">x</span>.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Proposition 3</h6>

    <p class="text-gray-300">Given an input of the form <span class="math">(b,\\ldots,b,x,b,\\ldots,b)</span> to the <span class="math">\\mathrm{UFN}_{\\mathsf{erf}}[p,r,t]</span>, where the position of <span class="math">x</span> is <span class="math">\\ell\\in\\{0,\\ldots,t-1\\}</span>, after <span class="math">r&gt;\\ell</span> rounds, the output polynomials <span class="math">P_{0}^{(r)},P_{1}^{(r)},\\ldots,P_{t-1}^{(r)}\\in\\mathbb{F}_{p}[x,k_{0},\\ldots,k_{r-1}]</span> have the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{deg}(P_{0}^{(r)})=\\ldots=\\mathsf{deg}(P_{t-2}^{(r)})=d^{r-\\ell}</span> and <span class="math">\\mathsf{deg}(P_{t-1}^{(r)})=d^{r-\\ell-1}</span></li>

      <li><span class="math">\\mathsf{coeff}(P_{0}^{(r)},x^{d^{r-\\ell}})=\\ldots=\\mathsf{coeff}(P_{t-2}^{(r)},x^{d^{r-\\ell}})=1</span></li>

      <li><span class="math">\\mathsf{coeff}(P_{0}^{(r)},x^{d^{r-\\ell}-1})=\\ldots=\\mathsf{coeff}(P_{t-2}^{(r)},x^{d^{r-\\ell}-1})=d^{r-\\ell-1}(a_{d-1}+d\\beta)</span></li>

    </ol>

    <p class="text-gray-300">where <span class="math">\\beta=\\sum_{i=0}^{\\ell-1}\\sigma_{i}+k_{\\ell}</span></p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Using the same argumentation as in the proof of Proposition 2, we observe that <span class="math">\\mathsf{deg}(\\sigma_{i})=0</span> for <span class="math">i&lt;\\ell</span>. In the <span class="math">\\ell</span>-th round, using the same expansion as in the proof of Proposition 2, we have the following expanded form for <span class="math">\\sigma_{\\ell}</span>:</p>

    <p class="text-gray-300"><span class="math">\\sigma_{\\ell}</span> <span class="math">=f(x+\\sigma_{0}+\\cdots+\\sigma_{\\ell-1}+k_{\\ell})</span> <span class="math">=f(x+\\beta)</span> <span class="math">=x^{d}+(a_{d-1}+d\\beta)x^{d-1}+\\cdots+a_{0}</span></p>

    <p class="text-gray-300">Now we can make an induction over <span class="math">r</span> much in the same way as in Proposition 1.</p>

    <p class="text-gray-300">Arnab Roy, Elena Andreeva, and Jan Ferdinand Sauer</p>

    <p class="text-gray-300">Corollary 2 Let <span class="math">\\sigma_{i}</span> be the output of the round function in round <span class="math">i</span> of a <span class="math">\\mathrm{UFN}_{\\mathrm{erf}}[p,r,t]</span> with input of the form <span class="math">(b,\\ldots ,b,x,b,\\ldots ,b)</span>, where indeterminate <span class="math">x</span> is at position <span class="math">\\ell</span>, and <span class="math">d\\geqslant 3</span>. From the proof of Proposition 3 we have</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {d e g} (\\sigma_ {i}) = \\left\\{ \\begin{array}{l l} 0, &amp;amp; 0 \\leqslant i &amp;lt;   \\ell \\\\ d ^ {i - \\ell + 1}, &amp;amp; \\ell \\leqslant i &amp;lt;   r \\end{array} \\right.</span></div>

    <p class="text-gray-300">Note that generally, the output polynomials in Proposition 3 are of higher degree than those in Proposition 2, unless <span class="math">\\ell = t - 1</span>, in which case Proposition 2 and Proposition 3 coincide.</p>

    <h2 id="sec-18" class="text-2xl font-bold">3.2 CRF analysis</h2>

    <p class="text-gray-300">For the <span class="math">\\mathrm{UFN}_{\\mathrm{crf}}[p,r,t]</span> we also analyze the degree and coefficients of the highest and second highest term in all the output polynomials, which are described in the following propositions. As in section 3.1, we simplify the analysis by combining actual round key <span class="math">k_{i}^{\\prime}</span> and round constant <span class="math">c_{i}</span> to <span class="math">k_{i}:= k_{i}^{\\prime} + c_{i}</span>. Recall that for a <span class="math">\\mathrm{UFN}_{\\mathrm{crf}}</span>, we use <span class="math">f(\\sum_{i=1}^{t-1} x_{i} + k_{i} + c_{i})</span> as round function in round <span class="math">i</span> on inputs <span class="math">(x_{0}, \\ldots, x_{t-1})</span>.</p>

    <p class="text-gray-300">Proposition 4 Given an input of the form <span class="math">(x, b, \\ldots, b)</span> to the <span class="math">\\mathrm{UFN}_{\\mathrm{crf}}[p, r, t]</span> with <span class="math">t \\geqslant 3</span> branches, after <span class="math">r \\geqslant 2</span> rounds, the rightmost output polynomial <span class="math">P_{t-1}^{(r)} \\in \\mathbb{F}_p[x, k_0, \\ldots, k_{r-1}]</span> has the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\deg(P_{t-1}^{(r)}) = d^{r-1}</span></li>

      <li><span class="math">\\operatorname{coeff}(P_{t-1}^{(r)}, x^{d^{r-1}}) = 1</span>,</li>

      <li><span class="math">\\operatorname{coeff}(P_{t-1}^{(r)}, x^{d^{r-1}-1}) = d^{r-1}(a_{d-1} + d\\beta)</span></li>

    </ol>

    <p class="text-gray-300">where <span class="math">\\beta = (t - 2)b + f((t - 1)b + k_0) + k_1</span></p>

    <p class="text-gray-300">Proof. The proof is given in appendix A.3</p>

    <p class="text-gray-300">Corollary 3 From Proposition 4 we can conclude for <span class="math">r \\geqslant t</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\deg(P_0^{(r)}) = \\deg(P_{t-1}^{(r-(t-1))}) = d^{r-t}</span></li>

      <li><span class="math">\\operatorname{coeff}(P_0^{(r)}, x^{d^{r-t-1}}) = \\operatorname{coeff}(P_{t-1}^{(r-(t-1))}, x^{d^{r-t-1}}) = d^{r-t-1}(a_{d-1} + d\\beta)</span></li>

    </ol>

    <p class="text-gray-300">Corollary 3 gives us the algebraic expression of the coefficient of the second highest degree term in the output polynomial <span class="math">P_0^{(r)}</span>. In the remainder of this article, we will informally refer to this coefficient as the "second highest coefficient."</p>

    <p class="text-gray-300">The insight of Proposition 4 allows the algebraic expression of the second highest coefficient in indeterminates <span class="math">k_{i}</span>, i.e. a polynomial in <span class="math">\\mathbb{F}_p[k_0,k_1]</span>.</p>

    <h2 id="sec-19" class="text-2xl font-bold">4 Low Memory Interpolation Cryptanalysis of UFNs</h2>

    <p class="text-gray-300">Using the results from section 3 we will analyze <span class="math">\\mathrm{UFN}_{\\mathrm{erf}}</span> and <span class="math">\\mathrm{UFN}_{\\mathrm{crf}}</span> with uniformly randomly fixed but unknown key <span class="math">\\bar{k} \\in \\mathbb{F}_p^s</span> (<span class="math">s \\geqslant 1</span>), resulting in round keys <span class="math">(\\bar{k}_0, \\dots, \\bar{k}_{r-1})</span>. When the key values are known the output polynomials developed</p>

    <p class="text-gray-300">in sections 3.1 and 3.2, specifically in Corollaries 1 and 3, are elements of <span class="math">\\mathbb{F}_{p}[x]</span> (not of <span class="math">\\mathbb{F}_{p}[x,k_{0},\\ldots,k_{r-1}]</span>).</p>

    <p class="text-gray-300">Since the interpolation of a single coefficient requires low memory, as outlined in section 2.2, we can recover the second highest coefficient to mount a low memory attack on <span class="math">\\mathrm{UFN}_{\\mathsf{erf}}</span> and <span class="math">\\mathrm{UFN}_{\\mathsf{crf}}</span>.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">4.1 Analysis outline</h3>

    <p class="text-gray-300">The general idea of the cryptanalysis can be described in the following steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Obtain the algebraic expression of the second highest coefficient <span class="math">Q(K)</span> of the output polynomial corresponding to the branch with the lowest algebraic degree. For <span class="math">\\mathrm{UFN}_{\\mathsf{erf}}</span> and <span class="math">\\mathrm{UFN}_{\\mathsf{crf}}</span> these are rightmost branch and leftmost branch respectively. (Detailed analysis of <span class="math">\\mathrm{UFN}_{\\mathsf{erf}}</span> and <span class="math">\\mathrm{UFN}_{\\mathsf{crf}}</span> are in sections 5.1 and 6 respectively.)</li>

      <li>Find value <span class="math">z</span> of second highest coefficient of <span class="math">E_{\\bar{K}}</span> of the same branch as in step 1 by applying the low memory interpolation (used in <em>[15]</em>) technique. (Detailed in Section 5.2)</li>

      <li>Recover the key by evaluating relation <span class="math">Q(K)=z</span> by solving for <span class="math">K</span>. Some of the key recovering techniques may require multiple equations <span class="math">Q_{i}(K)=z_{i}</span>. (Sections 5.3 and 6)</li>

    </ol>

    <p class="text-gray-300">Round keys. We explore two scenarios <em>single key</em> and <em>multiple keys</em>. In single key, <span class="math">k_{i}=g(k)</span>, where <span class="math">g</span> is a <em>linear</em> function (and degree one) over <span class="math">\\mathbb{F}_{p}</span> and <span class="math">k</span> can have values from <span class="math">\\mathbb{F}_{p}</span>. For single round keys, we use two different techniques: a novel <em>root finding</em> technique and the <em>gcd</em> technique (previously used by <em>[15]</em>).</p>

    <p class="text-gray-300">In section 5.4, we show that the complexity of the key recovery can be further improved for <span class="math">\\mathrm{UFN}_{\\mathsf{erf}}</span> by combining the output branch polynomials. We call this technique <em>branch subtraction</em>. Table 1 gives an overview of the complexities.</p>

    <p class="text-gray-300">In the multiple key scenario, the round keys are derived from <span class="math">k=(k_{0},k_{1})\\in\\mathbb{F}_{p}^{2}</span>. In GMiMC, the round key <span class="math">k_{i}=k_{i\\pmod{2}}</span>, where <span class="math">j\\in\\{0,\\ldots,r-1\\}</span>. The analysis for this multiple key scenario is provided in section 5.5.</p>

    <h2 id="sec-21" class="text-2xl font-bold">5 Cryptanalysis of <span class="math">\\mathrm{UFN}_{\\mathsf{erf}}</span></h2>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">5.1 Algebraic Expression of Second Highest Coefficient</h3>

    <p class="text-gray-300">We consider the output polynomial when all but one branch of the inputs have fixed values. By arranging the terms as in Propositions 1 to 3, the polynomial has the form <span class="math">x^{d^{r}}+Q(K)x^{d^{r}-1}+\\cdots+cx^{0}</span>, where <span class="math">Q(K)</span> depends on the number of rounds <span class="math">r</span>, the number of branches <span class="math">t</span>, and the position <span class="math">\\ell</span> of indeterminate <span class="math">x</span> in the UFNs input. The coefficient <span class="math">Q(K)</span> is a polynomial that we refer as “second highest coefficient.” This coefficient is computable by applying the results from section 3, as described below.</p>

    <p class="text-gray-300">Arnab Roy, Elena Andreeva, and Jan Ferdinand Sauer</p>

    <p class="text-gray-300">In a  <span class="math">\\mathrm{UFN}_{\\mathrm{erf}}[p,r,t]</span> , the polynomial representing the rightmost output branch has the lowest degree, as shown in Proposition 2. For this polynomial, the coefficient of the second highest degree term has form  <span class="math">Q(K) = d^{r - t - 1}(a_{d - 1} + d\\beta)</span> , with  <span class="math">\\beta = \\sum_{i = 0}^{t - 2}\\sigma_i + k_{t - 1}</span> . Algorithm 1 describes the method to obtain the polynomial  <span class="math">Q(K)</span> , representing the second highest coefficient.</p>

    <p class="text-gray-300">Complexity (of S1) In the single key case, the computation of  <span class="math">Q(K)</span>  requires multiplications of polynomials over  <span class="math">\\mathbb{F}_p</span> . More specifically, it requires at most  <span class="math">\\mathcal{O}(\\log D)</span>  multiplications of two polynomials with degree at most  <span class="math">D</span> . The multiplication of two polynomials of degree at most  <span class="math">D</span>  over  <span class="math">\\mathbb{F}_p</span>  requires  <span class="math">\\mathsf{M}(D) := 63.43D\\log D\\log \\log D + \\mathcal{O}(D\\log D)</span>  field operations [22, Thm. 8.23]. To simplify the expressions we define  <span class="math">\\mathsf{M}&#x27;(D) = \\mathcal{O}(\\log D)\\mathsf{M}(D)</span> . Hence, this step has complexity</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {M} ^ {\\prime} (d ^ {t - 1}) = \\mathcal {O} \\big (\\log d ^ {t - 1} \\big) \\mathsf {M} (d ^ {t - 1}).</span></div>

    <p class="text-gray-300">Space complexity is  <span class="math">\\mathcal{O}\\big(d^{t - 1}\\big)</span>  since only one polynomial of degree at most  <span class="math">d^{t - 1}</span>  has to be stored at any given time. Note that this space complexity is not due to the interpolation part of the attack.</p>

    <p class="text-gray-300">As outlined at the beginning of section 4, the second step of the analysis consists of recovering the value of the second highest coefficient of the rightmost output polynomial branch of the  <span class="math">\\mathrm{UFN}_{\\mathrm{erf}}</span> . For this step we use the low memory interpolation of [15] described in section 2.2.</p>

    <p class="text-gray-300">In general, inputs of form  <span class="math">\\alpha^j</span>  are required, where  <span class="math">\\alpha \\in \\mathbb{F}_p</span>  is a primitive element,  <span class="math">0 \\leqslant j \\leqslant D</span> , and  <span class="math">D</span>  is the degree of the underlying polynomial that is to be interpolated. In the current analysis this means using inputs of the form  <span class="math">x_j = (b, \\ldots, b, \\alpha^j)</span> , in accordance with Proposition 2. The evaluation points  <span class="math">y_j</span>  for the interpolation are the values of the rightmost output branch.</p>

    <p class="text-gray-300">Complexity (of S2) The time complexity of finding the value of the second highest coefficient using the low memory interpolation method of [15] is  <span class="math">\\mathsf{l}_{lm}(D) \\coloneqq \\mathcal{O}(D\\log(D))</span>  for polynomials of degree  <span class="math">D</span> . Its memory complexity is in  <span class="math">\\mathcal{O}(1)</span> , and data complexity is  <span class="math">D + 1</span> . For  <span class="math">\\mathrm{UFN}_{\\mathrm{erf}}</span> , we have  <span class="math">D = d^{r - t}</span> , resulting in time</p>

    <p class="text-gray-300">|  Algorithm 1: Second highest coefficient of rightmost branch in UFNerf[p,r,t] on input (b,...,b,x).  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: r,t,f, branch constant b, round constants c0,...,ct-1 Output: polynomial Q(K) for second highest coefficient of rightmost branch  |   |</p>

    <p class="text-gray-300">|  1 s := 0  |   |</p>

    <p class="text-gray-300">|  2 for i ∈ (0,...,t-2) do  |   |</p>

    <p class="text-gray-300">|  3 σi := f(s+b+ci+ki)  |   |</p>

    <p class="text-gray-300">|  4 s := s+σi  |   |</p>

    <p class="text-gray-300">|  5 β := s+kt-1+ct-1  |   |</p>

    <p class="text-gray-300">|  6 return dr-t-1(ad-1+dβ)  |   |</p>

    <p class="text-gray-300">complexity <span class="math">\\mathcal{O}((r-t)d^{r-t}\\log d)</span>. The approach requires <span class="math">d^{r-t}+1</span> pairs of plaintext and ciphertext and uses <span class="math">\\mathcal{O}(1)</span> space. Better time and data complexities can be achieved by combining branches, as described in section 5.4.</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">5.3 Key recovery with a single key</h3>

    <p class="text-gray-300">First, we consider the case of single key e.g., <span class="math">k_{i}=(i+1)\\cdot k</span> for <span class="math">i\\geqslant 0</span> and <span class="math">k</span> is the master key that can take any value in <span class="math">\\mathbb{F}_{p}</span>. We find the polynomial representing the second highest coefficient and the value of the second highest coefficient as described in the previous two sections. For finding the value of the secret key two different techniques can be employed: Finding the gcd, or finding roots.</p>

    <p class="text-gray-300">Finding the GCD. This technique was introduced in <em>[1]</em> and also used in <em>[15]</em> to analyze two-branch Feistel networks. We first select two different constants <span class="math">b,b^{\\prime}</span> for input to the UFN<span class="math">{}_{\\sf erf}</span>. We obtain two polynomials <span class="math">Q(k)</span> and <span class="math">Q^{\\prime}(k)</span> as described in algorithm 1 using <span class="math">b</span> and <span class="math">b^{\\prime}</span> respectively. Next, we interpolate the values of the second highest coefficient say <span class="math">z,z^{\\prime}</span> with as described in section 5.2, twice: The correct key is found from <span class="math">\\gcd(Q(k)-z,Q^{\\prime}(k)-z^{\\prime})</span> with high probability.</p>

    <p class="text-gray-300">Complexity of GCD Finding the gcd of two polynomials of degree at most <span class="math">D</span> over <span class="math">\\mathbb{F}_{p}</span> has time complexity <span class="math">\\mathsf{G}(D):=\\mathcal{O}\\big{(}D\\log^{2}D\\big{)}</span> <em>[22, Cor. 11.9]</em>. For UFN<span class="math">{}_{\\sf erf}</span>s, we have <span class="math">D=d^{t-1}</span>. Hence the key recovery using the gcd method has time complexity <span class="math">\\mathcal{O}\\big{(}t^{2}d^{(t-1)}\\log^{2}d\\big{)}</span> and space complexity <span class="math">\\mathcal{O}\\big{(}d^{t-1}\\big{)}</span>.</p>

    <p class="text-gray-300">Finding roots. By construction of <span class="math">Q(k)</span> it satisfies <span class="math">Q(\\bar{k})-z=0</span>, i.e., correct key <span class="math">\\bar{k}</span> is a root of above equation <span class="math">Q(k)-z</span>. Exhaustively trying the generally very short list of key candidates <em>[14]</em> on one additional pair of plaintext and ciphertext identifies the correct key.</p>

    <p class="text-gray-300">Complexity of root finding Finding all roots without multiplicity of a polynomial with degree <span class="math">D</span> over <span class="math">\\mathbb{F}_{p}</span> has time complexity <span class="math">\\mathsf{R}(D):=\\mathcal{O}(\\mathsf{M}(D)\\log D\\log(Dp))</span> <em>[22, Cor. 14.16]</em>. Checking at most <span class="math">D</span> key candidates for a polynomial of degree <span class="math">D</span> has time complexity <span class="math">\\mathcal{O}(D)</span>. For UFN<span class="math">{}_{\\sf erf}</span>, we have <span class="math">D=d^{t-1}</span>. Hence the key recovery using the root finding method has time complexity <span class="math">\\mathcal{O}\\big{(}\\mathsf{M}(d^{t-1})\\log d^{t-1}\\log(d^{t-1}p)\\big{)}</span> and data complexity of <span class="math">\\mathcal{O}(1)</span>.</p>

    <p class="text-gray-300">Finding roots versus GCD. Asymptotically, the complexity of the root finding method is worse than using the gcd method. However, for our target constructions, i.e., GMiMC block ciphers and hash functions that are aimed for practical applications, the complexities are roughly the same, since the field’s size <span class="math">\\log p\\leqslant 2^{8}</span>. More importantly, the root finding method can also be used to find collisions when UFN<span class="math">{}_{\\sf erf}</span> (with a fixed key) is used in sponge mode to construct a hash function, as described in section 7.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">5.4 Complexity improvements via Branch Subtraction</h3>

    <p class="text-gray-300">When analyzing a UFN<span class="math">{}_{\\sf erf}[p,r,t]</span> <span class="math">E_{\\bar{K}}</span> with <span class="math">\\bar{K}=(\\bar{k}_{0},\\ldots,\\bar{k}_{r-1})</span>, improvements on the complexities discussed above are possible. From Corollary 2 we have <span class="math">\\mathsf{deg}(\\sigma_{i})=d^{i-\\ell-1}</span> for <span class="math">i\\geqslant\\ell</span> for input of the form <span class="math">(b,\\ldots,b,x,b,\\ldots,b)</span>, where <span class="math">b\\in\\mathbb{F}_{p}</span> is a</p>

    <p class="text-gray-300">Arnab Roy, Elena Andreeva, and Jan Ferdinand Sauer</p>

    <p class="text-gray-300">constant and indeterminate  <span class="math">x</span>  is at position  <span class="math">\\ell</span> . After round  <span class="math">i</span> , by construction of  <span class="math">\\mathrm{UFN}_{\\mathrm{erf}}</span> ,  <span class="math">\\sigma_{i}</span>  has been added to all branches except the rightmost one. As has been used extensively in the proofs of Propositions 1 to 3, the degree of the output polynomial of any branch is dominated by the largest  <span class="math">\\sigma_{i}</span> . Thus, somehow removing one or more of the highest  <span class="math">\\sigma_{i}</span>  from an output branch reduces the degree of the corresponding polynomial. A lower degree in turn allows interpolation with reduced time and data complexity. Since we're using the low memory technique of [15], space complexity cannot be lowered further.</p>

    <p class="text-gray-300">As an example for this effect, consider the output branches  <span class="math">P_0^{(5)}(x), \\ldots, P_3^{(5)}(x)</span>  in fig. 2. We set  <span class="math">P&#x27;(x) \\coloneqq P_1^{(5)}(x) - P_0^{(5)}(x) = \\sigma_1 - \\sigma_2</span> . While  <span class="math">\\deg(P&#x27;(x)) = 0</span> , crucially  <span class="math">\\min_i (\\deg(P_i^{(5)}(x))) = \\deg(P_3^{(5)}(x)) = \\deg(\\sigma_3) = d</span> . This elimination of high degree  <span class="math">\\sigma_i</span>  is the basic idea behind branch subtraction.</p>

    <p class="text-gray-300">We represent the output of a  <span class="math">\\mathrm{UFN}_{\\mathrm{erf}}[p,r,t]E_K</span>  with input  <span class="math">(x_0,\\ldots ,x_{t - 1})</span>  as a vector  <span class="math">\\vec{o}</span>  using the following matrix notation. Intuitively, the matrix  <span class="math">A</span>  permutes the inputs like the last operation in any one round of a  <span class="math">\\mathrm{UFN}_{\\mathrm{erf}}</span> . The matrix  <span class="math">B</span>  accumulates the necessary  <span class="math">\\sigma_{i}</span> , following the definition of a  <span class="math">\\mathrm{UFN}_{\\mathrm{erf}}</span> .</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec {o} := A ^ {r} \\cdot \\vec {x} + \\left(\\underbrace {B _ {r \\bmod t} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overbrace {B \\mid \\dots \\mid B} ^ {\\lfloor \\frac {r}{2} \\rfloor \\text {t i m e s}}} _ {r \\text {c o l u m n s}}\\right) \\cdot \\vec {\\sigma}\\right) \\tag {5}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">A = \\left( \\begin{array}{c} - e _ {2} - \\\\ - e _ {3} - \\\\ \\vdots \\\\ - e _ {t} - \\\\ - e _ {1} - \\end{array} \\right), \\vec {x} = \\left( \\begin{array}{c} x _ {0} \\\\ x _ {1} \\\\ \\vdots \\\\ x _ {t - 1} \\end{array} \\right), B = \\left( \\begin{array}{c c} 0 &amp;amp; 1 \\\\ 0 &amp;amp; \\ddots \\\\ 1 &amp;amp; 0 \\end{array} \\right), \\vec {\\sigma} = \\left( \\begin{array}{c} \\sigma_ {0} \\\\ \\sigma_ {1} \\\\ \\vdots \\\\ \\sigma_ {r - 1} \\end{array} \\right)</span></div>

    <p class="text-gray-300">and  <span class="math">B_{r\\bmod t}</span>  are the right  <span class="math">r</span>  mod  <span class="math">t</span>  columns of  <span class="math">B</span> . Summarizing the dimensions, we have  <span class="math">A,B\\in \\mathbb{F}_p^{t\\times t}</span> ,  <span class="math">\\vec{x}\\in \\mathbb{F}_p^t</span> , and  <span class="math">\\vec{\\sigma}\\in \\mathbb{F}_p^r</span> .</p>

    <p class="text-gray-300">Note that eq. (5) is not recursive. Increasing  <span class="math">r</span>  to  <span class="math">r + 1</span>  leads to different dimensions in the composite matrix on the right hand side as well as in  <span class="math">\\vec{\\sigma}</span> . Note also that the output branches  <span class="math">\\vec{o}</span>  are nonlinear in variable  <span class="math">x</span>  despite the seemingly linear representation above, since the  <span class="math">\\sigma_{i}</span>  are nonlinear for  <span class="math">i \\geqslant \\ell</span> .</p>

    <p class="text-gray-300">As an example, we consider a  <span class="math">\\mathrm{UFN}_{\\mathrm{erf}}[p,5,4]</span>  with inputs  <span class="math">(b,b,b,x)</span>  like in fig. 2. In this instance, we have the following:</p>

    <div class="my-4 text-center"><span class="math-block">\\vec {o} = \\left( \\begin{array}{c c c c} 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\\\ 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\end{array} \\right) ^ {5} \\cdot \\left( \\begin{array}{c} b \\\\ b \\\\ b \\\\ x \\end{array} \\right) + \\left( \\begin{array}{c c c c} 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\\\ 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 \\\\ 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 \\\\ 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 \\end{array} \\right) \\cdot \\left( \\begin{array}{c} \\sigma_ {0} \\\\ \\sigma_ {1} \\\\ \\sigma_ {2} \\\\ \\sigma_ {3} \\\\ \\sigma_ {4} \\end{array} \\right) = \\left( \\begin{array}{c} b \\\\ b \\\\ x \\\\ b \\end{array} \\right) + \\left( \\begin{array}{c} \\sigma_ {0} + \\sigma_ {2} + \\sigma_ {3} + \\sigma_ {4} \\\\ \\sigma_ {0} + \\sigma_ {1} + \\sigma_ {3} + \\sigma_ {4} \\\\ \\sigma_ {0} + \\sigma_ {1} + \\sigma_ {2} + \\sigma_ {4} \\\\ \\sigma_ {1} + \\sigma_ {2} + \\sigma_ {3} \\end{array} \\right)</span></div>

    <p class="text-gray-300">Thus,  <span class="math">\\vec{o}</span>  is an alternative representation of  <span class="math">P_0^{(5)}(x),\\ldots ,P_3^{(5)}(x)</span> , concluding the example.</p>

    <p class="text-gray-300">Title Suppressed Due to Excessive Length</p>

    <p class="text-gray-300">Given this representation of the output branches <span class="math">\\vec{o}</span> of <span class="math">E_K</span>, we can apply some linear algebra in the following way: First, we observe the inverse of matrix <span class="math">B</span>.</p>

    <div class="my-4 text-center"><span class="math-block">B^{-1} = \\frac{1}{t - 1} \\begin{pmatrix} 2 - t &amp;amp; &amp;amp; 1 \\\\ &amp;amp; 2 - t &amp;amp; \\\\ &amp;amp; &amp;amp; \\ddots \\\\ 1 &amp;amp; &amp;amp; 2 - t \\end{pmatrix}</span></div>

    <p class="text-gray-300">Multiplying the vector of output branches <span class="math">\\vec{o}</span> by <span class="math">B^{-1}</span> limits occurrence of any <span class="math">\\sigma_i</span> in any one component of <span class="math">\\vec{o}</span> to exactly once. This corresponds to every <span class="math">\\sigma_i</span> occurring on only one "combined output branch".</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B^{-1} \\cdot \\vec{o} = B^{-1} \\cdot A^r \\cdot \\vec{x} + \\underbrace{(I_{\\text{rmod}t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{\\left\\lfloor \\frac{r}{t} \\right\\rfloor \\text{ times}}{I_t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I_t})}{r \\text{ columns}} \\cdot \\vec{\\sigma} \\tag{6}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">I_t \\in \\mathbb{F}_p^{t \\times t}</span> is the identity matrix and <span class="math">I_{\\text{rmod}t}</span> are the right <span class="math">r</span> mod <span class="math">t</span> columns of <span class="math">I_t</span>.</p>

    <p class="text-gray-300">From eq. (6) in combination with Corollary 2 we can derive</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\deg(\\text{first_component}(B^{-1} \\cdot \\vec{o})) \\tag{7} \\\\ = \\deg(\\sigma_{r-t} + \\sigma_{r-2t} + \\dots + B^{-1} A^r \\vec{x}) = \\deg(\\sigma_{r-t}) \\\\ = d^{r-2t+2} \\end{aligned}</span></div>

    <p class="text-gray-300">for <span class="math">\\ell = t - 1</span>.</p>

    <p class="text-gray-300"><strong>Complexity improvements</strong> Using the polynomial first_component <span class="math">(B^{-1} \\cdot \\vec{o})</span> of eq. (7) instead of the rightmost branch in the analysis of sections 5.1 to 5.3 lowers the complexities involved. Step 1 and 3 are unaffected by branch subtraction since the complexities do not depend on the number of rounds <span class="math">r</span>. For S2, the computational complexity is <span class="math">I_{lm}(d^{r-2t+2})</span> as opposed to <span class="math">I_{lm}(d^{r-t})</span>.</p>

    <p class="text-gray-300">Data complexity with branch subtraction is <span class="math">d^{r-2t+2} + 1</span> as opposed to <span class="math">d^{r-t} + 1</span> without. Space complexity stays <span class="math">\\mathcal{O}(1)</span> since the same low memory algorithm for recovery is being used. A summary of all the complexities with and without branch subtraction can be found in section 5.6.</p>

    <p class="text-gray-300">In order to achieve these improvements, <span class="math">B^{-1}</span> needs to be applied to the output branches <span class="math">\\vec{o}</span>. Since we only need the first component of vector <span class="math">B^{-1} \\cdot \\vec{o}</span>, we can limit ourselves to one product between two vectors of length <span class="math">r</span>, where each of the components has degree at most <span class="math">d^{r-t+1}</span>. The time complexity for <span class="math">r</span> many multiplications of two polynomials of degree at most <span class="math">d^{r-t+1}</span> is <span class="math">r \\mathsf{M}(d^{r-t+1})</span>.</p>

    <h2 id="sec-26" class="text-2xl font-bold">5.5 Key recovery with multiple keys</h2>

    <p class="text-gray-300">Our target case for multiple keys always reduces to keys <span class="math">(k_0, k_1) \\in \\mathbb{F}_p^2</span>, i.e. keys <span class="math">k_i</span> for <span class="math">i \\geqslant 2</span> do not influence the analysis, we interpret round keys <span class="math">k_i</span> as derived from <span class="math">k_0</span> and <span class="math">k_1</span>.</p>

    <p class="text-gray-300">We consider the round key scheduling <span class="math">k_{i}=(i+1)\\times k_{i\\pmod{2}}</span> for <span class="math">i\\geqslant 0</span>. As opposed to the variant where the same key is added in every round, the methods from section 5.3 building on Proposition 2 are not directly applicable. Instead, we use the results of Proposition 3. Furthermore, we use multiple instances of the equation <span class="math">Q_{i}(K)=z_{i}</span> for different constants <span class="math">b_{i}</span> for <span class="math">i\\in\\{0,1,2\\}</span>. This is an adaptation of the approach used in <em>[15]</em> where the authors analyzed balanced Feistel networks.</p>

    <p class="text-gray-300">In Proposition 3, let <span class="math">\\ell=1</span>, which corresponds to inputs of the form <span class="math">(b_{i},x,b_{i},\\ldots,b_{i})</span>. Then, the second highest coefficient of the rightmost branch of <span class="math">E_{K}</span> is of the form <span class="math">Q_{i}(K)=d^{r-2}(a_{d-1}+d\\beta_{i})</span> where <span class="math">\\beta_{i}=\\sigma_{0}+k_{1}=f(b_{i}+k_{0})+k_{1}</span>. Thus, we have <span class="math">Q_{i}(K)\\in\\mathbb{F}_{p}[k_{0},k_{1}]\\subsetneq\\mathbb{F}_{p}[K]</span>.</p>

    <p class="text-gray-300">We combine the three equations <span class="math">Q_{i}(K)=z_{i}</span> in the following manner: By solving for <span class="math">\\beta_{i}</span> we have</p>

    <p class="text-gray-300"><span class="math">\\beta_{0}</span> <span class="math">=f\\left(b_{0}+k_{0}\\right)+k_{1}=\\frac{z_{0}}{d^{r-1}}-\\frac{a_{d-1}}{d}</span> (8) <span class="math">\\beta_{1}</span> <span class="math">=f\\left(b_{1}+k_{0}\\right)+k_{1}=\\frac{z_{1}}{d^{r-1}}-\\frac{a_{d-1}}{d}</span> <span class="math">\\beta_{2}</span> <span class="math">=f\\left(b_{2}+k_{0}\\right)+k_{1}=\\frac{z_{2}}{d^{r-1}}-\\frac{a_{d-1}}{d}</span></p>

    <p class="text-gray-300">For <span class="math">0\\leqslant i,j\\leqslant 2</span> we get, through subtracting and rearranging,</p>

    <p class="text-gray-300"><span class="math">\\Delta_{(i,j)}:=f(b_{i}+k_{0})-f(b_{j}+k_{0})-\\frac{z_{i}-z_{j}}{d^{r-1}}=0</span> (9)</p>

    <p class="text-gray-300">As in section 5.3, it holds by the factor theorem that <span class="math">(k_{0}-\\bar{k}_{0})</span> is a factor of <span class="math">\\Delta_{(i,j)}</span> due to the construction of <span class="math">Q_{i}(K)</span>. <span class="math">\\bar{k}_{0}</span> can be found by computing the <span class="math">\\gcd\\left(\\Delta_{(0,1)},\\Delta_{(0,2)}\\right)</span>. Substituting <span class="math">k_{0}</span> with <span class="math">\\bar{k}_{0}</span> in any of eq. (8) yields <span class="math">\\bar{k}_{1}</span>.</p>

    <p class="text-gray-300"><span class="math">\\bar{k}_{1}=\\frac{z_{0}}{d^{r-1}}-\\frac{a_{d-1}}{d}-f\\left(b_{0}+\\bar{k}_{0}\\right)</span> (10)</p>

    <p class="text-gray-300">Complexity (of S1 and S2) Computing the algebraic form of the second highest coefficient can be done in constant time and space. For the complexities of recovering the value of the second highest coefficient, we refer to section 5.2, restating the computational complexity of <span class="math">\\mathsf{I}_{lm}(d^{r-1})</span> here. Data complexity is <span class="math">3d^{r-1}+3</span>.</p>

    <p class="text-gray-300">Complexity (of S3) Computing the gcd of polynomials of degree <span class="math">D</span> has computational complexity <span class="math">\\mathsf{G}(D)=\\mathcal{O}\\big{(}D\\log^{2}D\\big{)}</span>, as discussed in section 5.3. Since, <span class="math">D=d</span>, the complexity for recovering <span class="math">\\bar{k}_{0}</span> is <span class="math">\\mathsf{G}(d)</span>. Once, we recover <span class="math">k_{0}</span>, the <span class="math">k_{1}</span> can be found by using one of the eq. (8).</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">5.6 Summary of Complexities</h3>

    <p class="text-gray-300">In the sections above, a few approaches for key recovery are proposed. In the case of a single key <span class="math">\\bar{k}</span>, i. e. <span class="math">\\bar{K}=(\\bar{k},\\ldots,\\bar{k})</span>, we pointed out a novel method using root finding and applied an existing method using the gcd. The time and data complexities of the different approaches are summarized in table 1. Furthermore,</p>

    <p class="text-gray-300">Title Suppressed Due to Excessive Length</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Primitive</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">strategy</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">data</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">section</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ERF</td>

            <td class="px-3 py-2 border-b border-gray-700">root</td>

            <td class="px-3 py-2 border-b border-gray-700">M'(dt-1)+Im(dr-t)+R(dt-1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(dr-t)</td>

            <td class="px-3 py-2 border-b border-gray-700">5.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">gcd</td>

            <td class="px-3 py-2 border-b border-gray-700">M'(dt-1)+Im(dr-t)+G(dt-1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(dr-t)</td>

            <td class="px-3 py-2 border-b border-gray-700">5.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">root (bs)</td>

            <td class="px-3 py-2 border-b border-gray-700">M'(dt-1)+Im(dr-2t+2)+R(dt-1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(dr-2t+2)</td>

            <td class="px-3 py-2 border-b border-gray-700">5.3, 5.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">gcd (bs)</td>

            <td class="px-3 py-2 border-b border-gray-700">rM(dr-t+1)+Im(dr-2t+2)+G(dt-1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(dr-2t+2)</td>

            <td class="px-3 py-2 border-b border-gray-700">5.3, 5.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">multikey</td>

            <td class="px-3 py-2 border-b border-gray-700">Im(dr-1)+G(d)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(dr-1)</td>

            <td class="px-3 py-2 border-b border-gray-700">5.5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CRF</td>

            <td class="px-3 py-2 border-b border-gray-700">root</td>

            <td class="px-3 py-2 border-b border-gray-700">Im(dr-t)+R(d)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(dr-t)</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">gcd</td>

            <td class="px-3 py-2 border-b border-gray-700">Im(dr-t)+G(d)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(dr-t)</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">multikey</td>

            <td class="px-3 py-2 border-b border-gray-700">Im(dr-1)+G(d)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(dr-t)</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">the sections describing the approaches are pointed out. Since the algebraic degree of the round function  <span class="math">d</span>  is assumed to be small, space complexities are omitted in this overview. In most cases, the interpolation step dominates the computational as well as data complexity.</p>

    <p class="text-gray-300">We have validated our analysis by running small scale experiments. The UFN instances use randomized key, round constants, and coefficients for the round function. Since our analysis considers monic round functions, the highest coefficient of the round function is always 1. The fixed parameters of our experiments are  <span class="math">q = 99999989</span> ,  <span class="math">r = 17</span> ,  <span class="math">t = 4</span> . The round function is of degree 3. We use both proposed methods of key recovery, namely root finding and the gcd method, and apply the branch subtraction technique of section 5.4. Given above parameters, the degree of the combined output polynomial for  <span class="math">\\mathrm{UFN}_{\\mathrm{erf}}</span>  is  <span class="math">3^{11}</span> .</p>

    <p class="text-gray-300">It is interesting to observe the average number of roots: Although up to  <span class="math">3^{4 - 1} + 1 = 10</span>  roots could occur in theory, our experiments show that in practice, this number is significantly lower, with an average of only 1.89 roots.</p>

    <p class="text-gray-300">Table 1: Complexities of low memory interpolation cryptanalysis for  <span class="math">\\mathrm{UFN_{erf}}[p,r,t]</span>  for  <span class="math">r &amp;gt; 2t</span>  and  <span class="math">\\mathrm{UFN_{crf}}[p,r,t]</span>  for  <span class="math">r &amp;gt; t</span> . The branch subtraction technique of section 5.4 is denoted by "bs".  <span class="math">\\mathsf{M},\\mathsf{M}^{\\prime},\\mathsf{I}_{lm},\\mathsf{G}</span>  and  <span class="math">\\mathsf{R}</span>  are defined in section 5.2 and section 5.1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">root</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">gcd</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">algebraic coefficient</td>

            <td class="px-3 py-2 border-b border-gray-700">0.08950</td>

            <td class="px-3 py-2 border-b border-gray-700">0.10453</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">coefficient value</td>

            <td class="px-3 py-2 border-b border-gray-700">1468.50751</td>

            <td class="px-3 py-2 border-b border-gray-700">3132.21874</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">key recovery</td>

            <td class="px-3 py-2 border-b border-gray-700">0.80580</td>

            <td class="px-3 py-2 border-b border-gray-700">0.03565</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">total</td>

            <td class="px-3 py-2 border-b border-gray-700">1469.40283</td>

            <td class="px-3 py-2 border-b border-gray-700">3132.35892</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Observed average running times in milliseconds for key recovery of  <span class="math">\\mathrm{UFN_{erf}}[p,17,4]</span>  using root finding and the gcd method. The degree of the interpolated polynomial was  <span class="math">3^{11}</span> . ( <span class="math">n = 100</span> )</p>

    <p class="text-gray-300">Our experiments are implemented in python using sagemath <em>[21]</em>. All random values were generated using python’s built in “random” module. Measurements were taken on a machine with a standard Intel Core i5-6300U CPU and 7.22 GiB of RAM. Each experiment was run <span class="math">n=100</span> times. A summary of the observed average running times can be found in table 2. We note that the discrepancy of about factor 2 between the two applied methods comes from the fact that the gcd method requires interpolating two polynomials. For the root finding method, only one polynomial is required.</p>

    <h2 id="sec-29" class="text-2xl font-bold">6 Cryptanalysis of UFN_{crf}</h2>

    <p class="text-gray-300">We now analyze UFNs in the CRF variant according to the steps outlined in section 4. Since the analysis is extremely similar to the ERF variant, covered in section section 5, we only point out significant differences. Notably, recovering the value of the second highest coefficient as well as key recovery with only one round key <span class="math">\\bar{k}</span>, i. e. <span class="math">\\bar{K}=(\\bar{k},\\dots,\\bar{k})</span> are not reiterated herein.</p>

    <p class="text-gray-300">Algebraic Expression of Second Highest Coefficient. In a UFN_{crf}[<span class="math">p,r,t</span>], the polynomial representing the leftmost output branch has the lowest degree, as shown in Proposition 4. For this branch, the second highest coefficient <span class="math">Q(K)</span> has form <span class="math">d^{r-t-1}(a_{d-1}+d\\beta)</span>, with <span class="math">\\beta=(t-2)b+f((t-1)b+k_{0})+k_{1}</span>, as shown in Corollary 3. This coefficient is simpler than that of a UFN_{erf}, as it depends only on <span class="math">k_{0}</span> and <span class="math">k_{1}</span>. Consequently, computing <span class="math">Q(K)</span> is simpler, as described in algorithm 2.</p>

    <p class="text-gray-300">Algorithm 2 Second highest coefficient of leftmost branch in UFN_{crf}[<span class="math">p,r,t</span>] on input <span class="math">(x,b,\\dots,b)</span>. 100 <span class="math">\\textbf{Input: }r,t,f,</span> branch constant <span class="math">b</span>, round constants <span class="math">c_{0},c_{1}</span> 100 Output: polynomial <span class="math">q(K)</span> for second highest coefficient of leftmost branch 100 <span class="math">1\\ \\beta:=f\\left((t-1)b+k_{0}+c_{0}\\right)+(t-2)b+k_{1}+c_{1}</span> 100 <span class="math">\\textbf{2 return }d^{r-t-1}(a_{d-1}+d\\beta)</span></p>

    <p class="text-gray-300">Complexity (of S1) Calculating the algebraic form of the second highest coefficient requires only addition and multiplication of scalars. Thus, the complexity is <span class="math">\\mathcal{O}(1)</span>.</p>

    <p class="text-gray-300">Value of Second Highest Coefficient. We recover the second highest coefficient of the leftmost branch for UFN_{crf}. Consequently, evaluation points <span class="math">y_{j}</span> for the interpolation are the values of the leftmost output branch. Inputs of the form <span class="math">x_{j}=(\\alpha^{j},b,\\dots,b)</span> are used for the low memory interpolation, where <span class="math">\\alpha\\in\\mathbb{F}_{p}</span> is a primitive element as before. These changes allow application of Corollary 3. Complexity (of S2) The complexities do not change from those of UFN_{erf} in section 5.2, i.e., it remains <span class="math">\\mathsf{I}_{lm}(d^{r-t})</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Title Suppressed Due to Excessive Length</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">root</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">gcd</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">algebraic coefficient</td>

            <td class="px-3 py-2 border-b border-gray-700">0.03036</td>

            <td class="px-3 py-2 border-b border-gray-700">0.04744</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">coefficient value</td>

            <td class="px-3 py-2 border-b border-gray-700">11832.86184</td>

            <td class="px-3 py-2 border-b border-gray-700">23482.13424</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">key recovery</td>

            <td class="px-3 py-2 border-b border-gray-700">0.48999</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02876</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">total</td>

            <td class="px-3 py-2 border-b border-gray-700">11833.38219</td>

            <td class="px-3 py-2 border-b border-gray-700">23482.21044</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: Observed average running times in milliseconds for key recovery of  <span class="math">\\mathrm{UFN}_{\\mathrm{crf}}[p,17,4]</span>  using root finding and the gcd method. The degree of the interpolated polynomial was  <span class="math">3^{13}</span> . ( <span class="math">n = 100</span> )</p>

    <p class="text-gray-300">Complexity (of S3) This is the final key recovery step. For the case of single key, the complexity of this step using GCD technique is  <span class="math">\\mathsf{G}(d)</span>  and using root finding technique is  <span class="math">\\mathsf{R}(d)</span> .</p>

    <p class="text-gray-300">KEY RECOVERY IN THE GENERAL CASE. We now consider  <span class="math">\\mathrm{UFN}_{\\mathrm{crf}} E_{\\bar{K}}</span>  with general  <span class="math">\\bar{K}</span> , starting with the bivariate case. That is,  <span class="math">\\bar{K} = (\\bar{k}_0, \\dots, \\bar{k}_{r-1})</span>  where  <span class="math">\\bar{k}_i</span>  is derived from  <span class="math">\\bar{k}_0</span>  and  <span class="math">\\bar{k}_1</span> . Like in section 5.5, we consider the round key scheduling  <span class="math">k_i = (i+1) \\times k_{i \\pmod{2}}</span>  for  <span class="math">i \\geqslant 0</span> . The algebraic form of the second highest coefficient is  <span class="math">Q_i(K) = d^{r-1}(a_{d-1} + d\\beta_i)</span>  where  <span class="math">\\beta_i = (t-2)b_i + f((t-1)b_i + k_0) + k_1</span> , as shown in Proposition 4.</p>

    <p class="text-gray-300">Combining the three equations  <span class="math">Q_{i}(K) = z_{i}</span>  works the same way as in section 5.5. Due to the different form of  <span class="math">\\beta_{i}</span> , the equations change slightly: By solving for  <span class="math">\\beta_{i}</span>  we have</p>

    <div class="my-4 text-center"><span class="math-block">\\beta_ {i} = (t - 2) b _ {i} + f ((t - 1) b _ {i} + k _ {0}) + k _ {1} = \\frac {z _ {i}}{d ^ {r}} - \\frac {a _ {d - 1}}{d} \\tag {11}</span></div>

    <p class="text-gray-300">For  <span class="math">2 \\geqslant i, j \\geqslant 0</span>  we get, through subtracting and rearranging,</p>

    <div class="my-4 text-center"><span class="math-block">\\Delta_ {(i, j)} := f ((t - 1) b _ {i} + k _ {0}) - f ((t - 1) b _ {j} + k _ {0}) + (t - 2) (b _ {i} - b _ {j}) + \\frac {z _ {i} - z _ {j}}{d ^ {r}} = 0 \\tag {12}</span></div>

    <p class="text-gray-300">Now, as in section 5.3, we recover  <span class="math">\\bar{k}_0</span>  by finding  <span class="math">\\gcd \\left(\\Delta_{(0,1)},\\Delta_{(0,2)}\\right)</span> . Then  <span class="math">\\bar{k}_1</span>  can be found using one of the eq. (11).</p>

    <p class="text-gray-300">Complexity (of S1-S3). Although the form of  <span class="math">q(k)</span>  and  <span class="math">\\beta</span>  are slightly different from those in  <span class="math">\\mathrm{UFN}_{\\mathrm{erf}}</span> , the steps are fundamentally the same as for the ERF variant. Thus, the complexities don't differ from those in section 5.5. We summarize the complexities of the different key recovery approaches for  <span class="math">\\mathrm{UFN}_{\\mathrm{crf}}</span>  in table 1.</p>

    <p class="text-gray-300">Experimental Verification Just as for  <span class="math">\\mathrm{UFN}_{\\mathrm{erf}}</span>  in section 5.7, we performed small scale experiments for  <span class="math">\\mathrm{UFN}_{\\mathrm{crf}}</span>  with the same number of rounds  <span class="math">r = 17</span>  and branches  <span class="math">t = 4</span> . Because the branch subtraction technique of section 5.4 does not apply to  <span class="math">\\mathrm{UFN}_{\\mathrm{crf}}</span> , the degree of the polynomial that is to be interpolated is  <span class="math">3^{13}</span> . Running times of the experiments can be found in table 3. We note that for the root finding technique, the average length of the key candidate list was 2.1, extremely similar to those of the experiments on  <span class="math">\\mathrm{UFN}_{\\mathrm{erf}}</span>  of section 5.7.</p>

    <p class="text-gray-300">7 Cryptanalysis of UFN based Sponge hash</p>

    <p class="text-gray-300">Either of the UFNs may be used in a Sponge mode to construct a hash function over <span class="math">\\mathbb{F}_{p}</span>. The permutation thereof is instantiated with a fixed key UFN. An example of such hash function is recently proposed GMiMCHash <em>[2]</em>. Here we will describe how the root finding technique can be used to find collision in such hash function. We will assume that the rate in Sponge mode is <span class="math">r=\\log_{2}p</span> (bits) and the hash value also has the same size. An input message to the hash function <span class="math">\\in\\mathbb{F}_{p}^{s}</span> for <span class="math">s\\geqslant 1</span> and consists of message block that are elements of <span class="math">\\mathbb{F}_{p}</span>.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">7.0.1 Prelimage and second preimage attack</h4>

    <p class="text-gray-300">Let us consider a message <span class="math">M^{\\prime}=(m^{\\prime}_{0},m^{\\prime}_{1})\\in\\mathbb{F}_{p}^{2}</span> of size <span class="math">2r</span> bits. It is clear that the UFN must have branch size <span class="math">r</span> bits. Suppose, <span class="math">f</span> denotes the permutation instantiated with a fixed key UFN and the rightmost output branch corresponds to the rate in Sponge mode. We find a second preimage <span class="math">M</span> in the following way</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose arbitrary message block <span class="math">m_{0}\\in\\mathbb{F}_{p}</span>. Suppose, <span class="math">h_{t}</span> (<span class="math">\\in\\mathbb{F}_{p}</span>) denotes the first <span class="math">r</span> bits (and the rightmost output branch) of <span class="math">f(m_{0})</span> and <span class="math">h_{i}</span> for <span class="math">i=2,\\ldots t</span> denote the outputs corresponding to the <span class="math">t-1</span> branches of the UFN. Let <span class="math">h</span> be the hash value of the message <span class="math">M^{\\prime}=(m^{\\prime}_{0},m^{\\prime}_{1})</span>.</li>

      <li>Compute the polynomial <span class="math">P(x)</span> corresponding to the first output branch of the UFN for the input <span class="math">h_{1},h_{2},\\ldots,h_{t}+x</span>. Note that <span class="math">P(x)</span> is the polynomial corresponding to the hash value of <span class="math">(m_{0},x)</span>.</li>

      <li>Find the roots of <span class="math">P(x)-h</span>.</li>

    </ol>

    <p class="text-gray-300">Note that any root of <span class="math">P(x)-h</span> gives a second preimage attack.</p>

    <p class="text-gray-300">Instead of choosing <span class="math">h</span> as hash value of a message if we choose it arbitrarily then the above attack gives a <em>preimage</em> attack on the hash function.</p>

    <p class="text-gray-300">Complexity. The complexity of finding all roots (without multiplicities) is of a polynomial of degree <span class="math">D</span> over <span class="math">\\mathbb{F}_{p}</span> is <span class="math">\\mathsf{R}(D)</span>. For UFN<span class="math">{}_{\\mathsf{erf}}</span> the degree of the polynomial <span class="math">P(x)</span> after <span class="math">r</span> rounds is <span class="math">d^{r-t}</span>. Hence, the the complexity of the root finding step is <span class="math">\\mathsf{R}(d^{r-t})</span>.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">7.0.2 Collision attack</h4>

    <p class="text-gray-300">Choose two message blocks <span class="math">m_{0},m^{\\prime}_{0}\\in\\mathbb{F}_{p}</span>.Then, a collision attack on the hash function is described as following</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the polynomial <span class="math">P(x)</span> representing the hash value of a message of the form <span class="math">(m_{0},x)</span> and <span class="math">P^{\\prime}(x)</span> corresponding to the hash value of the message <span class="math">(m^{\\prime}_{0},x)</span>.</li>

      <li>Compute the roots of <span class="math">Q(x):=P(x)-P^{\\prime}(x)</span>.</li>

    </ol>

    <p class="text-gray-300">The complexity of the collision attack is same as the complexity of the preimage or second preimage attacks. The degree of the polynomial <span class="math">Q</span> is <span class="math">d^{r-t-1}</span>.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">7.0.3 Increasing the rate</h4>

    <p class="text-gray-300">If the rate is increased to <span class="math">2r</span> then the attacks apply similarly. For preimage and second preimage attack we choose the message <span class="math">M=((m^{\\prime}_{00},m^{\\prime}_{01}),(m^{\\prime}_{10},m^{\\prime}_{11}))</span> where each <span class="math">m_{ij}\\in\\mathbb{F}_{p}</span>. The polynomial is constructed for <span class="math">((m_{00},m_{01}),(m_{10},x))</span>. The collision attack also applies analogously as for rate <span class="math">r</span></p>

    <p class="text-gray-300">The hash output is in <span class="math">\\mathbb{F}_{p}</span>. The complexities remains the same since the degree of the does not change.</p>

    <p class="text-gray-300">We point out that the number of rounds for the UFN<span class="math">{}_{\\textsf{erf}}</span> given in the GMiMC proposal is not explicitly justified by analyzing the security of the hash function.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">7.1 Experimental verification</h3>

    <p class="text-gray-300">We evaluate our results from section 7 by running small scale experiments. We regarded GMiMC<span class="math">{}_{\\textsf{erf}}[p,r,t]</span> permutation with <span class="math">p=99999989</span>, <span class="math">3\\leqslant r\\leqslant 7</span>, <span class="math">3\\leqslant t\\leqslant 6</span> with <span class="math">k=0</span> to instantiate the hash function for two different sets of experiments: Finding second preimages and finding collisions. The round constants were randomly chosen and fixed. For each combination of <span class="math">(r,t)</span> in the given intervals, 100 experiments were performed. The messages were re-randomized for every experiment. The experiments were implemented in python using sagemath. To generate the random values, pythons “random” module was used. All the measurements were taken on a machine with a standard Intel Core i5-6300U CPU and 7.22 GiB of RAM.</p>

    <p class="text-gray-300">For the experiments on second preimages, across all 2000 experiments, we observed a total of 751 iterations where no second preimage was found. We consider these experiments to have failed. This puts the estimated success probability of finding at least one preimage to 62.5%. Of secondary interest is the average number of second preimages found given that the attack was successful, i. e. at least one second preimage was found. Over all the 1249 successful experiments, an average of 1.55 second preimages were observed per experiment.</p>

    <p class="text-gray-300">For the experiments on collisions, no collision could be found in 712 of the 2000 experiments. We consider these experiments to have failed. The success probability is thus 64.4%. Of secondary interest is the average number of collisions found in the successful experiments, i. e. at least one collision was found. In 1288 successful experiments, an average of 1.57 collisions were observed per experiment. The failure rates of 37.6% and 35.6% respectively are supported by the fact that for our parameters (<span class="math">p</span> and degree of the underlying polynomial), <span class="math">\\approx 36.8\\%</span> of the polynomials do not have a root <em>[14]</em>. We elaborate on this in appendix D.</p>

    <p class="text-gray-300">Tables 5 and 6 in appendix C summarize running times of our experiments on second preimages and collisions. In fig. 4 in appendix C, the number of second preimages found in our experiments is plotted. Similarly, fig. 5 in appendix C visualizes the number of collisions found.</p>

    <h2 id="sec-34" class="text-2xl font-bold">8 Attacks on Reduced Round GMiMC</h2>

    <p class="text-gray-300">The GMiMC family has two members that are based on UFN: GMiMC<span class="math">{}_{\\textsf{erf}}</span> and GMiMC<span class="math">{}_{\\textsf{crf}}</span>. The round function used in both variants is <span class="math">f(x)=x^{3}</span>, i.e.,<span class="math">d=3</span>. Due to target applications we can also assume that field size is bounded e.g. <span class="math">\\log_{2}p\\leqslant 256</span>. For some specific sizes of the field and number of branches in the UFNs, we show the number of rounds of GMiMC block cipher and hash functions that can be attacked in table 4. Our analysis of the GMiMCHash instances does</p>

    <p class="text-gray-300">Arnab Roy, Elena Andreeva, and Jan Ferdinand Sauer</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Primitive</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log2p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Security</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t/Arity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Data</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Attack type</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GMiMCerf</td>

            <td class="px-3 py-2 border-b border-gray-700">BC</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">292</td>

            <td class="px-3 py-2 border-b border-gray-700">254</td>

            <td class="px-3 py-2 border-b border-gray-700">KR</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GMiMCerf</td>

            <td class="px-3 py-2 border-b border-gray-700">Permutation</td>

            <td class="px-3 py-2 border-b border-gray-700">61</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">102</td>

            <td class="px-3 py-2 border-b border-gray-700">248</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">ZS [8]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GMiMCerf</td>

            <td class="px-3 py-2 border-b border-gray-700">Permutation</td>

            <td class="px-3 py-2 border-b border-gray-700">125</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700">206</td>

            <td class="px-3 py-2 border-b border-gray-700">2125</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">ZS [8]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GMiMCerf</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

            <td class="px-3 py-2 border-b border-gray-700">2159</td>

            <td class="px-3 py-2 border-b border-gray-700">296</td>

            <td class="px-3 py-2 border-b border-gray-700">KR</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GMiMCerfHash</td>

            <td class="px-3 py-2 border-b border-gray-700">Hash</td>

            <td class="px-3 py-2 border-b border-gray-700">254</td>

            <td class="px-3 py-2 border-b border-gray-700">127</td>

            <td class="px-3 py-2 border-b border-gray-700">1:4</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">2119</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">Coll</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GMiMCerfHash</td>

            <td class="px-3 py-2 border-b border-gray-700">Hash</td>

            <td class="px-3 py-2 border-b border-gray-700">61</td>

            <td class="px-3 py-2 border-b border-gray-700">128</td>

            <td class="px-3 py-2 border-b border-gray-700">4:12</td>

            <td class="px-3 py-2 border-b border-gray-700">52</td>

            <td class="px-3 py-2 border-b border-gray-700">283</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">Coll [8]</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: Number of attacked rounds for specific GMiMC instances of GMiMC block ciphers and hash functions. For hash function the arity denotes the ratio of no. of branches used for hash output and total number of branches(t) in UFN.</p>

    <p class="text-gray-300">not contradict their security claims in the GMiMC proposal [2] (in terms of number of secure rounds).</p>

    <p class="text-gray-300">Recently, in [8] a collision attack on GMiMCHash-256 was proposed for a field  <span class="math">\\mathbb{F}_q</span>  with  <span class="math">q = 2^{125} + 266 \\times 2^{64} + 1</span>  and  <span class="math">t = 14</span> . This means the hash output is  <span class="math">\\mathbb{F}_q^2</span> . However, our described method is designed for a hash output in  <span class="math">\\mathbb{F}_p</span> . Since the choice of hash outputs over a field in the two cases are incomparable, a direct comparison of our collision attack with the collision attack in [8] (in terms of complexity or number of rounds attacked) is not meaningful. For the attacks on GMiMC block ciphers, we provide key recovery attack on (reduced) 60-round  <span class="math">\\mathrm{GMiMC}_{\\mathrm{erf}}</span>  over a prime field of size 128 bits. On the other hand a zero-sum(ZS) distinguisher on the full GMiMC(ERF) permutation (with fixed key) over  <span class="math">\\mathbb{F}_q</span>  with  <span class="math">\\log q = 125</span>  is proposed in [8].</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Martin Albrecht, Lorenzo Grassi, Christian Rechberger, Arnab Roy, and Tyge Tiessen. Mimc: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. In International Conference on the Theory and Application of Cryptology and Information Security, pages 191-219. Springer, 2016.</li>

      <li>Martin R. Albrecht, Lorenzo Grassi, Léo Perrin, Sebastian Ramacher, Christian Rechberger, Dragos Rotaru, Arnab Roy, and Markus Schofnegger. Feistel structures for mpc, and more. In Computer Security - ESORICS 2019 - 24th European Symposium on Research in Computer Security, Luxembourg, September 23-27, 2019, Proceedings, Part II, pages 151-171, 2019.</li>

      <li>Martin R. Albrecht, Lorenzo Grassi, Leo Perrin, Sebastian Ramacher, Christian Rechberger, Dragos Rotaru, Arnab Roy, and Markus Schofnegger. Feistel structures for mpc, and more. Cryptology ePrint Archive, Report 2019/397, 2019.</li>

      <li>Martin R. Albrecht, Lorenzo Grassi, Christian Rechberger, Arnab Roy, and Tyge Tiessen. Mimc: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. In Advances in Cryptology - ASIACRyPT 2016 - 22nd International Conference on the Theory and Application of Cryptology and Information Security, Hanoi, Vietnam, December 4-8, 2016, Proceedings, Part I, 2016.</li>

      <li>Martin R. Albrecht, Christian Rechberger, Thomas Schneider, Tyge Tiessen, and Michael Zohner. Ciphers for MPC and FHE. In Advances in Cryptology - EURO-</li>

    </ol>

    <p class="text-gray-300">CRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part I, 2015.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[6] Abdelrahaman Aly, Tomer Ashur, Eli Ben-Sasson, Siemen Dhooghe, and Alan Szepieniec. Design of symmetric-key primitives for advanced cryptographic protocols. Cryptology ePrint Archive, Report 2019/426, 2019.</li>

      <li>[7] Tomer Ashur and Siemen Dhooghe. Marvellous: a stark-friendly family of cryptographic primitives. Cryptology ePrint Archive, Report 2018/1098, 2018.</li>

      <li>[8] Tim Beyne, Anne Canteaut, Itai Dinur, Maria Eichlseder, Gregor Leander, Gaëtan Leurent, María Naya-Plasencia, Léo Perrin, Yu Sasaki, Yosuke Todo, and Friedrich Wiemer. Out of oddity – new cryptanalytic techniques against symmetric primitives optimized for integrity proof systems. In Advances in Cryptology – CRYPTO 2020. Springer International Publishing, 2020.</li>

      <li>[9] Xavier Bonnetain. Collisions on Feistel-MiMC and univariate GMiMC. Cryptology ePrint Archive, Report 2019/951, 2019.</li>

      <li>[10] Anne Canteaut, Sergiu Carpov, Caroline Fontaine, Tancrède Lepoint, María Naya-Plasencia, Pascal Paillier, and Renaud Sirdey. Stream ciphers: A practical solution for efficient homomorphic-ciphertext compression. In Thomas Peyrin, editor, Fast Software Encryption, 2016.</li>

      <li>[11] Christoph Dobraunig, Maria Eichlseder, Lorenzo Grassi, Virginie Lallemand, Gregor Leander, Eik List, Florian Mendel, and Christian Rechberger. Rasta: A cipher with low anddepth and few ands per bit. In Advances in Cryptology - CRYPTO 2018 - 38th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 19-23, 2018, Proceedings, Part I, pages 662–692, 2018.</li>

      <li>[12] Lorenzo Grassi, Dmitry Khovratovich, Christian Rechberger, Arnab Roy, and Markus Schofnegger. Poseidon: A new hash function for zero-knowledge proof systems. Cryptology ePrint Archive, Report 2019/458, 2019.</li>

      <li>[13] Thomas Jakobsen and Lars R. Knudsen. The Interpolation Attack on Block Ciphers. In In Fast Software Encryption, pages 28–40. Springer-Verlag, 1997.</li>

      <li>[14] V. K. Leont’ev. Roots of random polynomials over a finite field. Mathematical Notes, 80(1):300–304, Jul 2006.</li>

      <li>[15] Chaoyun Li and Bart Preneel. Improved Interpolation Attacks on Cryptographic Primitives of Low Algebraic Degree. Cryptology ePrint Archive, Report 2019/812, 2019.</li>

      <li>[16] Arnab Roy Lorenzo Grassi, Christian Rechberger. Gmimcs new key schedule. personal communication, 8 2019.</li>

      <li>[17] Pierrick Méaux, Anthony Journault, François-Xavier Standaert, and Claude Carlet. Towards stream ciphers for efficient fhe with low-noise ciphertexts. Cryptology ePrint Archive, Report 2016/254, 2016.</li>

      <li>[18] Starkware. STARK-Friendly Hash Challenge. Website, 8 2019. https://starkware.co/hash-challenge/.</li>

      <li>[19] H.-J. Stoss. The complexity of evaluating interpolation polynomials. Theoretical Computer Science, 41:319–323, 1985.</li>

      <li>[20] Bing Sun, Longjiang Qu, and Chao Li. New cryptanalysis of block ciphers with low algebraic degree. In Orr Dunkelman, editor, Fast Software Encryption. Springer Berlin Heidelberg, 2009.</li>

      <li>[21] The Sage Developers. SageMath, the Sage Mathematics Software System (Version x.y.z), YYYY. https://www.sagemath.org.</li>

      <li>[22] Joachim Von Zur Gathen and Jürgen Gerhard. Modern Computer Algebra. Cambridge university press, 2013.</li>

    </ul>

    <p class="text-gray-300">A Proofs</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">A.1 Proof of Proposition 1</h3>

    <h6 id="sec-37" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose that Proposition 1 holds for fix <span class="math">r</span>. Applying one more round <span class="math">r+1</span> yields the following, according to eq. (1):</p>

    <p class="text-gray-300"><span class="math">\\sigma_{r}</span> <span class="math">=f(P_{0}^{(r)}+k_{r})</span> <span class="math">(P_{0}^{(r+1)},P_{1}^{(r+1)},P_{2}^{(r+1)})</span> <span class="math">=(P_{1}^{(r)}+\\sigma_{r},P_{2}^{(r)}+\\sigma_{r},P_{0}^{(r)})</span></p>

    <p class="text-gray-300">Developing <span class="math">\\sigma_{r}</span> by the binomial theorem we get the following:</p>

    <p class="text-gray-300"><span class="math">\\sigma_{r}</span> <span class="math">=(P_{0}^{(r)}+k_{r})^{d}+\\sum_{i=0}^{d-1}a_{i}(P_{0}^{(r)}+k_{r})^{i}</span> <span class="math">=\\left(x^{d^{r-2}}+d^{r-3}(a_{d-1}+d\\beta)x^{d^{r-2}-1}+\\cdots+a_{0}+k_{r})^{d}+\\sum_{i=0}^{d-1}a_{i}(P_{0}^{(r)}+k_{r})^{i}</span> <span class="math">=(x^{d^{r-2}})^{d}+d\\cdot d^{r-3}(a_{d-1}+d\\beta)x^{d^{r-2}-1}(x^{d^{r-2}})^{d-1}+\\cdots+(d^{r-3}(a_{d-1}+d\\beta)x^{d^{r-2}-1})^{d}</span> <span class="math">\\qquad+\\cdots+a_{0}^{d}+\\cdots+k_{r}^{d}+\\sum_{i=0}^{d-1}a_{i}(P_{0}^{(r)}+k_{r})^{i}</span> <span class="math">=x^{d^{r-1}}+d^{r-2}(a_{d-1}+d\\beta)x^{d^{r-1}-1}+\\cdots+a_{0}</span></p>

    <p class="text-gray-300">By the assumption of the induction, <span class="math">\\mathsf{deg}(P_{2}^{(r)})\\leqslant\\mathsf{deg}(P_{1}^{(r)})\\leqslant d^{r-2}</span>. Thus the degree of <span class="math">\\sigma_{r}</span> dominates, which leads us to the proofs first conclusions.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{deg}(P_{0}^{(r+1)})=\\mathsf{deg}(P_{1}^{(r+1)})=\\mathsf{deg}(\\sigma_{r})=x^{d^{r-1}}</span> <span class="math">\\mathsf{coeff}(P_{0}^{(r+1)},x^{d^{r-1}})=\\mathsf{coeff}(P_{1}^{(r+1)},x^{d^{r-1}})=\\mathsf{coeff}(\\sigma_{r},x^{d^{r-1}})=1</span></p>

    <p class="text-gray-300">Since, by assumption, <span class="math">d\\geqslant 3</span> and <span class="math">r\\geqslant 4</span>, it holds that <span class="math">d^{r-1}-1&gt;d^{r-2}</span>. The coefficients of the second highest term in <span class="math">P_{0}^{(r+1)}</span> and <span class="math">P_{1}^{(r+1)}</span> are thus solely contributed by <span class="math">\\sigma_{r}</span>. This leads us to the proofs last conclusion.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{coeff}(P_{0}^{(r+1)},x^{d^{r-1}-1})=\\mathsf{coeff}(P_{1}^{(r+1)},x^{d^{r-1}-1})=\\mathsf{coeff}(\\sigma_{r},x^{d^{r-1}-1})=d^{r-2}(a_{d-1}+d\\beta)</span></p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">A.2 Proof of Proposition 2</h3>

    <h6 id="sec-39" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Because of the position of the variable <span class="math">x</span>, <span class="math">(t-1)</span> many “swappings” of branches need to be performed before <span class="math">x</span> becomes part of the input to a round function. Each round of the UFN performs exactly one such swap. Thus, we observe that <span class="math">x</span> does not contribute to <span class="math">\\sigma_{i}</span> for the first <span class="math">(t-2)</span> rounds, i. e. <span class="math">\\mathsf{deg}(\\sigma_{i})=0</span></p>

    <p class="text-gray-300">Title Suppressed Due to Excessive Length</p>

    <p class="text-gray-300">for <span class="math">i &amp;lt; t - 1</span>. In the <span class="math">(t - 1)</span>-st round, we have the following:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sigma_{t-1} = f(x + \\sigma_0 + \\cdots + \\sigma_{t-2} + k_{t-1}) \\\\ = f(x + \\beta) \\\\ = (x + \\beta)^d + a_{d-1}(x + \\beta)^{d-1} + \\sum_{i=0}^{d-2} a_i(x + \\beta)^i \\\\ = x^d + d\\beta x^{d-1} + \\cdots + d\\beta^{d-1} x + \\beta^d \\\\ \\quad + a_{d-1} x^{d-1} + a_{d-1}(d-1) \\beta x^{d-2} + \\cdots + a_{d-1}(d-1) \\beta^{d-2} x + a_{d-1} \\beta^{d-1} \\\\ \\quad + \\sum_{i=0}^{d-2} a_i(x + \\beta)^i \\\\ = x^d + (a_{d-1} + d\\beta) x^{d-1} + \\cdots + a_0 \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Now, we can use induction over <span class="math">r</span> much in the same way as in Proposition 1.</p>

    <h2 id="sec-40" class="text-2xl font-bold">A.3 Proof of Proposition 4</h2>

    <p class="text-gray-300">Proof. After 1 round, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma_0 = f\\left(\\sum_{j=1}^{t-1} b + k_0\\right) = f\\left((t-1) b + k_0\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">(P_0^{(1)}, \\ldots, P_{t-2}^{(1)}, P_{t-1}^{(1)}) = (b, \\ldots, b, x + \\sigma_0)</span></div>

    <p class="text-gray-300">After 2 rounds, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma_1 = f\\left(\\sum_{j=1}^{t-2} b + x + \\sigma_0 + k_1\\right) = f(x + \\beta)</span></div>

    <div class="my-4 text-center"><span class="math-block">(P_0^{(2)}, \\ldots, P_{t-2}^{(2)}, P_{t-1}^{(2)}) = (b, \\ldots, x + \\sigma_0, b + \\sigma_1)</span></div>

    <p class="text-gray-300">Expanding <span class="math">\\sigma_1</span> by the binomial theorem yields the following:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sigma_1 = f(x + \\beta) \\\\ = (x + \\beta)^d + a_{d-1}(x + \\beta)^{d-1} + \\sum_{i=0}^{d-2} a_i(x + \\beta)^i \\\\ = x^d + d\\beta x^{d-1} + \\cdots + \\beta^d \\\\ \\quad + a_{d-1} x^{d-1} + a_{d-1}(d-1) \\beta x^{d-2} + \\cdots + a_{d-1} \\beta^{d-1} + \\sum_{i=0}^{d-2} a_i(x + \\beta)^i \\\\ = x^d + (a_{d-1} + d\\beta) x^{d-1} + \\cdots + a_0 \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Arnab Roy, Elena Andreeva, and Jan Ferdinand Sauer</p>

    <p class="text-gray-300">After expanding  <span class="math">\\sigma_{1}</span> , an induction over  <span class="math">r</span>  like in Proposition 1 finishes the proof.</p>

    <p class="text-gray-300">We depict the progression of an input  <span class="math">(b, b, b, x)</span>  through 5 rounds of  <span class="math">\\mathrm{UFN}_{\\mathrm{erf}}</span>  with 4 branches in fig. 2. In fig. 3, we show the progression of an input variable through 4 rounds of  <span class="math">\\mathrm{UFN}_{\\mathrm{erf}}</span>  with 3 branches and variable input in the rightmost branch as well as  <span class="math">\\mathrm{UFN}_{\\mathrm{crf}}</span>  with 3 branches and variable input in the leftmost branch.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 2: Example of summands being added in a  <span class="math">\\mathrm{UFN}_{\\mathrm{erf}}</span></p>

    <p class="text-gray-300">In tables 5 and 6 we summarize the running times for the experiments from section 7.1 for  <span class="math">5 \\leqslant r \\leqslant 7</span>  and  <span class="math">3 \\leqslant t \\leqslant 6</span> . The running times for reconstruction of the polynomial and root finding are reported alongside the total running times.</p>

    <p class="text-gray-300">In fig. 4, the number of second preimages found in our experiments is plotted. Similarly, fig. 5 visualizes the number of collisions found. In the subfigures,</p>

    <p class="text-gray-300">Title Suppressed Due to Excessive Length</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> (a) Branch development in a UFN erf[p,4,3].</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> (b) Branch development in a UFN crf[p,4,3]. Fig. 3:  <span class="math">\\mathrm{UFN}_{\\mathrm{erf}}[4, 3]</span>  and  <span class="math">\\mathrm{UFN}_{\\mathrm{crf}}[4, 3]</span>  with rightmost and leftmost branch input as variable respectively.</p>

    <p class="text-gray-300">different numbers of branches  <span class="math">t</span>  are depicted. Each subfigure shows, for different numbers of rounds  <span class="math">r</span>  on the  <span class="math">x</span> -axis, the number of additional preimages or collisions on the  <span class="math">y</span> -axis found over the 100 randomized experiments. For example, when regarding  <span class="math">t = 3</span>  branches in fig. 4a, for the GMiMCHash instance instantiated with  <span class="math">\\mathrm{GMimC_{erf}}</span>  with  <span class="math">r = 6</span>  rounds, there were 14 of our 100 experiments in which we found 2 preimages, and 9 in which we found 3 preimages. A red bar signifies that no preimage (or no collision for fig. 5) was found, while the green bars indicate at least one second preimage (or collision, respectively) found, i.e. a successful attack.</p>

    <p class="text-gray-300">In order to validate our failure rate of section 7.1, we calculate the probability that a random polynomial of degree  <span class="math">d</span>  has no roots in a specific finite field. A formula  <span class="math">t_d</span>  for the number of polynomials of degree  <span class="math">d</span>  over finite field  <span class="math">\\mathbb{F}_q</span>  that have no root in  <span class="math">\\mathbb{F}_q</span>  is given in lemma 1 in [14] and reproduced in eq. (13).</p>

    <div class="my-4 text-center"><span class="math-block">t _ {d} = \\sum_ {i = 0} ^ {d} (- 1) ^ {i} \\binom {q} {i} q ^ {d - i} \\tag {13}</span></div>

    <p class="text-gray-300">The total number of polynomials of degree  <span class="math">d</span>  over  <span class="math">\\mathbb{F}_q</span>  is  <span class="math">q^d</span> . Our parameters are  <span class="math">q = 99999989</span>  and  <span class="math">d = 3^i</span>  with  <span class="math">3 \\leqslant i \\leqslant 7</span> . This results in a probability of a random polynomial not having any root in  <span class="math">\\mathbb{F}_q</span>  of  <span class="math">t_d / q^d \\approx 36.8\\%</span>  for any  <span class="math">i</span>  in the given interval.</p>

    <p class="text-gray-300">Arnab Roy, Elena Andreeva, and Jan Ferdinand Sauer</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=7</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">construct poly</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0003</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0003</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0003</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">root finding</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0005</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0005</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0004</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">total</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0008</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0009</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0008</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(a)  <span class="math">t = 3</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=7</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">construct poly</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0233</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0235</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0229</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">root finding</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0263</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0267</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0268</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">total</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0498</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0503</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0498</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(c)  <span class="math">t = 5</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=7</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">construct poly</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0019</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0019</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0019</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">root finding</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0026</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0029</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0032</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">total</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0046</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0049</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0052</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(b)  <span class="math">t = 4</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=7</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">construct poly</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2966</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2940</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2954</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">root finding</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3018</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3016</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3025</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">total</td>

            <td class="px-3 py-2 border-b border-gray-700">0.5999</td>

            <td class="px-3 py-2 border-b border-gray-700">0.5971</td>

            <td class="px-3 py-2 border-b border-gray-700">0.5996</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(d)  <span class="math">t = 6</span></p>

    <p class="text-gray-300">Table 5: Observed average running times in milliseconds for finding second preimages of GMiMCHash using  <span class="math">\\mathrm{GMiMC}_{\\mathrm{erf}}[p,r,t]</span> . ( <span class="math">n = 100</span>  per column)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=7</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">construct poly</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0006</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0006</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0006</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">root finding</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0004</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0004</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0004</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">total</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0010</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0010</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0010</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(a)  <span class="math">t = 3</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=7</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">construct poly</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0458</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0457</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0458</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">root finding</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0275</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0280</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0269</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">total</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0733</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0738</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0728</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(c)  <span class="math">t = 5</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=7</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">construct poly</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0037</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0037</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0042</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">root finding</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0028</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0030</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0038</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">total</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0065</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0067</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0080</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(b)  <span class="math">t = 4</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r=7</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">construct poly</td>

            <td class="px-3 py-2 border-b border-gray-700">0.6015</td>

            <td class="px-3 py-2 border-b border-gray-700">0.6012</td>

            <td class="px-3 py-2 border-b border-gray-700">0.6801</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">root finding</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3116</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3063</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3536</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">total</td>

            <td class="px-3 py-2 border-b border-gray-700">0.9131</td>

            <td class="px-3 py-2 border-b border-gray-700">0.9075</td>

            <td class="px-3 py-2 border-b border-gray-700">1.0338</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(d)  <span class="math">t = 6</span></p>

    <p class="text-gray-300">Table 6: Observed average running times in milliseconds for collision finding of GMiMCHash using  <span class="math">\\mathrm{GMiMC}_{\\mathrm{erf}}[p,r,t]</span> . ( <span class="math">n = 100</span>  per column)</p>

    <p class="text-gray-300">Title Suppressed Due to Excessive Length</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> (a)  <span class="math">t = 3</span></p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> (b)  <span class="math">t = 4</span></p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> (c)  <span class="math">t = 5</span></p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> (d)  <span class="math">t = 6</span> Fig. 4: Number of second preimages found for various numbers of rounds with GMiMCHash using  <span class="math">\\mathrm{GMiMC}_{\\mathrm{erf}}[p,r,t]</span> . ( <span class="math">n = 100</span>  per given  <span class="math">(r,t)</span> )</p>

    <p class="text-gray-300">Arnab Roy, Elena Andreeva, and Jan Ferdinand Sauer</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a> (a)  <span class="math">t = 3</span></p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> (b)  <span class="math">t = 4</span></p>

    <p class="text-gray-300">!<a href="img-11.jpeg">img-11.jpeg</a> (c)  <span class="math">t = 5</span></p>

    <p class="text-gray-300">!<a href="img-12.jpeg">img-12.jpeg</a> (d)  <span class="math">t = 6</span> Fig.5: Number of collisions found for various numbers of rounds with GMiM-Chash using  <span class="math">\\mathrm{GMiMC}_{\\mathrm{erf}}[p,r,t]</span> . ( <span class="math">n = 100</span>  per given  <span class="math">(r,t)</span> )</p>`;
---

<BaseLayout title="Interpolation Cryptanalysis of Unbalanced Feistel Networks w... (2021/367)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/367
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
