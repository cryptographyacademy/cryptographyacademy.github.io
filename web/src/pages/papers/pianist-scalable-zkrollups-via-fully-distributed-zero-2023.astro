---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/1271';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Pianist: Scalable zkRollups via Fully Distributed Zero-Knowledge Proofs';
const AUTHORS_HTML = 'Tianyi Liu, Tiancheng Xie, Jiaheng Zhang, Dawn Song, Yupeng Zhang';

const CONTENT = `    <p class="text-gray-300">Tianyi Liu1, Tiancheng Xie23, Jiaheng Zhang23, Dawn Song23, Yupeng Zhang13 [ 1University of Illinois Urbana-Champaign, 2UC Berkeley, 3Berkeley Center for Responsible, Decentralized Intelligence (RDI) ]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">In the past decade, blockchains have seen various financial and technological innovations, with cryptocurrencies reaching a market cap of over 1 trillion dollars. However, scalability is one of the key issues hindering the deployment of blockchains in many applications. To improve the throughput of the transactions, zkRollups and zkEVM techniques using the cryptographic primitive of zero-knowledge proofs (ZKPs) have been proposed and many companies are adopting these technologies in the layer-2 solutions. However, in these technologies, the proof generation of the ZKP is the bottleneck and the companies have to deploy powerful machines with TBs of memory to batch a large number of transactions in a ZKP.</p>

    <p class="text-gray-300">In this work, we improve the scalability of these techniques by proposing new schemes of fully distributed ZKPs. Our schemes can improve the efficiency and the scalability of ZKPs using multiple machines, while the communication among the machines is minimal. With our schemes, the ZKP generation can be distributed to multiple participants in a model similar to the mining pools. Our protocols are based on Plonk, an efficient zero-knowledge proof system with a universal trusted setup. The first protocol is for data-parallel circuits. For a computation of <span class="math">M</span> sub-circuits of size <span class="math">T</span> each, using <span class="math">M</span> machines, the prover time is <span class="math">O(T\\log T+M\\log M)</span>, while the prover time of the original Plonk on a single machine is <span class="math">O(MT\\log(MT))</span>. Our protocol incurs only <span class="math">O(1)</span> communication per machine, and the proof size and verifier time are both <span class="math">O(1)</span>, the same as the original Plonk. Moreover, we show that with minor modifications, our second protocol can support general circuits with arbitrary connections while preserving the same proving, verifying, and communication complexity. The technique is general and may be of independent interest for other applications of ZKP.</p>

    <p class="text-gray-300">We implement Pianist (Plonk vIA uNlimited dISTribution), a fully distributed ZKP system using our protocols. Pianist can generate the proof for <span class="math">8192</span> transactions in <span class="math">313</span> seconds on <span class="math">64</span> machines. This improves the scalability of the Plonk scheme by <span class="math">64\\times</span>. The communication per machine is only <span class="math">2.1</span> KB, regardless of the number of machines and the size of the circuit. The proof size is <span class="math">2.2</span> KB and the verifier time is <span class="math">3.5</span> ms. We further show that Pianist has similar improvements for general circuits. On a randomly generated circuit with <span class="math">2^{25}</span> gates, it only takes <span class="math">5</span> s to generate the proof using <span class="math">32</span> machines, <span class="math">24.2\\times</span> faster than Plonk on a single machine.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Blockchain technology has paved the way for innovative services such as decentralized finance, NFTs, and GameFi. The cryptocurrency market has experienced significant growth, surpassing 1 trillion USD in value since Bitcoin’s inception 13 years ago <em>[4]</em>. Techniques like zkRollups and zkEVM have been proposed to boost blockchain efficiency and bridge the transaction throughput gap between digital and traditional scenarios. Implementing zkRollups could potentially increase transaction throughput by over 100 times, as estimated by Vitalik Buterin <em>[1]</em>. Numerous companies have incorporated these techniques into their products, including zkSync <em>[11]</em>, Starkware <em>[10]</em>, Hermez <em>[7]</em>, Aztec <em>[2]</em>, Scroll <em>[9]</em>, and others.</p>

    <p class="text-gray-300">zkRollups and zkEVM rely on zero-knowledge proofs (ZKPs), a cryptographic primitive that allows a prover to convince a verifier the correctness of computations. More specifically, they use Zero-Knowledge Succinct Noninteractive Argument of Knowledge (ZK-SNARK) systems, which ensures that the proof size is significantly smaller than the size of computation and enables faster validation. By utilizing ZKPs, a single server can validate multiple transactions, compute state transitions, and generate a proof that is posted on the blockchain. Instead of re-executing all transactions, nodes can verify transactions and smart contracts by checking the proof and updating their status. This approach greatly increases the transaction throughput of the blockchain.</p>

    <p class="text-gray-300">However, the proof generation remains a significant bottleneck for existing ZKP schemes when applied to large-scale statements such as zkRollups and zkEVM. For instance, our experiments show that the Plonk system <em>[31]</em>, a widely-used ZKP protocol in the industry, can only scale to a circuit with <span class="math">2^{25}</span> gates on a machine with <span class="math">200</span> GB of memory. As a result, companies like Starkware <em>[10]</em> and Scroll <em>[9]</em> must deploy powerful clusters with terabytes of memory to generate proofs for zkRollups and zkEVM. In this paper, we tackle this issue by proposing fully distributed ZKP schemes that enhance both efficiency and scalability through distributed proof generation across multiple machines. Crucially, our schemes require minimal communication among machines, with each machine only exchanging a constant number of values with the master machine. This approach allows us to distribute ZKP generation in zkRollups and</p>

    <p class="text-gray-300">zkEVM among multiple participants, in a similar model to existing mining pools. More transactions can be batched into a single ZKP within a fixed period, without necessitating participants to stay online and communicate with each other with high overhead. Participants can potentially share the reward for generating the ZKP, akin to miners in current proof-of-work blockchains. Furthermore, our scheme can be generalized to create proofs for arbitrary general circuits, leading us to the name "fully distributed ZKPs".</p>

    <p class="text-gray-300">Our distributed schemes are built upon Plonk [31]. Instead of using univariate polynomials to represent the constraints of a computation, we devise a protocol based on a bivariate constraint system. First, we claim that this protocol can cater to data-parallel circuits, allowing each machine to generate the witness for its corresponding sub-circuit. Second, we further generalize it to compute proofs for general circuits with arbitrary connections, assuming the witness has already been distributed among the machines. In both cases, our schemes demonstrate that the efficiency and scalability can be improved by a factor of  <span class="math">M</span>  using  <span class="math">M</span>  machines, the proof size remains  <span class="math">O(1)</span> , and the communication complexity per machine is only  <span class="math">O(1)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We propose two fully distributed ZKP protocols for data-parallel circuits and general circuits, respectively. To construct the schemes, we first propose a distributed polynomial interactive oracle proof (polynomial IOP) and then combine it with a polynomial commitment scheme (PCS) that is distributively computable as well. The polynomial IOP is a bivariate variant of Plonk's [31] constraint system. To "compile" both IOP schemes by polynomial commitments, we use the bivariate variant of the KZG [41] scheme and demonstrate that it is distributively computable. The use of the Lagrange polynomial in our scheme is inspired by a sub-scheme in Caulk [49]. The techniques can be used to accelerate any ZKP proof generations based on Plonk, and may be of independent interest to other ZKP applications beyond zkRollups and zkEVM.</li>

      <li>We further show that our protocols are robust in the presence of malicious machines. We formalize the notion as Robust Collaborative Proving Scheme (RCPS), for the collaborative generation of proofs among sub-provers in a malicious environment. In this setting, the master node is able to verify partial proofs and messages received from other machines before aggregating them to compute the final proof. We show that our protocols are robust under this definition with an additional step of verification. This property is crucial for the applications of distributed zkRollups and zkEVM to exclude malicious participants without ruining the distributed proof generation.</li>

      <li>We implement the fully distributed ZKP system, Pianist, for both data-parallel and general circuits. For the data-parallel version, we report experimental results for the blockchain application of zkRollups. Utilizing rollup circuits generated by the Circom compiler [3], we show that Pianist can scale to 8192 transactions on 64 machines</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pi time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Comm.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">& V time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Robust</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DIZK [46]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(T log2T)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">deVirgo [48]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(T logT)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log2N)</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Pianist</td>

            <td class="px-3 py-2 border-b border-gray-700">O(T logT)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(M)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">TABLE 1: Comparisons of our schemes to existing distributed ZKP protocols given  <span class="math">M</span>  distributed machines on the circuit with  <span class="math">M</span>  sub-circuits and total  <span class="math">N</span>  gates,where each sub-circuit has  <span class="math">T = \\frac{N}{M}</span>  gates.  <span class="math">{\\mathcal{P}}_{i}</span>  time denotes the prover time per machine,Comm. denotes the total communication among machines,  $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  denotes the proof size,and  </span>\\mathcal{V}$  time denotes the verifier time.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">with a prover time of 313 seconds. In comparison, the original Plonk scheme can only scale to 32 transactions with a prover time of 95 seconds on a single machine. The communication between each machine and the master machine is only 2144 bytes, and the proof size is 2208 bytes. We observe similar improvements for general circuits. On a circuit of size  <span class="math">2^{25}</span> , it only takes 5s to generate the proof using 32 machines, which is  <span class="math">24.2 \\times</span>  faster than Plonk on a single machine, with 2336 Bytes communication and 2816 Bytes proof size.</p>

    <p class="text-gray-300">Organization of the paper. We review the related work in Section 1.1 and present the preliminaries in Section 2. To explain our protocols, we first introduce our distributed polynomial IOP schemes in Section 3 for data-parallel circuits and general circuits. Then in Section 4, we present a bivariate variant of the polynomial commitment in [35], [41] to compile our polynomial IOP schemes to SNARKs. In Section 5, we formalize the notion of robust collaborative proving scheme (RCPS) and show that our scheme is able to detect malicious machines. We showcase the performance of our system in Section 6, and present additional discussions in Section 7.</p>

    <p class="text-gray-300">Zero-knowledge proofs (ZKP) were first introduced by Goldwasser, Micali, and Rackoff in their seminal paper [32]. Driven by real-world applications such as blockchains [16], [36], [48], there has been a rapid development of efficient zkSNARK systems in recent years [8], [13], [15], [17], [24], [26], [31], [33], [42], [44], [45], [47], [50], [51], [53]. Despite such progress, it remains challenging to scale ZKP protocols to large statements due to their high overhead on the prover running time and memory usage.</p>

    <p class="text-gray-300">Distributed ZKPs. To scale existing ZKP protocols to large-scale circuits, distributed algorithms provide a promising direction. Wu et al. proposed the first distributed zero-knowledge proof protocol called DIZK in [46]. DIZK scales the pairing-based zkSNARK in [33] to handle circuits that are 100 times larger on 128 machines compared to a single machine. However, DIZK incurs a high communication cost that is linear in the total size of the circuit among different machines because the scheme runs a distributed number theoretic transformation (NTT) algorithm among the machines</p>

    <p class="text-gray-300">using the Map-Reduce framework. Additionally, the recent work of zkBridge <em>[48]</em> proposed deVirgo, a distributed ZKP protocol based on the ZKP scheme in <em>[51]</em>, to build bridges between two blockchains using ZKPs. The protocol achieves linear improvement on both the prover time and scalability in the number of machines. However, deVirgo also incurs a linear communication cost among the machines, and the proof size grows with the number of machines. This seems inevitable due to the use of the FRI protocol in <em>[14]</em> with Merkle trees <em>[40]</em>. By contrast, our schemes offer optimal linear scalability in prover time and minimal communication among distributed machines simultaneously. We provide a comparison in Table 1.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">PCD and IVC</h4>

    <p class="text-gray-300"><em>Proof-Carrying Data</em> (PCD <em>[19, 28]</em>) is a cryptographic technique that breaks down computation into a sequence of steps. In each step, the prover convinces the verifier not only of the current step’s correctness but also of all previous steps. It is an alternative solution for data-parallel circuits when memory is limited. There are generally two ways to achieve PCD: one is from succinct verification, and the other is from accumulation. In the succinct verification approach, for each step, the prover generates a proof for the current step computation and verification for the proof generated from the previous step, as seen in <em>[18, 19, 27]</em>, etc. The accumulation approach postpones and accumulates the verification of SNARK proofs (or some expensive part of it) at each recursion step and proves it all at once at the last step, as demonstrated in <em>[6, 20, 25, 37, 38]</em>, etc. Although there is no direct correspondence for general circuits, some of these techniques, including but not limited to <em>[37, 38]</em>, claim to achieve <em>Incremental Verifiable Computation</em> (IVC). IVC focuses on dividing long-running computations into stages that can be verified incrementally. For instance, Nova <em>[38]</em> supports proof generation when the computation involves a nondeterministic function <span class="math">f</span> and the result of <span class="math">f^{n}(z_{0})</span>. These techniques are widely employed in various applications, however, we identify several drawbacks when compared to our proposed solution. See details in Section 7.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Distributed computation from proof aggregation</h4>

    <p class="text-gray-300">Similar to our approach, aPlonk <em>[12]</em> is a distributed solution based on Plonk that requires prover nodes to share the same Fiat-Shamir randomness, necessitating synchronization several times during the proving process. In their scheme, they propose a multi-polynomial commitment to combine parties’ polynomial commitments and attest to the batch opening using a generalized <em>Inner-Product Argument</em> (IPA) from <em>[23]</em>. Additionally, they delegate the verification of the constraint system through all evaluations to the prover. We also include the discussion for their protocol in Section 7.</p>

    <h2 id="sec-8" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">Our construction follows the framework proposed in <em>[21]</em> and achieves SNARK by first compiling a public-coin Polynomial IOP into a doubly-efficient public-coin interactive argument of knowledge using a polynomial commitment scheme. Subsequently, the non-interactive property is achieved through the Fiat-Shamir transform. We present the notations and corresponding definitions below</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.1 Notations</h3>

    <p class="text-gray-300">In our distributed setting, the size of the entire circuit is <span class="math">N</span>, and there are <span class="math">M</span> machines (or users acting as sub-provers) participating in this protocol. Consequently, each party is responsible for generating a proof for a sub-circuit of size <span class="math">T=\\frac{N}{M}</span>.</p>

    <p class="text-gray-300">We use bivariate polynomials to help construct the constraint system in the scheme. In our constraint system, for the <span class="math">i</span>-th party, it holds its local witness vector <span class="math">\\vec{a}_{i}=(a_{i,0},a_{i,1},\\ldots,a_{i,T-1})</span>. We can transform this witness vector into a univariate polynomial <span class="math">a_{i}(X)=\\sum_{j=0}^{T-1}a_{i,j}L_{j}(X)</span>, where <span class="math">L_{j}(X)</span> is the Lagrange polynomial defined by the <span class="math">T</span>-th roots of unity, with the close-form <span class="math">L_{j}(X)=\\frac{\\omega_{X}^{l}}{T}\\cdot\\frac{X^{T}-1}{X-\\omega_{X}^{l}}</span>. Furthermore, we aggregate the witness polynomial from all parties as a bivariate polynomial <span class="math">A(Y,X)=\\sum_{i=0}^{M-1}a_{i}(X)R_{i}(Y)</span>, where <span class="math">R_{i}(Y)</span> is also the Lagrange polynomial defined by the <span class="math">M</span>-th roots of unity, with the close-form <span class="math">R_{i}(Y)=\\frac{\\omega_{Y}^{l}}{M}\\cdot\\frac{Y^{M}-1}{Y-\\omega_{Y}^{l}}</span></p>

    <p class="text-gray-300">Unless specifically stated, for polynomials, we use lowercase letters such as <span class="math">a,b,c</span> to denote the univariate polynomial storing local information, and uppercase letters <span class="math">A,B,C</span> to denote the bivariate polynomial aggregating information throughout the entire circuit. In addition, we use lowercase letters <span class="math">x,y</span> to denote a specific assignment or evaluation for the polynomial, and uppercase letters <span class="math">X,Y</span> to denote unassigned variables.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.2 Interactive Argument</h3>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 1 (Interactive Argument).</h6>

    <p class="text-gray-300">We say that <span class="math">\\mathsf{ARG}=(\\mathcal{G},\\mathcal{P},\\mathcal{V})</span> is an interactive argument of knowledge for a relation <span class="math">\\mathcal{R}</span> if it satisfies the following completeness and knowledge properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: For every adversary <span class="math">\\mathcal{A}</span></li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{matrix}(\\mathbb{x},\\mathbb{w})\\not\\in\\mathcal{R}\\text{ or }&\\mathsf{pp}\\leftarrow\\mathcal{G}(1^{\\lambda})\\\\ \\langle\\mathcal{P}(\\mathsf{pp},\\mathbb{x},\\mathbb{w}),\\mathcal{V}(\\mathsf{pp},\\mathbb{x})\\rangle=1&:\\mathcal{(x,w)}\\leftarrow\\mathcal{A}(\\mathsf{pp})\\end{matrix}\\right]=1 \\]</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Witness-extended emulation: <span class="math">\\mathsf{ARG}</span> has witness-extended emulation with knowledge error <span class="math">\\kappa</span> if there exists an expected polynomial-time algorithm <span class="math">\\mathcal{E}</span> such that for every polynomial-size adversary <span class="math">\\mathcal{A}</span> it holds that</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr\\left[\\begin{matrix}&\\mathsf{pp}\\leftarrow\\mathcal{G}(1^{\\lambda})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathcal{A}(\\mathsf{aux},\\mathsf{tr})=1&:\\mathcal{(x,aux)}\\leftarrow\\mathcal{A}(\\mathsf{pp})\\\\ &\\mathsf{tr}\\leftarrow\\langle\\mathcal{A}(\\mathsf{aux}),\\mathcal{V}(\\mathsf{pp},\\mathbb{x})\\rangle\\end{matrix}\\right]\\right.\\\\ -\\Pr\\left[\\begin{matrix}&\\mathcal{A}(\\mathsf{aux},\\mathsf{tr})=1&\\mathsf{pp}\\leftarrow\\mathcal{G}(1^{\\lambda})\\\\ \\text{ and if }\\mathsf{tr}\\text{ is accepting }:\\mathcal{(x,aux)}\\leftarrow\\mathcal{A}(\\mathsf{pp})\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{ then }(\\mathbb{x},\\mathbb{w})\\in\\mathcal{R}&\\left(\\mathsf{tr},\\mathbb{w}\\right)\\leftarrow\\mathcal{E}^{\\mathcal{A}(\\mathsf{aux})}(\\mathsf{pp},\\mathbb{x})\\right\\end{matrix}\\right]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\kappa(\\lambda) \\]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Above <span class="math">\\mathcal{E}</span> has oracle access to (the next-message functions of) <span class="math">\\mathcal{A}(\\mathsf{aux})</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">If the interactive argument of knowledge protocol ARG is public-coin, is has been shown that by the Fiat-Shamir transformation <em>[30]</em>, we can derive a non-interactive argument of knowledge from ARG. If the scheme further satisfies the following property:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Succinctness. The proof size is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\textup{poly}(\\lambda,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and the verification time is </span>\\textup{poly}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">then it is a Succinct Non-interactive Argument of Knowledge (SNARK).</p>

    <p class="text-gray-300">For the applications of zkRollups and zkEVM, we only need a SNARK that is complete, sound, and succinct. Our constructions can be made zero-knowledge via known transformations with random masks and we omit the details in this paper.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.3 Polynomial Interactive Oracle Proof</h3>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 2 (Public-coin Polynomial Interactive Oracle Proof <em>[21]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}</span> be a binary relation and <span class="math">\\mathbb{F}</span> be a finite field. Let <span class="math">X=(X_{1},\\ldots,X_{\\mu})</span> be a vector of <span class="math">\\mu</span> indeterminates. A <span class="math">(\\mu,d)</span> Polynomial IOP for <span class="math">\\mathcal{R}</span> over <span class="math">\\mathbb{F}</span> with soundness error <span class="math">\\epsilon</span> and knowledge error <span class="math">\\delta</span> consists of two stateful PPT algorithms, the prover <span class="math">\\mathcal{P}</span>, and the verifier <span class="math">\\mathcal{V}</span>, that satisfy the following requirements:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Protocol syntax. For each <span class="math">i</span>-th round there is a prover state <span class="math">\\mathsf{st}^{\\mathcal{P}}_{i}</span> and a verifier state <span class="math">\\mathsf{st}^{\\mathcal{V}}_{i}</span>. For any common input <span class="math">x</span> and <span class="math">\\mathcal{R}</span> witness <span class="math">w</span>, at round 0 the states are <span class="math">\\mathsf{st}^{\\mathcal{P}}_{0}=(x,w)</span> and <span class="math">\\mathsf{st}^{\\mathcal{V}}_{0}=x</span>. In the <span class="math">i</span>-th round (starting at <span class="math">i=1</span>) the prover outputs a single proof oracle <span class="math">\\mathcal{P}(\\mathsf{st}^{\\mathcal{P}}_{i-1})\\to\\pi_{i}</span>, which is a polynomial <span class="math">\\pi_{i}(X)\\in\\mathbb{F}[X]</span>. The verifier deterministically computes the query matrix <span class="math">i\\in\\mathbb{F}^{\\mu\\times\\ell}</span> from its state and a string of public random bits <span class="math">\\mathsf{coins}_{i}\\leftarrow\\{0,1\\}^{*}</span>, i.e, <span class="math">\\mathcal{V}(\\mathsf{st}^{\\mathcal{V}}_{i-1},\\mathsf{coins}_{i})\\to\\Sigma_{i}</span>. This query matrix is interpreted as a list of <span class="math">\\ell</span> points in <span class="math">\\mathbb{F}^{\\mu}</span> denoted <span class="math">(\\sigma_{i,1},\\ldots,\\sigma_{i,\\ell})</span>. The oracle <span class="math">\\pi_{i}</span> is queried on all points in this list, producing the response vector <span class="math">(\\pi_{i}(\\sigma_{i,1}),\\ldots,\\pi_{\\ell}(\\sigma_{i,\\ell}))=a_{i}\\in\\mathbb{F}^{1\\times\\ell}</span>. The updated prover state is <span class="math">\\mathsf{st}^{\\mathcal{P}}_{i}\\leftarrow(\\mathsf{st}^{\\mathcal{P}}_{i-1}),\\Sigma_{i})</span> and verifier state is <span class="math">\\mathsf{st}^{\\mathcal{V}}_{i}\\leftarrow(\\mathsf{st}^{\\mathcal{V}}_{i-1},\\Sigma_{i},a_{i})</span>. Finally, <span class="math">\\mathcal{V}(\\mathsf{st}^{\\mathcal{V}}_{t})</span> returns <span class="math">1</span> or <span class="math">0</span>.</li>

    </ul>

    <p class="text-gray-300">(Extensions: multiple and prior round oracles; various arity. The syntax can be naturally extended such that multiple oracles are sent in the <span class="math">i</span>-th round; that the verifier may query oracles sent in the <span class="math">i</span>-th round or earlier; or that some of the oracles are polynomials in fewer variables than <span class="math">\\mu</span>.)</p>

    <p class="text-gray-300">Furthermore, a Polynomial IOP is stateless if for each <span class="math">i\\in[t],\\mathcal{V}(\\mathsf{st}^{\\mathcal{V}}_{i-1},\\mathsf{coins}_{i})=\\mathcal{V}(i,\\mathsf{coins}_{i})</span>.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">2.4 Polynomial Commitment Scheme (PCS)</h3>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 3 (Polynomial commitment scheme (PCS)).</h6>

    <p class="text-gray-300">A Polynomial commitment scheme <span class="math">\\Gamma</span> is a tuple <span class="math">\\Gamma=(\\textup{KeyGen},\\textup{Commit},\\textup{Open},\\textup{Verify})</span> of PPT algorithms where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\textup{KeyGen}(1^{\\lambda},\\mathcal{F})\\to\\textup{pp}</span> generates public parameters <span class="math">\\textup{pp}</span>;</li>

      <li><span class="math">\\textup{Commit}(f,\\textup{pp})\\to\\textup{com}_{f}</span> takes a secret polynomial <span class="math">f(\\mathbf{X})</span> where <span class="math">X=(X_{0},\\ldots,X_{\\mu-1})</span> and outputs a public commitment <span class="math">\\textup{com}_{f}</span>;</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\textup{Open}(\\textup{com}_{f},\\mathbf{x},\\textup{pp})\\to(z,\\pi_{f})</span> evaluates the polynomial <span class="math">y=f(\\mathbf{X})</span> on a point <span class="math">\\mathbf{x}</span> and generate a proof <span class="math">\\pi_{f}</span>;</li>

      <li><span class="math">\\textup{Verify}(\\textup{com}_{f},\\mathbf{x},z,\\pi_{f},\\textup{pp})\\to b\\in\\{1,0\\}</span> is a protocol between the prover <span class="math">\\mathcal{P}</span> and verifier <span class="math">\\mathcal{V}</span>, verifying whether <span class="math">f(\\mathbf{x})</span> is <span class="math">z</span> through <span class="math">\\textup{pp}</span>, <span class="math">\\textup{com}_{f}</span> and <span class="math">\\pi_{f}</span>;</li>

    </ul>

    <p class="text-gray-300">which satisfies the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For any polynomial <span class="math">f\\in\\mathcal{F}</span> and <span class="math">\\mathbf{x}\\in\\mathbb{F}^{\\mu}</span>, the following probability is <span class="math">1</span>.</li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c}\\textup{pp}\\leftarrow\\textup{KeyGen}(1^{\\lambda},\\mathcal{F})\\\\ \\textup{Verify}(\\textup{com}_{f},\\mathbf{x},z,\\pi_{h},\\textup{pp})=1&\\textup{ : com}_{f}\\leftarrow\\textup{Commit}(f,\\textup{pp})\\\\ &(z,\\pi_{f})\\leftarrow\\textup{Open}(f,\\mathbf{x},\\textup{pp})\\end{array}\\right] \\]</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge soundness. For any PPT adversary <span class="math">\\mathcal{P}^{<em>}</span>, there exists a PPT extractor <span class="math">\\mathcal{E}</span> with access to <span class="math">\\mathcal{P}^{</em>}</span>’s messages during the protocol, the following probability is <span class="math">\\textup{negl}(\\lambda)</span>.</li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c}\\textup{Verify}(\\textup{com}^{<em>},\\mathbf{x}^{</em>},z^{<em>},\\pi^{</em>},\\textup{pp})=1&\\textup{pp}\\leftarrow\\textup{KeyGen}(1^{\\lambda},\\mathcal{F})\\\\ \\wedge\\textup{com}^{<em>}=\\textup{Commit}(f^{</em>},\\textup{pp})&(z^{<em>},\\mathbf{x}^{</em>})\\leftarrow\\mathcal{P}^{<em>}(1^{\\lambda},\\textup{pp})\\\\ \\wedge f^{</em>}(\\mathbf{x}^{<em>})\\neq z^{</em>}&(\\textup{com}^{<em>},\\pi^{</em>})\\leftarrow\\mathcal{P}^{<em>}(1^{\\lambda},\\textup{pp})\\\\ &f^{</em>}\\leftarrow\\mathcal{E}^{\\mathcal{P}^{*}(\\cdot)}(1^{\\lambda},\\textup{pp})\\end{array}\\right] \\]</p>

    <p class="text-gray-300">It is worth noting that in <em>[21]</em>, although they demonstrate that if the polynomial commitment protocol satisfies witness-extended emulation, the compiled interactive argument also inherits this knowledge property. However, they also point out that it has been proven in <em>[39]</em> that every knowledge sound protocol satisfies witness-extended emulation as well.</p>

    <h2 id="sec-16" class="text-2xl font-bold">3 Distributed Polynomial IOP Protocols</h2>

    <p class="text-gray-300">In this and the following sections, we demonstrate how to construct our distributively computable SNARK for data-parallel circuits (which accommodate various sub-circuits) and arbitrary general circuits. In both settings, we distribute the input and computation across <span class="math">M</span> machines, each capable of evaluating one sub-circuit <span class="math">C_{i}</span> of size <span class="math">T=\\frac{N}{M}</span> locally. In this section, we first present the constraint system, and then design an IOP protocol proving the constraints. We prove that our IOP protocol has knowledge soundness and can be transformed into an interactive argument of knowledge after compiling with a bivariate PCS. In the next section, we will instantiate our protocol with bivariate KZG and provide a detailed analysis of proving time, verification time, proof size, and communication complexity.</p>

    <p class="text-gray-300">Before diving into the details, we first explain our intuition. We opt for the distributed system to avoid the substantial overhead introduced by recursive proof (see Section 7 for a detailed discussion). PCD-and-IVC-based solutions rely on recursive proofs because they handle each sub-circuit in a separate proof waiting to be aggregated. Instead, we treat all sub-circuits as a whole and exploit the succinctness of SNARK, resulting in a small proof size and verification time. However, DIZK <em>[46]</em> shows that directly applying distribution techniques to the original univariate SNARK system leads to linear communication costs due to the significantly interleaving network required to run the NTT algorithm. Taking both hazards into account, we propose a solution leveraging bivariate polynomial constraints to both</p>

    <p class="text-gray-300">”split” the NTT instances, avoiding substantial communication, and ”combine” the proof for each sub-circuit as a whole, eliminating the need for expensive aggregation costs. The details are as follows.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">3.1 Arithmetic Constraint System for Each Party</h3>

    <p class="text-gray-300">Our constraint system inherits the original Plonk <em>[31]</em>. The original Plonk works for a fan-in-two arithmetic circuit, where each gate takes at most two inputs. In Plonk, the left input, the right input, and the output of each gate are encoded by three univariate polynomials respectively. The verifier can check the computation of each gate by a polynomial equation, which we refer to as the gate constraint. Additionally, the verifier also checks that the input and output of the gates are connected correctly as defined by the structure of the circuit, which we refer to as the copy constraint.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">3.1.1 Gate Constraint</h4>

    <p class="text-gray-300">For the <span class="math">i</span>-th party, let <span class="math">a_{i,j},b_{i,j}</span> and <span class="math">o_{i,j}</span> be the left input, right input, and output of gate <span class="math">j</span> of the sub-circuit <span class="math">C_{i}</span>, for <span class="math">j=0,\\ldots,T-1</span>. We define a polynomials <span class="math">a_{i}(X)=\\sum_{j=0}^{T-1}a_{i,j}L_{j}(X)</span> where <span class="math">L_{j}(X)</span> is the Lagrange polynomials defined by the <span class="math">T</span>-th roots of unity. The coefficient representation of <span class="math">a_{i}(X)</span> can be computed using polynomial interpolation and the complexity is <span class="math">O(T\\log T)</span> via the NTT algorithm. Similarly, we define polynomials <span class="math">b_{i}(X)</span> and <span class="math">o_{i}(X)</span> using <span class="math">b_{i,j}</span> and <span class="math">o_{i,j}</span>. If gate <span class="math">j</span> is an addition gate, then <span class="math">a_{i,j}+b_{i,j}=o_{i,j}</span>, and thus <span class="math">a_{i}(\\omega_{X}^{j})+b_{i}(\\omega_{X}^{j})=o_{i}(\\omega_{X}^{j})</span>; if gate <span class="math">j</span> is a multiplication gate, then <span class="math">a_{i,j}\\cdot b_{i,j}=o_{i,j}</span>, and thus <span class="math">a_{i}(\\omega_{X}^{j})\\cdot b_{i}(\\omega_{X}^{j})=o_{i}(\\omega_{X}^{j})</span>. Following the design of Plonk, we can write the relationship of all gates as one polynomial in Equation 1.</p>

    <p class="text-gray-300"><span class="math">g_{i}(X)</span> <span class="math">:=</span> <span class="math">q_{a,i}(X)a_{i}(X)+q_{b,i}(X)b_{i}(X)+q_{o,i}(X)o_{i}(X)</span> <span class="math">+</span> <span class="math">q_{ab,i}(X)a_{i}(X)b_{i}(X)+q_{c,i}(X)=0.</span></p>

    <p class="text-gray-300">Here the polynomials <span class="math">q_{a,i}(X)</span>, <span class="math">q_{b,i}(X)</span>, <span class="math">q_{o,i}(X)</span>, <span class="math">q_{ab,i}(X)</span>, <span class="math">q_{c,i}(X)</span> are defined by the structure of <span class="math">C_{i}</span> satisfying</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>Addition gate: <span class="math">q_{a,i}(\\omega_{X}^{j})=1</span>, <span class="math">q_{b,i}(\\omega_{X}^{j})=1</span>, <span class="math">q_{o,i}(\\omega_{X}^{j})=-1</span>, <span class="math">q_{ab,i}(\\omega_{X}^{j})=0</span>, <span class="math">q_{c,i}(\\omega_{X}^{j})=0</span>.</li>

      <li>Multiplication gate: <span class="math">q_{a,i}(\\omega_{X}^{j})=0</span>, <span class="math">q_{b,i}(\\omega_{X}^{j})=0</span>, <span class="math">q_{o,i}(\\omega_{X}^{j})=-1</span>, <span class="math">q_{ab,i}(\\omega_{X}^{j})=1</span>, <span class="math">q_{c,i}(\\omega_{X}^{j})=0</span>.</li>

      <li>Public input: <span class="math">q_{a,i}(\\omega_{X}^{j})=0</span>, <span class="math">q_{b,i}(\\omega_{X}^{j})=0</span>, <span class="math">q_{o,i}(\\omega_{X}^{j})=-1</span>, <span class="math">q_{ab,i}(\\omega_{X}^{j})=0</span>, <span class="math">q_{c,i}(\\omega_{X}^{j})=\\mathsf{in}_{i,j}</span> if the <span class="math">j</span>-th gate in <span class="math">C_{i}</span> is a public input gate with the value of <span class="math">\\mathsf{in}_{i,j}</span>.</li>

    </ul>

    <p class="text-gray-300">In this way, the correct evaluation of the circuit is equivalent to Equation 1 being 0 for all <span class="math">X\\in\\Omega_{X}</span>, where <span class="math">\\Omega_{X}</span> denotes the set <span class="math">\\{\\omega_{X}^{0},\\cdots,\\omega_{X}^{T-1}\\}</span>.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">3.1.2 Copy Constraint</h4>

    <p class="text-gray-300">In addition to checking the gate constraint, the verifier also needs to check that the connections of wires are correct as defined by the circuit. In particular, there are redundancies in the vectors <span class="math">a_{i,j},b_{i,j}</span> and <span class="math">o_{i,j}</span>, since the output of one gate is the input of other gates in the circuit. The method used in Plonk is derived from a product argument, which can show that if a set of values <span class="math">\\{f_{j}\\}_{j\\in\\mathcal{J}}</span> are identical, then the following two sets are equal:</p>

    <p class="text-gray-300"><span class="math">\\left\\{(f_{j},j)\\right\\}_{j\\in\\mathcal{J}}=\\left\\{(f_{j},\\sigma(j))\\right\\}_{j\\in\\mathcal{J}}</span></p>

    <p class="text-gray-300">where <span class="math">\\sigma</span> defines a cycle connecting all indexes. The protocol reduces the argument to 2 polynomial equations.</p>

    <p class="text-gray-300">The details of the permutation argument are as follows: <span class="math">\\forall X\\in\\Omega_{X},a_{i}(\\sigma_{i}(X))=a_{i}^{\\prime}(X)</span>, where <span class="math">a_{i}(X)</span> and <span class="math">a_{i}^{\\prime}(X)</span> are two univariate polynomials in <span class="math">\\mathbb{F}</span> and <span class="math">\\sigma_{i}</span> is a public permutation from <span class="math">\\Omega_{X}</span> to <span class="math">\\Omega_{X}</span>. Particularly, in the protocol checking the consistency of <span class="math">a_{i}(X),b_{i}(X),o_{i}(X)</span> in the gate constraint, given two random points <span class="math">\\eta,\\gamma\\in\\mathbb{F}</span> from the verifier, the prover defines the running product polynomial <span class="math">z_{i}(X)</span> on <span class="math">\\mathbb{F}</span> defined as follows:</p>

    <p class="text-gray-300"><span class="math">z_{i}(\\omega_{X}^{j}):=\\prod_{k=0}^{j-1}\\frac{f_{i}(\\omega_{X}^{k})}{f_{i}^{\\prime}(\\omega_{X}^{k})}</span> (2)</p>

    <p class="text-gray-300">where for simplicity, the notation of <span class="math">f_{i}(X)</span> and <span class="math">f_{i}^{\\prime}(X)</span> are used to indicate</p>

    <p class="text-gray-300"><span class="math">f_{i}(X):=</span> <span class="math">(a_{i}(X)+\\eta\\sigma_{a,i}(X)+\\gamma)(b_{i}(X)+\\eta\\sigma_{b,i}(X)+\\gamma)</span> <span class="math">(o_{i}(X)+\\eta\\sigma_{c,i}(X)+\\gamma),</span> <span class="math">f_{i}^{\\prime}(X):=</span> <span class="math">(a_{i}(X)+\\eta k_{a}X+\\gamma)(b_{i}(X)+\\eta k_{b}X+\\gamma)</span> <span class="math">(o_{i}(X)+\\eta k_{o}X+\\gamma),</span> (3)</p>

    <p class="text-gray-300">where <span class="math">k_{a}=1</span>, <span class="math">k_{b}</span> is any quadratic non-residue, and <span class="math">k_{o}</span> is a quadratic non-residue not contained in <span class="math">k_{b}\\Omega_{X}</span>. The <span class="math">j</span>-th cell in <span class="math">a_{i}</span>, <span class="math">b_{i}</span>, <span class="math">o_{i}</span> is denoted by <span class="math">\\omega_{X}^{j}</span>, <span class="math">k_{1}\\omega_{X}^{j}</span>, <span class="math">k_{2}\\omega_{X}^{j}</span>, respectively, and <span class="math">\\sigma_{a,i}(\\omega_{X}^{j})</span> denotes the destination that the <span class="math">j</span>-th cell in <span class="math">a_{i}</span> is mapped to (<span class="math">\\sigma_{b,i}</span> and <span class="math">\\sigma_{c,i}</span> are defined similarly). The goal of the permutation argument is to prove <span class="math">\\prod_{k=0}^{T-1}\\frac{f_{i}(\\omega_{X}^{k})}{f_{i}^{\\prime}(\\omega_{X}^{k})}=1</span>, leading to the following constraints:</p>

    <p class="text-gray-300"><span class="math">p_{i,0}(X)</span> <span class="math">:=L_{0}(X)(z_{i}(X)-1)</span> (4) <span class="math">p_{i,1}(X)</span> <span class="math">:=z_{i}(X)f_{i}(X)-z_{i}(\\omega_{X}X)f_{i}^{\\prime}(X)</span> (5)</p>

    <p class="text-gray-300">which equals <span class="math">0</span> when <span class="math">X\\in\\Omega_{X}</span>.</p>

    <p class="text-gray-300">Finally, since the constraints <span class="math">g_{i}(X)</span>, <span class="math">p_{i,0}(X)</span> and <span class="math">p_{i,1}(X)</span> all equal <span class="math">0</span> when <span class="math">X\\in\\Omega_{X}</span>, then given a random challenge <span class="math">\\lambda</span> from the verifier, there must exist a quotient polynomial <span class="math">h_{i}(X)</span> satisfying</p>

    <p class="text-gray-300"><span class="math">g_{i}(X)+\\lambda p_{i,0}(X)+\\lambda^{2}p_{i,1}(X)=V_{X}(X)h_{i}(X),</span> (6)</p>

    <p class="text-gray-300">where <span class="math">V_{X}(X)=X^{T}-1</span>.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Polynomial IOP protocol for Plonk.</h4>

    <p class="text-gray-300">In the original Plonk, the IOP process sends oracles to the verifier in three rounds. Suppose the verifier knows the structure of the circuit and has oracles of <span class="math">\\left\\{q_{\\{a,b,o,ab,c\\}}(X),\\sigma_{\\{a,b,o\\}}(X)\\right\\}</span>. In the first round, the prover sends the polynomial oracles for <span class="math">a(X),b(X),o(X)</span>. In the second round, after receiving random challenge <span class="math">\\eta,\\gamma</span> from the verifier, the prover constructs the oracle <span class="math">z(X)</span> for the verifier. In the remaining round, with the randomness <span class="math">\\lambda</span> from the verifier, the prover computes the quotient polynomial <span class="math">h(X)</span> and sends its oracle to the verifier. After having access to all the oracles, the verifier queries them on a random point <span class="math">X=\\alpha</span> and an extra point</p>

    <p class="text-gray-300"><span class="math">X=\\omega_{X}\\cdot\\alpha</span> for <span class="math">z(X)</span>. With the evaluation, the verifier can verify all the constraints.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">3.2 Constraint System for Data-parallel Circuit</h3>

    <p class="text-gray-300">In this section, we show how to aggregate the polynomials from all separated sub-circuits into a single bivariate polynomial and keep the constraint structure. Inheriting the general-purpose arithmetic constraints from Plonk, it is clear that we not only have a constraint system proving data-parallel circuits but also for a more general case: we allow the sub-circuits to be different.</p>

    <p class="text-gray-300">Naively, we could use the powers of another variable <span class="math">Y</span> to randomly combine the polynomials from different parties. For example <span class="math">A(Y,X)=\\sum_{i=0}^{M-1}Y^{i}a_{i}(X)</span>, where <span class="math">a_{i}(X)</span> is held by the <span class="math">i</span>-th party. However, when using this formula in the polynomial equations, such as <span class="math">\\left(\\sum_{i=0}^{M-1}Y^{i}a_{i}(X)\\right)\\left(\\sum_{i=0}^{M-1}\\Psi^{i}b_{i}(X)\\right)-\\left(\\sum_{i=0}^{M-1}Y^{i}o_{i}(X)\\right)</span>, the cross-terms of the form <span class="math">Y^{i}a_{i}(X)\\cdot Y^{j}b_{j}(X)</span> for <span class="math">i\\neq j</span> in the expansion would be hard to deal with. To avoid the cross-terms, instead, we combine the polynomials using Lagrange polynomials <span class="math">R_{i}(Y)</span>. This idea is inspired by a sub-scheme in the recent work Caulk <em>[49]</em>. In particular, for each univariate polynomial in Equation 1, Equation 4, Equation 5 and Equation 6, i.e., <span class="math">s_{i}\\in\\{q_{a,i},q_{b,i},q_{o,i},q_{ab,i},q_{o,i},\\sigma_{a,i},\\sigma_{b,i},\\sigma_{o,i},a_{i},b_{i},o_{i},z_{i},h_{i}\\}</span>, we define a bivariate polynomial as</p>

    <p class="text-gray-300"><span class="math">S(Y,X)=\\sum\\nolimits_{i=0}^{M-1}R_{i}(Y)s_{i}(X).</span> (7)</p>

    <p class="text-gray-300">Then we have an aggregated gate constraint:</p>

    <p class="text-gray-300"><span class="math">G(Y,X)</span> <span class="math">:=Q_{a}(Y,X)A(Y,X)+Q_{b}(Y,X)B(Y,X)</span> (8) <span class="math">+Q_{ab}(Y,X)A(Y,X)B(Y,X)</span> <span class="math">+Q_{o}(Y,X)O(Y,X)+Q_{c}(Y,X)</span> <span class="math">P_{0}(Y,X)</span> <span class="math">:=L_{0}(X)(Z(Y,X)-1)</span> (9) <span class="math">P_{1}(Y,X)</span> <span class="math">:=Z(Y,X)\\prod_{S\\in\\{A,B,O\\}}(S(Y,X)+\\eta\\sigma_{a}(Y,X)+\\gamma)</span> <span class="math">-Z(Y,\\omega_{X}X)\\prod_{S\\in\\{A,B,O\\}}(S(Y,X)+\\eta k_{s}X+\\gamma)</span></p>

    <p class="text-gray-300">Then after the random linear combination as in Equation 6, we have</p>

    <p class="text-gray-300"><span class="math">G(Y,X)+\\lambda P_{0}(Y,X)+\\lambda^{2}P_{1}(Y,X)-V_{X}(X)H_{X}(Y,X)</span> (11)</p>

    <p class="text-gray-300">which equals 0 for all <span class="math">Y\\in\\Omega_{Y}</span>. It is no hard to see that this is equivalent to Equation 6 being true for all <span class="math">i\\in[M]</span>, because by the definition of the Lagrange polynomial <span class="math">R_{i}(Y)</span>, there is only one non-zero term <span class="math">g_{i}(X)</span>, <span class="math">p_{i,0}(X)</span> and <span class="math">p_{i,1}(X)</span> in Equation 6 when <span class="math">Y=\\omega_{Y}^{i}</span>. Therefore, evaluating Equation 11 at <span class="math">Y=\\omega_{Y}^{i}</span> is exactly the same as Equation 6 for <span class="math">C_{i}</span>.</p>

    <p class="text-gray-300">Finally, to check Equation 11 vanishes on <span class="math">Y\\in\\Omega_{Y}</span>, we compute <span class="math">H_{Y}(Y,X)</span> such that</p>

    <p class="text-gray-300"><span class="math">G(Y,X)+\\lambda P_{0}(Y,X)+\\lambda^{2}P_{1}(Y,X)-V_{X}(X)H_{X}(Y,X)</span> <span class="math">=V_{Y}(Y)H_{Y}(Y,X)</span> (12)</p>

    <p class="text-gray-300">where <span class="math">V_{Y}(Y)=Y^{M}-1</span>. This concludes the bivariate constraint system in our solution.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">A sketch of the distributed IOP.</h4>

    <p class="text-gray-300">In Protocol 1 (excluding the orange characters), we introduce the polynomial IOP protocol based on the constraint system above. From this protocol, we observe that, aside from sending and assisting the verifier with querying the polynomial oracles, the prover only needs to distributively maintain each oracle. We will later prove that this property is sufficient to construct a fully distributed ZKP. We also observe that this property trivially holds for all polynomials except <span class="math">H_{Y}(Y,X)</span>. To circumvent this obstacle, the prover receives a random opening point <span class="math">\\alpha</span> from the verifier and only sends the univariate oracle <span class="math">H_{Y}(Y,\\alpha)</span>. We claim that after this modification, the protocol remains knowledge-sound and can be distributively computed. We provide the full proof in Section 3.4 after explaining the system for general circuits.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">For the witness generation, since all sub-circuits are separated, each party can generate its witness locally.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">Although we assume the sub-circuits are independent of each other, it is easy to observe that if we introduce custom gates and rotation along with the variable <span class="math">Y</span>, then we can support some simple connections among different sub-circuits. In addition, we can also introduce local lookup arguments in our constraint system. Further discussion on custom gates and lookup arguments are in Section 7.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">3.3 Constraint System for General Circuit</h3>

    <p class="text-gray-300">In this section, we show the great potential of our system by generalizing it to generate proofs for arbitrary circuits. Recall that in the original Plonk, it leverages <span class="math">\\sigma_{a}(X)</span>, <span class="math">\\sigma_{b}(X)</span>, and <span class="math">\\sigma_{c}(X)</span> to navigate the next wire in the circuit with equal value, and computes the running product polynomial <span class="math">z(X)</span> as a helper polynomial to prove the product of <span class="math">\\prod_{k=0}^{j-1}\\frac{f(\\omega_{X}^{k})}{f^{\\prime}(\\omega_{X}^{k})}=1</span>. Similarly, we present how to indicate the position to the next wire and how to construct the product proof for the whole circuit.</p>

    <p class="text-gray-300">Since we need to indicate which sub-circuit the next wire locates, we define <span class="math">\\left\\{\\left(\\sigma_{Y,s,i}(X),\\sigma_{X,s,i}(X)\\right)\\right\\}_{s\\in\\{a,b,o\\}}</span> as: if for the <span class="math">i</span>-th party, for the <span class="math">j</span>-th entry in the polynomial <span class="math">s</span> is mapped to the <span class="math">i^{\\prime}</span>-th party, <span class="math">j^{\\prime}</span>-th entry in the polynomial <span class="math">s^{\\prime}</span> polynomial, then <span class="math">\\left(\\sigma_{Y,s,i}(\\omega_{X}^{j}),\\sigma_{X,s,i}(\\omega_{X}^{j})\\right)=\\left(\\omega_{Y}^{j^{\\prime}},k_{s^{\\prime}}\\omega_{X}^{j^{\\prime}}\\right)</span>. Therefore, we need to prove that</p>

    <p class="text-gray-300"><span class="math">\\prod_{i=0}^{M-1}\\prod_{j=0}^{T-1}\\frac{f_{i}(\\omega_{X}^{j})}{f_{i}^{\\prime}(\\omega_{X}^{j})}=1</span> (13)</p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">f_{i}(X):=</span> <span class="math">(a_{i}(X)+\\eta_{Y}\\sigma_{Y,a,i}(X)+\\eta_{X}\\sigma_{X,a,i}(X)+\\gamma)</span> <span class="math">(b_{i}(X)+\\eta_{Y}\\sigma_{Y,b,i}(X)+\\eta_{X}\\sigma_{X,b,i}(X)+\\gamma)</span> <span class="math">(o_{i}(X)+\\eta_{Y}\\sigma_{Y,o,i}(X)+\\eta_{X}\\sigma_{X,o,i}(X)+\\gamma)</span> <span class="math">f_{i}^{\\prime}(X):=</span> <span class="math">(a_{i}(X)+\\eta_{Y}Y+\\eta_{X}X+\\gamma)</span> <span class="math">(b_{i}(X)+\\eta_{Y}Y+\\eta_{X}k_{1}X+\\gamma)</span> <span class="math">(o_{i}(X)+\\eta_{Y}Y+\\eta_{X}k_{2}X+\\gamma)</span></p>

    <p class="text-gray-300">Then we show how to construct the constraints for the product argument. Similarly, each party keeps the running product <span class="math">z_{i}(X)</span>, however for the one after the last entry, <span class="math">z_{i}^{*}=z_{i}(\\omega_{X}^{T-1})\\frac{f_{i}\\big{(}\\omega_{X}^{T-1}\\big{)}}{f_{i}^{\\prime}\\big{(}\\omega_{X}^{T-1}\\big{)}}</span> no longer equals <span class="math">1</span>. Therefore, comparing with Equation 4 and Equation 5, we have the following constraints instead:</p>

    <p class="text-gray-300"><span class="math">p_{i,0}(X):=</span> <span class="math">L_{0}(X)(z_{i}(X)-1)</span> (14) <span class="math">p_{i,1}(X):=</span> <span class="math">(1-L_{T-1}(X))</span> (15) <span class="math">\\cdot(z_{i}(X)f_{i}(X)-z_{i}(\\omega_{X}X)f_{i}^{\\prime}(X))</span></p>

    <p class="text-gray-300">After constructing <span class="math">z_{i}</span>, each party will send the product of their slices <span class="math">z_{i}^{<em>}</span> to the master node, which then generates another helper polynomial <span class="math">W(X)</span> to denote the running product through <span class="math">\\big{(}z_{0}^{</em>},\\ldots,z_{M-1}^{*}\\big{)}</span>. Therefore, we have two more constraints that for <span class="math">0\\leq i&lt;M</span>:</p>

    <p class="text-gray-300"><span class="math">p_{i,2}:=</span> <span class="math">w_{0}-1\\text{ which is }0\\text{ for all }i</span> (16) <span class="math">p_{i,3}(X):=</span> <span class="math">L_{T-1}(X)</span> (17) <span class="math">\\cdot\\big{(}w_{i}z_{i}(X)f_{i}(X)-w_{(i+1)\\% M}f_{i}^{\\prime}(X)\\big{)}</span></p>

    <p class="text-gray-300">Therefore we compute <span class="math">h_{i}(X)</span> and <span class="math">H_{X}(Y,X)</span> through the following equation instead:</p>

    <p class="text-gray-300"><span class="math">h_{i}(X)</span> <span class="math">=\\frac{g_{i}(X)+\\lambda p_{i,0}+\\lambda^{2}p_{i,1}+\\lambda^{4}p_{i,3}}{X^{T}-1}</span> (18) <span class="math">H_{X}(Y,X)</span> <span class="math">=\\sum_{i=0}^{M-1}R_{i}(Y)h_{i}(X)</span></p>

    <p class="text-gray-300">Finally, by multiplying polynomials with <span class="math">R_{i}(Y)</span>, the permutation argument becomes</p>

    <p class="text-gray-300"><span class="math">P_{0}(Y,X):=</span> <span class="math">L_{0}(X)(Z(Y,X)-1)</span> (19) <span class="math">P_{1}(Y,X):=</span> <span class="math">(1-L_{T-1}(X))</span> (20) <span class="math">\\cdot(Z(Y,X)F(Y,X)-Z(Y,\\omega_{X}X)F^{\\prime}(Y,X))</span> <span class="math">P_{2}(Y):=</span> <span class="math">R_{0}(Y)(W(Y)-1)</span> (21) <span class="math">p_{3}(Y,X):=</span> <span class="math">L_{T-1}(X)</span> (22) <span class="math">\\cdot(W(Y)Z(Y,X)F(Y,X)-W(\\omega_{Y}Y)F^{\\prime}(Y,X))</span></p>

    <p class="text-gray-300">where <span class="math">F(Y,X)</span> and <span class="math">F^{\\prime}(Y,X)</span> are just notations to denote</p>

    <p class="text-gray-300"><span class="math">F(Y,X):=</span> <span class="math">\\prod_{S\\in\\{A,B,O\\}}(S(Y,X)+\\eta_{Y}\\sigma_{Y,s}(Y,X)</span> <span class="math">\\quad+\\eta_{X}\\sigma_{X,s}(Y,X)+\\gamma)</span> <span class="math">F^{\\prime}(Y,X):=</span> <span class="math">\\prod_{S\\in\\{A,B,O\\}}(S(Y,X)+\\eta_{Y}Y+\\eta_{X}k_{s}X+\\gamma)</span></p>

    <p class="text-gray-300">By combining with the same gate constraint as for data-parallel circuits, we finally have the equation to define <span class="math">H_{Y}(Y,X)</span>, which concludes our constraint system for general circuits.</p>

    <p class="text-gray-300"><span class="math">G(Y,X)+\\lambda P_{0}(Y,X)+\\lambda^{2}P_{1}(Y,X)+\\lambda^{3}P_{2}(Y)</span> <span class="math">+\\lambda^{4}P_{3}(Y,X)=V_{X}(Y,X)H_{X}(Y,X)+V_{Y}(Y)H_{Y}(Y,X)</span> (23)</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">3.4 Distributedly Computable Polynomial IOP Protocol</h3>

    <p class="text-gray-300">We present our polynomial IOP protocol in Protocol 1. The text in orange denotes the additional steps for general circuits. We have the following theorem:</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Protocol 1 is a polynomial IOP protocol for <span class="math">\\mathcal{R}</span> with negligible knowledge error.</p>

    <p class="text-gray-300">The proof is in Appendix A.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">Protocol 1 is a Polynomial IOP protocol that can be compiled into a distributedly computable double efficient non-interactive proof that has witness-extended emulation, using a distributed computable PCS, with only a constant increase in communication and <span class="math">O(N\\log T+M\\log M)</span> additional proving time compared to the PCS used.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove the theorem as follows:</p>

    <p class="text-gray-300">Security. In <em>[21]</em>, they provide a detailed proof demonstrating that if the polynomial commitment scheme <span class="math">\\Gamma</span> has witness-extended emulation, and if the <span class="math">t</span>-round Polynomial IOP for a relation <span class="math">\\mathcal{R}</span> has negligible knowledge error, an interactive argument for <span class="math">\\mathcal{R}</span> with witness-extended emulation exists.</p>

    <p class="text-gray-300">We present a sketch of the proof: for an arbitrary adversary prover <span class="math">\\mathcal{P}_{\\text{IP}}</span> for the IP scheme, we can construct an adversary prover <span class="math">\\mathcal{P}_{\\text{IOP}}</span>. With DKZG that guarantees witness-extended emulation, it enables <span class="math">\\mathcal{P}_{\\text{IOP}}^{<em>}</span> to simulate the transcript with <span class="math">\\mathcal{P}_{\\text{IP}}^{</em>}</span> to extract polynomials. After sending the oracles to <span class="math">\\mathcal{V}_{\\text{IOP}}</span> and receiving challenges, <span class="math">\\mathcal{P}_{\\text{IOP}}</span> can rewind the transcript with <span class="math">\\mathcal{P}_{\\text{IP}}</span> to insert the same randomness from <span class="math">\\mathcal{V}_{\\text{IOP}}</span>. Consequently, due to the knowledge soundness of PCS, the reduction succeeds with high probability. Then from the knowledge soundness proven in Theorem 1, an upper bound of the knowledge error for the IP protocol is achieved.</p>

    <p class="text-gray-300">We kindly refer to <em>[21]</em> for the complete proof.</p>

    <p class="text-gray-300">Efficiency. To analyze the extra communication, for all polynomials except <span class="math">H_{Y}(Y,X)</span> and <span class="math">W(Y)</span>, it is divided into slices and stored by each party. Then with a PCS which can generate commitments and proofs in this setting, we can handle all oracle constructions and queries to those polynomials. As for <span class="math">W(Y)</span>, it is computed by <span class="math">\\mathcal{P}_{0}</span> from <span class="math">z_{i}^{*}</span> received from the <span class="math">i</span>-th parties. Therefore, it can be easily computed from the constant-size messages exchanged between each node and the master node. While the difficulty occurs when computing <span class="math">H_{Y}(Y,X)</span>, instead of computing the full description, <span class="math">\\mathcal{P}_{0}</span> only deals with it after</p>

    <p class="text-gray-300">receiving the first opening coordinate <span class="math">X=\\alpha</span> and computes <span class="math">H_{Y,\\alpha}(Y)=H_{Y}(Y,\\alpha)</span>. Therefore, for <span class="math">0\\leq i&lt;M</span>, <span class="math">\\mathcal{P}_{i}</span> sends <span class="math">s_{i}(\\alpha)</span> for <span class="math">s\\in\\{q_{a},q_{b},q_{o},q_{ab},q_{c},a,b,c,z,h_{x}\\}</span> and recover the corresponding polynomial <span class="math">S(Y,\\alpha)</span>, <span class="math">\\mathcal{P}_{0}</span> can compute <span class="math">G(Y,\\alpha)</span>, <span class="math">P_{\\{0,1,2,3\\}}(Y,\\alpha)</span> and compute <span class="math">H_{Y,\\alpha}(Y)</span> according to Equation 23. Additionally considering the distribution of random challenges, the compiled polynomial IOP protocol only has a constant number of more communication than PCS.</p>

    <p class="text-gray-300">As for the proving time, it requires at most <span class="math">O(T\\log T)</span> time to compute <span class="math">z_{i}(X),h_{i}(X)</span> for each party and <span class="math">O(M\\log M)</span> for <span class="math">\\mathcal{P}_{0}</span> to compute <span class="math">W(Y)</span> and <span class="math">H_{Y,\\alpha}(Y)</span>, the extra proving time is up to <span class="math">O(T\\log T+M\\log M)</span> for a single machine and <span class="math">O(N\\log T+M\\log M)</span> in total. ∎</p>

    <h2 id="sec-30" class="text-2xl font-bold">4 Fully Distributed SNARK</h2>

    <p class="text-gray-300">In Theorem 2, we show that with a distributed PCS, we can build a fully distributed double-efficient interactive argument of knowledge protocol from distributed polynomial IOP. In this section, we instantiate Theorem 2 by a distributed bivariate KZG.</p>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">4.1 Distributed KZG</h3>

    <p class="text-gray-300">In this section, we present a distributedly computable PCS based on a bivariate variant the KZG scheme in <em>[35, 41]</em>. In our distributed setting, the total size of the polynomial is <span class="math">N</span>, and there are <span class="math">M</span> machines of <span class="math">\\mathcal{P}_{0},\\cdots,\\mathcal{P}_{M-1}</span> with part of the polynomial on each machine of size <span class="math">T=N/M</span>. The goal of the fully distributed polynomial commitments is to accelerate the prover time by <span class="math">B</span> times while keeping the communication complexity among the machine’s minimum. Moreover, both the proof size and the verifier time should remain the same as the original polynomial commitment schemes. We present the distributed protocol in Protocol 2.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300">Given polynomial <span class="math">f(Y,X)\\in\\mathbb{F}^{M}\\times\\mathbb{F}^{\\frac{N}{M}}</span>, Protocol 2 is PCS satisfying completeness and knowledge soundness. The total proving computation consists of <span class="math">O(N)</span> group operations, while <span class="math">O\\left(\\frac{N}{M}\\right)</span> group operations for each node and <span class="math">O\\left(\\frac{N}{M}+M\\right)</span> group operations for the master node. The total communication between <span class="math">\\mathcal{P}_{i}</span> and <span class="math">\\mathcal{P}_{0}</span> is <span class="math">O(1)</span>. The commitment and proof size are both <span class="math">O(1)</span> group elements. The verification cost is <span class="math">O(1)</span> group operations.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove the theorm as follows:</p>

    <p class="text-gray-300">For security. We kindly refer to <em>[52]</em> for a full proof of the knowledge soundness for the multivariate KZG protocol.</p>

    <p class="text-gray-300">For efficiency. For the proving complexity, to commit the polynomial <span class="math">f(Y,X)</span>, each prover node <span class="math">\\mathcal{P}_{i}</span> need to compute <span class="math">\\mathsf{com}_{f_{i}}</span>, which costs <span class="math">O\\left(\\frac{N}{M}\\right)</span> group operations, and the master prover products them up in <span class="math">O(M)</span> group operations. To open the polynomial on a point <span class="math">(\\beta,\\alpha)</span>, each node needs to evaluate <span class="math">f_{i}(\\alpha)</span> and compute <span class="math">\\pi_{0}^{(i)}</span>, from which the master node derives <span class="math">f(Y,\\alpha)</span>, and <span class="math">\\pi_{0}</span>, with the same number of group operations as computing the commitment. Finally <span class="math">P_{0}</span> computes <span class="math">\\pi_{1}</span> in <span class="math">O(M)</span> group operations. For the communication, <span class="math">\\mathcal{P}_{i}</span> only sends <span class="math">\\mathsf{com}_{f_{i}}</span>, <span class="math">f_{i}(\\alpha)</span> and <span class="math">\\pi_{0}^{(i)}</span> to <span class="math">\\mathcal{P}_{0}</span>, and receives random challenge <span class="math">\\alpha</span> from <span class="math">\\mathcal{P}_{0}</span>, thus the communication complexity is constant. It is easy to observe that the proof size and verification time are both constant. ∎</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">4.2 Using DKZG to Compile Protocol 1</h3>

    <p class="text-gray-300">We show our full instantiation in Protocol 3. From this protocol, we have the following theorem for general circuits, which implies the security and efficiency of the data-parallel setting.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Theorem 4.</h6>

    <p class="text-gray-300">Given a general circuit <span class="math">C</span> with <span class="math">N</span> gates, Protocol 3 is a double-efficient public-coin interactive argument of knowledge protocol with witness-extended emulation for the relation of <span class="math">C(\\mathtt{x};\\mathtt{w})=1</span> when splitting <span class="math">C</span> into <span class="math">M</span> parts <span class="math">(C_{0},\\ldots,C_{M-1})</span> each with <span class="math">T=\\frac{N}{M}</span> gates. The total proving computation consists of <span class="math">O(N\\log T+M\\log M)</span> field operations and <span class="math">O(N)</span> group operations, with each <span class="math">\\mathcal{P}_{i}</span> computes <span class="math">O(T\\log T)</span> field operations and <span class="math">O(T)</span> group operations, while <span class="math">\\mathcal{P}_{0}</span> computes <span class="math">O(T\\log T+M\\log M)</span> field operations plus <span class="math">O(M+T)</span> group operations. The communication is <span class="math">O(1)</span> per machine. The final proof size is <span class="math">O(1)</span>. The verification cost is <span class="math">O(1)</span> given the access to the commitments of the public polynomials defined by the circuit in the preprocessing model.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove the theorem as follows:</p>

    <p class="text-gray-300">For security. Following the security proof in Theorem 2, by combining the knowledge soundness of DKZG in Theorem 4.1 and polynomial IOP in Theorem 1, we prove that Protocol 3 is a double efficient public-coin interactive argument of knowledge protocol with negligible knowledge error.</p>

    <p class="text-gray-300">For efficiency. The complexity for the efficiency is directly implied by Theorem 2 and Theorem 4.1. ∎</p>

    <p class="text-gray-300">Since Protocol 3 operates in the public-coin setting, it can be transformed into a SNARK protocol using the Fiat-Shamir transform.</p>

    <h2 id="sec-37" class="text-2xl font-bold">5 Robust Collaborative Proving System for Data-parallel Circuits</h2>

    <p class="text-gray-300">In the previous sections, we propose a distributed ZKP protocol that divides the proving computation across multiple machines and generates a constant-size proof, with constant communication and minimal overhead in terms of proving and verification time. In this section, we introduce the definition of the Robust Collaborative Proving System (RCPS) scheme for data-parallel circuits and then propose a scheme in Protocol 3, demonstrating the potential of our protocol in a malicious environment where each prover node might sabotage the entire proof by intentionally generating a bad proof.</p>

    <p class="text-gray-300">Protocol 1 (Polynomial IOP for Data-parallel and General Circuits). Suppose the circuit structure is known by  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span> , therefore,  <span class="math">\\mathcal{V}</span>  knows the following oracles:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\{Q_{a}(Y,X),Q_{b}(Y,X),Q_{a}(Y,X),Q_{ab}(Y,X),Q_{c}(Y,X)\\}</span> .</li>

      <li><span class="math">\\{\\sigma_{Y,a}(Y,X),\\sigma_{Y,b}(Y,X),\\sigma_{Y,o}(Y,X),\\sigma_{X,a}(Y,X),\\sigma_{X,b}(Y,X),\\sigma_{X,o}(Y,X)\\}</span></li>

    </ul>

    <p class="text-gray-300">When generating proof for a new instance,  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  go through the following rounds:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  sends the oracles of  <span class="math">\\{A(Y,X),B(Y,X),C(Y,X)\\}</span>  to  <span class="math">\\mathcal{V}</span> .</li>

      <li>After receiving  <span class="math">\\eta_{Y},\\eta_{X},\\gamma</span>  from  <span class="math">\\mathcal{V}</span> <span class="math">\\mathcal{P}</span>  sends the oracle of  <span class="math">Z(Y,X)</span>  and  <span class="math">W(Y)</span>  to  <span class="math">\\mathcal{V}</span></li>

      <li>After receiving  <span class="math">\\lambda</span>  from  <span class="math">\\mathcal{V}</span> ,  <span class="math">\\mathcal{P}</span>  computes  <span class="math">H_{X}(Y,X) = \\sum_{i=0}^{M-1} R_{i}(Y) \\cdot \\frac{g_{i}(X) + \\lambda p_{i,0}(X) + \\lambda^{2} p_{i,1}(X) + \\lambda^{4} p_{i,2}(X)}{X^{T}-1}</span>  and sends the oracle to  <span class="math">\\mathcal{V}</span> .</li>

      <li>After receiving  <span class="math">\\alpha</span>  from  <span class="math">\\mathcal{V}</span> ,  <span class="math">\\mathcal{P}</span>  computes  <span class="math">H_{Y,\\alpha}(Y) = \\frac{G(Y,\\alpha) + \\lambda P_0(Y,\\alpha) + \\lambda^2P_1(Y,\\alpha) + \\lambda^3P_0(Y) + \\lambda^4P_0(Y,\\alpha) - (\\alpha^T - 1)H_X(Y,\\alpha)}{Y^M - 1}</span>  and sends the oracle to  <span class="math">\\mathcal{V}</span> .</li>

      <li><span class="math">\\mathcal{V}</span>  queries all oracles on  <span class="math">X = \\alpha, Y = \\beta</span>  and assign the evaluations to the corresponding polynomials in Equation 12 or Equation 23. If this equation holds, then  <span class="math">\\mathcal{V}</span>  output 1, otherwise 0.</li>

    </ol>

    <p class="text-gray-300">Protocol 2 (Distributed Bivariate Polynomial Commitment). Suppose  <span class="math">\\mathcal{P}</span>  has  <span class="math">M</span>  machines of  <span class="math">\\mathcal{P}_0, \\dots, \\mathcal{P}_{M-1}</span>  and suppose  <span class="math">\\mathcal{P}_0</span>  is the master node. Given the bivariate polynomial  <span class="math">f(Y, X) = \\sum_{i=0}^{M-1} \\sum_{j=0}^{T-1} f_{i,j} R_i(Y) L_j(X)</span> , each machine holds  <span class="math">f_i(X) = \\sum_{j=0}^{T-1} f_{i,j} L_j(X)</span> . The protocol proceeds as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>DKZG.KeyGen(1 <span class="math">\\lambda</span> , M, T): Generate pp =  <span class="math">\\left(g, g^{\\tau_X}, g^{\\tau_Y}, (U_{i,j})_{0 \\leq i &amp;lt; M, 0 \\leq j &amp;lt; T} = \\left(g^{R_i(\\tau_Y)L_j(\\tau_X)}\\right)_{0 \\leq i &amp;lt; M, 0 \\leq j &amp;lt; T}\\right)</span> , with trapdoor  <span class="math">\\tau_Y</span>  and  <span class="math">\\tau_X</span> . Let  <span class="math">\\mathcal{P}, \\mathcal{V}</span>  hold pp.</li>

      <li>DKZG.Commit(f, pp): In the commitment phase, each  <span class="math">\\mathcal{P}_i</span>  computes the commitment  <span class="math">\\operatorname{com}_{f_i} = \\prod_{j=0}^{T-1} U_{i,j}^{f_{i,j}}</span>  and sends it to  <span class="math">\\mathcal{P}_0</span> , where  <span class="math">f_{i,j}</span>  is the  <span class="math">j</span> -th entry in the evaluation representation of  <span class="math">f_i(X)</span> . After receiving commitments from others,  <span class="math">\\mathcal{P}_0</span>  computes  <span class="math">\\operatorname{com}_f = \\prod_{i=0}^{M-1} \\operatorname{com}_{f_i}</span> .</li>

    </ul>

    <p class="text-gray-300">DKZG.Open(f,β,α,pp)：</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each  <span class="math">\\mathcal{P}_i</span>  computes  <span class="math">f_{i}(\\alpha)</span>  and  <span class="math">q_0^{(i)}(X) = \\frac{f_i(X) - f_i(\\alpha)}{X - \\alpha}</span> .  <span class="math">\\mathcal{P}_i</span>  computes  <span class="math">\\pi_0^{(i)} = g^{R_i(\\tau_Y)q_0^{(i)}(\\tau_X)}</span>  using the public parameters and sends  <span class="math">f_{i}(\\alpha),\\pi_{0}^{(i)}</span>  to  <span class="math">\\mathcal{P}_0</span> .</li>

      <li>After receiving  <span class="math">\\left\\{\\left(f_{i}(\\alpha),\\pi_{0}^{(i)}\\right)\\right\\}_{0\\leq i &amp;lt; M},\\mathcal{P}_{0}</span>  computes  <span class="math">\\pi_0 = \\prod_{i = 0}^{M - 1}\\pi_0^{(i)}</span>  , and also recover  <span class="math">f(Y,\\alpha) = \\sum_{i = 0}^{M - 1}R_i(Y)f_i(\\alpha).</span></li>

      <li><span class="math">\\mathcal{P}_0</span>  computes  <span class="math">f(\\beta, \\alpha)</span>  and  <span class="math">q_1(Y) = \\frac{f(Y, \\alpha) - f(\\beta, \\alpha)}{Y - \\beta}</span> .  <span class="math">\\mathcal{P}_0</span>  computes  <span class="math">\\pi_1 = g^{q_1(\\tau_Y)}</span>  and sends  <span class="math">z = f(\\beta, \\alpha)</span>  and  <span class="math">\\pi_f = (\\pi_0, \\pi_1)</span>  to  <span class="math">\\mathcal{V}</span> .</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>DKZG.Verify  <span class="math">(\\operatorname{com}_f, \\beta, \\alpha, z, \\pi_f, \\mathsf{pp})</span> :  <span class="math">\\mathcal{V}</span>  parses  <span class="math">\\pi_f = (\\pi_0, \\pi_1)</span> , and checks if  <span class="math">e(\\operatorname{com}_f / g^z, g) \\stackrel{\\circ}{=} e(\\pi_0, g^{\\tau_X - \\alpha}) e(\\pi_1, g^{\\tau_Y - \\beta})</span> . It outputs 1 if the check passes, and 0 otherwise.</li>

    </ul>

    <p class="text-gray-300">Definition 4 (Robust Collaborative Proving System for Data-parallel Circuits). For a circuit  <span class="math">C</span> , a Robust Collaborative Proving System (RCPS) with  <span class="math">M</span>  participants has the following algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup  <span class="math">(1^{\\lambda})\\to \\mathsf{pp}</span>  : Generate the public parameters pp.</li>

      <li>SplitCircuit  <span class="math">(C, M) \\to \\mathcal{C} = (C_0, \\ldots, C_{M-1})</span> : From the circuit  <span class="math">C</span> , define  <span class="math">M</span>  sub-circuits covering its computation.</li>

      <li>MasterKeyGen  <span class="math">(\\mathcal{C}, M, \\mathsf{pp}) \\to (\\mathsf{mpk}, \\mathsf{vk})</span> : Generate the master proving key mpk and verifying key vk.</li>

      <li>KeyGen <span class="math">_i</span>  ( <span class="math">C_i, \\mathsf{mpk}</span> ) →  <span class="math">\\mathsf{pk}_i</span> : From the master key  <span class="math">\\mathsf{mpk}</span>  and  <span class="math">C_i</span> , generate the proving key for the  <span class="math">i</span> -th node.</li>

      <li>SplitInstance  <span class="math">(\\mathcal{C},\\mathbb{x})\\to ((\\mathbb{x}_0,\\mathbb{w}_0),\\ldots ,(\\mathbb{x}_{M - 1},\\mathbb{w}_{M - 1}))</span>  From  <span class="math">\\mathcal{C}</span>  and  <span class="math">\\mathbb{x}</span>  , define the public input and witness pairs.</li>

      <li>CoProve <span class="math">_i</span>  ( <span class="math">\\mathbb{x}_i, \\mathbb{w}_i, \\mathsf{pk}_i</span> ):  <span class="math">\\mathcal{P}_i</span>  interacts with  <span class="math">\\mathcal{P}_0</span>  and  <span class="math">\\mathcal{V}</span> , to prove the correctness of the computation for  <span class="math">C_i</span> .</li>

      <li>TestAndMerge  <span class="math">(\\mathbb{x},\\mathsf{mpk})\\to \\{1,0\\}^{M}</span> :  <span class="math">\\mathcal{P}_0</span>  interacts with  <span class="math">\\mathcal{P}_i</span>  for  <span class="math">0\\leq i &amp;lt; M</span> , outputs a vector  <span class="math">\\mathbf{b}</span> , with  <span class="math">b_{i}\\in \\{1,0\\}</span>  denoting whether to accept the messages from  <span class="math">\\mathcal{P}_i</span> .  <span class="math">\\mathcal{P}_0</span>  also interacts with  <span class="math">\\mathcal{V}</span>  to receive challenges and respond with merged messages.</li>

      <li>Verify  <span class="math">(\\mathbb{x},\\mathsf{vk})\\to \\{1,0\\}</span> :  <span class="math">\\mathcal{V}</span>  interacts with the set of  <span class="math">\\mathcal{P}</span>  and outputs whether to accept the interactive proof or not.</li>

    </ul>

    <p class="text-gray-300">We define the transcript between  <span class="math">\\mathcal{P}_i</span>  and  <span class="math">\\mathcal{P}_0</span>  as</p>

    <p class="text-gray-300"><span class="math">\\mathbf{tr}_i \\gets \\langle \\mathrm{CoProve}_i(\\mathbb{x}_i, \\mathbb{w}_i, \\mathsf{pk}_i), \\mathrm{TestAndMerge}(\\mathbb{x}, \\mathsf{mpk}) \\rangle</span></p>

    <p class="text-gray-300">and the transcript between  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\nu</span>  as</p>

    <p class="text-gray-300"><span class="math">\\mathbf{tr}\\gets \\langle \\mathrm{TestAndMerge}(\\mathbb{x},\\mathsf{mpk}),\\mathrm{Verify}(\\mathbb{x},\\mathsf{vk})\\rangle .</span></p>

    <p class="text-gray-300">It satisfies the following properties: completeness, witness-extended emulation, partial completeness, and partial witness-extended emulation as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Partial completeness. Given pp and the circuit partition for  <span class="math">C</span> , for each  <span class="math">0 \\leq i &amp;lt; M</span> , if  <span class="math">C_i(\\mathbb{x}_i; \\mathbb{w}_i) = 1</span> , mpk and pk are generated by MasterKeyGen and KeyGen, then the following probability is 1:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\operatorname{Pr}\\left[\\langle \\mathrm{CoProve}_i(\\mathbb{x}_i,\\mathbb{w}_i,\\mathsf{pk}_i),\\mathrm{TestAndMerge}(\\mathbb{x},\\mathsf{mpk})\\rangle = 1\\right].</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. Given pp, the circuit partition  <span class="math">\\mathcal{C}</span> , if for any  <span class="math">(\\mathbb{x},\\mathbb{w})</span> ,  <span class="math">C_i(\\mathbb{x}_i,\\mathbb{w}_i) = 1,0\\leq i &amp;lt; M</span>  where  <span class="math">(\\mathbb{x}_i,\\mathbb{w}_i)</span>  is generated from SplitInstance, and (mpk, vk) is generated from MasterKeyGen, then the following probability is 1:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\operatorname{Pr}\\left[\\langle \\text{TestAndMerge}(\\mathbb{x}, \\mathsf{mpk}), \\text{Verify}(\\mathbb{x}, \\mathsf{vk}) \\rangle = 1\\right]</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Partial witness-extended emulation. With a valid pp, a circuit partition  <span class="math">\\mathcal{C}</span>  for  <span class="math">C</span> , with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= M<span class="math"> , and  </span>\\mathrm{mpk} \\gets$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Protocol 3 (Distributedly Computable Double-efficient Public-coin Interactive Argument of Knowledge).  <span class="math">\\mathcal{P}</span>  is a prover with  <span class="math">M</span>  machines of  <span class="math">\\mathcal{P}_0, \\dots, \\mathcal{P}_{M-1}</span> , with master node  <span class="math">\\mathcal{P}_0</span> . Given a fan-in two arithmetic circuit  <span class="math">C</span>  of size  <span class="math">N</span>  with  <span class="math">M</span>  sub-circuits, each of size  <span class="math">T = N/M</span> .  <span class="math">\\mathcal{P}</span>  wants to convince  <span class="math">\\mathcal{V}</span>  that  <span class="math">C_i(\\mathbb{x}^{(i)}; \\mathbb{w}^{(i)}) = 1</span>  for all  <span class="math">i \\in [M]</span> , where  <span class="math">\\mathbb{x}^{(i)}</span>  is the public input and  <span class="math">\\mathbb{w}^{(i)}</span>  is the witness of  <span class="math">C_i</span> . Each  <span class="math">\\mathcal{P}_i</span>  holds the sub-circuit  <span class="math">C_i</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key generation and preprocessing procedure: Let  <span class="math">(\\mathsf{pk} = \\{\\mathsf{pk}_i\\}_{0\\leq i &amp;lt; M}, \\mathsf{vk})</span> . Run DKZG.KeyGen  <span class="math">(1^{\\lambda}, M, T)</span>  and generate  <span class="math">g, g^{\\tau_X}, g^{\\tau_Y}, \\mathbf{U} = (\\mathbf{U_i})_{0\\leq i &amp;lt; M} = \\left(g^{R_i(\\tau_Y)L_j(\\tau_X)}\\right)_{0\\leq i &amp;lt; M, 0\\leq j &amp;lt; T}</span> , and derive  <span class="math">\\mathbf{V} = \\left(g^{R_i(\\tau_Y)}\\right)_{0\\leq i &amp;lt; M}</span> . Compute commitments  <span class="math">\\mathsf{com}_S</span>  for each of the following polynomial set  <span class="math">S_{\\mathsf{pp}}</span> :</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{S}_{\\mathrm{pp}} = \\left\\{Q_a(Y,X),Q_b(Y,X),Q_o(Y,X),Q_{ab}(Y,X),Q_c(Y,X),\\sigma_{Y,a}(Y,X),\\sigma_{Y,b}(Y,X),\\sigma_{Y,o}(Y,X),\\sigma_{X,a}(Y,X),\\sigma_{X,b}(Y,X),\\sigma_{X,o}(Y,X)\\right\\}</span></p>

    <p class="text-gray-300">Let  <span class="math">s_i(X)</span>  be defined by  <span class="math">S(Y, X) = \\sum_{i=0}^{M-1} R_i(Y)s_i(X)</span> , we define  <span class="math">\\mathsf{pk}_0 = \\left( \\left( \\mathbf{V}, \\mathbf{U}_0, \\{s_0(X)\\}_{S \\in S_{\\mathsf{pp}}} \\right) \\right)</span> ,  <span class="math">\\mathsf{pk}_i = \\left( \\mathbf{U}_i, \\{s_i(X)\\}_{S \\in S_{\\mathsf{pp}}} \\right)</span> ,  <span class="math">\\mathsf{vk} = \\left( g^{\\tau_X}, g^{\\tau_Y}, \\{\\mathsf{com}_S\\}_{S \\in S_{\\mathsf{pp}}} \\right)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proving procedure:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each  <span class="math">\\mathcal{P}_i</span>  evaluates  <span class="math">C_i</span>  and defines polynomials  <span class="math">a_i(X), b_i(X), o_i(X)</span> .  <span class="math">\\mathcal{P}</span>  invokes the distributed algorithm Commit in Protocol 2 to obtain  <span class="math">\\mathsf{com}_A, \\mathsf{com}_B, \\mathsf{com}_G</span>  as commitments of  <span class="math">A(Y, X), B(Y, X), O(Y, X)</span>  and sends them to  <span class="math">\\mathcal{V}</span> .</li>

      <li>After receiving random points  <span class="math">\\eta_{Y},\\eta_{X}</span>  and  <span class="math">\\gamma</span>  from  <span class="math">\\mathcal{V}</span> , each  <span class="math">\\mathcal{P}_i</span>  computes  <span class="math">z_{i}(X)</span> , and sends the last entry  <span class="math">z_{i,T - 1}</span>  to the  <span class="math">\\mathcal{P}_0</span> , from which  <span class="math">\\mathcal{P}_0</span>  computes  <span class="math">W(Y) = \\sum_{i = 0}^{M - 1}w_iR_i(Y)</span> . Then,  <span class="math">\\mathcal{P}</span>  invokes the Commit algorithm in Protocol 2 to obtain  <span class="math">\\operatorname{com}_{Z},\\operatorname{com}_{W}</span>  and sends them to  <span class="math">\\mathcal{V}</span> .</li>

      <li>After receiving  <span class="math">\\lambda</span>  from  <span class="math">\\mathcal{V}</span> ,  <span class="math">\\mathcal{P}_0</span>  shares it to  <span class="math">\\mathcal{P}_i</span> . Each  <span class="math">\\mathcal{P}_i</span>  computes  <span class="math">h_i(X)</span>  according to Equation 6 or Equation 18. Then,  <span class="math">\\mathcal{P}</span>  invokes algorithm Commit in Protocol 2 to obtain  <span class="math">\\operatorname{com}_{H_X} = \\{\\operatorname{com}_{H_{X,0}}, \\operatorname{com}_{H_{X,1}}, \\operatorname{com}_{H_{X,2}}, \\operatorname{com}_{H_{X,3}}\\}</span>  as commitments of  <span class="math">H_X(Y, X) = \\sum_{i=0}^{M-1} R_i(Y) h_i(X)</span> , and sends them to  <span class="math">\\mathcal{V}</span> . The form of  <span class="math">\\operatorname{com}_{H_X}</span>  due to the fact that  <span class="math">H_X(Y, X)</span>  has degree  <span class="math">3T - 2</span>  or  <span class="math">4T - 2</span>  with respect to  <span class="math">X</span> .</li>

      <li>After receiving the random point  <span class="math">\\alpha</span>  from  <span class="math">\\mathcal{V}</span> ,  <span class="math">\\mathcal{P}_0</span>  sends  <span class="math">\\alpha</span>  to each  <span class="math">\\mathcal{P}_i</span> . We define  <span class="math">S_{\\mathrm{wt}} = \\{A, B, O, Z\\}</span> . Then  <span class="math">\\mathcal{P}</span>  process the following computation:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>for each polynomial  <span class="math">S \\in S_{\\mathrm{pp}} \\cup S_{\\mathrm{wt}}</span> , run Step 1 &amp; 2 in DKZG.Open function, computing  <span class="math">S(Y, \\alpha)</span>  and the first entry of  <span class="math">\\pi_S</span>  as  <span class="math">\\pi_S[0]</span> .</li>

      <li>Furthermore,  <span class="math">\\mathcal{P}_0</span>  also recovers  <span class="math">Z(Y,\\omega_X\\cdot \\alpha)</span>  and  <span class="math">\\pi_Z^{\\prime}[0]</span>  when running DKZG.Open for opening  <span class="math">Z(Y,X)</span>  on  <span class="math">X = \\omega_{X}\\cdot \\alpha</span></li>

      <li>With all  <span class="math">\\{S(Y,\\alpha)\\}_{S\\in S_{\\mathrm{wt}}\\cup S_{\\mathrm{pp}}}</span>  and  <span class="math">Z(Y,\\omega_X\\alpha)</span> ,  <span class="math">\\mathcal{P}</span>  computes  <span class="math">H_{Y,\\alpha}(Y)</span>  according to Equation 12 or Equation 23 and the univariate commitment  <span class="math">\\operatorname{com}_{H_Y} = \\{\\operatorname{com}_{H_{Y,0}},\\operatorname{com}_{H_{Y,1}},\\operatorname{com}_{H_{Y,2}},\\operatorname{com}_{H_{Y,3}}\\}</span>  as commitments of  <span class="math">H_{Y,\\alpha}(Y) = \\sum_{i=0}^{M-1} h_{y,\\alpha,i} R_i(Y)</span> , and sends them to  <span class="math">\\mathcal{V}</span> . The degree of  <span class="math">H_{Y,\\alpha}(Y)</span>  has degree  <span class="math">3T - 2</span>  or  <span class="math">4T - 2</span>  with respect to  <span class="math">Y</span> .</li>

      <li>Finally,  <span class="math">\\mathcal{P}</span>  sends  <span class="math">\\{\\pi_S[0]\\}_{S\\in S_{\\mathrm{wt}}\\cup S_{\\mathrm{pp}}}\\cup \\{\\pi_Z&#x27;[0],\\mathrm{com}_{h_Y}\\}</span>  to  <span class="math">\\mathcal{V}</span> .</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>After receiving  <span class="math">\\beta</span>  from  <span class="math">\\mathcal{V}</span> ,  <span class="math">\\mathcal{P}</span>  executes Step 3 in the Open algorithm in Protocol 2 to compute the evaluations on  <span class="math">S(\\beta, \\alpha)</span>  and  <span class="math">\\pi_S[1]</span>  for  <span class="math">S \\in S_{\\mathrm{wt}} \\cup S_{\\mathrm{pp}}</span>  and  <span class="math">Z(\\beta, \\omega_X \\alpha)</span> ,  <span class="math">H_X(\\beta, \\alpha)</span> .  <span class="math">\\mathcal{P}</span>  also computes  <span class="math">H_Y(\\beta), \\pi_{H_Y}</span>  and  <span class="math">W(\\beta), \\pi_W</span> . In the end,  <span class="math">\\mathcal{P}</span>  sends all the evaluations and proofs to  <span class="math">\\mathcal{V}</span> .</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verification procedure:  <span class="math">\\mathcal{V}</span>  verifies the following steps:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  verifies the evaluation and proof  <span class="math">S(\\beta, \\alpha), \\pi_S</span>  for  <span class="math">S \\in S_{\\mathrm{wt}} \\cup S_{\\mathrm{pp}} \\cup \\{Z(Y, \\omega_X X), H_X(Y, X)\\}</span> , together with  <span class="math">H_Y(\\beta)</span> ,  <span class="math">W(\\beta)</span>  with corresponding proofs by invoking the Verify algorithm in Protocol 2.</li>

      <li>With the evaluations,  <span class="math">\\mathcal{V}</span>  outputs 1 if  <span class="math">\\mathcal{V}</span>  successfully verifies the gate constraint and copy constraints through Equation 8, Equation 9, Equation 10, Equation 12 or Equation 19. Equation 20, Equation 21, Equation 22, and Equation 23.</li>

    </ol>

    <p class="text-gray-300">MasterKeyGen  <span class="math">(\\mathcal{C},M,\\mathsf{pp})</span>  , an RCPS has partial witnessextended emulation if that: for each  <span class="math">0\\leq i &amp;lt;   M</span>  , and any PPT adversary  <span class="math">\\hat{\\mathcal{P}}_i</span>  , there exists a PPT extractor  <span class="math">\\mathcal{E}_i</span>  with access to  <span class="math">\\hat{\\mathcal{P}}_i</span>  's messages during the protocol such that  <span class="math">(\\mathbb{x}_i,\\mathsf{aux}_i)\\gets \\hat{\\mathcal{P}}_i(\\mathsf{mpk}),(w_i,\\mathsf{tr}_i)\\gets \\mathcal{E}_i^{\\hat{\\mathcal{P}}_i(\\mathsf{aux}_i)}(\\mathbb{x}_i,\\mathsf{mpk}),</span>  and</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Pr}\\left[\\hat{\\mathcal{P}}_i(\\mathsf{aux}_i;\\mathsf{tr}_i) = 1 \\wedge \\text{TestAndMerge accepts } \\mathsf{tr}_i\\right.\\right.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Rightarrow C_{i}(\\mathbb{x}_{i},\\mathbb{w}_{i}) = 1] - \\operatorname *{Pr}\\left[\\hat{\\mathcal{P}}_{i}(\\mathsf{aux}_{i};\\mathsf{tr}_{i}) = 1\\right]\\bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathsf{negl}(\\lambda)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Witness-extended emulation. With a valid pp, a circuit partition  <span class="math">\\mathcal{C}</span>  for  <span class="math">C</span> , with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= M<span class="math"> , and  </span>\\mathsf{vk} \\gets$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">MasterKeyGen  <span class="math">(\\mathcal{C},M,\\mathsf{pp})</span>  , an RCPS has witness-extended emulation if for any b, any PPT adversary  <span class="math">\\hat{\\mathcal{P}}</span>  , there exists a PPT extractor  <span class="math">\\mathcal{E}</span>  with access to  <span class="math">\\hat{\\mathcal{P}}</span>  's messages during the protocol such that for  <span class="math">(\\mathbb{x},\\mathsf{aux})\\gets \\hat{\\mathcal{P}} (\\mathsf{vk},\\mathsf{b})</span> <span class="math">(\\mathbb{w},\\mathsf{tr})\\gets \\mathcal{E}^{\\hat{\\mathcal{P}} (\\mathsf{aux})}(\\mathbb{x},\\mathsf{vk},\\mathsf{b})</span>  , and  <span class="math">(\\mathbb{x}_i,\\mathbb{w}_i)</span>  computed from SplitInstance, there is:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname *{Pr}\\left[\\hat{\\mathcal{P}} (\\mathsf{aux};\\mathsf{tr}) = 1\\wedge \\mathsf{Verify}\\right.\\right.<span class="math">  accepts  </span>\\mathsf{tr}\\Rightarrow C_i(\\mathbb{x}_i,\\mathbb{w}_i) = 1<span class="math">  if  </span>b_{i} = 1$  1</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $\\operatorname{Pr}\\left[\\hat{\\mathcal{P}} (\\mathsf{aux};\\mathsf{tr}) = 1\\right]\\bigg</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathsf{negl}(\\lambda)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We further show that with additional verification and sub-commitments recombination using an inner product ar</p>

    <p class="text-gray-300">gument [22], our protocol for data-parallel circuits is an RCPS. The full protocol is presented in Appendix B. We have the following theorem:</p>

    <p class="text-gray-300">Theorem 5. For a data-parallel circuit  <span class="math">C</span>  consisting of  <span class="math">M</span>  independent sub-circuits, the protocol in Appendix B is an RCPS with completeness, witness-extended emulation, partial completeness, and partial witness-extended emulation.</p>

    <p class="text-gray-300">Please refer to the protocol and the proof sketch in Appendix B.</p>

    <p class="text-gray-300">We have implemented the fully distributed ZKP system, Pianist and we present the implementation details and evaluation results in this section.</p>

    <p class="text-gray-300">Software and hardware. Our implementation is based on the Gnark [5] library written in Golang. Our scheme is implemented using  <span class="math">3700+</span>  lines of code in Go. The bilinear map is instantiated using a BN254 curve. It provides around 100 bits of security and the pairing instruction is supported in Solidity, the programming language of Ethereum smart contracts. The experiments were executed on AWS m6i.16xlarge machines with 64 vCPUs and 256 GiB memory. We used the multi-threading enabled by the Gnark library. We opened 2-64 machines over the two regions of California and Oregon.</p>

    <p class="text-gray-300">Design of the experiments. The goal of the experiments is to evaluate and demonstrate the following three advantages of Pianist:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Linear scalability: we measure the running time and memory usage and demonstrate that Pianist has linear scalability in the number of machines. The running time decreases linearly as the machine number grows. The maximum size of the circuit supported by the system grows linearly in the number of machines.</li>

      <li>Minimum communication and synchronization: we measure the communication between the machines to demonstrate that Pianist only incurs  <span class="math">O(1)</span>  communication per machine in  <span class="math">O(1)</span>  round.</li>

      <li>Constant proof size and verifier time: we report the proof size and the verifier time and show that they remain small in practice.</li>

    </ol>

    <p class="text-gray-300">These three properties are critical for blockchain applications where with our new system, users can contribute to ZKP generations in these applications in a model similar to mining pools.</p>

    <p class="text-gray-300">We first present the performance of Pianist on data-parallel circuits in the application of zkRollups. We use the rollup circuit by Polygon Hermez [7]. The circuit is compiled using Circom [3] and the output format is the rank-1-constraint-system (R1CS). As Pianist and the original</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Prover time of Pianist for zkRollups transaction verification.</p>

    <p class="text-gray-300">Plonk do not support R1CS directly, we further compile the R1CS to Gnark's Plonk constraint. The number of R1CS constraints is about 86k per transaction and the final Plonk circuit we use in our experiments is about 660k per transaction. This transformation introduces a big overhead compared to manually designed circuits. In practice, the size of the Plonk circuit can be reduced significantly with special gates and lookup arguments. For example, Scroll [9] designed more than 2000 custom gates for the zkEVM circuit. Unfortunately, we could not find any open-source code of the Plonk circuit for zkRollups (even with custom gates). However, the big overhead of the transformation does not defeat the purpose of our experiments. No matter how many transactions can be supported on a single machine, we show that Pianist can scale it to  <span class="math">M</span>  times more using  <span class="math">M</span>  machines with small communication.</p>

    <p class="text-gray-300">Prover time. We run our distributed proof generation on 2-64 machines and Figure 1 shows the result. The  <span class="math">x</span> -axis is the number of transactions to batch in the zkRollups and the  <span class="math">y</span> -axis is the prover time. We report the prover time of each  <span class="math">\\mathcal{P}_i</span>  in our scheme and the running time of the original Plonk scheme on a single machine as a baseline. We introduced additional optimizations to Plonk on a single machine to improve the memory usage, and the performance shown in all of our experiments are based on the optimized version. We run each case to the maximum number of transactions until the machines run out of memory. As shown in the figure, with 64 machines, Pianist can prove up to 8192 transactions in 313s, while the original Plonk can only scale to 32 transactions with a prover time of 95s. The number of transactions and thus the maximum circuit size scales linearly in the number of machines. Moreover, given a fixed number of transactions, the prover time is accelerated by the number of machines. For example, it only takes 17.5s to prove 32 transactions using 4 machines,  <span class="math">5.4 \\times</span>  faster than on a single machine. In addition, the additional time on  <span class="math">P_0</span>  to generate the final proof is only 2-16ms in all of our experiments, which is extremely fast compared to the prover time of each machine.</p>

    <p class="text-gray-300">Constant communication, proof size, and verifier time. In our experiments, each machine only sends 1984 bytes of messages for data-parallel circuits (or 2080 for general circuits) in 4 rounds to the master node and receives 160 bytes for data-parallel (or 256 for general) circuits from the master node, regardless of the total number of machines. Because of this, the bandwidth and the network delay of the machines do not affect the results at all. This feature enables large-scale zkRollups with the help of users globally in a model similar to a mining pool, as the nodes do not have to stay online and deal with massive communication with other nodes in a Map-Reduce framework as in [46]. The proof size is  <span class="math">27\\mathbb{G}_1</span>  (or 34 for general circuits) and 15 (or 20 for general circuits)  <span class="math">\\mathbb{F}</span>  elements (2208 bytes or 2816 for general circuits) and the verifier time is  <span class="math">3.5\\mathrm{ms}</span>  in all cases regardless of the number of transactions. Compared to the original Plonk, we use bivariate polynomials, which increase the proof size by 18 (or 25 for general circuits)  <span class="math">\\mathbb{G}_1</span> , 7 (or 12 for general circuits)  <span class="math">\\mathbb{F}</span>  elements, and the verifier time by two pairings.</p>

    <p class="text-gray-300">In this section, we further demonstrate that Pianist supports the distributed proof generation of general circuits with arbitrary connections. We vary the total size of the circuit from  <span class="math">2^{21}</span>  to  <span class="math">2^{25}</span> , and randomly sample the type and the connection of each gate. The circuit is evaluated and the witness is distributed evenly to multiple machines. In practice, the memory usage of the circuit evaluation is not the bottleneck and the evaluation of the entire circuit can be executed on each machine individually.</p>

    <p class="text-gray-300">Prover time. In Figure 2, the  <span class="math">x</span> -axis is the number of machines and the  <span class="math">y</span> -axis is the prover time of each machine  <span class="math">P_{i}</span> . As shown in the Figure, the running time is decreasing with the number of machines. In particular, for a random circuit of size  <span class="math">2^{25}</span> , it takes  <span class="math">121\\mathrm{s}</span>  to generate the proof using Plonk on a single machine (with our optimizations), while it takes  <span class="math">76.9\\mathrm{s}</span>  on 2 machines in Pianist,  <span class="math">1.57\\times</span>  faster than Plonk. It is further reduced to  <span class="math">5\\mathrm{s}</span>  using 32 machines, which is  <span class="math">24.2\\times</span>  faster than Plonk.</p>

    <p class="text-gray-300">In addition, Table 2 shows the additional time on  <span class="math">P_0</span>  to merge proofs and messages from  <span class="math">P_1</span> s. As shown in the table, this step only takes several milliseconds in all instances.</p>

    <p class="text-gray-300">Overhead vs. Plonk To show that the overhead of proving time between Pianist and Plonk, we illustrate the case with the same circuit size as  <span class="math">2^{21}</span>  per instance in Figure 4. From this result, we show that the overhead of Pianist is negligible.</p>

    <p class="text-gray-300">Memory usage. Figure 3 shows the memory usage of the machines. As shown in the figure, in Pianist, the memory usage on each machine decreases with the number of machines. For example, for a circuit of size  <span class="math">2^{24}</span> , it takes 70.7 GB of memory to run the original protocol on a single machine, while it only takes 31.7 GB on each machine to run Pianist using two machines. It is further improved to 1.92</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: Prover time of the random circuit</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: Memory consumption of the random circuit</p>

    <p class="text-gray-300">GB using 32 machines, which is  <span class="math">36.8 \\times</span>  smaller than Plonk. The improvement is critical for zkRollups and zkEVM as the memory consumption of existing ZKP systems is large. Pianist is able to increase the scalability of these schemes linearly in the number of machines, thus batching more transactions in one ZKP with the help of the fully distributed proof generations.</p>

    <p class="text-gray-300">Communication, proof size, and verifier time. Similar to the case of data-parallel circuits, they all remain  <span class="math">O(1)</span>  for general circuits. In particular, the communication is 2336 bytes per machine, the proof size is 2816 bytes and the verifier time is 3 ms.</p>

    <p class="text-gray-300">Comparison with PCD and IVC As highlighted in Section 1.1, Proof-Carrying Data (PCD) [19], [28] generates a proof at each step for newly received transactions. To ensure the correctness of previous proofs, there are two approaches:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Circuit Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">8 Nodes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">16 Nodes</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">32 Nodes</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">221</td>

            <td class="px-3 py-2 border-b border-gray-700">2.764 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">3.576ms</td>

            <td class="px-3 py-2 border-b border-gray-700">4.629ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">222</td>

            <td class="px-3 py-2 border-b border-gray-700">2.975 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">3.666ms</td>

            <td class="px-3 py-2 border-b border-gray-700">4.800ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">223</td>

            <td class="px-3 py-2 border-b border-gray-700">3.073 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">3.687ms</td>

            <td class="px-3 py-2 border-b border-gray-700">5.009ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">224</td>

            <td class="px-3 py-2 border-b border-gray-700">3.120 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">3.692ms</td>

            <td class="px-3 py-2 border-b border-gray-700">5.705ms</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">TABLE 2: Extra time to merge proofs on  <span class="math">{\\mathcal{P}}_{0}</span>  .</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 4: Comparison between the prover time of a single node in Pianist and Plonk for sub-circuit with the same size</p>

    <p class="text-gray-300">either aggregating a recursive proof for the previous succinct verification circuits in the current proof [18], [19], [27], or merging each proof into an accumulator and verifying them all at once [6], [20], [25], [37], [38]. By using either the aggregated verification circuit or the accumulator, the prover does not need to store the entire circuit, making these methods suitable alternatives when memory is limited.</p>

    <p class="text-gray-300">Nonetheless, these techniques share some common drawbacks. First, they all utilize recursive proofs, which depend on the assumption that the random oracle (RO) used in the Fiat-Shamir transform can be efficiently instantiated. Second, their proofs are generated sequentially, potentially imposing an upper bound on TPS. Third, either the succinct verification aggregation or the accumulator demands extra effort from the prover, which will at least increase linearly as the number of steps grows, resulting in reduced practical performance. Our work, on the other hand, avoids these issues since we do not employ recursive proofs.</p>

    <p class="text-gray-300">We also mentioned Incremental Verifiable Computation (IVC) for incrementally verifying stages of long-run computation, such as Nova [38] and SuperNova [37]. While Nova and SuperNova are suitable for real-world applications like zkRollups and zkEVM, they expose the output of each stage, which cannot guarantee a zero-knowledge property throughout the entire process. We argue that our work not only supports general circuits, offering a more powerful computation model but can also achieve zero-knowledge properties using common techniques.</p>

    <p class="text-gray-300">Comparison with aPlonk [12] In Section 1.1, we mentioned an alternative solution, aPlonk, which is based on Plonk and generalized IPA under the same settings (distributed, shared Fiat-Shamir randomness) as our approach. However, due to the use of IPA, their final verification cost is logarithmic with respect to the number of parties. Additionally, they only propose a solution for data-parallel circuits and their solution involves recursive proofs. By contrast, our proof does not require recursive circuits, our verification cost is independent of the number of parties, and our approach is more flexible when generalizing to circuits with connections and general circuits. Consequently, our solution delivers better performance, both theoretically and practically.</p>

    <p class="text-gray-300">Custom gates. A key advantage of the Plonk scheme lies</p>

    <p class="text-gray-300">in its support for custom gates. Users can define their own gate constraints, differing from Equation 1, by altering term forms and introducing rotations. Custom gates may increase the degree and total number of terms in Equation 1, but typically reduce the overall gate count in the circuit, leading to significant improvements in prover time in practice. As mentioned earlier, Scroll [9] designed over 2000 custom gates to enhance Plonk's performance in their zkEVM implementation. Our new schemes are fully compatible with custom gates by following the outline introduced in Section 3.</p>

    <p class="text-gray-300">Additionally, as mentioned in Section 3, rotations can be introduced for the variable  <span class="math">Y</span> , and simple, regular connections among different sub-circuits can be established based on the data-parallel setting. For instance, in a zkEVM context, if we treat a block of instructions as a sub-circuit, we can define the constraint  <span class="math">S_{\\mathrm{pc}}(X)f_{\\mathrm{pc}}(Y,X) + \\Delta = S_{\\mathrm{pc}}(X)f_{\\mathrm{pc}}(\\omega_Y Y,X)</span>  to represent the program counter change between the previous and current blocks, where  <span class="math">S_{\\mathrm{pc}}(X)</span>  serves as a selector to indicate the row recording the program counter.</p>

    <p class="text-gray-300">Lookup arguments. Lookup arguments play a crucial role in the implementation of zkRollups and zkEVM, as they help construct proofs for RAM and chiplet computations. Since these lookup arguments are compiled into polynomial equations, we assert that they are compatible with our system. We can identify two primary use cases for lookup arguments:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Lookup arguments with local tables. In this scenario, each sub-circuit possesses its own lookup arguments, independent of other sub-circuits. This setup is well-suited for situations where each machine runs a program with its local memory, for example.</li>

      <li>Lookup arguments with global tables. This configuration allows applications to define global lookup tables, such as range tables or chiplet computing. We argue that, by leveraging the latest lookup argument research [29], [34] based on logarithmic derivatives, this can be easily implemented. These protocols eliminate the need for cumbersome permutations of input and table vectors, requiring only the counting of occurrences and the execution of a sumcheck protocol. Furthermore, by employing rotation on the variable  <span class="math">Y</span> , global tables can be distributed across different machines, thus reducing the workload for the master.</li>

    </ol>

    <p class="text-gray-300">This material is in part based upon work supported by the National Science Foundation (NSF) under Grant No. TWC-1518899 and Grant No. 2144625, DARPA under Contract No. HR001120C0087, the Center for Long-Term Cybersecurity (CLTC) and the Berkeley Center for Responsible, Decentralized Intelligence (RDI). Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of these institutes.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] An Incomplete Guide to Rollups. https://vitalik.ca/general/2021/01/05/rollup.</li>

      <li>[2] Aztec. https://aztec.network/</li>

      <li>[3] Circom. https://github.com/iden3/circom</li>

      <li>[4] Cryptocurrency prices, charts and market capitalizations, https://coinmarketcap.com/</li>

      <li>[5] gnark. https://docs.gnark.consensys.net/en/latest/</li>

      <li>[6] The halo2 book, https://zcash.github.io/halo2/</li>

      <li>[7] Hermez. https://polygon.technology/solutions/polygon-hermez/</li>

      <li>[8] libsnark. https://github.com/scipr-lab/libsnark</li>

      <li>[9] Scroll. https://scroll.io/</li>

      <li>[10] Starkware. https://starkware.co/</li>

      <li>[11] ZkSync. https://zksync.io/</li>

      <li>[12] Ambrona, M., Beunardeau, M., Schmitt, A.L., Toledo, R.R.: aplonk : Aggregated plonk from multi-polynomial commitment schemes. Cryptology ePrint Archive, Paper 2022/1352 (2022)</li>

      <li>[13] Ames, S., Hazay, C., Ishai, Y., Venkitasubramaniam, M.: Ligero: Lightweight sublinear arguments without a trusted setup. In: Proceedings of the ACM SIGSAC Conference on Computer and Communications Security (2017)</li>

      <li>[14] Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.: Fast Reed-Solomon interactive oracle proofs of proximity. In: 45th international colloquium on automata, languages, and programming (icalp 2018) (2018)</li>

      <li>[15] Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.: Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint (2018)</li>

      <li>[16] Ben-Sasson, E., Chiesa, A., Garman, C., Green, M., Miers, I., Tromer, E., Virza, M.: Zerocash: Decentralized anonymous payments from bitcoin. In: Proceedings of the Symposium on Security and Privacy (SP), 2014 (2014)</li>

      <li>[17] Ben-Sasson, E., Chiesa, A., Riabzev, M., Spooner, N., Virza, M., Ward, N.P.: Aurora: Transparent succinct arguments for r1cs. In: Advances in Cryptology – EUROCRYPT 2019. pp. 103–128 (2019)</li>

      <li>[18] Ben-Sasson, E., Chiesa, A., Tromer, E., Virza, M.: Scalable zero knowledge via cycles of elliptic curves. Algorithmica 79, 1102–1160 (2017)</li>

      <li>[19] Bitansky, N., Canetti, R., Chiesa, A., Tromer, E.: Recursive composition and bootstrapping for snarks and proof-carrying data. In: Proceedings of the Forty-Fifth Annual ACM Symposium on Theory of Computing. p. 111–120. STOC ’13, New York, NY, USA (2013)</li>

      <li>[20] Bünz, B., Chiesa, A., Lin, W., Mishra, P., Spooner, N.: Proof-carrying data without succinct arguments. In: Advances in Cryptology – CRYPTO 2021. pp. 681–710. Cham (2021)</li>

      <li>[21] Bünz, B., Fisch, B., Szepieniec, A.: Transparent snarks from dark compilers. In: Advances in Cryptology – EUROCRYPT 2020. pp. 677–706 (2020)</li>

      <li>[22] Bünz, B., Maller, M., Mishra, P., Tyagi, N., Vesely, P.: Proofs for inner pairing products and applications. In: Advances in Cryptology – ASIACRYPT 2021. pp. 65–97 (2021)</li>

      <li>[23] Bünz, B., Maller, M., Vesely, N.: Efficient proofs for pairing-based languages. Tech. rep., Cryptology ePrint Archive, Report 2019/1177 (2019)</li>

      <li>[24] Bünz, B., Bootle, J., Boneh, D., Poelstra, A., Wuille, P., Maxwell, G.: Bulletproofs: Short proofs for confidential transactions and more. In: Proceedings of the Symposium on Security and Privacy (SP), 2018. vol. 00, pp. 319–338</li>

      <li>[25] Bünz, B., Chiesa, A., Mishra, P., Spooner, N.: Proof-carrying data from accumulation schemes. Cryptology ePrint Archive, Paper 2020/499 (2020)</li>

      <li>[26] Chiesa, A., Hu, Y., Maller, M., Mishra, P., Vesely, N., Ward, N.: Marlin: Preprocessing zksnarks with universal and updatable srs. In: Advances in Cryptology – EUROCRYPT 2020. pp. 738–768 (2020)</li>

      <li>[27] Chiesa, A., Ojha, D., Spooner, N.: Fractal: Post-quantum and transparent recursive proofs from holography. In: Advances in Cryptology – EUROCRYPT 2020. pp. 769–793 (2020)</li>

      <li>[28] Chiesa, A., Tromer, E.: Proof-carrying data and hearsay arguments from signature cards. In: Innovations in Computer Science - ICS 2010, Tsinghua University, Beijing, China, January 5-7, 2010. Proceedings. pp. 310–331 (2010)</li>

      <li>[29] Eagen, L., Fiore, D., Gabizon, A.: cq: Cached quotients for fast lookups. Cryptology ePrint Archive, Paper 2022/1763 (2022)</li>

      <li>[30] Fiat, A., Shamir, A.: How to prove yourself: Practical solutions to identification and signature problems. In: Advances in Cryptology — CRYPTO’ 86 (1987)</li>

      <li>[31] Gabizon, A., Williamson, Z.J., Ciobotaru, O.: Plonk: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive (2019)</li>

      <li>[32] Goldwasser, S., Micali, S., Rackoff, C.: The knowledge complexity of interactive proof-systems. In: STOC 1985. pp. 291–304</li>

      <li>[33] Groth, J.: On the size of pairing-based non-interactive arguments. In: Advances in Cryptology – EUROCRYPT 2016. pp. 305–326 (2016)</li>

      <li>[34] Haböck, U.: Multivariate lookups based on logarithmic derivatives. Cryptology ePrint Archive, Paper 2022/1530 (2022)</li>

      <li>[35] Kate, A., Zaverucha, G.M., Goldberg, I.: Constant-size commitments to polynomials and their applications. In: Advances in Cryptology – ASIACRYPT 2010. pp. 177–194</li>

      <li>[36] Kosba, A., Miller, A., Shi, E., Wen, Z., Papamanthou, C.: Hawk: The blockchain model of cryptography and privacy-preserving smart contracts. In: Proceedings of Symposium on security and privacy (SP), 2016</li>

      <li>[37] Kothapalli, A., Setty, S.: Supernova: Proving universal machine executions without universal circuits. Cryptology ePrint Archive, Paper 2022/1758 (2022)</li>

      <li>[38] Kothapalli, A., Setty, S., Tzialla, I.: Nova: Recursive zero-knowledge arguments from folding schemes. In: Advances in Cryptology – CRYPTO 2022. pp. 359–388 (2022)</li>

      <li>[39] Lindell, Y.: Parallel coin-tossing and constant-round secure two-party computation. Cryptology ePrint Archive, Paper 2001/107 (2001)</li>

      <li>[40] Merkle, R.C.: A digital signature based on a conventional encryption function. In: Conference on the theory and application of cryptographic techniques (1987)</li>

      <li>[41] Papamanthou, C., Shi, E., Tamassia, R.: Signatures of correct computation. In: TCC 2013. pp. 222–242 (2013)</li>

      <li>[42] Parno, B., Howell, J., Gentry, C., Raykova, M.: Pinocchio: Nearly practical verifiable computation pp. 238–252 (2013)</li>

      <li>[43] Schwartz, J.T.: Fast probabilistic algorithms for verification of polynomial identities. Journal of the ACM (JACM) 27(4), 701–717 (1980)</li>

      <li>[44] Setty, S.: Spartan: Efficient and general-purpose zksnarks without trusted setup. In: Advances in Cryptology – CRYPTO 2020. pp. 704–737 (2020)</li>

      <li>[45] Wahby, R.S., Tzialla, I., Shelat, A., Thaler, J., Walfish, M.: Doubly-efficient zkSNARKs without trusted setup. In: 2018 IEEE Symposium on Security and Privacy (SP). pp. 926–943 (2018)</li>

      <li>[46] Wu, H., Zheng, W., Chiesa, A., Popa, R.A., Stoica, I.: Dizk: A distributed zero knowledge proof system. In: Proceedings of the 27th USENIX Conference on Security Symposium. p. 675–692. SEC’18, USA (2018)</li>

    </ul>

    <p class="text-gray-300">[47] Xie, T., Zhang, J., Zhang, Y., Papamanthou, C., Song, D.: Libra: Succinct zero-knowledge proofs with optimal prover computation. In: Advances in Cryptology – CRYPTO 2019. pp. 733–764 (2019)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[48] Xie, T., Zhang, J., Cheng, Z., Zhang, F., Zhang, Y., Jia, Y., Boneh, D., Song, D.X.: zkbridge: Trustless cross-chain bridges made practical. Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security (2022)</li>

      <li>[49] Zapico, A., Buterin, V., Khovratovich, D., Maller, M., Nitulescu, A., Simkin, M., Fabra, U.P.: Caulk: Lookup arguments in sublinear time. Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security (2022)</li>

      <li>[50] Zhang, J., Wang, W., Zhang, Y., Zhang, Y.: Doubly efficient interactive proofs for general arithmetic circuits with linear prover time. Proceedings of the 2021 ACM SIGSAC Conference on Computer and Communications Security (2021)</li>

      <li>[51] Zhang, J., Xie, T., Zhang, Y., Song, D.X.: Transparent polynomial delegation and its applications to zero knowledge proof. 2020 IEEE Symposium on Security and Privacy (SP) pp. 859–876 (2020)</li>

      <li>[52] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: vsql: Verifying arbitrary sql queries over dynamic outsourced databases. In: 2017 IEEE Symposium on Security and Privacy (SP). pp. 863–880. Los Alamitos, CA, USA (may 2017)</li>

      <li>[53] Zhang, Y., Genkin, D., Katz, J., Papadopoulos, D., Papamanthou, C.: A zero-knowledge version of vsql. IACR Cryptol. ePrint Arch. 2017, 1146 (2017)</li>

      <li>[54] Zippel, R.: Probabilistic algorithms for sparse polynomials. In: Symbolic and Algebraic Computation (1979)</li>

    </ul>

    <h2 id="sec-44" class="text-2xl font-bold">Appendix A Proof of Theorem 1</h2>

    <h6 id="sec-45" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Protocol 1 is a Polynomial IOP protocol with negligible knowledge error.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For simplicity, we only prove the theorem in the general-circuit setting. We assume the adversary <span class="math">\\mathcal{P}^{<em>}</span> has unbounded power. At the beginning, both <span class="math">\\mathcal{P}^{</em>}</span> and <span class="math">\\mathcal{V}</span> hold the following precomputed polynomial set <span class="math">\\mathcal{S}_{\\mathtt{pp}}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\{Q_{a}(Y,X),Q_{b}(Y,X),Q_{o}(Y,X),Q_{ab}(Y,X),Q_{c}(Y,X)\\}</span></li>

      <li><span class="math">\\{\\sigma_{Y,a}(Y,X),\\sigma_{Y,b}(Y,X),\\sigma_{Y,o}(Y,X)</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">\\sigma_{X,a}(Y,X),\\sigma_{X,b}(Y,X),\\sigma_{X,o}(Y,X)\\}</span></p>

    <p class="text-gray-300">With arbitrary invalid witness <span class="math">\\mathbf{a}^{<em>},\\mathbf{b}^{</em>},\\mathbf{o}^{<em>}\\in\\mathbb{F}^{M\\times T}</span> generated by <span class="math">\\mathcal{P}^{</em>}</span>, the possibility that <span class="math">\\mathcal{V}</span> outputs <span class="math">1</span> is negiligible.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">\\mathbf{f}\\in\\{\\mathbf{a}^{<em>},\\mathbf{b}^{</em>},\\mathbf{o}^{<em>}\\}</span>, <span class="math">\\mathcal{P}^{</em>}</span> define the polynomial <span class="math">F(Y,X)=\\sum_{i=0}^{M-1}\\sum_{j=0}^{T-1}f_{i,j}L_{j}(X)R_{i}(Y)=\\sum_{i=0}^{M-1}f_{i,j}L_{j}(X)</span>, <span class="math">Z^{<em>}(Y,X)</span> and <span class="math">W^{</em>}(Y)</span> are derived from the witnesses.</li>

      <li>In the round after <span class="math">\\mathcal{V}</span> sends <span class="math">\\beta</span> to <span class="math">\\mathcal{P}^{<em>}</span>, which is the last round, <span class="math">\\mathcal{V}</span> queries all oracles in <span class="math">\\mathcal{S}_{\\mathtt{pp}}</span> and <span class="math">\\mathcal{S}_{\\mathtt{mit}}=\\{A^{</em>}(Y,X),B^{<em>}(Y,X),O^{</em>}(Y,X),Z^{<em>}(Y,X),W^{</em>}(Y)\\}</span> with random challenge <span class="math">\\alpha</span> and <span class="math">\\beta</span> and verifies the Equation 23. Since <span class="math">\\mathcal{V}</span> has received all oracles before sending <span class="math">\\beta</span> to <span class="math">\\mathcal{P}</span>, by the Schwartz–Zippel Lemma <em>[43, 54]</em>, it implies that there exists <span class="math">Q_{0}(Y):=G_{\\alpha}(Y)\\ +\\ \\sum_{i=0}^{3}\\lambda^{i+1}P_{i,\\alpha}(Y)\\ -\\ \\left(\\alpha^{T}-1\\right)H_{X}(Y,\\alpha)</span> where</li>

    </ol>

    <p class="text-gray-300"><span class="math">G_{\\alpha}(Y)</span> <span class="math">:=Q_{a}(Y,\\alpha)A^{<em>}(Y,\\alpha)+Q_{b}(Y,\\alpha)B^{</em>}(Y,\\alpha)</span> <span class="math">\\quad+Q_{ab}(Y,\\alpha)A^{<em>}(Y,\\alpha)B^{</em>}(Y,\\alpha)</span> <span class="math">\\quad+Q_{o}(Y,\\alpha)O^{<em>}(Y,\\alpha)+Q_{c}(Y,\\alpha)</span> <span class="math">P_{0,\\alpha}(Y)</span> <span class="math">:=L_{0}(\\alpha)(Z^{</em>}(Y,\\alpha)-1)</span> <span class="math">P_{1,\\alpha}(Y)</span> <span class="math">:=(1-L_{T-1}(\\alpha))</span> <span class="math">\\quad\\cdot\\left(Z^{<em>}(Y,\\alpha)F_{\\alpha}(Y)-Z^{</em>}_{\\alpha,\\mathtt{nat}}(Y)F^{\\prime}_{\\alpha}(Y)\\right)</span> <span class="math">P_{2,\\alpha}(Y)</span> <span class="math">:=R_{0}(Y)(W^{<em>}(Y)-1)</span> <span class="math">P_{3,\\alpha}(Y)</span> <span class="math">:=L_{T-1}(\\alpha)\\left(W^{</em>}(Y)Z^{<em>}(Y,\\alpha)F_{\\alpha}(Y)\\right.</span> <span class="math">\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad</span> <span class="math">\\quad-\\ W^{</em>}(\\omega_{Y}Y)F^{\\prime}_{\\alpha}(Y))</span> <span class="math">F_{\\alpha}(Y)</span> <span class="math">:=\\prod_{S\\in\\{A^{<em>},B^{</em>},O^{<em>}\\}}\\left(S(Y,\\alpha)+\\eta_{Y}\\sigma_{Y,s}(Y,\\alpha)\\right.</span> <span class="math">\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad</span> <span class="math">\\quad+\\eta_{X}\\sigma_{X,s}(Y,\\alpha)+\\gamma)</span> <span class="math">F^{\\prime}_{\\alpha}(Y)</span> <span class="math">:=\\prod_{S\\in\\{A^{</em>},B^{<em>},O^{</em>}\\}}\\left(S(Y,\\alpha)+\\eta_{Y}Y+\\eta_{X}k_{s}\\alpha+\\gamma\\right)</span> (24)</p>

    <p class="text-gray-300">such that</p>

    <p class="text-gray-300"><span class="math">Q_{0}(Y)=\\left(Y^{M}-1\\right)H_{Y,\\alpha}(Y)</span> (25)</p>

    <p class="text-gray-300">which means, for <span class="math">0\\leq i&lt;M</span>, <span class="math">Q(\\omega_{Y}^{i})=0</span>. From the form of <span class="math">F\\in\\{A^{<em>},B^{</em>},O^{<em>},Z^{</em>},H_{X}\\}</span>, <span class="math">F(Y,X)=\\sum_{i=0}^{M-1}f_{i}(X)R_{i}(Y)</span> and <span class="math">W^{<em>}(Y)=\\sum_{i=0}^{M-1}w_{i}^{</em>}R_{i}(Y)</span>, we know that for <span class="math">0\\leq i&lt;M</span> after assigning the value <span class="math">a_{i}^{<em>}(\\alpha),b_{i}^{</em>}(\\alpha),o_{i}^{<em>}(\\alpha),z_{i}^{</em>}(\\alpha),z_{i}^{*}(\\omega_{X}\\alpha)</span> and <span class="math">w_{i}</span> to the corresponding polynomials of <span class="math">Y</span> in Equation 24, we will derive <span class="math">q_{0,i}=Q_{0}(\\omega_{Y}^{i})=0</span>.</p>

    <p class="text-gray-300">In the following rounds, we go through the proof for <span class="math">0\\leq i&lt;M</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the round after <span class="math">\\mathcal{V}</span> sends <span class="math">\\alpha</span> to <span class="math">\\mathcal{P}</span>. Since <span class="math">\\mathcal{V}^{<em>}</span> has oracles for all polynomials, before sending <span class="math">\\alpha</span> to <span class="math">\\mathcal{P}^{</em>}</span>, which is equivalent to have oracles of <span class="math">s_{i}(X)\\in(a_{i}^{<em>}(X),b_{i}^{</em>}(X),c_{i}^{<em>}(X),z_{i}^{</em>}(X),h_{X,i}(X))</span> since <span class="math">s_{i}(r)=S(\\omega_{Y}^{i},r)</span>. In addition, <span class="math">\\mathcal{V}</span> has the oracle <span class="math">W(Y)</span> from which he can query <span class="math">w_{i}=W(\\omega_{Y}^{i})</span>. Again from the Schwartz–Zippel Lemma, there exists <span class="math">q_{i}(X):=g_{i}(X)+\\lambda p_{i,0}(X)+\\lambda^{2}p_{i,1}(X)+\\lambda^{4}p_{i,3}(X)</span>, where</li>

    </ol>

    <p class="text-gray-300"><span class="math">g_{i}(X)</span> <span class="math">:=q_{a,i}(X)a_{i}^{<em>}(X)+q_{b,i}(X)b_{i}^{</em>}(X)+q_{c,i}(X)</span> <span class="math">\\quad+q_{ab,i}(X)a_{i}^{<em>}(X)b_{i}^{</em>}(X)+q_{o,i}(X)o_{i}^{<em>}(X)</span> <span class="math">p_{0,i}(X)</span> <span class="math">:=L_{0}(X)(z_{i}^{</em>}(X)-1)</span> <span class="math">p_{1,i}(X)</span> <span class="math">:=(1-L_{T-1}(X))</span> <span class="math">\\quad\\cdot(z_{i}^{<em>}(X)f_{i}(X)-z_{i}^{</em>}(\\omega_{X}X)f^{\\prime}_{i}(X))</span> <span class="math">p_{3,i}(X)</span> <span class="math">:=L_{T-1}(X)\\left(w_{i}z_{i}^{<em>}(X)f_{i}(X)-w_{i+1}f^{\\prime}_{i}(X)\\right)</span> <span class="math">f_{i}(X)</span> <span class="math">:=\\prod_{s\\in\\{a^{</em>},b^{<em>},o^{</em>}\\}}\\left(s_{i}(X)+\\eta_{Y}\\omega_{Y}^{i}\\right.</span> <span class="math">\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad\\qquad</span> <span class="math">\\quad+\\eta_{X}\\sigma_{X,s,i}(X)+\\gamma)</span> <span class="math">f^{\\prime}_{i}(X)</span> <span class="math">:=\\prod_{s\\in\\{a^{<em>},b^{</em>},o^{*}\\}}\\left(s_{i}(X)+\\eta_{Y}\\omega_{Y}^{i}+\\eta_{X}k_{s}X+\\gamma\\right)</span> (26)</p>

    <p class="text-gray-300">such that</p>

    <p class="text-gray-300"><span class="math">q_{i}(X)=\\left(X^{T}-1\\right)h_{X,i}(X)</span> (27)</p>

    <p class="text-gray-300">which means, for <span class="math">0\\leq i&lt;M</span>, <span class="math">Q(\\omega_{Y}^{i})=0</span>. From the form of <span class="math">f\\in\\{a^{<em>},b^{</em>},o^{<em>},z^{</em>},h_{X}\\}</span>, <span class="math">f_{i}(Y,X)=\\sum_{j=0}^{T-1}f_{i,j}L_{j}(X)</span>, we know that for <span class="math">0\\leq j&lt;T</span> after assigning the value <span class="math">a^{<em>}_{i,j},b^{</em>}_{i,j},o^{<em>}_{i,j},z^{</em>}_{i,j},z^{*}_{i,j+1}</span> to the corresponding polynomials of <span class="math">X</span> in Equation 26, we will derive <span class="math">q_{i,j}=q_{i}(\\omega_{X}^{j})=0</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the round after <span class="math">\\mathcal{V}</span> sends <span class="math">\\gamma</span> to <span class="math">\\mathcal{P}^{<em>}</span>, since <span class="math">\\mathcal{V}^{</em>}</span> has received oracles <span class="math">\\left(a_{i}^{<em>}(X),b_{i}^{</em>}(X),c_{i}^{<em>}(X),z_{i}^{</em>}(X),w_{i}^{<em>},w_{i+1}^{</em>}\\right)</span> before sending <span class="math">\\lambda</span> to <span class="math">\\mathcal{P}</span>, from Schwartz–Zippel Lemma, it implies for each <span class="math">0\\leq j&lt;T</span>, <span class="math">g_{i}(\\omega_{X}^{j})=p_{0,i}(\\omega_{X}^{j})=p_{1,i}(\\omega_{X}^{j})=p_{2,i}(\\omega_{X}^{j})=0</span>.</li>

    </ol>

    <p class="text-gray-300">After combine the claims for <span class="math">0\\leq i&lt;M</span>, it implies <span class="math">(\\mathbf{a}^{<em>},\\mathbf{b}^{</em>},\\mathbf{c}^{*})\\in(\\mathbb{F}^{M\\times T},\\mathbb{F}^{M\\times T},\\mathbb{F}^{M\\times T})</span> is a valid witness for gate constraints. From the constraints related to <span class="math">\\mathcal{Z}</span> and <span class="math">W</span>, suppose <span class="math">(\\sigma_{Y,i,j},\\sigma_{X,i,j})</span> correctly describe the permutation cycles similar to the permutation cycles in Plonk, we prove the argument that</p>

    <p class="text-gray-300">\\[ \\left\\{\\begin{array}[]{l}(a_{i,j},\\sigma_{Y,a,i,j},\\sigma_{X,a,i,j})\\\\ (b_{i,j},\\sigma_{Y,b,i,j},\\sigma_{X,b,i,j})\\\\ (o_{i,j},\\sigma_{Y,o,i,j},\\sigma_{X,o,i,j})\\end{array}\\right\\}=\\left\\{\\begin{array}[]{l}(a_{i,j},\\omega_{Y}^{i},k_{a}\\omega_{X}^{j})\\\\ (b_{i,j},\\omega_{Y}^{i},k_{b}\\omega_{X}^{j})\\\\ (o_{i,j},\\omega_{Y}^{i},k_{o}\\omega_{X}^{j})\\end{array}\\right\\} \\]</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Therefore, <span class="math">(\\mathbf{a}^{<em>},\\mathbf{b}^{</em>},\\mathbf{c}^{<em>})\\in(\\mathbb{F}^{M\\times T},\\mathbb{F}^{M\\times T},\\mathbb{F}^{M\\times T})</span> also satisfies the copy constraints which is equivalent to the copy constraints in original Plonk. The possibility <span class="math">\\mathcal{P}^{</em>}</span> successfully cheats <span class="math">\\mathcal{V}</span> is bounded by $\\frac{5M+5T+O(1)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{P}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-47" class="text-2xl font-bold">Appendix B Proof of Theorem 5</h2>

    <h6 id="sec-48" class="text-base font-medium mt-4">Theorem 5.</h6>

    <p class="text-gray-300">For a data-parallel circuit <span class="math">C</span> consisting of <span class="math">M</span> independent sub-circuits, there exists an RCPS scheme with completeness, witness-extended emulation, partial correctness, and partial witness-extended emulation.</p>

    <p class="text-gray-300">We prove this theorem by first utilizing Protocol 3 in a data-parallel setting to implement RCPS and subsequently demonstrating that the instantiation possesses the witness-extended emulation property.</p>

    <p class="text-gray-300">Implementation. To achieve the robustness, we redefine the circuit <span class="math">C</span> by replacing the Equation 12 with the following equation:</p>

    <p class="text-gray-300"><span class="math">b(Y)\\cdot</span> <span class="math">\\left(G(Y,X)+\\lambda P_{0}(Y,X)+\\lambda^{2}P_{1}(Y,X)\\right.</span> (28) <span class="math">-</span> <span class="math">\\left.V_{X}(X)H_{X}(Y,X)\\right)=V_{Y}(Y)H_{Y}(Y,X)</span></p>

    <p class="text-gray-300">where <span class="math">b(Y)=\\sum_{i=0}^{M-1}b_{i}R_{i}(Y)</span>, with <span class="math">b_{i}</span> denoting whether <span class="math">\\mathcal{P}_{i}</span> generates the correct sub-proof or not. We implement the functionalities in Definition 4 as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}\\left(1^{\\lambda}\\right)\\rightarrow\\mathsf{pp}</span>: run DKZG.KeyGen<span class="math">(1^{\\lambda},M_{\\mathsf{max}},T_{\\mathsf{max}})</span> and generate all bases needed for creating and verifying polynomial commitments.</li>

      <li><span class="math">\\mathsf{SplitCircuit}\\left(C,M\\right)\\rightarrow\\mathcal{C}=(C_{0},\\ldots,C_{M-1})</span>: split <span class="math">C</span> into <span class="math">M</span> independent sub-circuits, denoted as <span class="math">C_{0},\\ldots,C_{M-1}</span>.</li>

    </ul>

    <p class="text-gray-300">Define the circuit <span class="math">C_{\\mathsf{IPA}}</span> computing the inner product between <span class="math">\\mathbf{G}</span> and <span class="math">\\mathbf{F}</span>, where <span class="math">\\mathbf{G}\\in\\mathbb{G}^{M}</span> and <span class="math">\\mathbf{F}\\in\\mathbb{F}^{M}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{MasterKeyGen}\\left(\\mathcal{C},M,\\mathsf{pp}\\right)\\rightarrow(\\mathsf{mpk},\\mathsf{vk})</span>: call DKZG.Commit<span class="math">(S,\\mathsf{pp})</span> to compute <span class="math">\\{(\\mathsf{com}_{S},\\mathsf{com}_{s_{i}})\\}_{s\\in\\mathcal{S}_{\\mathsf{pp}}}</span>. We choose a SNARK protocol to prove <span class="math">C_{\\mathsf{IPA}}</span>, with key pair <span class="math">(\\mathsf{pk}_{\\mathsf{IPA}},\\mathsf{vk}_{\\mathsf{IPA}})</span>. A candidate SNARK is the inner product argument in <em>[22]</em>. We define <span class="math">\\mathsf{mpk}=\\left(\\left(\\mathsf{com}_{s_{i}}\\right)\\mathop{\\scriptstyle s\\in\\mathcal{S}_{\\mathsf{pp}}}\\limits_{0\\leq i&lt;M}.\\mathsf{pp},\\mathsf{pk}_{\\mathsf{IPA}}\\right)</span>. Run key generation and preprocessing procedure from Protocol 3 to compute <span class="math">\\mathsf{vk}</span> and include <span class="math">\\mathsf{vk}_{\\mathsf{IPA}}</span> in it.</li>

      <li><span class="math">\\mathsf{KeyGen}_{i}\\left(C_{i},\\mathsf{mpk}\\right)\\rightarrow\\mathsf{pk}_{i}</span>: generate <span class="math">\\mathsf{pk}_{i}</span> for <span class="math">\\mathcal{P}_{i}</span> following the key generation and preprocessing procedure in Protocol 3.</li>

      <li><span class="math">\\mathsf{SplitInstance}\\left(C,\\mathbb{x}\\right)\\rightarrow\\left((\\mathbb{x}_{0},\\mathbb{x}_{0}),\\ldots,(\\mathbb{x}_{M-1},\\mathbb{x}_{M-1})\\right)</span>: each prover <span class="math">\\mathcal{P}_{i}</span> holds the instance-witness pair <span class="math">(\\mathbb{x}_{i},\\mathbb{x}_{i})</span> in <span class="math">C_{i}</span>.</li>

      <li><span class="math">\\mathsf{CoProve}_{i}\\left(\\mathbb{x}_{i},\\mathbb{x}_{i},\\mathsf{pk}_{i}\\right)\\rightarrow(\\pi_{0}^{(i)},b_{i})</span>: follow Protocol 3 from Step 1 to Step 4.</li>

      <li><span class="math">\\mathsf{TestAndMerge}\\left(\\mathbb{x},\\mathsf{mpk}\\right)\\rightarrow\\mathbf{b}\\in\\{1,0\\}</span>:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Execute from Step 1 to Step 3 in the proving procedure in Protocol 3 between <span class="math">\\mathcal{P}_{0}</span> and other nodes. However in each step, instead of computing <span class="math">\\mathsf{com}_{S}</span> directly for <span class="math">S\\in\\mathcal{S}_{\\mathsf{wit}}</span> and <span class="math">H_{X}</span> generated in the current step, <span class="math">\\mathcal{P}_{0}</span> defines <span class="math">\\mathbf{G}_{s}=(\\mathsf{com}_{s_{i}})_{0\\leq i&lt;M}</span> and commits each of them with <span class="math">\\mathsf{pk}_{\\mathsf{IPA}}</span> and send to <span class="math">\\mathcal{V}</span>.</li>

      <li>Execute Step 4 in the proving procedure in Protocol 3. Then <span class="math">\\mathcal{P}_{0}</span> needs to check whether the other nodes have sent malicious proof. Since <span class="math">\\mathcal{P}_{0}</span> has received the commitments <span class="math">(\\mathsf{com}_{s_{i}})_{0\\leq i&lt;M}</span> for each <span class="math">s\\in\\mathcal{S}_{\\mathsf{wit}}\\cup\\{h_{X,0},h_{X,1},h_{X,2}\\}</span> when distributively committing polynomials, and the corresponding evaluations <span class="math">\\{s_{i}(\\alpha)\\}</span> and opening proof <span class="math">\\left\\{\\pi_{0,s}^{(i)}\\right\\}</span> when distributively opening the polynomials with <span class="math">\\alpha</span>, <span class="math">\\mathcal{P}_{0}</span> can verify Equation 1, Equation 14, Equation 15, Equation 16, Equation 17 with evaluations and the following paring check:</li>

    </ol>

    <p class="text-gray-300"><span class="math">e(\\mathsf{com}_{s_{i}}/g^{s_{i}(\\alpha)},g)\\stackrel{{\\scriptstyle?}}{{=}}e(\\pi_{0,s}^{(i)},g^{s_{X}-\\alpha})</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{0}</span> sets the vector <span class="math">\\mathbf{b}</span> with <span class="math">b_{i}=1</span> if the check above is passed and <span class="math">b_{i}=0</span> otherwise. Then <span class="math">\\mathcal{P}_{0}</span> sends <span class="math">\\mathbf{b}</span> to <span class="math">\\mathcal{V}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define <span class="math">\\bar{S}=\\sum_{i=0}^{M-1}b_{i}s_{i}(X)R_{i}(Y)</span> for <span class="math">S\\in\\mathcal{S}_{\\mathsf{wit}}\\cup\\{H_{X}\\}</span>. <span class="math">\\mathcal{P}_{0}</span> computes <span class="math">\\mathsf{com}_{\\bar{S}}=\\langle\\mathsf{G}_{s},\\mathbf{b}\\rangle</span> for each <span class="math">s\\in\\mathcal{S}_{\\mathsf{wit}}\\cup\\{H_{X}\\}</span>, generates proofs according to <span class="math">C_{\\mathsf{IPA}}</span> and sends them to <span class="math">\\mathcal{V}</span>.</li>

      <li>Execute Step 5 with redefined <span class="math">\\mathcal{S}_{\\mathsf{wit}}=\\left\\{\\bar{A},\\bar{B},\\bar{O},\\bar{Z}\\right\\}</span> and <span class="math">\\bar{H_{X}}</span>.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Verify}\\left(\\mathbb{x},\\mathsf{vk}\\right)\\rightarrow\\{1,0\\}</span>: After Step 4, <span class="math">\\mathcal{V}</span> verifies the correctness of <span class="math">C_{\\mathsf{IPA}}</span> applied on each <span class="math">G_{s}</span> for <span class="math">s\\in\\mathcal{S}_{\\mathsf{wit}}\\cup\\{H_{X}\\}</span>. Then <span class="math">\\mathcal{V}</span> runs the verification procedure in Protocol 3 with redefined <span class="math">\\mathcal{S}_{\\mathsf{wit}}\\cup\\{H_{X}\\}</span>.</li>

    </ul>

    <p class="text-gray-300">Proof sketch. Completeness is inherited from Protocol 3 as proven in Theorem 4 and the completeness of the SNARK protocol for IPA. Partial correctness is straightforward. Consequently, we only need to prove the partial witness-extended emulation and the witness-extended emulation.</p>

    <p class="text-gray-300">Lemma 1.</p>

    <p class="text-gray-300">The protocol given above has the property of partial witness-extended emulation.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We note that the underlying polynomial IOP is derived from the constraints in Equation 1, Equation 4, and Equation 5, compiled with a variant of KZG protocol. As a result, we follow the same framework used in the proof for Theorem 2.</p>

    <p class="text-gray-300">The knowledge error in the IOP. By replacing <span class="math">\\mathcal{V}</span> with <span class="math">\\mathcal{P}_{0}</span>, we claim that the second part of the proof in Appendix A, which argues for <span class="math">0\\leq i&lt;M</span>, provides evidence of the knowledge error in this implementation.</p>

    <p class="text-gray-300">The knowledge soundness of PCS. We observe that the PCS scheme between <span class="math">\\mathcal{P}_{i}</span> and <span class="math">\\mathcal{P}_{0}</span> is a variant of the KZG protocol, with <span class="math">\\mathsf{pp}=\\left(g^{R_{i}(\\tau_{Y})L_{j}(\\tau_{X})}\\right)0\\leq j&lt;T</span> instead of <span class="math">\\left(g^{L_{i}(\\tau_{X})}\\right)</span> for the standard KZG protocol with <span class="math">\\mathsf{pp}</span> in the Lagrange basis. To prove the knowledge soundness of the KZG variant, we proceed as follows: assuming <span class="math">\\mathsf{pp}=\\left(g^{L_{j}(\\tau_{X})}\\right)0\\leq j&lt;T</span>, the adversary <span class="math">\\mathcal{A}</span> for the KZG protocol generates <span class="math">z^{<em>},\\mathbf{x}^{</em>},\\mathsf{com}^{<em>},\\pi^{</em>}</span>. Then, <span class="math">\\mathcal{A}</span> creates <span class="math">\\mathsf{pp}^{\\prime}=\\left(g^{R_{i}(\\tau_{Y})L_{J}(\\tau_{X})}\\right)</span> for the KZG variant using a randomly sampled <span class="math">\\tau_{Y}</span>. If an extractor <span class="math">\\mathcal{E}^{\\mathcal{A}^{\\prime}(\\cdot)}(1^{\\lambda},\\mathsf{pp}^{\\prime})</span> can successfully compute <span class="math">f^{<em>}</span> such that <span class="math">f^{</em>}(\\mathbf{x}^{<em>})=z^{</em>}</span>, we can construct <span class="math">\\mathcal{E}^{\\mathcal{A}(\\cdot)}(1^{\\lambda},\\mathsf{pp})</span> by invoking <span class="math">\\mathcal{E}^{\\prime}</span> and returning <span class="math">f^{*}</span>. Therefore, we proved that the KZG variant also has knowledge soundness. ∎</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">The protocol given above has the property of witness-extended emulation.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Proof sketch.</h6>

    <p class="text-gray-300">From the knowledge soundness of the SNARK protocol for IPA, we can extract <span class="math">(\\mathsf{com}_{s_{i}})</span> for <span class="math">s\\in\\mathcal{S}_{\\mathsf{wt}}\\cup\\{H_{X}\\}</span>. With the completeness of the SNARK protocol, we guarantee that <span class="math">\\mathsf{com}_{\\mathcal{S}}=\\langle\\mathbf{G}_{s},\\mathbf{b}\\rangle</span> with the sub-circuit indicator <span class="math">\\mathbf{b}</span>. Then by going through the similar process as in the the proof of Theorem 5, we can derive the knowledge soundness for the whole protocol. ∎</p>

    <p class="text-gray-300">By combining the completeness and the proof of Lemma 1 and Lemma 2, we can prove Theorem 5.</p>`;
---

<BaseLayout title="Pianist: Scalable zkRollups via Fully Distributed Zero-Knowl... (2023/1271)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/1271
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
