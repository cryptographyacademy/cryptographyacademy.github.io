---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2005/385';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Practical Group Signatures without Random Oracles';
const AUTHORS_HTML = 'Giuseppe Ateniese&lt;sup&gt;∗&lt;/sup&gt; Jan Camenisch† Susan Hohenberger† Breno de Medeiros‡';

const CONTENT = `    <p class="text-gray-300">Giuseppe Ateniese&lt;sup&gt;∗&lt;/sup&gt; Jan Camenisch† Susan Hohenberger† Breno de Medeiros‡</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6"><strong>Abstract</strong></h4>

    <p class="text-gray-300">We provide a construction for a group signature scheme that is provably secure in a universally composable framework, within the standard model with trusted parameters. Our proposed scheme is fairly simple and its efficiency falls within small factors of the most efficient group signature schemes with provable security in any model (including random oracles). Security of our constructions require new cryptographic assumptions, namely the Strong LRSW, EDH, and Strong SXDH assumptions. Evidence for any assumption we introduce is provided by proving hardness in the generic group model.</p>

    <p class="text-gray-300">Our second contribution is the first definition of security for group signatures based on the simulatability of real protocol executions in an ideal setting that captures the basic properties of unforgeability, anonymity, unlinkability, and exculpability for group signature schemes.</p>

    <h2 id="sec-2" class="text-2xl font-bold"><strong>1 Introduction</strong></h2>

    <p class="text-gray-300">Group signature schemes, introduced by Chaum and van Heyst [23], allow a member of a user group to sign anonymously on behalf of the group, where a user's anonymity may be revoked by a designated group manager, in case of disputes.</p>

    <p class="text-gray-300">The motivation of this paper is twofold. Our first motivation is to build a practical group signature scheme provably secure under standard assumptions, in particular without resorting to the random oracle model. Prior to this work, there was no group signature scheme known achieving this (with the exception of the recent scheme by Boyen-Waters [16] which, however, fails to meet all required properties–we will later discuss their scheme in more detail).</p>

    <p class="text-gray-300">In this paper, we present a full group signature scheme provably secure under new number-theoretic assumptions. Now, one might say that we trade the &quot;assumption&quot; that the Fiat-Shamir heuristic works with proof of knowledge protocols for discrete logarithms (e.g., such as the Schnorr signature scheme) with other possibly false assumptions. However, while one will probably never be able to prove that the Fiat-Shamir heuristic is reasonable for some cases (on the contrary, many cases are known for which it is unreasonable [33]), our new assumptions are algebraic and hence naturally much easier to analyze. Indeed, as a first step towards their justification, we prove that they hold in the generic group model [40, 46]. We hasten to point out that one can of course prove assumptions hard in the generic group model that are not hard against an algebraically unrestricted adversary, and that the generic group model has some of the same faults as random oracles [27]. Rather, a proof in the generic model should be considered a sanity check for an complexity assumption.</p>

    <p class="text-gray-300">In the light of the quest for a group signature scheme provably secure in the standard model, one can view both schemes, the Boyen-Waters one and ours, as first steps in this direction. The Boyen-Waters scheme uses</p>

    <p class="text-gray-300">&lt;sup&gt;∗&lt;/sup&gt;Dept. of Computer Science; The Johns Hopkins University; 3400 N. Charles Street; Baltimore, MD 21218, USA.</p>

    <p class="text-gray-300">&lt;sup&gt;†&lt;/sup&gt; IBM Research; Zurich Research Laboratory; Saumerstrasse 4, CH-8803 R ¨ uschlikon, Switzerland. ¨</p>

    <p class="text-gray-300">&lt;sup&gt;‡&lt;/sup&gt;Dept of Computer Science; Florida State University; 105-D James Love Bldg Tallahassee; FL 32306-4530 USA.</p>

    <p class="text-gray-300">somewhat less complicated assumptions, but sacrifies some desirable properties while our scheme captures these properties but makes more involved assumptions.</p>

    <p class="text-gray-300">The second motivation of this paper is the definition of security in the reactive security or universally composablility model [8, 42, 22, 43]. Let us expand here. The security of early schemes was defined in terms of whether they satisfied a number of independent properties, and lacked a comprehensive view of adversarial behavior. Indeed, as initially the set of features considered was insufficient, some proposed schemes were subsequently broken. An important realization was the requirement that membership certificates be the equivalent of group manager signatures, in order to prevent against attacks by arbitrary group member coalitions [5]. Later, Bellare, Micciancio, and Warinschi [9] (BMW) introduced a security formalism based on adversarial games that combined the several requirements of previous works into fewer ones (namely, traceability and anonymity). However, the BMW formalization relies on the existence of a (trusted) keyissuing entity that generates all keys in the system and distributes them to the group manager and group members. As argued by Kiayias and Yung [36], BMW models a <em>weaker</em> primitive than the group signatures proposed by Chaum and van Heyst, since assuming a &quot;tamper-proof&quot; key setup conflicts with the goals of many practical schemes. The BMW model has been extensively adapted (via incorporating exculpability, changing the proof model to the random oracle setting and/or to dynamic groups) to allow for security proofs of recently proposed group signature schemes, e.g., works by Boneh et al. [13] and Camenisch and Lysyanskaya [19].</p>

    <p class="text-gray-300">The first formal model to apply to the case of dynamic groups was introduced by Kiayias et al. [36, 35]. The formalization works in the random oracle model, not the standard model, but it captures closely the security requirements of practical group signatures, and it can be readily applied to formally prove the security of practical schemes. Indeed, [36] includes a security proof of a variant of the Ateniese et al. scheme [4]. More recently, Bellare, Shi, and Zhang [11] have proposed a standard-model formalism for dynamic groups, and constructed theoretical schemes based on black-box zero-knowledge primitives.</p>

    <p class="text-gray-300">Simultaneously with this evolution of understanding in group signatures was the development of the universally composable (UC)/reactive framework [8, 42, 22, 43]. The UC/reactive framework enables proofs of security of protocols that are valid under concurrent execution and in composition with other arbitrary protocols. It has been shown that this framework is more powerful than a property based definitional approach as it captures all properties at the same time. Indeed, examples are known of schemes that satisfy a property based defintion (i.e., each property individually) but not a UC/reactive framework definition that requires the fullfilment of all the properties at the same time [22].</p>

    <p class="text-gray-300">To date, it remained an open problem to introduce a UC/reactive security model for group signatures. We introduce this definition in Section 2. It was carefully constructed to incorporate the original vision of Chaum and van Heyst and its subsequent developments. Our definition implies many of the guarantees of prior property-based definitions (e.g., [9, 11, 36, 35]). Two properties that we do not require are: (1) membership revocation, and (2) anonymity even after exposure of a user's secret key (forward anonymity), as in BMW [9]. Regarding point (2), we mean that we provide anonymity only to honest users, i.e., users of which the adversary does not know the secret key of which we believe is sufficient in practise. We emphasize that our model does not require any trusted key-issuing entity and group member secrets are known only to group members.</p>

    <p class="text-gray-300">Note that our results are not in contradiction with the work of Datta et al. [26] on the impossibility of realizing an ideal functionality for group signatures with <em>perfect anonymity</em> (i.e., the probability of guessing the identity of one of two signers is <em>exactly</em> 1/2) and <em>perfect traceability</em> (i.e., the probability of a dishonest group manager violating exculpability is <em>exactly</em> zero). Datta et al. admit that they only consider a strong form of group signature, and indeed, their formulation of group signatures has a single entity generating all</p>

    <p class="text-gray-300">signing keys. They also require that the scheme remain secure even when all public parameters are chosen by a potentially malicious group manager, i.e., they consider UC security in the <em>plain model</em>. In contrast, our definition (and scheme) does not have a key issuing entity and will allow some global parameters to be given to the group manager—e.g., bilinear map parameters. This is sometimes referred to as a UC model with <em>trusted parameters</em>.</p>

    <p class="text-gray-300">We now summarize the contributions of our paper.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8"><strong>1.1 Our Contribution and Comparison with Previous Work</strong></h3>

    <p class="text-gray-300"><strong>Strong security model:</strong> We provide the first definition of security for group signature schemes as an ideal functionality, and provide a construction of a practical and provably secure scheme within the new framework. Static-membership versions of our group signature schemes are secure in the context of composition and concurrent executions. The dynamic-membership version of our group signature scheme is similarly secure, if the join protocol is restricted to sequential execution.</p>

    <p class="text-gray-300"><strong>Better Efficiency:</strong> Our construction is the first in the standard model to provide <em>constant</em> time and space efficiency with respect to the security parameter. Concurrently, and independently from us, Boyen and Waters [16] proposed a scheme provably secure the standard model (under a different definition of security). However, in their scheme the bit length of the signatures and the complexity of the signature and verification algorithms are O((log n) · k), where n is the number of group members and k is the security parameter. In our scheme, all of these complexities will be O((log n) + k), where the (log n) term is there to guarantee that there are enough unique secret keys for each user in the algebraic group. In practice, log n is smaller than k, so our scheme is an O(k) scheme (i.e., constant in the security parameter).</p>

    <p class="text-gray-300"><strong>CCA-anonymity:</strong> Our scheme achieves CCA anonymity, i.e., anonymity holds even when the adversary continually has access to an open oracle (which, when queried on a signature, returns the signer's identity). In constrast, the Boyen-Waters scheme achieves only CPA anonymity, where the adversary is not allowed access to the oracle after receiving the challenge signature. Similarly as CCA security is the de facto requirement for encryption schemes, we believe this is a vital property for group signatures.</p>

    <p class="text-gray-300"><strong>Strong exculpability:</strong> We achieve exculpability, an important property originally proposed by Chaum and van Heyst. In our scheme, a user's secret key is chosen by the user, and we prove that group managers cannot sign on behalf of honest users. The Boyen-Waters scheme lacks (strong) exculpability of users: In their scheme, a trusted key-issuing entity generates and distributes users' secret keys. Thus, this entity can sign messages on behalf of the user, and thus holding users <em>accountable</em> for any misbehavior is difficult.</p>

    <p class="text-gray-300"><strong>Forward security:</strong> Our scheme does not achieve forward anonymity as defined in BMW [9] under the full anonymity property where members remain untraceable even if their secret keys are exposed, but only ordinary anonymity. The Boyen and Waters scheme does achieve forward anonymity.</p>

    <p class="text-gray-300"><strong>General setting for bilinear mappings:</strong> We use curves with isomorphism-free paired groups, arguably the most efficient, secure, and versatile setting for pairings-based cryptography (e.g., see Galbraith et. al. [31]). In contrast, the Boyen-Waters scheme is restricted to symmetric bilinear mapping settings (supersingular curves). Even more significantly, their scheme uses elliptic curve groups of composite order, and they require that this order be hard to factor, implying it must be large (1024 bits or larger). Consequently, the representation of every elliptic curve point is similarly large, which heavily impacts the performance of cryptographic operations in these curves, as well as their bandwidth requirements.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">1.2 Overview of the Construction</h4>

    <p class="text-gray-300">We now provide intuition for understanding our construction, described in detail in Section 5. Our group signature scheme has the standard protocols: Setup, Join, GroupSign, GroupVerify, and Open. Let S = (Gen, Sign, Verify) be an efficient signature scheme secure in the standard model. Let the group manager have keypair (GPK, GSK) and a user have keypair (pk, sk), generated according to Gen. Consider the following scheme. During the Join protocol, the group manager gives the user a certificate on her public key:  <span class="math">Sign_{GSK}(pk)</span> . To sign message m as a group member, the user prepends her certificate and public key to her signature:  <span class="math">(Sign_{GSK}(pk), pk, Sign_{sk}(m))</span> . This scheme is clearly unforgeable, but not anonymous. In order to achieve anonymity, the certificate and user's public key must be made unlinkably randomizable, while the signature element must be instantiated using a key-private signature scheme. We actually have the manager and user employ different signature schemes,  <span class="math">S_1</span>  and  <span class="math">S_2</span> .</p>

    <p class="text-gray-300"><span class="math">S_1</span>  is based on the pairing-based signature scheme of Camenisch and Lysyanskaya [19] (CL); Specifically it uses the extension of this scheme (CL&lt;sup&gt;+&lt;/sup&gt;) by Ateniese et al. [3]. Consider a bilinear map (pairing)  <span class="math">e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span> , defined on groups of prime order p, with generators  <span class="math">g, \\tilde{g}, \\hat{g}</span> , respectively. Select random  <span class="math">s, t \\in \\mathbb{Z}_p</span>  and set sk = (s, t) and  <span class="math">pk = (\\tilde{g}^s, \\tilde{g}^t)</span> . To sign a message  <span class="math">m \\in \\mathbb{Z}_p^*</span> , choose random  <span class="math">a \\in \\mathbb{G}_1</span>  and output the tuple  <span class="math">(a, a^t, a^{s+stm}, a^m, a^{mt})</span> . Verify signature (A, B, C, D, E) by checking that:  <span class="math">(1) \\ e(A, \\tilde{g}^t) = e(B, \\tilde{g}), (2) \\ e(D, \\tilde{g}^t) = e(E, \\tilde{g}),</span>  and  <span class="math">(3) \\ e(AE, \\tilde{g}^s) = e(C, \\tilde{g}).</span></p>

    <p class="text-gray-300">The user's certificate is nothing more than a <em>blind</em> CL&lt;sup&gt;+&lt;/sup&gt; signature from the group manager on the user's secret key sk, i.e., the group member signs sk without learning its value, a necessary condition for our scheme to provide exculpability. Fortunately, the CL&lt;sup&gt;+&lt;/sup&gt; signature inherits an efficient blind-signature protocol from the original CL scheme. In the above, we instantiate the elements  <span class="math">(Sign_{GSK}(pk), pk)</span>  with  <span class="math">CL^+_{GSK}(sk) = (a, a^t, a^{s+st(sk)}, a^{sk}, a^{t(sk)})</span> , which is the group manager's signature on sk which can be thought of as including an obfuscated version of the user's public key  <span class="math">(a, a^{sk})</span> . As observed in [3], these signatures can be unlinkably re-randomized by choosing a random  <span class="math">r \\in \\mathbb{Z}_p</span>  and computing  <span class="math">(a^r, a^{tr}, a^{\\{s+st(sk)\\}r}, a^{skr}, a^{t(sk)r})</span> , assuming DDH is hard in  <span class="math">\\mathbb{G}_1</span> . The user may therefore release a random-looking copy of her certificate with each group signature.</p>

    <p class="text-gray-300">We implement  <span class="math">S_2</span>  with a new signature scheme (secure in the standard model) which is based on the weak signatures of Boneh and Boyen [13] (BB). By weak, we mean the Boneh-Boyen signature scheme proven weak message attack secure, where the adversary must submit all challenge messages in advance of learning the public key. The scheme works in a similar pairing setting as the  <span class="math">CL^+</span>  signature. Select a random  <span class="math">sk \\in \\mathbb{Z}_p</span>  and a random generator  <span class="math">g \\in \\mathbb{G}_1</span>  and output  <span class="math">pk = (g, g^{sk})</span> . To sign a message  <span class="math">m \\in \\{0, 1\\}^{\\log |p|}</span> , output  <span class="math">A = \\tilde{g}^{1/(sk+m)}</span> . Verify by checking that  <span class="math">e(q^m pk, A) = e(q, \\tilde{q})</span> .</p>

    <p class="text-gray-300">As a thought experiment, consider our group signature structure using weak BB signatures to implement  <span class="math">S_2</span> . The construction is  <span class="math">(CL_{GSK}^+(sk); BB_{sk}(m)) = (a, a^t, a^{s+st(sk)}, a^{sk}, a^{t(sk)}; \\tilde{g}^{1/(sk+m)}) = (A, B, C, D, E, F)</span> , verifiable by checking the  <span class="math">CL^+</span>  signature first and then testing if  <span class="math">e(DA^m, F) = e(A, \\tilde{g})</span> . Unfortunately, as the BB signatures are deterministic, it will be obvious when the same user signs the same message a second time. This violates our privacy definition, so we modify this basic scheme to provide more privacy and enable longer messages.</p>

    <p class="text-gray-300">In their paper [13], Boneh and Boyen present one method for adapting the weak scheme to longer messages. In this paper, we present another method, which we denote  <span class="math">BB^+</span> , that is more suited to our purposes. To sign a message  <span class="math">m \\in \\mathbb{Z}_p^*</span> , select a random  <span class="math">v \\in \\mathbb{Z}_p</span>  and output the tuple  <span class="math">(g^v, \\tilde{g}^{1/(sk+v)}, \\tilde{g}^{1/(v+m)})</span> . Verify signature triple (A, B, C) by checking that  <span class="math">e(A\\,pk, B) = e(g, \\tilde{g})</span>  and  <span class="math">e(A\\,g^m, C) = e(g, \\tilde{g})</span> . We arrive at the construction  <span class="math">(CL_{GSK}^+(sk); BB_{sk}^+(m))</span> , or more exactly  <span class="math">(a, a^t, a^{s+st(sk)}, a^{sk}, a^{t(sk)}; a^v, \\tilde{g}^{1/(sk+v)}, \\tilde{g}^{1/(v+m)})</span>  for message  <span class="math">m \\in \\mathbb{Z}_p^*</span> , where  <span class="math">a \\in \\mathbb{G}_1</span>  and  <span class="math">v \\in \\mathbb{Z}_p</span>  are randomly chosen for each new signature.</p>

    <p class="text-gray-300">At this point, we have described the entire construction, except for how the Open algorithm works. The</p>

    <p class="text-gray-300">simplest method is for the user to give the group manager a  <span class="math">tracing\\ value\\ \\tilde{g}^{sk}</span>  during the Join protocol. Later, the group manager can open a signature  <span class="math">(a,\\,a^t,\\,a^{s+st(sk)},\\,a^{sk},\\,a^{t(sk)};\\,a^v,\\,\\tilde{g}^{1/(sk+v)},\\,\\tilde{g}^{1/(v+m)})=(A,\\,B,\\,C,\\,D,\\,E;\\,F,\\,G,\\,H)</span>  by testing if  <span class="math">e(A,\\tilde{g}^{sk})=e(D,\\tilde{g})</span>  for each user. Obviously, this algorithm runs linearly in the number of group members. We improve on this result in Section 6, providing two alternative Open algorithms. The first has  <span class="math">O(\\sqrt{n}\\cdot k)</span>  complexity, for membership groups of size n and security parameter k, under the same cryptographic assumptions as the basic scheme. The second reduces to  <span class="math">((\\log n)+k)</span>  under an additional assumption.</p>

    <p class="text-gray-300"><strong>Remark 1.1</strong> (Security under concurrent executions.) The join protocol is the only protocol in our scheme that requires sequential composition for security, because it involves a zero-knowledge proof of knowledge. In Appendix B, we discuss some techniques for securely achieving limited forms of concurrency.</p>

    <p class="text-gray-300"><strong>Remark 1.2</strong> (<strong>Revocation.</strong>) Finding an elegant revocation mechanism is a pervasive problem among group signature schemes. To revoke a user in our scheme, the group manager could publish that user's <em>tracing information</em> obtained during the join protocol. We explore more efficient alternatives in the full version.</p>

    <p class="text-gray-300"><strong>Length of Signatures.</strong> The signatures produced by this scheme are short. In the following comparisons we are going use the NIST suggested equivalence of 80-bit symmetric security with RSA-1024 and 128-bit symmetric security with RSA-3072.  <span class="math">^{1}</span>  For our schemes, we estimate the key sizes from our generic-model security reductions to be 1/3 of the equivalent symmetric key size, i.e., 240 bits for 80-bit symmetric security and 384 bits for 128-bit symmetric security. This 3:1 ratio should be also used to compare schemes based on the q-Strong Diffie Hellman assumption, due to recent results by Cheon [24].</p>

    <p class="text-gray-300">Assuming that the bitlength of elements in  <span class="math">\\mathbb{G}_1</span>  is 241 (an extra bit is needed to indicate the <em>y</em>-coordinate among two options), and that the curves implemented in the MIRACL library are used [44], the basic scheme achieves roughly the same level of security as a 1024-bit RSA signature [13]. For these curves, the bitlengths of elements in  <span class="math">\\mathbb{G}_2</span>  are roughly three times that of  <span class="math">\\mathbb{G}_1</span>  (more precisely 721 bits), and our scheme would take approximately 2888 bits to represent a group signature, comprised of six elements in  <span class="math">\\mathbb{G}_1</span>  and two elements in  <span class="math">\\mathbb{G}_2</span> . If the newer curves of embedding degree 12 are used [7], one could employ 385-bit groups (for 128-bit generic security) to achieve RSA-3072 security equivalence. These new curves have better ratios, with  <span class="math">\\log |\\mathbb{G}_2|/\\log |\\mathbb{G}_1| = 2</span> . In this case, our signatures would take 3848 bits to be represented, about 25% larger than a plain RSA signature with the same security level. As mentioned before, this efficiency is incomparable with that of Boyen and Waters [16], which (1) grow logarithmically with the number of system members and (2) require elliptic curve group orders over a 1000 bits long.</p>

    <p class="text-gray-300">Our scheme can be compared with the most efficient short group signatures secure in the random oracle setting. For instance, the scheme by Boneh, Boyen, and Shacham [13], which achieves only CPA-anonymity, would require about 2163 bits for the RSA-1024 security level (or about 1442 in the MNT setting). &lt;sup&gt;2&lt;/sup&gt; A shorter scheme by Boneh and Shacham [15] requires 1682 bits to achieve RSA-1024 comparable security. &lt;sup&gt;3&lt;/sup&gt;</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 Group Signature Security Definition</h2>

    <p class="text-gray-300"><strong>Notation:</strong> if P is a protocol between parties A and B, then P(A(x), B(y)) denotes that A's input is x and B's input is y.</p>

    <p class="text-gray-300">http://www.nsa.gov/ia/industry/crypto_elliptic_curve.cfm</p>

    <p class="text-gray-300">&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;2&lt;/sup&gt;Their paper provides the value 1533 bits instead of 2163, but this does not take into account the above mentioned results about the concrete security of the q-Strong Diffie-Hellman assumption [24].</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{3}&lt;/sup&gt;</span> Again, this value is larger than the one provided by the authors to account for the concrete security of q-Strong Diffie-Hellman.</p>

    <p class="text-gray-300">A group signature scheme consists of the usual types of players: a group manager GM and a user U&lt;sup&gt;i&lt;/sup&gt; . These players can execute the algorithms: GroupSetup, UserKeyGen, Join, GroupSign, GroupVerify, Open, and VerifyOpen. We now specify the input-output specifications for these algorithms as well as providing some informal intuition for what they do.</p>

    <p class="text-gray-300">Let params be global parameters generated during a setup phase; ideally params is empty.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The GroupSetup(1&lt;sup&gt;k&lt;/sup&gt; , params) algorithm is a key generation algorithm for the group manager GM. It takes as input the security parameter 1 k and outputs the key pair (pkGM, skGM). (Assume that skGM contains the params, so we do not have to give params explicitly to the group manager again.)</li>
      <li>The UserKeyGen(1&lt;sup&gt;k&lt;/sup&gt; , params) algorithm is a key generation algorithm for a group member U, which outputs (pkU, skU). (Assume that sk&lt;sup&gt;U&lt;/sup&gt; contains the params, so we do not have to give params explicitly to the user again.)</li>
      <li>In the Join(U(pkGM, skU), GM(pkU, skGM)) protocol, the user U joins the signatory group managed by GM. The user's output is a personalized group signing credential CU, or an error message. GM's output is some information T&lt;sup&gt;U&lt;/sup&gt; which will allow the group manager to revoke the anonymity of any signatures produced by U. The group manager maintains a database D for this revocation information, to which it adds the record (pkU, TU).</li>
      <li>The GroupSign(skU, CU, m) algorithm allows group members to sign messages. It takes as input the user's secret key skU, the user's signing credential CU, and an arbitrary string m. The output is a group signature σ.</li>
      <li>The GroupVerify(pkGM, m, σ) algorithm allows to publicly verify that σ is a signature on message m generated by some member of the group associated with group public key pkGM.</li>
      <li>The Open(skGM, D, m, σ) algorithm allows the group manager, with skGM and database D, to identify the group member U who was responsible for creating the signature σ on message m. The output is a member identity pk&lt;sup&gt;U&lt;/sup&gt; or an error message.</li>
      <li>In the VerifyOpen(GM(skGM, D, m, σ, pk), V(pkGM, m, σ, pk)) protocol, GM convinces a verifier that the user with public key pk was responsible for creating the signature σ on message m. The verifier outputs either 1 (accept) or 0 (reject).</li>
    </ul>

    <p class="text-gray-300">In addition to supporting the above algorithms, a group signature scheme must also be <em>correct</em> and <em>secure</em>. Correctness is fairly straightforward. Informally, if an honest user runs Join with an honest group manager, then neither will output an error message. If an honest user runs GroupSign, then the output will be accepted by an honest verifier running GroupVerify. If a signature passes GroupVerify and a honest manager runs Open, then the result will be accepted by an honest verifier running VerifyOpen.</p>

    <h2 id="sec-6" class="text-2xl font-bold"><strong>2.1 The Group Signature Ideal Functionality,</strong> Fgs</h2>

    <p class="text-gray-300">Our security model uses the ideal/real world model as in multiparty computation [20, 21, 22] and reactive systems [42, 43] to capture the security properties of group signatures in a single definition.</p>

    <p class="text-gray-300">In the real world, there are a number of parties who together execute some cryptographic protocol. A number of these parties may be corrupted by the adversary A (all corrupted parties are combined into this single adversary). Each party receives its input and reports its output to the environment Z. The environment Z and the adversary A may arbitrarily interact. In the ideal world, we have the same parties. As before, each party receives its input and reports its output to the environment. However, instead of running a cryptographic protocol, the parties provide their inputs to and receive their outputs from a trusted party T . The specification for how T behaves is formalized as an ideal functionality.</p>

    <p class="text-gray-300">We say that a cryptographic protocol securely implements an ideal functionality if for every real-world adversary A and every environment Z, there exists a simulator S, which controls the same parties in the ideal world as A does in the real world, such that Z cannot distinguish whether it is interacting in the real world with A or in the ideal world with S.</p>

    <p class="text-gray-300"><strong>Group Signature Ideal Functionality.</strong> We now describe Fgs. In addition to the environment Z, we have two types of players: a group manager GM and users U&lt;sup&gt;i&lt;/sup&gt; . We work in the <em>non-adaptive</em> setting.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Non-adaptive Setup: Each user U&lt;sup&gt;i&lt;/sup&gt; tells the functionality Fgs whether or not it is corrupted. Optionally, in this stage the global parameters are broadcast to all parties.</li>
      <li>GroupSetup: Upon receiving (GM, &quot;group setup&quot;) from GM, send to S tuple (GM, &quot;group setup&quot;).</li>
      <li>UserKeyGen: Similarly, upon receiving (U&lt;sup&gt;i&lt;/sup&gt; , &quot;keygen&quot;) from U&lt;sup&gt;i&lt;/sup&gt; inform S.</li>
      <li>Join: Upon receiving (U&lt;sup&gt;i&lt;/sup&gt; , &quot;enroll&quot;) from U&lt;sup&gt;i&lt;/sup&gt; , ask the group manager GM if U&lt;sup&gt;i&lt;/sup&gt; may join the group. The GM responds with res&lt;sup&gt;i&lt;/sup&gt; ∈ {0, 1}. Record the pair (U&lt;sup&gt;i&lt;/sup&gt; , resi) in database D and return res&lt;sup&gt;i&lt;/sup&gt; to U&lt;sup&gt;i&lt;/sup&gt; . Additionally, if the group manager is corrupted, then register a special user corrupt-GM.</li>
      <li>GroupSign: Upon receiving (U&lt;sup&gt;i&lt;/sup&gt; , &quot;sign&quot;, m), where m is an arbitrary string, check that U&lt;sup&gt;i&lt;/sup&gt; is a valid member of the group by checking that the entry for U&lt;sup&gt;i&lt;/sup&gt; in D has res&lt;sup&gt;i&lt;/sup&gt; = 1. If not, deny the command. Otherwise, tell the simulator S that GroupSign has been envoked on message m. If the GM is corrupted, also tell the simulator the identity U&lt;sup&gt;i&lt;/sup&gt; . Ask S for a signature index id. Record the entry (U&lt;sup&gt;i&lt;/sup&gt; , m, id) in database L and return the value id to U&lt;sup&gt;i&lt;/sup&gt; .</li>
      <li>GroupVerify: Upon receiving (U&lt;sup&gt;i&lt;/sup&gt; , &quot;verify&quot;, m, id) from U&lt;sup&gt;i&lt;/sup&gt; (or GM), search database L for an entry containing message m, and if one exists, return 1. Otherwise, return 0.</li>
      <li>Open: This ideal operation combines both the Open and VerifyOpen cryptographic protocols. Upon receiving (U&lt;sup&gt;i&lt;/sup&gt; , &quot;open&quot;, m, id) from U&lt;sup&gt;i&lt;/sup&gt; , search database L for an entry (U&lt;sup&gt;j&lt;/sup&gt; , m, id) for any U&lt;sup&gt;j&lt;/sup&gt; . Ask GM if it will allow Fgs to open id for user U&lt;sup&gt;i&lt;/sup&gt; . If GM agrees and U&lt;sup&gt;j&lt;/sup&gt; 6= corrupt-GM, then output the identity U&lt;sup&gt;j&lt;/sup&gt; . Otherwise, output ⊥.</li>
    </ul>

    <p class="text-gray-300">Let us provide some intuition for understanding this model. Informally, the properties that we capture are unforgeability, anonymity, and exculpability. This definition is general enough to capture unforgeability under adaptive chosen message attack [34] without <em>requiring</em> schemes to be <em>strongly</em> unforgeable [2]. In a strongly unforgeable scheme, a new signature on a previously signed message is considered a forgery; while in the standard notion, a forgery must be on a new message.</p>

    <p class="text-gray-300">The definition also captures the important exculpability property (i.e., even a rogue group manager cannot frame an honest user). Indeed, the environment Z may instruct a user to sign any messages of its choosing and may interact freely with the adversary A. Our model, however, enforces that unless an honest user U&lt;sup&gt;i&lt;/sup&gt; requested a signature on m (i.e., sent (&quot;sign&quot;, m) to Fgs), then for all values of id, the Open command on (U&lt;sup&gt;i&lt;/sup&gt; , m, id) will return ⊥.</p>

    <p class="text-gray-300">Furthermore, there is a strong anonymity guarantee for a user: unless the group manager is corrupted, the users remain anonymous. When the group manager is honest, the simulator must create signatures for A knowing only the message contents, but not the identity of the honest user.</p>

    <p class="text-gray-300">Finally, the definition ensures that, whenever the group manager is honest, he will be able to open all group signatures. During the Open command, Fgs only asks S for permission to execute the opening if the group manager is corrupted. Thus, if a user honestly runs the verification algorithm and accepts a signature as valid, then this user may be confident that an honest GM will later be able to open it, reveal the identity of the original signer, and prove this to the user.</p>

    <p class="text-gray-300">The above definition does not define membership revocation. However, it is not difficult to extend Fgs to address revocation, and we plan to do so in the full version of the paper.</p>

    <p class="text-gray-300">It is not hard to see that our definition implies prior many of the guarantees of the property-based definitions (e.g., [9, 11, 36, 35]). Two properties that we do not require are: (1) membership revocation, and (2) anonymity even after exposure of a user secret key (forward anonymity), as in BMW [9]. While of course both of these properties could be added easily to the model, our scheme does not statisfy them. Note, however, that our definition (and scheme) does provide anonymity to (honest) users, i.e., users of which the adversary is not privy of their secret keys. Finally, notice that our definition implies CCA anonymity, i.e., an anonymity property based definition where the adversary is allowed to query the open oracle even after having been presented the challenge signature. This is in contrast to BMW model (and to the Boyen-Waters group signature scheme) which provide only CPA anonymity, i.e., where the adversary is no longer allowed access to the open oracle after seeing the challenge signature.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">3 Preliminaries and Complexity Assumptions</h3>

    <p class="text-gray-300"><strong>Notation:</strong> The notation  <span class="math">G = \\langle q \\rangle</span>  means that q generates the group G.</p>

    <p class="text-gray-300"><strong>Pairings:</strong> Let BilinearSetup be an algorithm that, on input the security parameter  <span class="math">1^k</span> , outputs the parameters for a pairing as  <span class="math">\\gamma = (p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, g, \\tilde{g})</span> , where  <span class="math">\\mathbb{G}_1 = \\langle g \\rangle</span>  and  <span class="math">\\mathbb{G}_2 = \\langle \\tilde{g} \\rangle</span> . We follow the notation of Boneh, Lynn, and Shacham [14]. Let  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2</span> , and  <span class="math">\\mathbb{G}_T</span>  all be (multiplicative) groups of prime order  <span class="math">p = \\Theta(2^k)</span> , where each element of each group has a unique binary representation. Furthermore, let  <span class="math">e : \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span>  be an efficient <em>pairing</em>, i.e., a mapping with the following properties: (Bilinearity) for all  <span class="math">g \\in \\mathbb{G}_1</span> ,  <span class="math">\\tilde{g} \\in \\mathbb{G}_2</span> , and  <span class="math">a, b \\in \\mathbb{Z}_p</span> ,  <span class="math">e(g^a, \\tilde{g}^b) = e(g, \\tilde{g})^{ab}</span> ; and (Non-degeneracy) if g is a generator of  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\tilde{g}</span>  is a generator of  <span class="math">\\mathbb{G}_2</span> , then  <span class="math">e(g, \\tilde{g})</span>  generates  <span class="math">\\mathbb{G}_T</span> .</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">3.1 Complexity Assumptions</h4>

    <p class="text-gray-300">The security of our construction in Section §5 is based on the following assumptions about pairing groups. In Appendix §D, we provide generic group proofs for EDH and Strong SXDH. A generic group proof for Strong LRSW was previously given in [3].</p>

    <p class="text-gray-300">Two criticisms could be made of these assumptions. The first could be that they are closely related to specific security properties of the scheme. With regards to this, we point out that even if we <em>were</em> to assume a specific property, such as unforgeability (which we don't do), security in our model would not follow. Indeed, it is non-trivial to show that our assumptions imply that our scheme realizes our ideal functionality. We also point out that the generic group proofs of these assumptions are highly non-trivial and required new techniques, which may be useful elsewhere.</p>

    <p class="text-gray-300">A second criticism could be that the assumptions are interactive and thus not black-box falsifiable [39]. However, we believe that our provided generic-model hardness proofs show that these assumptions are reasonable: Violating them would result in the design of elliptic curve algorithms with better than generic efficiency, a major cryptographic breakthrough with likely wider ramifications. In addition, our proofs provide estimates for the key sizes required for particular security levels, making our security assumptions indeed very concrete: The resulting  <span class="math">\\Omega(p^{1/3})</span> -generic security of our interactive assumptions (for elliptic curve subgroups of order p) puts them on a similar footing with related falsifiable assumptions, such as the q-Strong Diffie-Hellman assumption [24].</p>

    <p class="text-gray-300">Let BilinearSetup(1&lt;sup&gt;k&lt;/sup&gt;)  <span class="math">\\to</span>  (p,  <span class="math">\\mathbb{G}_1</span> ,  <span class="math">\\mathbb{G}_2</span> ,  <span class="math">\\mathbb{G}_T</span> , q,  <span class="math">\\tilde{q}</span> ), where  <span class="math">\\mathbb{G}_1 = \\langle q \\rangle</span>  and  <span class="math">\\mathbb{G}_2 = \\langle \\tilde{q} \\rangle</span> , be public.</p>

    <p class="text-gray-300">Assumption 1 (Symmetric External Diffie-Hellman (SXDH) [6, 3, 30]) The Decisional Diffie-Hellman (DDH) problem is hard in both  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span> . This implies that there do not exist efficiently computable isomorphisms  <span class="math">\\psi : \\mathbb{G}_1 \\to \\mathbb{G}_2</span>  or  <span class="math">\\psi&#x27; : \\mathbb{G}_2 \\to \\mathbb{G}_1</span> .</p>

    <p class="text-gray-300">Note that SXDH also subsumes a traditional Co-Gap assumption, i.e., the Co-CDH problem [14] is hard in the pairing groups: Given  <span class="math">(g, \\tilde{g}, g^x, \\tilde{g}^y)</span> , it is hard to compute  <span class="math">\\tilde{g}^{xy}</span>  or  <span class="math">g^{xy}</span> .</p>

    <p class="text-gray-300">Good candidates for pairing groups where SXDH is hard are certain MNT curve implementations where no efficient isomorphisms between  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  are known [6, 3, 47, 32, 30]. The asymmetric version of this assumption, simply called XDH, only requires that DDH be hard in  <span class="math">\\mathbb{G}_1</span>  [29, 45, 38, 13, 6].</p>

    <p class="text-gray-300">The LRSW assumption is a discrete-logarithm assumption introduced in 1999 by Lysyanskaya et al. [37] and used in many subsequent works. Recently, a stronger form of the LRSW assumption which <em>implies the SXDH assumption</em>, called <em>Strong LRSW</em>, was introduced by Ateniese et al. [3].</p>

    <p class="text-gray-300"><strong>Assumption 2 (Strong LRSW [3])</strong> Let  <span class="math">X, Y \\in \\mathbb{G}_2, X = \\tilde{g}^x, Y = \\tilde{g}^y</span> . Let  <span class="math">O_{X,Y}(\\cdot)</span>  be an oracle that takes as input a value  <span class="math">m \\in \\mathbb{Z}_p^*</span> , and outputs an LRSW-tuple  <span class="math">(a, a^x, a^{y+yxm})</span>  for a random  <span class="math">a \\in \\mathbb{G}_1</span> . Then for all probabilistic polynomial-time adversaries  <span class="math">\\mathcal{A}^{(\\cdot)}</span>  and all  <span class="math">m \\in \\mathbb{Z}_p^*</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[x \\stackrel{R}{\\leftarrow} \\mathbb{Z}_p, y \\stackrel{R}{\\leftarrow} \\mathbb{Z}_p, X = \\tilde{g}^x, Y = \\tilde{g}^y, (a_1, a_2, a_3, a_4, a_5) \\leftarrow \\mathcal{A}^{O_{X,Y}}(g, \\tilde{g}, X, Y) : \\\\ m \\notin Q \\land a_1 \\in \\mathbb{G}_1 \\land a_2 = a_1^x \\land a_3 = a_1^{y+yxm} \\land a_4 = a_1^m \\land a_5 = a_1^{mx}] &lt; 1/\\text{poly}(k),</span>$</p>

    <p class="text-gray-300">where Q is the set of queries A makes to  <span class="math">O_{X,Y}(\\cdot)</span> .</p>

    <p class="text-gray-300">The q-Strong Diffie-Hellman (q-SDH) assumption, as introduced by Boneh and Boyen [12], states that: for all probabilistic polynomial-time adversaries  <span class="math">\\mathcal{A}</span> , and all  <span class="math">c \\in \\mathbb{Z}_n^*</span> :</p>

    <p class="text-gray-300"><span class="math">$\\Pr[x \\stackrel{R}{\\leftarrow} \\mathbb{Z}_p : \\mathcal{A}(g, \\tilde{g}, g^x, \\dots, g^{(x^q)}, \\tilde{g}^x, \\dots, \\tilde{g}^{(x^q)}) = (c, \\tilde{g}^{1/(x+c)})] &lt; 1/\\operatorname{poly}(k).</span>$</p>

    <p class="text-gray-300">We make an interactive version of this assumption. As we mentioned in the introduction, our efficiency analysis takes into account Cheon's recent results [24] on q-SDH.</p>

    <p class="text-gray-300"><strong>Assumption 3 (Extended Diffie-Hellman (EDH))</strong> Let  <span class="math">x \\in \\mathbb{Z}_p^*</span> . Let oracle  <span class="math">O_x(\\cdot)</span>  take input  <span class="math">c_i \\in \\mathbb{Z}_p^*</span>  and produce output  <span class="math">(g^{v_i}, \\tilde{g}^{1/(x+v_i)}, \\tilde{g}^{1/(v_i+c_i)})</span> , for a random  <span class="math">v_i \\in \\mathbb{Z}_p^*</span> . For all probabilistic polynomial-time adversaries A, all  <span class="math">v, c \\in \\mathbb{Z}_p^*</span> , and all  <span class="math">a \\in \\mathbb{G}_1</span>  such that  <span class="math">a \\neq 1</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[x \\stackrel{R}{\\leftarrow} \\mathbb{Z}_p : \\mathcal{A}^{O_x}(g, g^x, \\tilde{g}, \\tilde{g}^x) = (c, a, a^x, a^v, \\tilde{g}^{1/(x+v)}, \\tilde{g}^{1/(v+c)}) \\land c \\notin Q] &lt; 1/\\operatorname{poly}(k)</span>$</p>

    <p class="text-gray-300">where Q is the set of queries A makes to oracle  <span class="math">O_x(\\cdot)</span> .</p>

    <p class="text-gray-300">The assumptions discussed so far are underlying the unforgeability of our group signature scheme. Its anonymity is based on a single assumption: that SXDH holds even when the adversary is given oracle access to additional information about the DDH instance.</p>

    <p class="text-gray-300"><strong>Assumption 4 (Strong SXDH)</strong> Let  <span class="math">g \\in \\mathbb{G}_1</span> ,  <span class="math">\\tilde{g} \\in \\mathbb{G}_2</span> , and  <span class="math">x \\in \\mathbb{Z}_p</span> . Let  <span class="math">O_x(\\cdot)</span>  be an oracle that takes as input  <span class="math">m \\in \\mathbb{Z}_p^*</span>  and outputs  <span class="math">(g^v, \\tilde{g}^{1/(x+v)}, \\tilde{g}^{1/(v+m)})</span>  for a random  <span class="math">v \\in \\mathbb{Z}_p^*</span> . Let  <span class="math">Q_y(\\cdot)</span>  be an oracle that takes the same input type and outputs  <span class="math">(g^r, g^{ry}, g^{rv}, \\tilde{g}^{1/(y+v)}, \\tilde{g}^{1/(v+m)})</span>  for a random  <span class="math">r, v \\in \\mathbb{Z}_p^*</span> . Then for all probabilistic polynomial-time adversaries  <span class="math">\\mathcal{A}^{(\\cdot)}</span> , and for randomly chosen  <span class="math">g \\in \\mathbb{G}_1</span> ,  <span class="math">\\tilde{g} \\in \\mathbb{G}_2</span> , and  <span class="math">x, y \\in \\mathbb{Z}_p</span> ,</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[\\mathcal{A}^{O_x,Q_x}(g,g^x,\\tilde{g})=1] - \\Pr[\\mathcal{A}^{O_x,Q_y}(g,g^x,\\tilde{g})=1]| &lt; 1/\\mathrm{poly}(k).</span>$</p>

    <p class="text-gray-300">In Theorem D.3, we show that Strong SXDH also has the same complexity as q-SDH for generic groups.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">4 Key Building Blocks: CL&lt;sup&gt;+&lt;/sup&gt; and BB&lt;sup&gt;+&lt;/sup&gt; Signatures</h3>

    <p class="text-gray-300">As mentioned in Section §1, our group signature scheme is built out of two standard signature schemes secure without random oracles. We review the important details now.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">4.1 Camenisch-Lysyanskaya Signatures</h4>

    <p class="text-gray-300">Recall the basic Pedersen commitment scheme [41], in which the public parameters are a group G of prime order p, and two generators g and h of G. To commit to the value  <span class="math">m \\in \\mathbb{Z}_p</span> , pick a random  <span class="math">r \\in \\mathbb{Z}_p</span>  and set  <span class="math">C = \\operatorname{PedCom}(m; r) = g^m h^r</span> .</p>

    <p class="text-gray-300">The Camenisch-Lysyanskaya (CL) signature scheme is secure without random oracles under the LRSW assumption [19]. CL signatures are also useful, because they support an efficient two-party protocol for obtaining a CL signature on the value (message) committed to in a Pedersen commitment. The common inputs are C = PedCom(m; r) and the verification key of the signer pk. The signer additionally knows the corresponding signing key sk, while the receiver additionally knows m and r. As a result of this protocol, the receiver obtains the signature  <span class="math">\\sigma_{sk}(m)</span> , while the signer does not learn anything about m. For our current purposes, it will not matter how this protocol actually works. Fortunately, a recent extension of the CL signatures by Ateniese et al. [3], denoted  <span class="math">CL^+</span> , inherits this protocol.</p>

    <p class="text-gray-300"><strong>CL</strong>&lt;sup&gt;+&lt;/sup&gt; <strong>Signatures.</strong> Let the security parameter be  <span class="math">1^k</span> . The global parameters are the description of a pairing  <span class="math">params = (p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, g, \\tilde{g})</span> , where  <span class="math">\\mathbb{G}_1 = \\langle g \\rangle</span>  and  <span class="math">\\mathbb{G}_2 = \\langle \\tilde{g} \\rangle</span> , obtained by running BilinearSetup <span class="math">(1^k)</span> . Keypairs are of the form  <span class="math">pk = (\\tilde{g}^s, \\tilde{g}^t)</span>  and  <span class="math">sk = (s, t) \\in \\mathbb{Z}_p^2</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Signing:</strong> Choose random  <span class="math">a \\in \\mathbb{G}_1</span> , output  <span class="math">(a, a^t, a^{s+stm}, a^m, a^{mt})</span>  as the signature on <em>hidden</em> message  <span class="math">m \\in \\mathbb{Z}_p^*</span> .</li>
      <li><strong>Verification:</strong> On input a purported signature (A, B, C, D, E) accept that  <span class="math">\\sigma</span>  authenticates the message hidden as  <span class="math">\\log_A(D)</span>  if and only if: (1)  <span class="math">e(B, \\tilde{g}) = e(A, \\tilde{g}^t)</span> , (2)  <span class="math">e(D, \\tilde{g}^t) = e(E, \\tilde{g})</span> , and (3)  <span class="math">e(C, \\tilde{g}) = e(A, \\tilde{g}^s)e(E, \\tilde{g}^s)</span> .</li>
      <li><strong>Re-Randomization:</strong> On input a signature (A, B, C, D, E), choose a random  <span class="math">r \\in \\mathbb{Z}_p^*</span>  and output  <span class="math">(A^r, B^r, C^r, D^r, E^r)</span> .</li>
    </ul>

    <p class="text-gray-300">CL&lt;sup&gt;+&lt;/sup&gt; signatures are secure assuming SXDH and Strong LRSW. As previously observed in [3], when CL&lt;sup&gt;+&lt;/sup&gt; signatures are set in pairing groups where SXDH is hard, this re-randomization is <em>unlinkable</em>. We formally argue this second point in Lemma A.2.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">4.2 Boneh-Boyen Signatures</h4>

    <p class="text-gray-300">Recall the weak Boneh-Boyen (BB) signature scheme [12]. Let the security parameter be  <span class="math">1^k</span> . The global parameters are the description of a pairing  <span class="math">params = (p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T)</span>  obtained by running BilinearSetup <span class="math">(1^k)</span>  (here, we ignore the generators output by BilinearSetup). Keypairs are of the form  <span class="math">pk = (g, g^{sk}, \\tilde{g})</span>  and  <span class="math">sk \\in \\mathbb{Z}_p^*</span> , for random generators  <span class="math">g \\in \\mathbb{G}_1</span>  and  <span class="math">\\tilde{g} \\in \\mathbb{G}_2</span> . To sign a message  <span class="math">m \\in \\mathbb{Z}_p^*</span> , output the signature  <span class="math">\\tilde{g}^{1/(sk+m)}</span> . To verify signature  <span class="math">\\sigma</span> , accept if and only if  <span class="math">e(\\sigma, g^{sk}g^m) = e(g, \\tilde{g})</span> . Note that in this work we reverse the roles of  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  from the original description in [12]. As in other implementation of pairing-based schemes where distortion maps are not available, one chooses the role of each pairing group to maximize the efficiency of one's protocol.</p>

    <p class="text-gray-300">This scheme was proven unforgeable only against weak chosen-message attack under the q-SDH assumption [12], where the adversary must submit all of his signature queries in advance of the public key</p>

    <p class="text-gray-300">generation. Boneh and Boyen gave one method of modifying this weak scheme into an adaptively-secure one [12]. We provide a second method, which is more suited to our purposes.</p>

    <p class="text-gray-300"><span class="math">{\\bf BB^+}</span>  Signatures. The intuition here is that to issue a signature on a message m, a weak BB signature under sk is issued on a one-time signing key v, and then another weak BB signature under v is issued on message m. The additional randomness v allows to prove adaptive security.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Key generation:</strong> Same as before. (Although, now the same bases may be used for all keys.)</li>
      <li><strong>Signing:</strong> On input a secret key sk and a message  <span class="math">m \\in \\mathbb{Z}_p^*</span> , select a random  <span class="math">r \\in \\mathbb{Z}_p^*</span> , and output the signature  <span class="math">(g^r, \\tilde{g}^{1/(sk+r)}, \\tilde{g}^{1/(r+m)})</span> .</li>
      <li><strong>Verification:</strong> On input a public key  <span class="math">(g, g^{sk}, \\tilde{g})</span> , a message m, and a purported signature (A, B, C), accept if and only if: (1)  <span class="math">e(g^{sk}A, B) = e(g, \\tilde{g})</span>  and (2)  <span class="math">e(Ag^m, C) = e(g, \\tilde{g})</span> .</li>
    </ul>

    <p class="text-gray-300"><strong>Lemma 4.1</strong> The BB&lt;sup&gt;+&lt;/sup&gt; signature scheme is existentially unforgeable under adaptive chosen-message attack under the EDH assumption.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">5 Our Basic Group Signature Construction</h3>

    <p class="text-gray-300"><strong>Notation:</strong> BB&lt;sup&gt;+&lt;/sup&gt; and CL&lt;sup&gt;+&lt;/sup&gt;, respectively, denote our Section §4 modifications of the Boneh-Boyen [12] and Camenisch-Lysyanskaya [19] signature schemes. When we write  <span class="math">A = Sign_{GSK}^{CL+}(m;a)</span> , we mean that A is a CL&lt;sup&gt;+&lt;/sup&gt; signature under key GSK on message m using base a; that is,  <span class="math">A = (a, a^t, a^{s+stm}, a^m, a^{mt})</span>  for GSK = (s, t). Similarly, when we write  <span class="math">A = Sign_{sk}^{BB+}(m; g, \\tilde{g})</span> , we mean that A is a BB&lt;sup&gt;+&lt;/sup&gt; signature under key sk on message m using bases  <span class="math">(g, \\tilde{g})</span> ; that is,  <span class="math">A = (g^v, \\tilde{g}^{1/(sk+v)}, \\tilde{g}^{1/(v+m)})</span>  for some  <span class="math">v \\in \\mathbb{Z}_p^*</span> .</p>

    <p class="text-gray-300">Let BilinearSetup(1&lt;sup&gt;k&lt;/sup&gt;)  <span class="math">\\rightarrow params = (p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, q, \\tilde{q})</span> , where  <span class="math">\\mathbb{G}_1 = \\langle q \\rangle</span>  and  <span class="math">\\mathbb{G}_2 = \\langle \\tilde{q} \\rangle</span> .</p>

    <p class="text-gray-300"><strong>GroupSetup</strong>( <span class="math">1^k</span> , params): The group manager establishes the public parameters for the Pedersen commitment scheme [41] and adds those to params. Then, the group manager executes  <span class="math">Gen^{CL+}(1^k, params)</span>  to obtain  <span class="math">GPK = (params, \\mathcal{S} = \\tilde{g}^s, \\mathcal{T} = \\tilde{g}^t)</span>  and GSK = (s, t).</p>

    <p class="text-gray-300"><strong>UserKeyGen</strong>( <span class="math">1^k</span> , params): Each user  <span class="math">\\mathcal{U}</span>  selects random  <span class="math">sk \\in \\mathbb{Z}_p^*</span>  and random  <span class="math">h \\in \\mathbb{G}_1</span> , and outputs a public key  <span class="math">pk = (h, e(h, \\tilde{g})^{sk})</span> .</p>

    <p class="text-gray-300"><strong>Join</strong>( <span class="math">\\mathcal{U}_i(GPK, sk_i), \\mathcal{GM}(pk_i, GSK)</span> ): In this interactive protocol, the user's inputs are her secret key  <span class="math">sk_i</span>  and the public key of the group manager GPK. Likewise, the group manager receives as input GSK and  <span class="math">pk_i</span> . They interact as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathcal{U}_i</span>  submits her public key  <span class="math">pk_i = (p_1, p_2)</span>  and tracing information  <span class="math">Q_i = \\tilde{g}^{sk_i}</span>  to  <span class="math">\\mathcal{GM}</span> . If  <span class="math">e(p_1, Q_i) \\neq p_2</span>  or  <span class="math">sk_i</span>  was already in D,  <span class="math">\\mathcal{GM}</span>  aborts. Else,  <span class="math">\\mathcal{GM}</span>  enters  <span class="math">Q_i</span>  in database D.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The user sends a commitment  <span class="math">A = \\operatorname{PedCom}(sk_i)</span>  to  <span class="math">\\mathcal{GM}</span> . The user and  <span class="math">\\mathcal{GM}</span>  run the CL protocol (see Section 4.1) for obtaining  <span class="math">\\mathcal{GM}</span> 's signature on the committed value contained in commitment A.  <span class="math">\\mathcal{GM}</span>  picks a random  <span class="math">r \\in \\mathbb{Z}_p^*</span>  and sets  <span class="math">f_1 = g^r</span> . Then,  <span class="math">\\mathcal{GM}</span>  computes  <span class="math">\\operatorname{Sign}_{GSK}^{CL+}(sk_i; f_1) = (f_2, f_3)</span>  and sends all three values to the user. If the CL signature  <span class="math">(f_1, f_2, f_3)</span>  does not verify for message  <span class="math">sk_i</span> , the user aborts.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The user provides a zero-knowledge proof that the committed value  <span class="math">sk_i</span>  contained in commitment A is consistent with the public key  <span class="math">pk_i</span>  and a zero-knowledge proof of knowledge of  <span class="math">sk_i</span>  using any proof technique that is <em>extractable</em>. (For more on such proofs, see Appendix B.)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The group manager provides an extractable zero-knowledge proof of GSK = (s, t).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Next, the user locally computes the values  <span class="math">f_4 = f_1^{sk_i}</span>  and  <span class="math">f_5 = f_2^{sk_i}</span> .</li>
    </ol></li>
    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>At the end of this protocol, the user obtains the following membership certificate:</li>
    </ol>

    <p class="text-gray-300"><span class="math">$C_i = (f_1, \\dots, f_5) = (a, a^t, a^{s+st(sk_i)}, a^{sk_i}, a^{(sk_i)t}).</span>$</p>

    <p class="text-gray-300"><strong>GroupSign</strong> <span class="math">(sk_i, C_i, m)</span> : A user with secret key  <span class="math">sk_i</span>  and membership certificate  <span class="math">C_i = (f_1, \\ldots, f_5)</span>  may sign a message  <span class="math">m \\in \\mathbb{Z}_p^*</span>  as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Re-randomize  <span class="math">C_i</span>  using a random  <span class="math">r \\in \\mathbb{Z}_p</span> , i.e., compute  <span class="math">(a_1,\\ldots,a_5)=(f_1^r,\\ldots,f_5^r)</span> . 2. Compute  <span class="math">Sign_{sk_i}^{BB+}(m;a_5,\\tilde{g})=(a_6,a_7,a_8)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output the signature  <span class="math">(a_1, \\ldots, a_8)</span>  of the form  <span class="math">(b, b^t, b^{s+st(sk_i)}, b^{sk_i}, b^{(sk_i)t}, b^v, \\tilde{q}^{1/(sk_i+v)}, \\tilde{q}^{1/(v+m)})</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><strong>GroupVerify</strong>  <span class="math">(GPK, m, \\sigma)</span> : To verify that  <span class="math">\\sigma = (a_1, \\ldots, a_8)</span>  is a group signature on m, do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that  <span class="math">(a_1, a_2, a_3, a_4, a_5)</span>  is a valid  <span class="math">CL^+</span>  signature for public key GPK where the <em>hidden</em> message is the exponent of  <span class="math">a_4</span>  (base  <span class="math">a_1</span> ). Specifically, verify that: (1)  <span class="math">e(a_1, \\mathcal{T}) = e(a_2, \\tilde{g})</span> , (2)  <span class="math">e(a_4, \\mathcal{T}) =</span>  <span class="math">e(a_5, \\tilde{g})</span> , and (3)  <span class="math">e(a_1a_5, \\mathcal{S}) = e(a_3, \\tilde{g})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that  <span class="math">(a_6, a_7, a_8)</span>  is a valid BB&lt;sup&gt;+&lt;/sup&gt; signature for public key  <span class="math">(a_1, a_4, \\tilde{g})</span>  on message m. Specifically, verify that: (1)  <span class="math">e(a_4a_6, a_7) = e(a_1, \\tilde{g})</span>  and (2)  <span class="math">e(a_6a_1^m, a_8) = e(a_1, \\tilde{g})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If both checks pass, accept; otherwise, reject.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><strong>Open</strong>( <span class="math">GSK, m, \\sigma</span> ): On input any valid signature  <span class="math">\\sigma = (a_1, \\ldots, a_8)</span>  and tracing database  <span class="math">D, \\mathcal{GM}</span>  may run the following algorithm to identify the signer. For each entry  <span class="math">Q_i \\in D</span> , the group manager checks whether  <span class="math">e(a_4, \\tilde{g}) = e(a_1, Q_i)</span> . If a match is found, then  <span class="math">\\mathcal{GM}</span>  outputs  <span class="math">\\mathcal{U}_i</span>  as the identity of the original signer.</p>

    <p class="text-gray-300"><strong>VerifyOpen</strong>( <span class="math">\\mathcal{GM}(GSK, m, \\sigma, pk_i, Q_i), \\mathcal{V}(GPK, m, \\sigma, pk_i)</span> ): First,  <span class="math">\\mathcal{GM}</span>  checks that  <span class="math">\\sigma</span>  is a valid group signature; that is, GroupVerify <span class="math">(GPK, \\sigma, m) = 1</span> . Next,  <span class="math">\\mathcal{GM}</span>  checks that  <span class="math">\\mathcal{U}_i</span>  is responsible for creating  <span class="math">\\sigma</span> ; that is, using tracing information  <span class="math">Q_i = \\tilde{g}^{sk_i}</span>  from database D and  <span class="math">pk_i = (p_1, p_2)</span> , test that  <span class="math">e(p_1, Q_i) = p_2</span> . If both of these conditions hold, then  <span class="math">\\mathcal{GM}</span>  proceeds to convince a verifier that  <span class="math">\\mathcal{U}_i</span>  was responsible for  <span class="math">\\sigma</span> . We call this step anonymity revocation. Here, the  <span class="math">\\mathcal{GM}</span>  provides a zero-knowledge proof of knowledge of a value  <span class="math">\\alpha \\in \\mathbb{G}_2</span>  (i.e., the tracing information for  <span class="math">\\mathcal{U}_i</span> ) such that  <span class="math">e(p_1, \\alpha) = p_2</span>  and  <span class="math">e(a_1, \\alpha) = e(a_4, \\tilde{g})</span>  [1].</p>

    <p class="text-gray-300">The revocation described above revokes the anonymity of a particular signature, however, the  <span class="math">\\mathcal{GM}</span>  could instead revoke the anonymity of all signatures belonging to user  <span class="math">U_i</span>  by publishing the tracing information  <span class="math">Q_i</span> . Then anyone can verify that the user with public key  <span class="math">pk = (p_1, p_2)</span>  must be responsible by checking that: (1)  <span class="math">e(p_1, Q_i) = p_2</span> , and (2)  <span class="math">e(a_1, Q_i) = e(a_4, \\tilde{g})</span> .</p>

    <p class="text-gray-300"><strong>Theorem 5.1</strong> In the plain model, the above group signature scheme realizes  <span class="math">\\mathcal{F}_{qs}</span>  from Section §2 under the Strong LRSW, the EDH, and the Strong SXDH assumptions.</p>

    <p class="text-gray-300">Proof of Theorem 5.1 appears in Appendix A.</p>

    <h2 id="sec-13" class="text-2xl font-bold"><strong>Opening Signatures in Sublinear Time</strong></h2>

    <p class="text-gray-300">The basic Open algorithm described in Section §5 takes  <span class="math">O(n \\cdot k)</span>  for a signing group of n members and security parameter k. Practically, this precludes this scheme from being used for many applications with large groups. We provide several options to remedy this situation in Appendix C.</p>

    <p class="text-gray-300">First, we present an Open algorithm with complexity  <span class="math">O(\\sqrt{n} \\cdot k)</span>  which can be extended to one with complexity  <span class="math">O((\\log n) \\cdot k)</span>  at the cost of group signatures becoming of size  <span class="math">O((\\log n) \\cdot k)</span> . This improvement requires no additional assumptions, but does add two elements in  <span class="math">\\mathbb{G}_1</span>  (resp.  <span class="math">\\log n</span>  elements) to the signature length. Next, we present a  <span class="math">O((\\log n) + k)</span>  Open algorithm. This increases the basic signature by three elements in  <span class="math">\\mathbb{G}_1</span>  and requires a slightly different anonymity assumption.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8"><strong>References</strong></h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[1] B. Adida, S. Hohenberger, and R. L. Rivest. Ad-Hoc-Group Signatures from Hijacked Keypairs, 2005. At http://theory.lcs.mit.edu/&lt;sup&gt;∼&lt;/sup&gt;rivest/publications.</p></li>
      <li><p class="text-gray-300">[2] J. H. An, Y. Dodis, and T. Rabin. On the security of joint signature and encryption. In <em>EUROCRYPT</em>, volume 2332 of LNCS, pages 83–107, 2002.</p></li>
      <li><p class="text-gray-300">[3] G. Ateniese, J. Camenisch, and B. de Medeiros. Untraceable RFID tags via insubvertible encryption. In <em>ACM CCS</em>, pages 92–101, 2005.</p></li>
      <li><p class="text-gray-300">[4] G. Ateniese, J. Camenisch, M. Joye, and G. Tsudik. A practical and provably secure coalition-resistant group signature scheme. In <em>CRYPTO</em>, volume 1880 of LNCS, pages 255–270, 2000.</p></li>
      <li><p class="text-gray-300">[5] G. Ateniese and G. Tsudik. Some open issues and new directions in group signatures. In <em>Financial Cryptography</em>, volume 1648 of LNCS, pages 196–211, 1999.</p></li>
      <li><p class="text-gray-300">[6] L. Ballard, M. Green, B. de Medeiros, and F. Monrose. Correlation-resistant storage. Technical Report TR-SP-BGMM-050705, Johns Hopkins University, CS Dept, 2005. http://spar.isi.jhu.edu/&lt;sup&gt;∼&lt;/sup&gt;mgreen/ correlation.pdf.</p></li>
      <li><p class="text-gray-300">[7] P. S. L. M. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order, 2005. Cryptology ePrint Archive: 2005/133.</p></li>
      <li><p class="text-gray-300">[8] D. Beaver. Secure multi-party protocols and zero-knowledge proof systems tolerating a faulty minority. <em>Journal of Cryptology</em>, 4:75–122, 1991.</p></li>
      <li><p class="text-gray-300">[9] M. Bellare, D. Micciancio, and B. Warinschi. Foundations of group signatures: Formal definition, simplified requirements and a construction based on general assumptions. In <em>EUROCRYPT</em>, volume 2656 of LNCS, pages 614–629, 2003.</p></li>
      <li><p class="text-gray-300">[10] M. Bellare and A. Palacio. GQ and Schnorr Identification Schemes: Proofs of Security against Impersonation under Active and Concurrent Attacks. In <em>CRYPTO</em>, volume 2442 of LNCS, pages 162–177, 2002.</p></li>
      <li><p class="text-gray-300">[11] M. Bellare, H. Shi, and C. Zhang. Foundations of group signatures: The case of dynamic groups. In <em>CT-RSA</em>, volume 3376 of LNCS, pages 136–153, 2005.</p></li>
      <li><p class="text-gray-300">[12] D. Boneh and X. Boyen. Short signatures without random oracles. In <em>EUROCRYPT 2004</em>, volume 3027 of LNCS, pages 56–73, 2004.</p></li>
      <li><p class="text-gray-300">[13] D. Boneh, X. Boyen, and H. Shacham. Short group signatures. In <em>CRYPTO</em>, volume 3152 of <em>LNCS</em>, pages 41–55, 2004.</p></li>
      <li><p class="text-gray-300">[14] D. Boneh, B. Lynn, and H. Shacham. Short signatures from the Weil pairing. In <em>ASIACRYPT</em>, volume 2248 of LNCS, pages 514–532, 2001.</p></li>
      <li><p class="text-gray-300">[15] D. Boneh and H. Shacham. Group signatures with verifier-local revocation. In <em>Proc. of the ACM Conf. on Computer and Communications Security (ACM CSS 2004)</em>, pages 168–177. ACM Press, 2004.</p></li>
      <li><p class="text-gray-300">[16] X. Boyen and B. Waters. Compact Group Signatures Without Random Oracles. In <em>EUROCRYPT '06</em>, volume 4004 of LNCS, pages 427–444, 2006.</p></li>
      <li><p class="text-gray-300">[17] E. Brickell, J. Camenisch, and L. Chen. Direct anonymous attestation. In <em>ACM CCS</em>, pages 132–145, 2004.</p></li>
      <li><p class="text-gray-300">[18] J. Camenisch and I. Damgard. Verifiable encryption, group encryption, and their applications to group signatures ˚ and signature sharing schemes. In <em>ASIACRYPT</em>, volume 1976 of LNCS, pages 331–345, 2000.</p></li>
      <li><p class="text-gray-300">[19] J. Camenisch and A. Lysyanskaya. Signature Schemes and Anonymous Credentials from Bilinear Maps. In <em>CRYPTO</em>, volume 3152 of LNCS, pages 56–72, 2004.</p></li>
      <li><p class="text-gray-300">[20] R. Canetti. <em>Studies in Secure Multiparty Computation and Applications</em>. PhD thesis, Weizmann Institute of Science, Rehovot 76100, Israel, June 1995.</p></li>
      <li><p class="text-gray-300">[21] R. Canetti. Security and composition of multi-party cryptographic protocols. <em>Journal of Cryptology</em>, 13(1):143– 202, 2000.</p></li>
      <li><p class="text-gray-300">[22] R. Canetti. Universally composable security: A new paradigm for cryptographic protocols. In <em>FOCS</em>, pages 136–145, 2001.</p></li>
      <li><p class="text-gray-300">[23] D. Chaum and E. van Heyst. Group Signatures. In <em>EUROCRYPT</em>, volume 547 of LNCS, pages 257–265, 1991.</p></li>
      <li><p class="text-gray-300">[24] J. H. Cheon. Security Analysis of the Strong Diffie-Hellman Problem. In <em>EUROCRYPT '06</em>, volume 4004 of LNCS, pages 1–11, 2006.</p></li>
      <li><p class="text-gray-300">[25] I. Damgard. Efficient concurrent zero-knowledge in the auxiliary string model. In ˚ <em>EUROCRYPT</em>, volume 1807 of LNCS, pages 418–430, 2000.</p></li>
      <li><p class="text-gray-300">[26] A. Datta, A. Derek, J. C. Mitchell, A. Ramanathan, and A. Scedrov. Games and the impossibility of realizable ideal functionality. In <em>TCC</em>, volume 3876 of LNCS, pages 360–379, 2006.</p></li>
      <li><p class="text-gray-300">[27] A. W. Dent. Adapting the weaknesses of the random oracle model to the generic group model. In <em>ASIACRYPT '02</em>, volume 2501 of LNCS, pages 100–109, 2002.</p></li>
      <li><p class="text-gray-300">[28] M. Fischlin. Communication-Efficient Non-Interactive Proofs of Knowledge with Online Extractors. In <em>CRYPTO</em>, pages 152–168, 2005.</p></li>
      <li><p class="text-gray-300">[29] S. D. Galbraith. Supersingular curves in cryptography. In <em>ASIACRYPT</em>, volume 2248 of LNCS, pages 495–513, 2001.</p></li>
      <li><p class="text-gray-300">[30] S. D. Galbraith. Personal communication, August, 2005.</p></li>
      <li><p class="text-gray-300">[31] S. D. Galbraith, K. G. Paterson, and N. P. Smart. Pairings for cryptographers. Technical Report 2006/165, International Association for Cryptological Research, 2006.</p></li>
      <li><p class="text-gray-300">[32] S. D. Galbraith and V. Rotger. Easy decision Diffie-Hellman groups. <em>Journal of Computation and Mathematics</em>, 7:201–218, 2004.</p></li>
      <li><p class="text-gray-300">[33] S. Goldwasser and Y. T. Kalai. On the (In)security of the Fiat-Shamir Paradigm. In <em>FOCS</em>, pages 102–115, 2003.</p></li>
      <li><p class="text-gray-300">[34] S. Goldwasser, S. Micali, and R. Rivest. A digital signature scheme secure against adaptive chosen-message attacks. <em>SIAM J. of Computing</em>, 17(2):281–308, 1988.</p></li>
      <li><p class="text-gray-300">[35] A. Kiayias, Y. Tsiounis, and M. Yung. Traceable signatures. In <em>EUROCRYPT</em>, volume 3027 of <em>LNCS</em>, pages 571–589, 2004.</p></li>
      <li><p class="text-gray-300">[36] A. Kiayias and M. Yung. Group signatures: Provable security, efficient constructions and anonymity from trapdoor-holders, 2004. Cryptology ePrint Archive: 2004/076.</p></li>
      <li><p class="text-gray-300">[37] A. Lysyanskaya, R. L. Rivest, A. Sahai, and S. Wolf. Pseudonym systems. In <em>SAC</em>, volume 1758 of <em>LNCS</em>, pages 184–199, 1999.</p></li>
      <li><p class="text-gray-300">[38] N. McCullagh and P. S. L. M. Barreto. A new two-party identity-based authenticated key agreement. In <em>CT-RSA</em>, volume 3376 of LNCS, pages 262–274, 2004.</p></li>
      <li><p class="text-gray-300">[39] M. Naor. Cryptographic assumptions and challenges. In <em>Proc. Adv. in Cryptology (CRYPTO 2003)</em>, volume 2729 of <em>LNCS</em>, pages 96–109. Springer, 2003.</p></li>
      <li><p class="text-gray-300">[40] V. I. Nechaev. Complexity of a determinate algorithm for the discrete logarithm. <em>Mathematical Notes</em>, 55:165– 172, 1994.</p></li>
      <li><p class="text-gray-300">[41] T. P. Pedersen. Non-interactive and information-theoretic secure verifiable secret sharing. In <em>CRYPTO</em>, volume 576 of LNCS, pages 129–140, 1991.</p></li>
      <li><p class="text-gray-300">[42] B. Pfitzmann and M. Waidner. Composition and integrity preservation of secure reactive systems. In <em>ACM CCS</em>, pages 245–254, 2000.</p></li>
      <li><p class="text-gray-300">[43] B. Pfitzmann and M. Waidner. A model for asynchronous reactive systems and its application to secure message transmission. In <em>IEEE S&amp;P</em>, pages 184–200, 2001.</p></li>
      <li><p class="text-gray-300">[44] M. Scott. MIRACL library. Indigo Software. http://indigo.ie/&lt;sup&gt;∼&lt;/sup&gt;mscott.</p></li>
      <li><p class="text-gray-300">[45] M. Scott. Authenticated ID-based key exchange and remote log-in with simple token and PIN number, 2002. Cryptology ePrint Archive: 2002/164.</p></li>
      <li><p class="text-gray-300">[46] V. Shoup. Lower bounds for discrete logarithms and related problems. In <em>EUROCRYPT</em>, LNCS, pages 256–266, 1997. Update: http://www.shoup.net/papers/.</p></li>
      <li><p class="text-gray-300">[47] E. R. Verheul. Evidence that XTR is more secure than supersingular elliptic curve cryptosystems. In <em>EURO-CRYPT</em>, volume 2045 of LNCS, pages 195–210, 2001.</p></li>
    </ul>

    <h2 id="sec-15" class="text-2xl font-bold"><strong>A Security Proof of Basic Construction</strong></h2>

    <p class="text-gray-300">We now prove Theorem 5.1 on the security of our basic construction.</p>

    <p class="text-gray-300"><em>Proof.</em> Our goal is to show that for every adversary A and environment Z, there exists a simulator S such that Z cannot distinguish whether it is interacting in the real world with A or the ideal world with S. The proof is structured in two parts. First, for arbitrary fixed A and Z, we describe a simulator S. Then, we argue that S satisfies our goal.</p>

    <p class="text-gray-300">Recall that the simulator interacts with the ideal functionality  <span class="math">\\mathcal{F}_{gs}</span>  on behalf of all corrupted parties in the ideal world, and also simulates the real-world adversary  <span class="math">\\mathcal{A}</span>  towards the environment.  <span class="math">\\mathcal{S}</span>  is given black-box access to  <span class="math">\\mathcal{A}</span> . In our description,  <span class="math">\\mathcal{S}</span>  will use  <span class="math">\\mathcal{A}</span>  to simulate conversations with  <span class="math">\\mathcal{Z}</span> . Specifically,  <span class="math">\\mathcal{S}</span>  will directly forward all messages from  <span class="math">\\mathcal{A}</span>  to  <span class="math">\\mathcal{Z}</span>  and from  <span class="math">\\mathcal{Z}</span>  to  <span class="math">\\mathcal{A}</span> .</p>

    <p class="text-gray-300">The simulator will be responsible for handling several different operations within the group signature system. The operations are triggered either by messages from  <span class="math">\\mathcal{F}_{gs}</span>  to any of the corrupted parties in the ideal system (and thus these messages are sent to  <span class="math">\\mathcal{S}</span> ) or when  <span class="math">\\mathcal{A}</span>  wants to send any messages to honest parties. In our description,  <span class="math">\\mathcal{S}</span>  will simulate the (real-world) honest parties of towards  <span class="math">\\mathcal{A}</span> .</p>

    <p class="text-gray-300">Finally, we assume that when a signature is created, it becomes public information. Likewise, whenever a signature is opened, the corresponding identity is announced to all. (However, each user may still require individual proof from the  <span class="math">\\mathcal{GM}</span>  that this identity is correct.)</p>

    <p class="text-gray-300"><strong>Notation:</strong> The simulator S may need to behave differently depending on which parties are corrupted. There are two parties of interest: the group manager and a user. We adopt previous notation [17] for this: a capital letter denotes that the corresponding party is not corrupted and a small letter denotes that it is. For example, by &quot;Case (Gu)&quot; we refer to the case where the group manager is honest, but the user is corrupted.</p>

    <p class="text-gray-300">We will refer to a user as  <span class="math">\\mathcal{U}_i</span>  and a user's public key as  <span class="math">pk_i</span> . We assume throughout that a party in possession of one of these two identifiers is also in possession of the other.</p>

    <p class="text-gray-300">We now describe how the simulator S behaves. Intuitively, when the group manager is corrupt, S will sign messages for whatever user  <span class="math">\\mathcal{F}_{gs}</span>  tells it. When the group manager is honest, however, S will be asked to sign messages on behalf of unknown users and might later be asked to open them. In this case, S will sign all messages using the same secret key, which we denote  <span class="math">sk^*</span> . Then, whenever S is told to open this signature to a particular user later revealed by  <span class="math">\\mathcal{F}_{qs}</span> , it will fake the corresponding proof.</p>

    <p class="text-gray-300"><strong>Non-Adaptive Setup:</strong> Each party that  <span class="math">\\mathcal{S}</span>  corrupts reports to  <span class="math">\\mathcal{F}_{gs}</span>  that it is corrupted. The global parameters BilinearSetup <span class="math">(1^k) \\to (p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, g, \\tilde{g}) = params</span> , where  <span class="math">\\mathbb{G}_1 = \\langle g \\rangle</span>  and  <span class="math">\\mathbb{G}_2 = \\langle \\tilde{g} \\rangle</span> , are broadcast to all parties.</p>

    <p class="text-gray-300"><strong>Simulation of the Real World's Setup:</strong> The group manager has an associated key pair (GPK, GSK). Regardless of the honesty of the group manager, S sets up any public parameters needed later for the registration of a user's key in Join (e.g., the hash function used in the Fischlin transformation).</p>

    <p class="text-gray-300">Case (g): If the group manager is corrupted, then S receives the group key GPK from A.</p>

    <p class="text-gray-300">Case (G): If the group manager is honest, then S runs the GroupSetup algorithm to generate a group public key GPK which it then gives to A. Note that in this case S knows the corresponding secrets and the relation of the Pedersen commitment bases. (Although, an ideal group manager exists outside of S, the simulator will internally act as a real-world manager toward A.)</p>

    <p class="text-gray-300"><strong>Simulation of Honest Parties' Setup:</strong> Each party must have an associated key pair  <span class="math">(pk_i, sk_i)</span> .</p>

    <p class="text-gray-300">Case (u): If user  <span class="math">\\mathcal{U}_i</span>  is corrupted, then  <span class="math">\\mathcal{S}</span>  receives the user's public key  <span class="math">pk_i</span>  from  <span class="math">\\mathcal{A}</span> .</p>

    <p class="text-gray-300">Case (U): If  <span class="math">\\mathcal{U}_i</span>  is honest, then  <span class="math">\\mathcal{S}</span>  runs the UserKeyGen algorithm to generate a public key  <span class="math">pk_i</span>  which it then gives to  <span class="math">\\mathcal{A}</span> . (Although, ideal honest parties exist outside of  <span class="math">\\mathcal{S}</span> , the simulator will internally create real-world public keys for them.)</p>

    <p class="text-gray-300"><strong>Simulation of the Join Protocol:</strong> In this operation, a user asks the group manager, via  <span class="math">\\mathcal{F}_{gs}</span> , if it can join the group and receives an answer bit.</p>

    <p class="text-gray-300">Case (gu): If both the group manager and the user are corrupt, then S does nothing.</p>

    <p class="text-gray-300">Case (Gu): The group manager is honest, but the user is corrupt. Then,  <span class="math">\\mathcal{A}</span>  will start by sending  <span class="math">\\mathcal{S}</span>  the public key  <span class="math">pk = (p_1, p_2)</span>  and tracing information Q associated with some corrupt user  <span class="math">\\mathcal{U}_i</span> .  <span class="math">\\mathcal{S}</span>  will verify the tracing information by checking that  <span class="math">e(p_1, Q) = p_2</span> . If this check does not pass,  <span class="math">\\mathcal{S}</span>  returns an error message to the corrupt user and ends the Join protocol. Otherwise,  <span class="math">\\mathcal{S}</span>  stores the pair (pk, Q) in a database D. Now  <span class="math">\\mathcal{S}</span> , acting as the honest group manager with knowledge of GSK, executes the remainder of the real-world Join protocol with  <span class="math">\\mathcal{A}</span> , exiting with an error message when necessary according to the protocol. If  <span class="math">\\mathcal{S}</span>  does not output an error message, then  <span class="math">\\mathcal{S}</span>  submits  <span class="math">(\\mathcal{U}_i</span> , &quot;enroll&quot;) to  <span class="math">\\mathcal{F}_{qs}</span> .</p>

    <p class="text-gray-300">Case (gU): The group manager is corrupt, but the user is honest. S will be triggered in this case by  <span class="math">\\mathcal{F}_{gs}</span>  asking if some honest user  <span class="math">\\mathcal{U}_i</span>  may enroll. S will internally simulate a real-world version of  <span class="math">\\mathcal{U}_i</span>  towards A using the key pair S generated for  <span class="math">\\mathcal{U}_i</span>  during the user setup phase. If A stops before the end of the protocol, S returns the answer &quot;no&quot; to  <span class="math">\\mathcal{F}_{gs}</span> . If the  <span class="math">CL^+</span>  signature obtained by S during step 2 of the Join protocol verifies, then S records this certificate and returns &quot;yes&quot; to  <span class="math">\\mathcal{F}_{gs}</span> . Otherwise, it returns &quot;no&quot;.</p>

    <p class="text-gray-300">Case (GU): If both the group manager and the user are honest, then S does nothing.</p>

    <p class="text-gray-300">Simulation of the GroupSign Operation: Let id be a counter initialized to zero. In this operation, a user anonymously obtains a signature on a message via  <span class="math">\\mathcal{F}_{gs}</span> . When an honest member of the group requests to sign a message m,  <span class="math">\\mathcal{F}_{gs}</span>  will forward (&quot;sign&quot;, m) to  <span class="math">\\mathcal{S}</span> . When  <span class="math">\\mathcal{A}</span>  outputs a real-world signature,  <span class="math">\\mathcal{S}</span>  will be responsible for translating it into the ideal world.</p>

    <p class="text-gray-300">Here, we denote by  <span class="math">sk^*</span>  the special signing key that S uses to sign all messages, for <em>all</em> honest parties when the group manager is honest.</p>

    <p class="text-gray-300">Case (u): The user is corrupt. When  <span class="math">\\mathcal{A}</span>  outputs a valid signature  <span class="math">\\sigma=(a_1,\\ldots,a_8)</span>  on message  <span class="math">m,\\mathcal{S}</span>  tests if it is a (partial) re-randomization of any previous signature; that is, for all signatures  <span class="math">(b_1,\\ldots,b_8)</span>  on message m in L, test if  <span class="math">a_7=b_7</span>  (this corresponds to the value  <span class="math">\\tilde{g}^{1/(sk+v)}</span> ). If any match is found,  <span class="math">\\mathcal{S}</span>  takes no further action.</p>

    <p class="text-gray-300">However, when no match is found, S must register the signature with  <span class="math">\\mathcal{F}_{gs}</span> . To do so, S must first discover the signer of  <span class="math">\\sigma</span> . For every registered user, S uses the tracing information in database D to check if  <span class="math">e(a_1,Q_i)=e(a_4,\\tilde{g})</span> . Suppose a match is found for some  <span class="math">Q_i=\\tilde{g}^{sk_i}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">sk_i = sk^*</span> , then the simulation has failed. S aborts and outputs &quot;Failure 2&quot;.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">sk_i \\neq sk^*</span>  and  <span class="math">\\mathcal{U}_i</span>  is honest, the simulation has failed.  <span class="math">\\mathcal{S}</span>  aborts and outputs &quot;Failure 3&quot;.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">U_i</span>  is corrupted, then S records  <span class="math">(U_i, \\sigma, m, id)</span>  in L, and sends  <span class="math">(U_i, \\text{&quot;sign&quot;}, m, id)</span>  on behalf of corrupt  <span class="math">U_i</span>  to  <span class="math">\\mathcal{F}_{as}</span> . S increments the counter id.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">If no match for any registered user was found, then:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Subcase (gu): The group manager being corrupt, S records (corrupt- <span class="math">\\mathcal{GM}</span> ,  <span class="math">\\sigma</span> , m, id) in L, chooses an identity  <span class="math">\\mathcal{U}_i</span>  at random among the corrupt users, and sends ( <span class="math">\\mathcal{U}_i</span> , &quot;sign&quot;, m, id) on behalf of corrupt- <span class="math">\\mathcal{GM}</span>  to  <span class="math">\\mathcal{F}_{qs}</span> . S increments the counter id.</li>
      <li>Subcase (Gu): If the group manager is honest, the simulation has failed. S aborts and outputs &quot;Failure 4&quot;.</li>
    </ul>

    <p class="text-gray-300">Case (gU): The group manager is corrupt, but the user is honest. Since the group manager is corrupt,  <span class="math">\\mathcal{F}_{gs}</span>  additionally tells  <span class="math">\\mathcal{S}</span>  the identity  <span class="math">\\mathcal{U}_i</span>  of the honest user requesting a signature. Then  <span class="math">\\mathcal{S}</span>  generates a real-world group signature  <span class="math">\\sigma</span>  for the simulated  <span class="math">\\mathcal{U}_i</span> , using that user's certificate (obtained during</p>

    <p class="text-gray-300">Join) and that user's secret key (which S created during the user setup phase). S records this entry (U&lt;sup&gt;i&lt;/sup&gt; , σ, m, id) in an internal database L. Finally, S provides A with the real-world signature (σ, m), and returns the &quot;ideal signature&quot; id to Fgs and increments id.</p>

    <p class="text-gray-300">Case (GU): Both the group manager and the user are honest. As stated above, S is triggered by a request (&quot;sign&quot;,m) from Fgs. This time the ideal-world identity of the honest user is not known to S. However, S still needs to provide A with <em>some</em> group signature, thus it proceeds as follows. S generates a real-world group signature σ using the secret key GSK of the group manager (which S created during the group setup phase) and the secret key of the first honest group member sk &lt;sup&gt;∗&lt;/sup&gt; that it simulates towards A (which S also created during the user setup phase). Since all signatures are considered public information, S must forward the values (σ, m) to A. As before, S records the entry (?, σ, m, id) in an internal database L. Finally, S returns the &quot;ideal signature&quot; id to Fgs and increments id.</p>

    <p class="text-gray-300"><strong>Simulation of the GroupVerify Operation:</strong> The simulator does not take any action on this operation. A will be able to verify all real-world signatures within its view itself. Furthermore, Fgs verifies signatures for honest users without informing S.</p>

    <p class="text-gray-300"><strong>Simulation of the Open Operation:</strong> The simulator is triggered on this operation in a variety of ways. There are two parties to consider: the group manager and the user requesting the opening (i.e., the verifier).</p>

    <p class="text-gray-300">On the request (&quot;open&quot;, σ, m) from a real-world corrupted user, S first runs its ideal-world Group-Sign algorithm for receiving (σ, m) from A.</p>

    <p class="text-gray-300">Case (gu): Both the group manager and the verifier are corrupted. S does nothing.</p>

    <p class="text-gray-300">Case (gU): The group manager is corrupted, but the verifier is honest. Fgs asks S (as the corrupted group manager) if it may open the ideal-world tuple (U&lt;sup&gt;i&lt;/sup&gt; , m, id). (Recall that if U&lt;sup&gt;i&lt;/sup&gt; = corrupt-GM, then Fgs refuses to open the signature.) S searches its database L for an entry (U&lt;sup&gt;j&lt;/sup&gt; , σ, m, id), where σ is a real-world signature on m for some user U&lt;sup&gt;j&lt;/sup&gt; . Since the id's are unique, only one such entry will exist. Next, S, acting as an honest, real-world verifier toward A, engages A in the VerifyOpen protocol with common input (U&lt;sup&gt;i&lt;/sup&gt; , m, σ). If S, as an honest verifier, does not accept this proof, then S tells Fgs to refuse to open this signature. If S accepts this verification from A and U&lt;sup&gt;i&lt;/sup&gt; = U&lt;sup&gt;j&lt;/sup&gt; , then S tells Fgs to open the signature. Finally, if S accepts this verification and yet U&lt;sup&gt;i&lt;/sup&gt; 6= U&lt;sup&gt;j&lt;/sup&gt; , then our simulation has failed. S aborts and outputs &quot;Failure 1&quot;.</p>

    <p class="text-gray-300">Case (Gu): The group manager is honest, but the verifier is corrupted. Since the verifier is corrupted, it may ask about the openings of any signatures it likes. (For example, it may re-randomize a valid signature, etc.) Suppose A, acting as a corrupt verifier, requests an opening on (m, σ). The first thing that S does is to check if σ is a valid group signature (according to the real-world verification algorithm) on m under the group public key GPK. If it is not, then S returns an error message, ⊥, to A. Otherwise, S proceeds.</p>

    <p class="text-gray-300">Now, S must figure out which user, if any, is responsible for σ. First, S uses its tracing database to test if any registered user is responsible for σ. Specifically for σ = (a1, . . . , a8) and tracing information Q&lt;sup&gt;j&lt;/sup&gt; , S checks if e(a1, Q&lt;sup&gt;j&lt;/sup&gt; ) = e(a4, g˜).</p>

    <p class="text-gray-300">If σ opens to some registered user U&lt;sup&gt;j&lt;/sup&gt; , then there are three cases.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>U&lt;sup&gt;j&lt;/sup&gt; is corrupted. This is not considered a forgery. S honestly runs the real-world VerifyOpen</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>protocol with A on common inputs (U&lt;sup&gt;j&lt;/sup&gt; , m, σ). This transaction can be completely simulated by S without involving Fgs.</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>U&lt;sup&gt;j&lt;/sup&gt; is honest, and sk&lt;sup&gt;j&lt;/sup&gt; = sk &lt;sup&gt;∗&lt;/sup&gt; . Here, S needs to further differentiate if σ is a forgery or merely a re-randomization of a previous signature. (Observe that the first part of our signatures may be rerandomized.) To do this, S searches database L and complies a list of all entries (?, σ&lt;sup&gt;i&lt;/sup&gt; , m, idi) containing message m. Next, S checks whether σ = (a1, . . . , a8) is derived from any σ&lt;sup&gt;i&lt;/sup&gt; = (b1,i, . . . , b8,i) by checking if a&lt;sup&gt;7&lt;/sup&gt; = b7,i.</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If S finds a match for some entry i, then it sends the request (&quot;open&quot;, m, idi) to Fgs. Suppose Fgs returns the identity Ux. Now, S must prove this opening to A. S did not know who the ideal-world signer was at the time it created σ under sk &lt;sup&gt;∗&lt;/sup&gt; (recall that our simulator creates all signatures using sk &lt;sup&gt;∗&lt;/sup&gt; ), thus it must now fake a real-world VerifyOpen opening towards A. That is, S must open σ = (a1, . . . , a8) to user U&lt;sup&gt;x&lt;/sup&gt; with pk&lt;sup&gt;x&lt;/sup&gt; = (hx, e(hx, g˜) skx). S simulates the interactive VerifyOpen proof as follows [1]. Let pk&lt;sup&gt;x&lt;/sup&gt; = (p1, p2). Recall that this is proof of knowledge of a value α ∈ G&lt;sup&gt;2&lt;/sup&gt; such that e(p1, α) = p&lt;sup&gt;2&lt;/sup&gt; and e(a1, α) = e(a4, g˜).    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>i. A selects a random challenge c ∈ Z&lt;sup&gt;p&lt;/sup&gt; and sends C = PedCom(c) to S.</li>
      <li>ii. S selects a random r ∈ Z&lt;sup&gt;p&lt;/sup&gt; and sends (t1, t2) = (e(p r 1 , g˜), e(a r 1 , g˜)) to A.</li>
      <li>iii. A sends c along with the opening of commitment C.</li>
      <li>iv. S verifies that C opens to c and, if so, sends s = (˜g skx) c g˜ r to A.</li>
      <li>v. A accepts if and only if: (1) e(p1, s) = (p2) c t&lt;sup&gt;1&lt;/sup&gt; and (2) e(a1, s) = e(a4, g˜) c t2.</li>
    </ul></li>
      <li>(b) If S does not find a match for any entry i, then A has succeeded in a forgery against user U&lt;sup&gt;j&lt;/sup&gt; with sk&lt;sup&gt;j&lt;/sup&gt; = sk &lt;sup&gt;∗&lt;/sup&gt; . The simulation fails. S aborts and outputs &quot;Failure 2&quot;.</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>U&lt;sup&gt;j&lt;/sup&gt; is honest, and sk&lt;sup&gt;j&lt;/sup&gt; 6= sk &lt;sup&gt;∗&lt;/sup&gt; . S immediately knows σ is a forgery, because S signs for all honest users with the key sk &lt;sup&gt;∗&lt;/sup&gt; . The simulation fails. S aborts and outputs &quot;Failure 3&quot;.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">If σ does not open to any registered user, then A has succeeded in creating a valid group signature for a non-registered user. That is, for all tracing information Q&lt;sup&gt;i&lt;/sup&gt; known to S and letting σ = (a1, . . . , a8), we have e(a1, Qi) 6= e(a4, g˜). In this case, S aborts and outputs &quot;Failure 4&quot;.</p>

    <p class="text-gray-300">Case (GU): Both the group manager and the verifier are honest. S does nothing. S will not even know that this transaction has taken place.</p>

    <p class="text-gray-300">This ends our description of simulator S. It remains to show that S works; that is, under the Strong LRSW, the EDH, and the Strong SXDH assumptions, the simulator will not abort, except with negligible probability, and that the environment will not be able to distinguish between the real and ideal worlds.</p>

    <p class="text-gray-300"><strong>Claim A.1</strong> <em>Conditioned on the fact that</em> S <em>never aborts,</em> Z <em>cannot distinguish between the real world and the ideal world under the Strong LRSW, the EDH, and the Strong SXDH assumptions.</em></p>

    <p class="text-gray-300"><em>Proof.</em> To see this, let us explore each operation. First, we observe that in GroupSetup and UserKeyGen, the simulator S performs all key generation operations as the respective players in the real world would do. The simulator never deviates from the actions of any honest player during Join and it need not take any action during GroupVerify. In the real world, anyone may verify a signature autonomously. The remaining operations to consider are GroupSign and VerifyOpen.</p>

    <p class="text-gray-300">Let us begin with GroupSign. In this operation, S only needs to take action when it must translate an honest party ideal-world signature into a real-world signature, or a corrupted party real-world signature into an ideal-world one. When the user is corrupted, S submits &quot;sign&quot; requests for A whenever it outputs a new signature. There is nothing here for A to observe.</p>

    <p class="text-gray-300">When the user is honest, however, then S must generate real-world signatures towards A. When the group manager is corrupted, then  <span class="math">\\mathcal{F}_{gs}</span>  tells S which user is signing the message, and thus S may perfectly generate a real-world signature for A. S is only forced to deviate in case (GU) when it must simulate both the honest group manager and honest signer towards A. The problem is that S does not know which user is requesting a signature on some message m; thus S always signs with the same honest user key  <span class="math">sk^*</span> . By Lemma A.2, we know that neither A nor Z can distinguish between this homogeneous, ideal-world distribution of signatures and the heterogeneous, real-world distribution.</p>

    <p class="text-gray-300">Now, it remains to consider VerifyOpen. In this operation, S only takes action when one of the two parties is corrupted. In the case (gU), S behaves exactly as an honest verifier would towards A; that is, S finds the (single)  <span class="math">\\sigma</span>  associated with id, and acts as an honest verifier towards A. We will later argue that it does not abort, due to Failure 1, in this step.</p>

    <p class="text-gray-300">The case (Gu), however, is more complicated. Suppose  <span class="math">\\mathcal{S}</span>  is being asked by  <span class="math">\\mathcal{A}</span>  to open  <span class="math">(m,\\sigma)</span> . If  <span class="math">\\sigma</span>  opens to a corrupted user or does not open to any registered user, then  <span class="math">\\mathcal{S}</span>  behaves exactly as an honest  <span class="math">\\mathcal{GM}</span>  would. However, what happens when  <span class="math">\\sigma</span>  opens to an honest user? We will later argue that  <span class="math">\\mathcal{S}</span>  is not forced to abort due to Failures 2, 3, or 4. Even conditioned on this fact,  <span class="math">\\mathcal{S}</span>  will almost always be forced to deviate since it signed using key  <span class="math">sk^*</span>  for all honest users and now must open the signatures to whichever honest party  <span class="math">\\mathcal{F}_{gs}</span>  dictates. Suppose  <span class="math">\\mathcal{S}</span>  is told to open  <span class="math">\\sigma=(a_1,\\ldots,a_8)</span>  to some honest user  <span class="math">\\mathcal{U}_i</span> , where  <span class="math">sk_i\\neq sk^*</span> , then  <span class="math">\\mathcal{S}</span>  must fake the VerifyOpen protocol toward  <span class="math">\\mathcal{A}</span> .  <span class="math">\\mathcal{S}</span>  succeeds in doing this, in the usual way, by requiring  <span class="math">\\mathcal{A}</span>  to commit to his challenge and then resetting  <span class="math">\\mathcal{A}</span>  after seeing the challenge. That is, after seeing  <span class="math">c\\in\\mathbb{Z}_p</span> ,  <span class="math">\\mathcal{S}</span>  chooses a random value  <span class="math">s\\in\\mathbb{G}_2</span>  and computes  <span class="math">sk_1=e(p_1,s)/p_2^c</span>  and  <span class="math">sk_2=e(a_1,s)/e(a_4,\\tilde{g})^c</span> , where  <span class="math">sk_3=e(p_1,p_2)</span> . Now  <span class="math">\\mathcal{S}</span>  rewinds  <span class="math">\\mathcal{A}</span>  to right after it sent a commitment to  <span class="math">sk_2=e(a_1,s)/e(a_4,\\tilde{g})^c</span> , where  <span class="math">sk_3=e(a_1,s)/e(a_4,\\tilde{g})^c</span>  with a valid opening, and returns the response  <span class="math">sk_3=e(a_1,s)/e(a_1,s_2)</span> , receives  <span class="math">sk_3=e(a_1,s_2)</span> . Now  <span class="math">sk_3=e(a_1,s_2)</span>  in the unlikely event that  <span class="math">sk_3=e(a_1,s_2)</span>  is able to break the binding property of the Pedersen commitments (i.e., CDH in  <span class="math">sk_3=e(a_1,s_2)</span> ).</p>

    <p class="text-gray-300">This concludes our proof of Claim A.1. It remains to show that, except with negligible probability, S will not abort. Recall that S may abort under the following conditions:</p>

    <p class="text-gray-300">• Failure 1:  <span class="math">\\mathcal{A}</span>  breaks exculpability. We argue that it is not possible for a dishonest group manager to falsely open a signature; i.e.,  <span class="math">\\mathcal{A}</span>  is not able to successfully complete the VerifyOpen protocol with  <span class="math">\\mathcal{S}</span>  on common input  <span class="math">(\\mathcal{U}_i, m, \\sigma)</span>  where  <span class="math">\\mathcal{U}_i</span>  is not the real signer. Here, the simulation fails, because  <span class="math">\\mathcal{F}_{gs}</span>  will only open signatures honestly.</p>

    <p class="text-gray-300">We now argue that, for a given VerifyOpen instance  <span class="math">(\\mathcal{U}_i, m, \\sigma)</span> , an adversary that can cause Failure 1 with probability  <span class="math">\\varepsilon</span>  can be used to break the Co-CDH assumption with probability  <span class="math">\\geq (\\varepsilon - 1/p)^2</span> . (Recall from Section 3.1 that Co-CDH is implied by the Strong SXDH assumption.) On Co-CDH input  <span class="math">(g, \\tilde{g}, g^x, \\tilde{g}^y)</span> , the goal is to compute  <span class="math">\\tilde{g}^{xy}</span>  and the simulator proceeds as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Step 1: S initiates the VerifyOpen protocol with A on input  <span class="math">(U_i, m, \\sigma)</span> , setting  <span class="math">pk_i = (g^z, e(g^{zx}, \\tilde{g}^y))</span> , for random  <span class="math">z \\in \\mathbb{Z}_p</span> , and computing  <span class="math">\\sigma</span>  as a valid signature on m for the user with  <span class="math">sk^*</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Step 2: S commits to all zeros, as  <span class="math">C = \\text{PedCom}(0^{|p|})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Step 3: After receiving  <span class="math">(t_1, t_2)</span>  from  <span class="math">\\mathcal{A}</span> ,  <span class="math">\\mathcal{S}</span>  using its knowledge of the relation of the Pedersen public parameters to fake the openings as:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>selects a random challenge  <span class="math">c_1 \\in \\mathbb{Z}_p</span> , opens C to  <span class="math">c_1</span> , and obtains A's response  <span class="math">s_1</span> .</li>
    </ul></li>
      <li><p class="text-gray-300">rewinds A, selects a different random challenge  <span class="math">c_2 \\in \\mathbb{Z}_p</span> , opens C to  <span class="math">c_2</span> , and obtains A's response  <span class="math">s_2</span> .</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Step 4: S computes and outputs  <span class="math">(s_1/s_2)^{1/(c_1-c_2)}</span>  (which hopefully corresponds to  <span class="math">\\tilde{g}^{xy}</span> ).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">In Step 1, the adversary cannot tell that it was given a signature under  <span class="math">sk^*</span>  instead of  <span class="math">sk_i</span>  due to Lemma A.2. The fake openings in Step 4 are perfectly indistinguishable from an honest opening due to the perfect hiding property of Pedersen commitments. If both  <span class="math">((t_1,t_2),c_1,s_1)</span>  and  <span class="math">((t_1,t_2),c_2,s_2)</span>  are valid transcripts, then  <span class="math">\\mathcal S</span>  outputs  <span class="math">\\tilde g^{xy}</span>  in Step 4 with probability  <span class="math">\\geq (\\varepsilon-1/p)^2</span> . Our bound of  <span class="math">(\\varepsilon-1/p)^2</span>  comes from the well-known Reset Lemma [10], where the advantage of  <span class="math">\\mathcal A</span>  was given as  <span class="math">\\varepsilon</span>  and the size of the challenge set is p.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Failure 2:  <span class="math">\\mathcal{A}</span>  creates a forgery against the honest user with  <span class="math">sk^*</span> .  <span class="math">\\mathcal{A}</span>  produces signature  <span class="math">\\sigma=(a_1,\\ldots,a_8)</span>  and message m s.t. GroupVerify <span class="math">(GPK,\\sigma,m)=1</span> ,  <span class="math">\\sigma</span>  opens to  <span class="math">\\mathcal{U}^*</span>  (i.e.,  <span class="math">e(a_1,Q^*)=e(a_4,\\tilde{g})</span> ), and yet  <span class="math">\\mathcal{S}</span>  never gave  <span class="math">\\mathcal{A}</span>  this user's signature on m. This scenario occurs with only negligible probability under the EDH assumption, regardless of whether the group manager is corrupted.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Recall that EDH takes as input  <span class="math">(g, g^x, \\tilde{g}, \\tilde{g}^x)</span>  together with access to oracle  <span class="math">O_x(\\cdot)</span>  that takes input  <span class="math">c \\in \\mathbb{Z}_p^*</span>  and produces output  <span class="math">(g^x, \\tilde{g}^{1/(x+v)}, \\tilde{g}^{1/(v+c)})</span>  for a random  <span class="math">v \\in \\mathbb{Z}_p^*</span> . The goal is to produce a tuple  <span class="math">(c, a, a^v, \\tilde{g}^{\\frac{1}{x+v}}, \\tilde{g}^{\\frac{1}{v+c}})</span>  for any  <span class="math">a \\in \\mathbb{G}_1</span>  and any  <span class="math">v, c \\in \\mathbb{Z}_p^*</span>  such that c was not queried to the oracle. Let  <span class="math">\\tau</span>  be the number of honest users in the system. When A succeeds with probability  <span class="math">\\varepsilon</span> , then B solves</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Let  <span class="math">\\tau</span>  be the number of honest users in the system. When  <span class="math">\\mathcal{A}</span>  succeeds with probability  <span class="math">\\varepsilon</span> , then  <span class="math">\\mathcal{B}</span>  solves the EDH problem with probability  <span class="math">\\varepsilon/\\tau</span> .  <span class="math">\\mathcal{B}</span>  proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Setup:  <span class="math">\\mathcal{B}</span>  must establish the global parameters and key generation.</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Output  <span class="math">(g, \\tilde{g})</span>  as the public parameters for the group signature scheme, and  <span class="math">GPK = (\\tilde{S}, \\tilde{T}) = (\\tilde{g}^s, \\tilde{g}^t)</span>  on behalf of the group manager. If  <span class="math">\\mathcal{GM}</span>  is corrupt, GPK is given to  <span class="math">\\mathcal{S}</span>  by  <span class="math">\\mathcal{A}</span> . Setup all remaining keys and parameters as  <span class="math">\\mathcal{S}</span>  would normally do.</li>
      <li>(b) Guess which of the  <span class="math">\\tau</span>  honest users  <span class="math">\\mathcal{A}</span>  will attack. Give this user  <span class="math">\\mathcal{U}^*</span>  the public key  <span class="math">pk^* = (g^r, e(g^r, \\tilde{g}^x))</span> , for random  <span class="math">r \\in \\mathbb{Z}_p</span> . (Logically this assigns the user's secret key as  <span class="math">sk^* = x</span> .)</li>
      <li>(c) Obtain group certificates for all honest users;  <span class="math">\\mathcal{B}</span>  fakes the proof of knowledge of  <span class="math">sk^*</span>  using any of the techniques discussed in Section 5 (Join). Finally,  <span class="math">\\mathcal{B}</span>  submits the <em>correct</em> tracing information,  <span class="math">Q^* = \\tilde{g}^{sk^*} = \\tilde{g}^x</span> , for this user.</li>
      <li>(d) If the group manager is corrupt, extract the group key GSK = (s,t) during the proof of knowledge.</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Signing: When  <span class="math">\\mathcal{A}</span>  requests a signature from a user not associated with  <span class="math">sk^* = x</span> , sign as normal. Now, when  <span class="math">\\mathcal{A}</span>  asks for a group signature on  <span class="math">m \\in \\mathbb{Z}_p^*</span>  from the honest user associated with secret key  <span class="math">sk^* = x</span> , do:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Query oracle  <span class="math">O_x(m)</span>  to get output  <span class="math">(f_1, f_2, f_3)</span> .</li>
      <li>(b) Select a random  <span class="math">r \\in \\mathbb{Z}_p</span> . Use GSK = (s, t), to output the group signature on m as</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$(g^r, g^{tr}, g^{sr}(g^x)^{str}, (g^x)^r, (g^x)^{tr}, f_1^r, f_2, f_3).</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Opening:  <span class="math">\\mathcal{B}</span>  honestly executes the VerifyOpen protocol with  <span class="math">\\mathcal{A}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output: Suppose  <span class="math">\\mathcal{A}</span>  produces a valid signature  <span class="math">\\sigma&#x27; = (a_1, \\ldots, a_8)</span>  for a new message  <span class="math">m&#x27; \\in \\mathbb{Z}_p^*</span>  for the user with key  <span class="math">sk^* = x</span> . Then  <span class="math">\\mathcal{B}</span>  outputs  <span class="math">(m&#x27;, a_1, a_4, a_6, a_7, a_8)</span>  to solve the EDH problem.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">It is easy to observe that  <span class="math">\\mathcal{B}</span>  perfectly simulates the group signature world for  <span class="math">\\mathcal{A}</span> .  <span class="math">\\mathcal{B}</span>  has probability  <span class="math">1/\\tau</span>  of choosing which honest user  <span class="math">\\mathcal{A}</span>  will forge against. Thus, when  <span class="math">\\mathcal{A}</span>  succeeds with probability  <span class="math">\\varepsilon</span> , then  <span class="math">\\mathcal{B}</span>  solves the EDH problem with probability  <span class="math">\\varepsilon/\\tau</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Failure 3:  <span class="math">\\mathcal{A}</span>  creates a forgery against a user with  <span class="math">sk_j \\neq sk^*</span> . Proof that this failure occurs with only negligible probability follows directly from that of Failure 2. Indeed,  <span class="math">\\mathcal{A}</span>  has strictly less information at its disposal; that is,  <span class="math">\\mathcal{A}</span>  never sees real signatures under key  <span class="math">sk_j</span> .</li>
      <li>Failure 4:  <span class="math">\\mathcal{A}</span>  creates a valid signature for a non-registered user. In this case,  <span class="math">\\mathcal{A}</span>  produces a signature-message pair  <span class="math">(\\sigma, m)</span>  such that GroupVerify <span class="math">(GPK, \\sigma, m) = 1</span>  and yet it cannot be opened by  <span class="math">\\mathcal{S}</span>  to any registered user. We now argue that this is not possible under the Strong LRSW assumption, except with negligible probability. Suppose we are given  <span class="math">(g, \\tilde{g}, \\tilde{g}^s, \\tilde{g}^t)</span>  as the Strong LRSW input.</li>
    </ul>

    <p class="text-gray-300">Instead of running GroupSetup, let the public parameters  <span class="math">g, \\tilde{g} \\in params</span>  and the public key  <span class="math">GPK = (\\tilde{S}, \\tilde{T}) = (\\tilde{g}^s, \\tilde{g}^t)</span> . During the UserKeyGen operation, for any honest users, S queries the Strong LRSW oracle  <span class="math">O_{\\tilde{S},\\tilde{T}}</span>  on a random  <span class="math">sk_i \\in \\mathbb{Z}_p</span>  to obtain a membership certificate  <span class="math">(a, a^t, a^{s+st(sk_i)})</span> , for any  <span class="math">a \\in \\mathbb{G}_1</span> . (This tuple is, in fact, a CL signature on  <span class="math">sk_i</span>  [19].) S now uses  <span class="math">sk_i</span>  as the secret key for this honest user.</p>

    <p class="text-gray-300">When S is asked to execute Join with an <em>honest</em> user, S simply finds the corresponding CL signature and uses it to output the certificate  <span class="math">(a, a^t, a^{s+st(sk_i)}, a^{sk_i}, a^{t(sk_i)})</span> . When S is asked to execute Join with a <em>corrupted</em> user, S extracts the user's secret key  <span class="math">sk_j</span>  using any of the techniques discussed in Section 5 (Join), queries the Strong LRSW oracle on input  <span class="math">sk_j</span> , and uses the oracle's output to create a valid certificate for this corrupt user. Now, the adversary can sign any message for a corrupt user, and S can honestly respond to any GroupSign call for an honest user.</p>

    <p class="text-gray-300">Suppose that Failure 1 has occurred during VerifyOpen, meaning that  <span class="math">\\mathcal{A}</span>  output a signature  <span class="math">\\sigma = (a_1, \\ldots, a_8)</span>  such that the following relations hold:</p>

    <p class="text-gray-300"><span class="math">$e(a_1, \\tilde{T}) = e(a_2, \\tilde{g}), \\quad e(a_4, \\tilde{T}) = e(a_5, \\tilde{g}), \\quad e(a_1 a_5, \\tilde{S}) = e(a_3, \\tilde{g})</span>$</p>

    <p class="text-gray-300">and yet S did <em>not</em> query  <span class="math">O_{\\tilde{S},\\tilde{T}}</span>  on the corresponding secret key; that is, for all  <span class="math">sk_i</span>  known to S, we have  <span class="math">a_1^{sk_i} \\neq a_4</span> . Then, S may output  <span class="math">(a_1, a_2, a_3, a_4, a_5)</span>  to break the Strong LRSW assumption.</p>

    <p class="text-gray-300">Combining Claim A.1 with the above arguments that S will not abort, except with negligible probability, concludes our main proof.</p>

    <p class="text-gray-300">We end by proving a Lemma used in the above proof. Intuitively, this Lemma captures the anonymity of our signatures. In the below, the values  <span class="math">u_1, \\ldots, u_{\\tau}</span>  may be thought of as the secret keys of  <span class="math">\\tau</span>  different honest users.</p>

    <p class="text-gray-300"><strong>Lemma A.2</strong> (Anonymity of Signatures) Suppose we have the group signature parameters from Section 5; that is, security parameter  <span class="math">1^k</span> , params, and GPK. Suppose  <span class="math">u_1, \\ldots, u_{\\tau}</span>  are random elements of  <span class="math">\\mathbb{Z}_p</span> . Let  <span class="math">O_{u_1,\\ldots,u_{\\tau}}(\\cdot,\\cdot)</span>  be an oracle that takes as input a message  <span class="math">m \\in \\mathbb{Z}_p^*</span>  and an index  <span class="math">1 \\leq i \\leq \\tau</span> , and outputs a group signature  <span class="math">(a_1,\\ldots,a_8)</span>  on m with user secret key  <span class="math">u_i</span> . Then, under the Strong SXDH assumptions, for all probabilistic polynomial-time adversaries A, the following value is negligible in k:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathcal{A}^{O_{u_1,u_2,...,u_{\\tau}}}(params, GPK, \\{pk_i\\}_{i \\in [1,\\tau]}) = 1\\right] - \\Pr\\left[\\mathcal{A}^{O_{u_1,u_1,...,u_1}}(params, GPK, \\{pk_i\\}_{i \\in [1,\\tau]}) = 1\\right].</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> First, if  <span class="math">\\mathcal{A}</span>  can distinguish between oracles  <span class="math">O_{u_1,u_2,...,u_{\\tau}}</span>  and  <span class="math">O_{u_1,u_1,...,u_1}</span> , then we can create an adversary  <span class="math">\\mathcal{B}</span>  that can distinguish between oracles  <span class="math">O_{u_1,u_2}</span>  and  <span class="math">O_{u_1,u_1}</span> . Next, we show that adversary  <span class="math">\\mathcal{B}</span>  can be used to break the Strong SXDH assumption. Overall, if  <span class="math">\\mathcal{A}</span>  succeeds with probability  <span class="math">\\varepsilon</span> , then we can break Strong SXDH with probability  <span class="math">\\geq \\varepsilon/\\tau</span> .</p>

    <p class="text-gray-300">Stage One. First, we make the simple hybrid argument that given  <span class="math">\\mathcal{A}</span> , which can distinguish the signatures of  <span class="math">\\tau</span>  distinct honest users from those of a single user, we can create an adversary  <span class="math">\\mathcal{B}</span>  that can distinguish the signatures of only 2 distinct users from those of a single user. Indeed, by the hybrid argument, we know that if  <span class="math">\\mathcal{A}</span>  distinguishes with probability  <span class="math">\\varepsilon</span> , then for some  <span class="math">1 \\leq \\ell \\leq \\tau</span> ,  <span class="math">\\mathcal{A}</span>  can distinguish with probability  <span class="math">\\geq \\varepsilon/\\tau</span>  between the oracle instantiated with  <span class="math">\\ell</span>   <span class="math">u_1</span> 's followed by  <span class="math">\\tau - \\ell</span>  different seeds and the oracle instantiated with  <span class="math">\\ell + 1</span>   <span class="math">u_1</span> 's followed by  <span class="math">\\tau - \\ell - 1</span>  different values. The obvious reduction follows; that is, the two oracles of  <span class="math">\\mathcal{B}</span>  will be applied to this hybrid point for  <span class="math">\\mathcal{A}</span> .  <span class="math">\\mathcal{B}</span>  will then return whatever answer  <span class="math">\\mathcal{A}</span>  does.</p>

    <p class="text-gray-300">Stage Two. Now, we show that  <span class="math">\\mathcal{B}</span>  can be used to create another adversary  <span class="math">\\mathcal{C}</span>  that breaks Strong SXDH. On Strong SXDH input  <span class="math">(g, g^x, \\tilde{g})</span> , the adversary  <span class="math">\\mathcal{C}</span>  proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate group public key GPK as  <span class="math">(\\tilde{S}, \\tilde{T}) = (\\tilde{g}^s, \\tilde{g}^t)</span>  for random  <span class="math">s, t \\in \\mathbb{Z}_p</span> . Give GPK to  <span class="math">\\mathcal{B}</span> ; store GSK = (s, t). (Remember, anonymity only makes sense when the group manager is honest, so the adversary does not get to set these keys.)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Query  <span class="math">Q_y</span>  on a random input, disregard all output except  <span class="math">(h, h^y)</span>  for some  <span class="math">h \\in \\mathbb{G}_1</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate the two user keys as  <span class="math">pk_1=(g,e(g^x,\\tilde{g}))</span>  for user  <span class="math">\\mathcal{U}_1</span>  and  <span class="math">pk_2=(h,e(h^y,\\tilde{g}))</span>  for user  <span class="math">\\mathcal{U}_2</span> . Give  <span class="math">pk_1,pk_2</span>  to  <span class="math">\\mathcal{B}</span> . (This first key could be re-randomized away from the public parameters by choosing a random  <span class="math">r\\in\\mathbb{Z}_p</span>  and setting  <span class="math">pk_1=(g^r,e(g^x,\\tilde{g})^r)</span> . This has no effect on the remainder, and for clarity we omit it.)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>When  <span class="math">\\mathcal{B}</span>  requests a signature for index  <span class="math">i \\in \\{1,2\\}</span>  on  <span class="math">m \\in \\mathbb{Z}_p^*</span> , if i=1, use  <span class="math">O_x(\\cdot)</span>  to do:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Query  <span class="math">O_x(m)</span>  to obtain the output  <span class="math">(g^v, \\tilde{g}^{1/(x+v)}, \\tilde{g}^{1/(v+m)})</span> , where  <span class="math">v \\in \\mathbb{Z}_p^*</span>  is a fresh random value chosen by the oracle. Denote this output as  <span class="math">(f_6, \\ldots, f_8)</span> .</li>
      <li>(b) Using GSK = (s, t), compute the remaining parts of the group signature:  <span class="math">f_2 = g^t</span> ,  <span class="math">f_3 = g^s(g^x)^{st}</span> ,  <span class="math">f_4 = g^x</span> , and  <span class="math">f_5 = (g^x)^t</span> .</li>
      <li>(c) Select a random  <span class="math">r \\in \\mathbb{Z}_p^*</span> , and return the signature  <span class="math">(g^r, f_2^r, f_3^r, f_4^r, f_5^r, f_6^r, f_7, f_8)</span> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">If i = 2, use oracle  <span class="math">O_u(\\cdot)</span>  to do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Query  <span class="math">Q_y(m)</span>  to obtain the output  <span class="math">(a, a^y, a^v, \\tilde{g}^{1/(y+v)}, \\tilde{g}^{1/(v+m)})</span> , where  <span class="math">a \\in \\mathbb{G}_1</span>  and  <span class="math">v \\in \\mathbb{Z}_p^*</span>  are fresh random values chosen by the oracle. Denote this output as  <span class="math">(f_1, f_4, f_6, \\ldots, f_8)</span> .</li>
      <li>(b) Using GSK = (s,t), compute the remaining parts of the group signature:  <span class="math">f_2 = a^t</span> ,  <span class="math">f_3 = a^s(a^x)^{st}</span> , and  <span class="math">f_5 = (a^y)^t</span> .</li>
      <li>(c) Return the signature  <span class="math">(f_1, \\ldots, f_8)</span> .</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Eventually,  <span class="math">\\mathcal{B}</span>  will attempt to distinguish whether he's been talking to oracle  <span class="math">O_{x,x}</span>  or oracle  <span class="math">O_{x,y}</span> . If  <span class="math">\\mathcal{B}</span>  says that he's been talking to oracle  <span class="math">O_{x,x}</span> , then output 1 corresponding to &quot;x = y&quot;. Otherwise, output 0 corresponding to &quot; <span class="math">x \\neq y</span> &quot;.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">It is easy to see that the stage 2 simulation is perfect; the output is always correct and perfectly distributed. Indeed, C and B will succeed with identical probabilities. This concludes our proof. We find that if any A can break the anonymity of our signatures with probability ε, then A can be used to break Strong SXDH with probability at least ε/τ , where τ is the number of honest users in the system. ✷</p>

    <h2 id="sec-16" class="text-2xl font-bold"><strong>B Towards a Concurrent Join Protocol</strong></h2>

    <p class="text-gray-300">In Section 5, we specified that the group manager runs the Join protocol sequentially with the different users. The reason for this is technical, i.e., to prove security we require that the users' secrets keys sk&lt;sup&gt;i&lt;/sup&gt; are <em>extractable</em>. To this end we require the users to commit to their secret key and then prove knowledge of them. If one uses the standard proof of knowledge protocol for the latter, extracting the users' secret keys requires rewinding of the users. It is well known that if these proofs of knowledge protocols are run concurrently with many users, then extracting all the secret keys can take time exponential in the number of users. There are, however, alternatives which allow for concurrent execution of these proofs and thus also of the Join protocol.</p>

    <p class="text-gray-300">First of all, one could require the group manager to run the protocol concurrently only with a limited numbers of users, i.e., by defining time intervals within which the group manager runs the protocol concurrently with a logarithmic number of users and enforcing a time-out if a protocol does not finish within this time interval. This solution would not give a group signature scheme that can be concurrently composed with other schemes.</p>

    <p class="text-gray-300">Solutions that would allow for concurrent executions come from applying one of the various transformations of a standard proof of knowledge protocol (or Σ-protocol) into one that can be executed concurrently.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>Common random reference string.</em> Assuming that the parties have a common random reference string available, one can interpret this as the key for an encryption scheme such that the corresponding secret key is not know to any party. Alternatively, one could have a (distributed) trusted third party generate such a public key (cf. [25]). Then, the users would be required to verifiably encrypt their secret key sk&lt;sup&gt;i&lt;/sup&gt; under this reference public key (e.g., using the techniques of Camenisch and Damgard [18]). For ˚ extraction of the secret keys in the security proof, the reference string would need to be patched such that the simulator knows the reference decryption key and thus can extract the users' secret keys by simple decryption.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>Non-concurrent setup phase.</em> When having a common random reference string or a trusted third party is impractical, each user can instead generate their own public key and then prove knowledge of the corresponding secret key in a setup phase where non-concurrent execution can be guaranteed (e.g, because the user's part is run by an isolated smart card). Then, during the Join protocol, the user would verifiably encrypt her secret key sk&lt;sup&gt;i&lt;/sup&gt; under <em>her own</em> public key pk&lt;sup&gt;i&lt;/sup&gt; .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>Assuming random oracles for</em> Join <em>only.</em> A third alternative that comes to mind, in the random oracle model, is to apply Fischlin's results [28]. Fischlin recently presented a transformation for turning any standard proof of knowledge (or Σ-protocol) into a non-interactive proof in the random oracle model that supports an online extractor (i.e., no rewinding).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The parameters required for any of these options (e.g., the hash function for option (c)) are assumed to be global information outside the control of the group manager.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8"><strong>C</strong> Open Algorithm with <span class="math">O(\\sqrt{n} \\cdot k)</span> Complexity from Trees.</h3>

    <p class="text-gray-300">As before, let  <span class="math">(p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, g, \\tilde{g})</span> , where  <span class="math">\\mathbb{G}_1 = \\langle g \\rangle</span>  and  <span class="math">\\mathbb{G}_2 = \\langle \\tilde{g} \\rangle</span> , be the global parameters for the bilinear groups.</p>

    <p class="text-gray-300">The intuition here is that group members are logically divided into a 2-level tree; then to revoke the anonymity of a signature, the group manager first locates the correct branch and then the correct leaf (user) for that branch. For a balanced tree, this results in a search time of  <span class="math">2k\\sqrt{n}</span> . Now we present the details. During the Join protocol, the group manager secretly assigns each user to one of  <span class="math">\\sqrt{n}k</span>  logical branches. Each branch is associated with a unique ID as a value  <span class="math">ID \\in \\mathbb{Z}_p^*</span> . Now, the group manager and the user run a protocol such that at the end the user obtains a  <span class="math">\\mathrm{CL}^+</span>  signature on the pair of messages (sk,ID) without learning its branch identity ID and the group manager does not learn the user's secret key sk. Following Camenisch and Lysyanskaya [19] this  <span class="math">\\mathrm{CL}^+</span>  signature would be of the following form for  <span class="math">GPK = (\\tilde{g}^s, \\tilde{g}^t, \\tilde{g}^z, \\tilde{g}^{tz})</span> , GSK = (s,t,z), and some  <span class="math">a \\in \\mathbb{G}_1</span> :</p>

    <p class="text-gray-300"><span class="math">$(a_1, \\ldots, a_7) = (a, a^t, a^{s+st(sk)+stz(ID)}, a^{sk}, a^{t(sk)}, a^{ID}, a^{tz(ID)})</span>$</p>

    <p class="text-gray-300">This  <span class="math">\\operatorname{CL}^+</span>  signature would be used as the user's certificate. Let the user submit tracing information  <span class="math">Q_j = \\tilde{g}^{sk_j}</span>  during the Join protocol as before. Then to open a group signature, the group manager now does: For each branch identity  <span class="math">ID_i</span> , check if  <span class="math">e(a_6, \\tilde{g}) = e(a_1, \\tilde{g})^{ID_i}</span> ; then for each member of the matching branch, check if  <span class="math">e(a_4, \\tilde{g}) = e(a_1, Q_j)</span> . Under the DDH assumption in  <span class="math">\\mathbb{G}_1</span> , a user's branch identity remains hidden from everyone except the group manager, so full anonymity is preserved. By the Strong LRSW assumption, a user cannot change which branch he is associated with, and thus the group manager will be able to find him (i.e., open the signature).</p>

    <p class="text-gray-300"><strong>Theorem C.1</strong> In the plain model, the above extension to the Section §5 scheme realizes  <span class="math">\\mathcal{F}_{gs}</span>  from Section §2 under the the Strong LRSW, the EDH, and the Strong SXDH assumptions.</p>

    <p class="text-gray-300">In practice, one can achieve a &quot;constant time&quot; open algorithm by having less branches per node but more levels. Assume we want to be able to handle  <span class="math">2^{40}</span>  members. Then we could have  <span class="math">2^{10}</span>  branches and a tree depth of 4. This would result is a scheme where signature would have an additional 8 elements (i.e., this would double the length of the signature) the group manager would need to do at most 3072 exponentations (to walk through the first three levels) and 1024 pairings (to find the group member) to open a signature. Furthermore, the 3072 exponentations could be considerably sped-up by giving all branches of the same node the same (but random) ID except the last 10 bits. Given that opening signatures is an exceptional event, we believe such a scheme would be practical.</p>

    <p class="text-gray-300"><strong>Open Algorithm with</strong>  <span class="math">O((\\log n) + k)</span>  <strong>Complexity from Encryption.</strong> The intuition here is to have the signer include an encryption of her identity under the group manager's encryption key as part of every signature. The trick is to do this in such a way that the <em>correctness</em> of the encryption is publicly-verifiable, and yet, the <em>anonymity</em> of the signer is preserved.</p>

    <p class="text-gray-300">Let (eGPK, eGSK) be Elgamal encryption keys generated by the group manager, where  <span class="math">eGSK \\in \\mathbb{Z}_p</span>  and  <span class="math">eGPK = \\tilde{g}^{eGSK}</span> . Then in addition to a regular signature from Section §5, a user would add a version of Elgamal encryption of their identity as the last three items:</p>

    <p class="text-gray-300">To verify the signature  <span class="math">\\sigma=(a_1,\\ldots,a_{11})</span> , in addition to the usual  <span class="math">CL^+</span>  and  <span class="math">BB^+</span>  checks, a verifier must be sure that the ciphertext is correctly formed by checking that: (1)  <span class="math">e(a_1,a_{10})=e(a_4,\\tilde{g})e(a_9,\\tilde{g})</span>  and (2)  <span class="math">e(a_9,eGPK)=e(a_1,a_{11})</span> .</p>

    <p class="text-gray-300">Now, to the key point: the group manager may, at any time, open the signature by simply decrypting the last portion as  <span class="math">a_{10}/(a_{11})^{1/eGSK} = \\tilde{g}^{sk}</span> , which reveals the user's identity. Recall that the group manager obtains this same <em>tracing information</em> from the user during the Join protocol.</p>

    <p class="text-gray-300"><strong>Theorem C.2</strong> In the plain model, the above extension to the Section §5 scheme realizes  <span class="math">\\mathcal{F}_{gs}</span>  from Section §2 under the Strong LRSW, the EDH, and (an extension of) the Strong SXDH assumptions.</p>

    <p class="text-gray-300">The extension of the Strong SXDH assumption mentioned above requires changes to oracles O and Q, from Definition 4 in Section §3. Specifically, we change the oracles as follows: Select a value  <span class="math">eGPK \\in \\mathbb{G}_2</span>  at random and give as input the adversary. Let  <span class="math">O&#x27;_x(\\cdot)</span>  be an oracle that takes as input  <span class="math">m \\in \\mathbb{Z}_p^*</span>  and outputs  <span class="math">(g^r, g^{rx}, g^{rv}, \\tilde{g}^{1/(x+v)}, \\tilde{g}^{1/(v+m)}, g^{rc}, \\tilde{g}^{sk+c}, eGPK^c)</span>  for a random  <span class="math">r, v, c \\in \\mathbb{Z}_p^*</span> . Then, we say that on input  <span class="math">(g, g^x, \\tilde{g}, eGPK)</span> , the adversary cannot distinguish access to oracles  <span class="math">(O&#x27;_x(\\cdot), O&#x27;_y(\\cdot))</span>  from  <span class="math">(O&#x27;_x(\\cdot), O&#x27;_x(\\cdot))</span> .</p>

    <p class="text-gray-300">The proof of Theorem D.3 that Strong SXDH is hard in generic groups can be modified to cover this extended version as well.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">D Generic Security of the New Assumptions</h3>

    <p class="text-gray-300">To provide more confidence in our scheme, we prove lower bounds on the complexity of our assumptions for generic groups [40, 46].</p>

    <p class="text-gray-300">Let us begin by recalling the basics. We follow the notation and general outline of Boneh and Boyen [12]. In the generic group model, elements of the bilinear groups  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2</span> , and  <span class="math">\\mathbb{G}_T</span>  are encoded as unique random strings. Thus, the adversary cannot directly test any property other than equality. Oracles are assumed to perform operations between group elements, such as performing the group operations in  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2</span> , and  <span class="math">\\mathbb{G}_T</span> . The opaque encoding of the elements of  <span class="math">\\mathbb{G}_1</span>  is defined as the function  <span class="math">\\xi_1: \\mathbb{Z}_p \\to \\{0,1\\}^*</span> , which maps all  <span class="math">a \\in \\mathbb{Z}_p</span>  to the string representation  <span class="math">\\xi_1(a)</span>  of  <span class="math">g^a \\in \\mathbb{G}_1</span> . Likewise, we have  <span class="math">\\xi_2: \\mathbb{Z}_p \\to \\{0,1\\}^*</span>  for  <span class="math">\\mathbb{G}_2</span>  and  <span class="math">\\xi_T: \\mathbb{Z}_p \\to \\{0,1\\}^*</span>  for  <span class="math">\\mathbb{G}_T</span> . The adversary  <span class="math">\\mathcal{A}</span>  communicates with the oracles using the  <span class="math">\\xi</span> -representations of the group elements only.</p>

    <p class="text-gray-300">We achieve the same asymptotic complexity bound for EDH as was shown for q-SDH.</p>

    <p class="text-gray-300"><strong>Theorem D.1 (EDH is Hard in Generic Groups)</strong> Let  <span class="math">\\mathcal{A}</span>  be an algorithm that solves the EDH problem in the generic group model, making a total of  <span class="math">q_G</span>  queries to the oracles computing the group action in  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T</span> , the oracle computing the bilinear pairing e, and oracle  <span class="math">O_x(\\cdot)</span> . If  <span class="math">x \\in \\mathbb{Z}_p^*</span>  and  <span class="math">\\xi_1, \\xi_2, \\xi_T</span>  are chosen at random, then the probability  <span class="math">\\varepsilon</span>  that  <span class="math">\\mathcal{A}^{O_x}(p, \\xi_1(1), \\xi_1(x), \\xi_2(1), \\xi_2(x))</span>  outputs  <span class="math">(c, \\xi_1(r), \\xi_1(r \\cdot x), \\xi_1(r \\cdot v), \\xi_2(\\frac{1}{x+v}), \\xi_2(\\frac{1}{v+c}))</span>  with  <span class="math">c \\in \\mathbb{Z}_p^*</span>  not previously queried to  <span class="math">O_x</span> , is bounded by</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon \\le \\frac{(q_G + 4)^2 (8q + 8)}{p} = O\\left(\\frac{q_G^3}{p}\\right).</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Consider an algorithm  <span class="math">\\mathcal{B}</span>  that interacts with  <span class="math">\\mathcal{A}</span>  in the following game.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span>  maintains three lists of pairs  <span class="math">L_1 = \\{(F_{1,i}, \\xi_{1,i}) : i = 0, \\dots, \\tau_1 - 1\\}</span> ,  <span class="math">L_2 = \\{(F_{2,i}, \\xi_{2,i}) : i = 0, \\dots, \\tau_2 - 1\\}</span> ,  <span class="math">L_T = \\{(F_{T,i}, \\xi_{T,i}) : i = 0, \\dots, \\tau_T - 1\\}</span> , such that, at step  <span class="math">\\tau</span>  in the game, we have  <span class="math">\\tau_1 + \\tau_2 + \\tau_T = \\tau + 4</span> . The only twist between our setup and that of Boneh and Boyen is that we will let the  <span class="math">F_{1,i}, F_{2,i}</span>  and  <span class="math">F_{T,i}</span> 's be rational functions (i.e, fractions whose numerators and denominators are polynomials); and</p>

    <p class="text-gray-300">all polynomials are multivariate polynomials in  <span class="math">\\mathbb{Z}_p[x,\\ldots]</span>  where additional variables will be dynamically added. The  <span class="math">\\xi_{1,i}</span> ,  <span class="math">\\xi_{2,i}</span> , and  <span class="math">\\xi_{T,i}</span>  are set to unique random strings in  <span class="math">\\{0,1\\}^*</span> . Of course, we start the EDH game at step  <span class="math">\\tau=0</span>  with  <span class="math">\\tau_1=2</span> ,  <span class="math">\\tau_2=2</span> , and  <span class="math">\\tau_T=0</span> . These correspond to the polynomials  <span class="math">F_{1,0}=F_{2,0}=1</span>  and  <span class="math">F_{1,1}=F_{2,1}=x</span> , and the random strings  <span class="math">\\xi_{1,0}</span> ,  <span class="math">\\xi_{1,1}</span> ,  <span class="math">\\xi_{2,0}</span> ,  <span class="math">\\xi_{2,1}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span>  begins the game with  <span class="math">\\mathcal{A}</span>  by providing it with the 4 strings  <span class="math">\\xi_{1,0}, \\xi_{1,1}, \\xi_{2,0}, \\xi_{2,1}</span> . Now, we describe the oracles  <span class="math">\\mathcal{A}</span>  may query.</p>

    <p class="text-gray-300"><strong>Group action:</strong>  <span class="math">\\mathcal{A}</span>  inputs two group elements  <span class="math">\\xi_{1,i}</span>  and  <span class="math">\\xi_{1,j}</span> , where  <span class="math">0 \\leq i,j &lt; \\tau_1</span> , and a request to multiply/divide.  <span class="math">\\mathcal{B}</span>  sets  <span class="math">F_{1,\\tau_1} \\leftarrow F_{1,i} \\pm F_{1,j}</span> . If  <span class="math">F_{1,\\tau_1} = F_{1,u}</span>  for some  <span class="math">u \\in \\{0,\\ldots,\\tau_1-1\\}</span> , then  <span class="math">\\mathcal{B}</span>  sets  <span class="math">\\xi_{1,\\tau_1} = \\xi_{1,u}</span> ; otherwise, it sets  <span class="math">\\xi_{1,\\tau_1}</span>  to a random string in  <span class="math">\\{0,1\\}^* \\setminus \\{\\xi_{1,0},\\ldots,\\xi_{1,\\tau_1-1}\\}</span> . Finally,  <span class="math">\\mathcal{B}</span>  returns  <span class="math">\\xi_{1,\\tau_1}</span>  to  <span class="math">\\mathcal{A}</span> , adds  <span class="math">(F_{1,\\tau_1},\\xi_{1,\\tau_1})</span>  to  <span class="math">L_1</span> , and increments  <span class="math">\\tau_1</span> . Group actions for  <span class="math">\\mathbb{G}_2</span>  and  <span class="math">\\mathbb{G}_T</span>  are handled the same way.</p>

    <p class="text-gray-300"><strong>Pairing:</strong>  <span class="math">\\mathcal{A}</span>  inputs two group elements  <span class="math">\\xi_{1,i}</span>  and  <span class="math">\\xi_{2,j}</span> , where  <span class="math">0 \\leq i &lt; \\tau_1</span>  and  <span class="math">0 \\leq j &lt; \\tau_2</span> .  <span class="math">\\mathcal{B}</span>  sets  <span class="math">F_{T,\\tau_T} \\leftarrow F_{1,i} \\cdot F_{2,j}</span> . If  <span class="math">F_{T,\\tau_T} = F_{T,u}</span>  for some  <span class="math">u \\in \\{0,\\ldots,\\tau_T-1\\}</span> , then  <span class="math">\\mathcal{B}</span>  sets  <span class="math">\\xi_{T,\\tau_T} = \\xi_{T,u}</span> ; otherwise, it sets  <span class="math">\\xi_{T,\\tau_T}</span>  to a random string in  <span class="math">\\{0,1\\}^* \\setminus \\{\\xi_{T,0},\\ldots,\\xi_{T,\\tau_T-1}\\}</span> . Finally,  <span class="math">\\mathcal{B}</span>  returns  <span class="math">\\xi_{T,\\tau_T}</span>  to  <span class="math">\\mathcal{A}</span> , adds  <span class="math">(F_{T,\\tau_T},\\xi_{T,\\tau_T})</span>  to  <span class="math">L_T</span> , and increments  <span class="math">\\tau_T</span> .</p>

    <p class="text-gray-300"><strong>Oracle</strong>  <span class="math">O_x(\\cdot)</span> : Let  <span class="math">\\tau_v</span>  be a counter initialized to 1.  <span class="math">\\mathcal{A}</span>  inputs c in  <span class="math">\\mathbb{Z}_p^*</span> , followed by  <span class="math">\\mathcal{B}</span>  choosing a new <em>variable</em>  <span class="math">v_{\\tau_v}</span>  and setting  <span class="math">F_{1,\\tau_1} \\leftarrow v_{\\tau_v}</span> . If  <span class="math">F_{1,\\tau_1} = F_{1,u}</span>  for some  <span class="math">u \\in \\{0,\\ldots,\\tau_1-1\\}</span> , then  <span class="math">\\mathcal{B}</span>  sets  <span class="math">\\xi_{1,\\tau_1} = \\xi_{1,u}</span> ; otherwise, it sets  <span class="math">\\xi_{1,\\tau_1}</span>  to a random string in  <span class="math">\\{0,1\\}^* \\setminus \\{\\xi_{1,0},\\ldots,\\xi_{1,\\tau_1-1}\\}</span> .  <span class="math">\\mathcal{B}</span>  sends  <span class="math">\\xi_{1,\\tau_1}</span>  to  <span class="math">\\mathcal{A}</span> , adding  <span class="math">(F_{1,\\tau_1},\\xi_{1,\\tau_1})</span>  to  <span class="math">L_1</span> .</p>

    <p class="text-gray-300">Next,  <span class="math">\\mathcal{B}</span>  set  <span class="math">F_{2,\\tau_2} \\leftarrow 1/(x+v_{\\tau_v})</span>  and  <span class="math">F_{2,\\tau_2+1} \\leftarrow 1/(v_{\\tau_v}+m)</span> . For  <span class="math">j \\in \\{0,1\\}</span> , if  <span class="math">F_{2,\\tau_2+j} = F_{2,u}</span>  for some  <span class="math">u \\in \\{0,\\dots,\\tau_2-1+j\\}</span> , then  <span class="math">\\mathcal{B}</span>  sets  <span class="math">\\xi_{2,\\tau_2+j} = \\xi_{2,u}</span> ; otherwise, it sets  <span class="math">\\xi_{2,\\tau_2+j}</span>  to a random string in  <span class="math">\\{0,1\\}^* \\setminus \\{\\xi_{2,0},\\dots,\\xi_{2,\\tau_2-1+j}\\}</span> .  <span class="math">\\mathcal{B}</span>  sends  <span class="math">(\\xi_{2,\\tau_2},\\xi_{2,\\tau_2+1})</span>  to  <span class="math">\\mathcal{A}</span> , adding  <span class="math">(F_{2,\\tau_2},\\xi_{2,\\tau_2})</span>  and  <span class="math">(F_{2,\\tau_2+1},\\xi_{2,\\tau_2+1})</span>  to  <span class="math">L_2</span> .</p>

    <p class="text-gray-300">Finally,  <span class="math">\\mathcal{B}</span>  adds one to  <span class="math">\\tau_1</span> , two to  <span class="math">\\tau_2</span> , and one to  <span class="math">\\tau_v</span> .</p>

    <p class="text-gray-300">We assume SXDH holds in  <span class="math">(\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T)</span>  and therefore no ismorphism oracles exist.</p>

    <p class="text-gray-300">Eventually  <span class="math">\\mathcal{A}</span>  stops and outputs a tuple of elements  <span class="math">(c, \\xi_{1,a}, \\xi_{1,b}, \\xi_{1,k}, \\xi_{2,d}, \\xi_{2,f})</span> , where  <span class="math">0 \\leq a, b, k &lt; \\tau_1</span>  and  <span class="math">0 \\leq d, f &lt; \\tau_2</span> . To later test the correctness of  <span class="math">\\mathcal{A}</span> 's output within the framework of this game,  <span class="math">\\mathcal{B}</span>  computes the polynomials:</p>

    <p class="text-gray-300"><span class="math">$F_{T,*} = \\left(\\frac{F_{1,k}}{F_{1,a}} + x\\right) \\cdot F_{2,d} - 1.</span>$
(1)</p>

    <p class="text-gray-300"><span class="math">$F_{T,\\circ} = \\left(\\frac{F_{1,k}}{F_{1,a}} + c\\right) \\cdot F_{2,f} - 1.</span>$
(2)</p>

    <p class="text-gray-300">Intuitively, this correspond to the equalities &quot; <span class="math">e(h^xh^v, \\tilde{g}^{1/(x+v)}) = e(h, \\tilde{g}) = e(h^vh^c, \\tilde{g}^{1/(v+c)})</span> &quot;, where h denotes the element of  <span class="math">\\mathbb{G}_1</span>  represented by  <span class="math">\\xi_{1,a}</span> ,  <span class="math">h^v</span>  denotes the element of  <span class="math">\\mathbb{G}_1</span>  represented by  <span class="math">\\xi_{1,k}</span> ,  <span class="math">\\tilde{g}^{1/(x+v)}</span>  denotes the element of  <span class="math">\\mathbb{G}_2</span>  represented by  <span class="math">\\xi_{2,d}</span> , and  <span class="math">\\tilde{g}^{1/(v+c)}</span>  denotes the element of  <span class="math">\\mathbb{G}_2</span>  represented by  <span class="math">\\xi_{2,f}</span> .</p>

    <p class="text-gray-300">Analysis of  <span class="math">\\mathcal{A}</span> 's Output. For  <span class="math">\\mathcal{A}</span> 's response to always be correct, then it must be the case that  <span class="math">F_{T,*}(x) = F_{T,\\circ}(x) = 0</span>  for any value of x. We now argue that it is <em>impossible</em> for  <span class="math">\\mathcal{A}</span>  to achieve this. Each output polynomial must be some linear combination of polynomials corresponding to elements available to  <span class="math">\\mathcal{A}</span>  in</p>

    <p class="text-gray-300">the respective groups:</p>

    <p class="text-gray-300"><span class="math">$F_{1,a} = a_0 + a_1 x + \\sum_{i=1}^{q} a_{2,i} v_i</span>$
(3)</p>

    <p class="text-gray-300"><span class="math">$F_{1,b} = b_0 + b_1 x + \\sum_{i=1}^{q} b_{2,i} v_i \\tag{4}</span>$</p>

    <p class="text-gray-300"><span class="math">$F_{1,k} = k_0 + k_1 x + \\sum_{i=1}^{q} k_{2,i} v_i</span>$
(5)</p>

    <p class="text-gray-300"><span class="math">$F_{2,d} = d_0 + d_1 x + \\sum_{i=1}^{q} \\frac{d_{2,i}}{x + v_i} + \\sum_{i=1}^{q} \\frac{d_{3,i}}{v_i + c_i}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\tag{6}</span>$</p>

    <p class="text-gray-300"><span class="math">$F_{2,f} = f_0 + f_1 x + \\sum_{i=1}^{q} \\frac{f_{2,i}}{x + v_i} + \\sum_{i=1}^{q} \\frac{f_{3,i}}{v_i + c_i}</span>$</p>

    <p class="text-gray-300"><span class="math">$(7)</span>$</p>

    <p class="text-gray-300">where q is the number of queries to oracle Qx. Now, we know, by definition, that F1,b/F1,a = x, thus one can verify, using equations (3) and (4), that a&lt;sup&gt;1&lt;/sup&gt; = a2,i = 0 and F1,a = a&lt;sup&gt;0&lt;/sup&gt; is a constant.</p>

    <p class="text-gray-300"><strong>Notation</strong>: For readability of our later analysis, we denote the following values, where <em>constant</em> values y&lt;sup&gt;0&lt;/sup&gt; = b0/a0, y&lt;sup&gt;1&lt;/sup&gt; = b1/a&lt;sup&gt;0&lt;/sup&gt; + 1, y2,i = b2,i/a0:</p>

    <p class="text-gray-300"><span class="math">$Y = (F_{1,k}/a_0 + x) = y_0 + y_1 x + \\sum_{i=1}^{q} y_{2,i} v_i</span>$
(8)</p>

    <p class="text-gray-300"><span class="math">$Z = (F_{1,k}/a_0 + c) = c + y_0 + (y_1 - 1)x + \\sum_{i=1}^{q} y_{2,i}v_i</span>$
(9)</p>

    <p class="text-gray-300">We also give names to the following frequently-used products:</p>

    <p class="text-gray-300"><span class="math">$P = \\prod_{j=1}^{q} (x + v_j) \\quad \\text{and} \\quad P_{i \\neq j} = \\prod_{i \\neq j}^{q} (x + v_j)</span>$
(10)</p>

    <p class="text-gray-300"><span class="math">$Q = \\prod_{j=1}^{q} (v_j + c_j) \\quad \\text{and} \\quad Q_{i \\neq j} = \\prod_{i \\neq j}^{q} (v_j + c_j)</span>$
(11)</p>

    <p class="text-gray-300">(12)</p>

    <p class="text-gray-300">Using our above notation, consider the polynomials F2,&lt;sup&gt;∗&lt;/sup&gt; and FT,◦ from equations (1) and (2) when both sides are multiplied by P Q and we substitute in equations (6), (7), (8), and (9). For some <em>constants</em> d&lt;sup&gt;i&lt;/sup&gt; and fi , the new polynomials:</p>

    <p class="text-gray-300"><span class="math">$PQF_{T,*} = 0 = d_0YPQ + d_1xYPQ + \\sum_{i=1}^{q} d_{2,i}YP_{i\\neq j}Q + \\sum_{i=1}^{q} d_{3,i}YPQ_{i\\neq j} - PQ</span>$
(13)</p>

    <p class="text-gray-300"><span class="math">$PQF_{T,\\circ} = 0 = f_0 ZPQ + f_1 x ZPQ + \\sum_{i=1}^{q} f_{2,i} ZP_{i \\neq j} Q + \\sum_{i=1}^{q} f_{3,i} ZPQ_{i \\neq j} - PQ</span>$
(14)</p>

    <p class="text-gray-300">Now, we inspect equations (13) and (14). We consider two cases.</p>

    <p class="text-gray-300">Case 1:  <span class="math">y_1 = 0</span> . Then we have  <span class="math">Z = c + y_0 - x + \\sum_{i=1}^q y_{2,i} v_i</span> . Now, we inspect the terms of equation (14). We deduce that  <span class="math">f_1 = 0</span> , because it is the only term containing  <span class="math">x^{q+2} \\prod_{i=1}^q v_i</span> . Then,  <span class="math">f_0 = 0</span> , because it is the only term containing  <span class="math">x^{q+1} \\prod_{i=1}^q v_i</span> . Next, each  <span class="math">f_{3,i} = 0</span> , because they have unique terms  <span class="math">x^{q+1} \\prod_{i \\neq j} v_j</span> . We are left with  <span class="math">0 = \\sum_{i=1}^q f_{2,i} Z P_{i \\neq j} Q - PQ</span> . We divide by Q, and the result is  <span class="math">0 = \\sum_{i=1}^q f_{2,i} Z P_{i \\neq j} - P</span> . It follows then that at least one  <span class="math">f_{2,i}</span>  must be non-zero for the equation to be solvable; denote the first non-zero  <span class="math">f_{2,i}</span>  as  <span class="math">f_{2,\\beta}</span> .</p>

    <p class="text-gray-300">Now, suppose some constant  <span class="math">y_{2,i} \\neq 0</span>  in Z, meaning that Z contains a  <span class="math">v_i</span>  term. If  <span class="math">\\beta \\neq i</span> , then  <span class="math">y_{2,i}ZP_{i\\neq j}</span>  contains a unique term  <span class="math">v_i^2\\prod_{i\\neq j\\neq \\alpha}v_j</span>  that cannot be canceled. Thus,  <span class="math">y_{2,i}=0</span> , and furthermore  <span class="math">f_{2,i}</span> , for all  <span class="math">i\\neq \\beta</span> . Now we are left with the equation  <span class="math">0=f_{2,\\beta}(c+y_0-x+y_{2,\\beta}v_\\beta)P_{\\beta\\neq j}-P</span> , we divide out  <span class="math">P_{\\beta\\neq j}</span>  and observe that  <span class="math">f_{2,\\beta}=-1</span> , to get  <span class="math">0=-(c+y_0-x+y_{2,\\beta}v_\\beta)-(x+v_\\beta)</span> .</p>

    <p class="text-gray-300">Now, since  <span class="math">c, y_0, y_{2,\\beta}</span>  are all constants and  <span class="math">v_\\beta</span>  is a variable, we conclude that  <span class="math">y_{2,\\beta}=1</span>  and  <span class="math">c=-y_0</span> . That means that  <span class="math">Y=y_0+v_\\beta</span> , where  <span class="math">y_0\\neq 0</span> . Plugging back into equation (13), we have  <span class="math">d_1=0</span>  due to unique  <span class="math">x^{q+1}</span>  term, then it must be the case that  <span class="math">d_0=0</span>  due to  <span class="math">x^qv_\\beta\\prod_{i=1}^q v_i</span> . Next, it must be that  <span class="math">d_{3,i}=0</span>  for all  <span class="math">i\\neq \\beta</span>  due to unique  <span class="math">x^qv_\\beta^2\\prod_{j\\neq i\\neq \\beta}v_j</span> . Next, we see that terms corresponding to  <span class="math">d_{3,\\beta}YPQ_{\\beta\\neq j}=d_{3,\\beta}(y_0+v_\\beta)PQ_{\\beta\\neq j}</span>  and PQ are the only two left with a  <span class="math">x^q</span>  term; thus,  <span class="math">d_{3,\\beta}\\neq 0</span> . Further, cancelling the term  <span class="math">x^q\\prod_{i=1}^q v_i</span>  from PQ requires that  <span class="math">d_{3,1}=1</span> . Thus, we find that to cancel all related  <span class="math">x^q</span>  terms, it must be that  <span class="math">c=c_\\beta</span> . Since c, which represents the message corresponding to  <span class="math">\\mathcal{A}</span> 's signature, is an old value, this is not a valid forgery.</p>

    <p class="text-gray-300">Case 2:  <span class="math">y_1 \\neq 0</span> . Now Y contains an x term, and we inspect equation (13). We deduce that  <span class="math">d_1 = 0</span> , because it is the only term containing  <span class="math">x^{q+2} \\prod_{i=1}^q v_i</span> . Then,  <span class="math">d_0 = 0</span> , because it is the only term containing  <span class="math">x^{q+1} \\prod_{i=1}^q v_i</span> . Next, each  <span class="math">d_{3,i} = 0</span> , because they have unique terms  <span class="math">x^{q+1} \\prod_{i \\neq j} v_j</span> . We are left with  <span class="math">0 = \\sum_{i=1}^q d_{2,i} Y P_{i \\neq j} Q - PQ</span> . We divide by Q, and the result is  <span class="math">0 = \\sum_{i=1}^q d_{2,i} Y P_{i \\neq j} - P</span> . To satisfy this equation, for some  <span class="math">d_{2,i}</span> , we must have  <span class="math">d_{2,i} \\neq 0</span> . We denote this value  <span class="math">d_{2,\\beta}</span> .</p>

    <p class="text-gray-300">From this point, we proceed in a fashion similar to case 1. By inspecting the above equation, we find that  <span class="math">y_0=0</span> , and for all  <span class="math">i\\neq \\beta, \\ y_{2,i}=0</span> , otherwise there exist unique terms: e.g.,  <span class="math">v_\\beta\\prod_{\\beta\\neq j}^q v_j</span> . Furthermore,  <span class="math">d_{2,\\beta}y_1=1</span> , since the  <span class="math">x^q</span>  term of P has coefficient 1. And,  <span class="math">d_{2,\\beta}y_{2,\\beta}=1</span> , since the  <span class="math">\\prod_{i=1}^q v_i</span>  term of P has coefficient 1. So,  <span class="math">y_1=y_{2,\\beta}=1/d_{2,\\beta}</span>  and we plug into Z as  <span class="math">Z=c+(1/d_{2,\\beta}-1)x+v_\\beta/d_{2,\\beta}</span> .</p>

    <p class="text-gray-300">From equation (14), we have that  <span class="math">f_1=0</span>  due to  <span class="math">x^{q+1}\\prod_{i=1}^q v_i</span> ,  <span class="math">f_0=0</span>  due to  <span class="math">v_\\beta x^q\\prod_{i=1}^q v_i</span> . For all  <span class="math">i\\neq \\beta</span> ,  <span class="math">f_{3,i}=0</span> , otherwise unique terms  <span class="math">v_\\beta^2 x^q\\prod_{i\\neq j\\neq \\beta} v_j</span>  appear. Given that all  <span class="math">f_{3,i}=0</span>  except for  <span class="math">f_{3,\\beta}</span> , it follows all  <span class="math">f_{2,i}=0</span>  except for  <span class="math">f_{2,\\beta}</span>  due to unique terms containing  <span class="math">v_i^3</span>  for  <span class="math">i\\neq \\beta</span> . Thus, we now have the equation  <span class="math">0=f_{2,\\beta}ZP_{\\beta\\neq j}Q+f_{3,\\beta}ZPQ_{\\beta\\neq j}-PQ</span> . We divide by  <span class="math">P_{\\beta\\neq j}Q_{\\beta\\neq j}</span>  to obtain  <span class="math">0=f_{2,\\beta}Z(v_\\beta+c_\\beta)+f_{3,\\beta}Z(x+v_\\beta)-(x+v_\\beta)(v_\\beta+c_\\beta)</span> .</p>

    <p class="text-gray-300">Now, suppose  <span class="math">d_{2,\\beta}=1</span>  and thus  <span class="math">Z=(c+v_{\\beta})</span> . Then we know that  <span class="math">f_{3,\\beta}=1</span>  to cancel the term  <span class="math">xv_{\\beta}</span> ; this forces  <span class="math">f_{2,\\beta}=0</span>  because the  <span class="math">v_{\\beta}^2</span>  term is already canceled in whole by the  <span class="math">f_{3,\\beta}</span>  component. Thus, it is immediate that  <span class="math">c=c_{\\beta}</span> , which is not a valid forgery.</p>

    <p class="text-gray-300">On the other hand, suppose  <span class="math">d_{2,\\beta} \\neq 1</span>  and thus Z contains an x term. Then, we know that  <span class="math">f_{3,\\beta} = 0</span> , because its  <span class="math">x^2</span>  term would be unique. This forces c = 0 because otherwise the constant term  <span class="math">f_{2,\\beta}cc_{\\beta}</span>  would be unique. However, c must be an element in  <span class="math">\\mathbb{Z}_p^*</span> , and thus this is also not a valid forgery.</p>

    <p class="text-gray-300">Thus, we conclude that A's success depends <em>solely</em> on his luck when the variables are instantiated.</p>

    <p class="text-gray-300"><strong>Analysis of</strong>  <span class="math">\\mathcal{B}</span> 's <strong>Simulation.</strong> At this point  <span class="math">\\mathcal{B}</span>  chooses a random  <span class="math">x^* \\in \\mathbb{Z}_p^*</span> .  <span class="math">\\mathcal{B}</span>  now tests (in equations 15,16,17) if its simulation was perfect; that is, if the instantiation of x by  <span class="math">x^*</span>  does <em>not</em> create any</p>

    <p class="text-gray-300">equality relation among the polynomials that was not revealed by the random strings provided to  <span class="math">\\mathcal{A}</span> .  <span class="math">\\mathcal{B}</span>  also tests (in equations 18, 19) whether or not A's output was correct. Thus, A's overall success is bounded by the probability that any of the following holds:</p>

    <p class="text-gray-300"><span class="math">$F_{1,i}(x^*) - F_{1,j}(x^*) = 0</span>$
, for some  <span class="math">i, j</span>  such that  <span class="math">F_{1,i} \\neq F_{1,j}</span> , (15)</p>

    <p class="text-gray-300"><span class="math">$F_{1,i}(x^*) - F_{1,j}(x^*) = 0</span>$
, for some  <span class="math">i, j</span>  such that  <span class="math">F_{1,i} \\neq F_{1,j}</span> , (15)
<span class="math">F_{2,i}(x^*) - F_{2,j}(x^*) = 0</span> , for some  <span class="math">i, j</span>  such that  <span class="math">F_{2,i} \\neq F_{2,j}</span> , (16)</p>

    <p class="text-gray-300"><span class="math">$F_{T,i}(x^*) - F_{T,j}(x^*) = 0</span>$
, for some  <span class="math">i, j</span>  such that  <span class="math">F_{T,i} \\neq F_{T,j}</span> , (17)</p>

    <p class="text-gray-300"><span class="math">$F_{T,*}(x^*) = 0, (18)</span>$</p>

    <p class="text-gray-300"><span class="math">$F_{T,o}(x^*) = 0.</span>$
(19)</p>

    <p class="text-gray-300">We observe that  <span class="math">F_{T,*}</span>  and  <span class="math">F_{T,\\circ}</span>  are non-trivial polynomials of degree at most  <span class="math">\\leq 2q+2</span> . Each polynomial  <span class="math">F_{1,i}</span>  and  <span class="math">F_{2,i}</span>  has degree at most 1 and 2q + 1, respectively.</p>

    <p class="text-gray-300">For fixed i and j, the first case occurs with probability  <span class="math">\\leq 1/p</span> ; the second occurs with probability  <span class="math">\\leq (2q+1)/p</span> ; and the third occurs with probability  <span class="math">\\leq (2q+2)/p</span> . (We already take into account multiplying out the denominators of any rational polynomials.) Finally, the fourth and fifth cases happen with probability  <span class="math">\\leq (2q+2)/p</span> . Now summing over all (i,j) pairs in each case, we bound A's overall success probability  <span class="math">\\varepsilon \\le {\\tau_1 \\choose 2} \\frac{1}{p} + {\\tau_2 \\choose 2} \\frac{2q+1}{p} + {\\tau_T \\choose 2} \\frac{2q+2}{p} + \\frac{2(2q+2)}{p}</span> . Since  <span class="math">\\tau_1 + \\tau_2 + \\tau_T \\le q_G + 4</span> , we end with  <span class="math">\\varepsilon \\le (q_G + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8</span>  <span class="math">(8)/p = O(q_G^3/p).</span></p>

    <p class="text-gray-300">The following corollary is immediate.</p>

    <p class="text-gray-300"><strong>Corollary D.2</strong> Any adversary that breaks the EDH assumption with constant probability  <span class="math">\\varepsilon &gt; 0</span>  in generic groups of order p such that  <span class="math">q &lt; o(\\sqrt[3]{p})</span>  requires  <span class="math">\\Omega(\\sqrt{\\varepsilon p/q})</span>  generic group operations.</p>

    <p class="text-gray-300">We now turn our attention from a computational to a decisional problem. Recall from Section 2 that the Strong SXDH assumption involves oracle  <span class="math">O_x(\\cdot)</span>  that take as input a value  <span class="math">m \\in \\mathbb{Z}_p^*</span>  and returns  <span class="math">(g^v, \\tilde{g}^{1/(x+v)}, \\tilde{g}^{1/(v+m)})</span>  for  <span class="math">v \\in \\mathbb{Z}_p^*</span>  randomly chosen by the oracle, and an oracle  <span class="math">Q_y(\\cdot)</span>  that takes the same type of input and returns  <span class="math">(a, a^y, \\dot{\\tilde{g}}^{1/(y+v)}, \\tilde{g}^{1/(v+m)})</span> , for  <span class="math">a \\in \\mathbb{G}_1</span>  and  <span class="math">v \\in \\mathbb{Z}_p^*</span>  chosen randomly by the oracle. These random values are freshly chosen at each invocation of the oracle.</p>

    <p class="text-gray-300"><strong>Theorem D.3</strong> (Strong SXDH is Hard in Generic Groups) Let  <span class="math">x \\in \\mathbb{Z}_p^*</span> ,  <span class="math">b \\in \\{0,1\\}</span> , and  <span class="math">\\xi_1, \\xi_2, \\xi_T</span>  be chosen at random. Also, if b = 1, set y = x, but if b = 0, then set y to be a value selected randomly from  <span class="math">\\mathbb{Z}_p^* \\setminus x</span> . Let  <span class="math">\\mathcal{A}</span>  be an algorithm that solves the Strong SXDH problem in the generic group model, making a total of  <span class="math">q_G</span>  queries to the oracles computing the group action in  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T</span> , the oracle computing the bilinear pairing e, and the two oracles  <span class="math">O_x(\\cdot)</span>  and  <span class="math">Q_y(\\cdot)</span>  as described above. Then the probability  <span class="math">\\varepsilon</span>  that  <span class="math">A(p, \\xi_1(1), \\xi_1(x), \\xi_2(1)) = b</span>  is bounded by</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon \\le \\frac{1}{2} + \\frac{(q_G + 3)^2 (3q_G)}{p} = \\frac{1}{2} + O\\left(\\frac{q_G^3}{p}\\right).</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> B maintains the lists  <span class="math">L_1</span> ,  <span class="math">L_2</span> , and  <span class="math">L_T</span>  as in the proof of Theorem D.1. (Consider the bit b as not yet set.) At step  <span class="math">\\tau</span>  in the game, we now have  <span class="math">\\tau_1 + \\tau_2 + \\tau_T = \\tau + 3</span> , where at  <span class="math">\\tau = 0</span> , we set  <span class="math">\\tau_1 = 2</span> ,  <span class="math">\\tau_2 = 1</span> , and  <span class="math">\\tau_T = 0</span> . These correspond to the polynomials  <span class="math">F_{1,0} = F_{2,0} = 1</span>  and  <span class="math">F_{1,1} = x</span> .  <span class="math">\\mathcal{B}</span>  also selects unique, random strings  <span class="math">\\xi_{1,0}, \\xi_{1,1}</span> , and  <span class="math">\\xi_{2,0}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span>  begins the game with  <span class="math">\\mathcal{A}</span>  by providing it with the strings  <span class="math">\\xi_{1,0}, \\xi_{1,1}</span> , and  <span class="math">\\xi_{2,0}</span> .  <span class="math">\\mathcal{A}</span>  may, at any time, make the group action or pairing queries as in the proof of Theorem D.1. A may additionally query the following two oracles. Let  <span class="math">\\tau_v = 1</span>  and  <span class="math">\\tau_w = 1</span>  be counters.</p>

    <p class="text-gray-300"><strong>Oracle</strong>  <span class="math">O_x(\\cdot)</span> :  <span class="math">\\mathcal{A}</span>  inputs m in  <span class="math">\\mathbb{Z}_p^*</span> , followed by  <span class="math">\\mathcal{B}</span>  choosing a new <em>variable</em>  <span class="math">v_{\\tau_v}</span>  and setting  <span class="math">F_{1,\\tau_1} \\leftarrow v_{\\tau_v}</span> . If  <span class="math">F_{1,\\tau_1} = F_{1,u}</span>  for some  <span class="math">u \\in \\{0,\\ldots,\\tau_1-1\\}</span> , then  <span class="math">\\mathcal{B}</span>  sets  <span class="math">\\xi_{1,\\tau_1} = \\xi_{1,u}</span> ; otherwise, it sets  <span class="math">\\xi_{1,\\tau_1}</span>  to a random string in  <span class="math">\\{0,1\\}^* \\setminus \\{\\xi_{1,0},\\ldots,\\xi_{1,\\tau_1-1}\\}</span> .  <span class="math">\\mathcal{B}</span>  sends  <span class="math">\\xi_{1,\\tau_1}</span>  to  <span class="math">\\mathcal{A}</span> , adding  <span class="math">(F_{1,\\tau_1},\\xi_{1,\\tau_1})</span>  to  <span class="math">L_1</span> .</p>

    <p class="text-gray-300">Next,  <span class="math">\\mathcal{B}</span>  set  <span class="math">F_{2,\\tau_2} \\leftarrow 1/(x+v_{\\tau_v})</span>  and  <span class="math">F_{2,\\tau_2+1} \\leftarrow 1/(v_{\\tau_v}+m)</span> . For  <span class="math">j \\in \\{0,1\\}</span> , if  <span class="math">F_{2,\\tau_2+j} = F_{2,u}</span>  for some  <span class="math">u \\in \\{0,\\dots,\\tau_2-1+j\\}</span> , then  <span class="math">\\mathcal{B}</span>  sets  <span class="math">\\xi_{2,\\tau_2+j} = \\xi_{2,u}</span> ; otherwise, it sets  <span class="math">\\xi_{2,\\tau_2+j}</span>  to a random string in  <span class="math">\\{0,1\\}^* \\setminus \\{\\xi_{2,0},\\dots,\\xi_{2,\\tau_2-1+j}\\}</span> .  <span class="math">\\mathcal{B}</span>  sends  <span class="math">(\\xi_{2,\\tau_2},\\xi_{2,\\tau_2+1})</span>  to  <span class="math">\\mathcal{A}</span> , adding  <span class="math">(F_{2,\\tau_2},\\xi_{2,\\tau_2})</span>  and  <span class="math">(F_{2,\\tau_2+1},\\xi_{2,\\tau_2+1})</span>  to  <span class="math">L_2</span> .</p>

    <p class="text-gray-300">Finally,  <span class="math">\\mathcal{B}</span>  adds one to  <span class="math">\\tau_1</span> , two to  <span class="math">\\tau_2</span> , and one to  <span class="math">\\tau_v</span> .</p>

    <p class="text-gray-300"><strong>Oracle</strong>  <span class="math">Q_y(\\cdot)</span> :  <span class="math">\\mathcal{B}</span>  responds similarly, except that it chooses new <em>variables</em>  <span class="math">r_{\\tau_w}</span>  and  <span class="math">w_{\\tau_w}</span> , and sets  <span class="math">F_{1,\\tau_1} \\leftarrow r_{\\tau_w}</span> ,  <span class="math">F_{1,\\tau_1+1} \\leftarrow r_{\\tau_w} \\cdot y</span> ,  <span class="math">F_{1,\\tau_1+2} \\leftarrow r_{\\tau_w} \\cdot w_{\\tau_w}</span> ,  <span class="math">F_{2,\\tau_2} \\leftarrow 1/(y+w_{\\tau_w})</span> , and  <span class="math">F_{2,\\tau_2+1} \\leftarrow 1/(w_{\\tau_w}+m)</span> . At the end,  <span class="math">\\mathcal{B}</span>  adds three to  <span class="math">\\tau_1</span> , two to  <span class="math">\\tau_2</span> , and one to  <span class="math">\\tau_w</span> .</p>

    <p class="text-gray-300">Eventually  <span class="math">\\mathcal{A}</span>  stops and outputs a guess  <span class="math">b&#x27; \\in \\{0, 1\\}</span> .</p>

    <p class="text-gray-300">Analysis of  <span class="math">\\mathcal{A}</span> 's Output. First, we argue that, provided  <span class="math">\\mathcal{B}</span> 's simulation is perfect, the bit b' is independent of b; that is,  <span class="math">\\mathcal{A}</span>  cannot output a string such that the corresponding polynomial is always equal when x=y (b=1) and non-zero otherwise (b=0). We show this for each group  <span class="math">\\mathbb{G}_1</span> ,  <span class="math">\\mathbb{G}_2</span> , and  <span class="math">\\mathbb{G}_T</span> . Showing this for  <span class="math">\\mathbb{G}_T</span>  is the hardest case. Here, we sum over all expressions containing i or j.</p>

    <p class="text-gray-300"><strong>Group</strong>  <span class="math">\\mathbb{G}_1</span> : The polynomials corresponding to elements in  <span class="math">\\mathbb{G}_1</span>  that the adversary can compute as a linear combination of elements in its view are:</p>

    <p class="text-gray-300"><span class="math">$F_{1,a} = a_0 + a_1 \\cdot x + a_{2,i} \\cdot v_i + a_{3,i} \\cdot r_i + a_{4,i} \\cdot r_i \\cdot y + a_{5,i} \\cdot r_i \\cdot w_i \\tag{20}</span>$</p>

    <p class="text-gray-300">where i=1 to  <span class="math">\\tau_v</span>  and j=1 to  <span class="math">\\tau_w</span> . For  <span class="math">F_{1,a}=0</span> , both  <span class="math">a_1</span>  and  <span class="math">a_{4,j}</span>  must be zero whether y is replaced by x or not; otherwise those terms cannot be canceled. The remaining polynomial does not contain the variables x or y.</p>

    <p class="text-gray-300"><strong>Group</strong>  <span class="math">\\mathbb{G}_2</span> : The polynomials corresponding to elements in  <span class="math">\\mathbb{G}_2</span>  that the adversary can compute as a linear combination of elements in its view are:</p>

    <p class="text-gray-300"><span class="math">$F_{2,b} = b_0 + \\frac{b_{1,i}}{x + v_i} + \\frac{b_{2,i}}{v_i + m_i} + \\frac{b_{3,j}}{y + w_j} + \\frac{b_{4,j}}{w_j + m_j}</span>$
(21)</p>

    <p class="text-gray-300">where i=1 to  <span class="math">\\tau_v</span> , j=1 to  <span class="math">\\tau_w</span> , and each  <span class="math">m_i, m_j \\in \\mathbb{Z}_p^*</span>  was chosen by the adversary. Suppose  <span class="math">F_{2,b}=0</span> . We multiply out the denominators in equation (21) to obtain:</p>

    <p class="text-gray-300"><span class="math">$F&#x27;_{2,b} = b_0(x+v_i)(v_i+m_i)(y+w_j)(w_j+m_j) + b_{1,i}(v_i+m_i)(y+w_j)(w_j+m_j) + b_{2,i}(x+v_i)(y+w_j)(w_j+m_j) + b_{3,j}(x+v_i)(v_i+m_i)(w_i+m_j) + b_{4,j}(x+v_i)(v_i+m_i)(y+w_j)</span>$
(22)</p>

    <p class="text-gray-300">Now, for  <span class="math">F_{b,2}&#x27;=0</span> , regardless of whether we substitute x for y, we see that  <span class="math">b_0=0</span> , otherwise the term  <span class="math">xv_iyw_j</span>  (or  <span class="math">x^2v_iw_j</span> ) cannot be canceled. Similarly,  <span class="math">b_{1,i}=0</span>  because of the unique summand  <span class="math">xv_iy</span>  (or  <span class="math">x^2v_i</span> ), which makes  <span class="math">b_{2,i}=0</span>  because of the summand  <span class="math">v_i^2w_j</span> . Then,  <span class="math">b_{3,j}=0</span>  because of the summand  <span class="math">xyw_j</span>  (or  <span class="math">x^2w_j</span> ), which makes  <span class="math">b_{4,j}=0</span>  because of the summand  <span class="math">v_iw_j^2</span> . We are left with the constant zero.</p>

    <p class="text-gray-300"><strong>Group</strong>  <span class="math">\\mathbb{G}_T</span> : The polynomials corresponding to elements in  <span class="math">\\mathbb{G}_T</span>  that the adversary can compute as a linear combination of elements in its view are:</p>

    <p class="text-gray-300"><span class="math">$F_{T,c} = \\sum F_{1,a} \\cdot F_{2,b}.</span>$
(23)</p>

    <p class="text-gray-300">Now, a simple expansion of  <span class="math">F_{T,c}</span>  has thirty terms. Suppose we clear the denominators in  <span class="math">F_{T,c} = 0</span>  by multiplying out by  <span class="math">(x + v_i)(v_i + m_i)(y + w_j)(w_j + m_j)</span> , then we have</p>

    <p class="text-gray-300"><span class="math">$F&#x27;_{T,c} = \\sum F_{1,a} \\cdot F&#x27;_{2,b}. \\tag{24}</span>$</p>

    <p class="text-gray-300">Now, each of the terms in  <span class="math">F_{1,a}</span>  is unique and  <span class="math">F&#x27;_{2,b}</span>  contains the following unique summands  <span class="math">(xv_iyw_j, xv_iy, v_i^2w_j, xyw_j, v_iw_j^2)</span> . (Here, the summands  <span class="math">v_i^2w_j</span>  and  <span class="math">v_iw_j^2</span>  are actually not unique, but since they also do not contain x or y, it will not matter.) Multiplying these key components out and dropping the subscript for clarity, we obtain:</p>

    <p class="text-gray-300"><span class="math">$F_{T,c}&#x27;&#x27; = c_0(vwxy) + c_1(vxy) + c_2(v^2w) + c_3(wxy) + c_4(vw^2) + c_5(vwx^2y) + c_6(vx^2y) + c_7(v^2wx) + c_8(wx^2y) + c_9(vw^2x) + c_{10}(v^2wxy) + c_{11}(v^2x^2y) + c_{12}(v^3w) + c_{13}(vwxy) + c_{14}(v^2w^2) + c_{15}(vwxyz) + c_{16}(vxyz) + c_{17}(v^2wz) + c_{18}(wxyz) + c_{19}(vw^2z) + c_{20}(vwxy^2z) + c_{21}(vxy^2z) + c_{22}(v^2wyz) + c_{23}(wxy^2z) + c_{24}(vw^2yz) + c_{25}(vw^2xyz) + c_{26}(vwxyz) + c_{27}(v^2w^2z) + c_{28}(w^2xyz) + c_{29}(vw^3z)</span>$</p>

    <p class="text-gray-300"><span class="math">$(25)</span>$</p>

    <p class="text-gray-300">Now, we are only interested in differences in the polynomial  <span class="math">F&#x27;&#x27;_{T,c}</span>  when y is replaced by x or not. For clarity, we drop all terms containing neither x nor y, resulting in  <span class="math">c_2 = c_4 = c_{12} = c_{14} = c_{17} = c_{19} = c_{27} = c_{29} = 0</span> . We substitute x = y to obtain.</p>

    <p class="text-gray-300"><span class="math">$F_{T,c}^{&quot;&quot;} = c_{0}(vwx^{2}) + c_{1}(vx^{2}) + c_{0}(vx^{2}) + c_{3}(wx^{2}) + c_{1}(vx^{2}) + c_{1}(vx^{2}) + c_{2}(vx^{2}) + c_{1}(v^{2}x^{3}) + c_{1}(v^{2}x^{3}) + c_{1}(vx^{2}x^{2}) + c_{1}(vx^{2}x^{2}) + c_{1}(vx^{2}x^{2}) + c_{1}(vx^{2}x^{2}) + c_{1}(vx^{2}x^{2}) + c_{2}(vx^{2}x^{2}) + c_{2}(vx^{2}x^{2}) + c_{2}(vx^{2}x^{2}) + c_{2}(vx^{2}x^{2}) + c_{2}(vx^{2}x^{2}) + c_{2}(vx^{2}x^{2}) + c_{2}(vx^{2}x^{2}x^{2})</span>$</p>

    <p class="text-gray-300"><span class="math">$(26)</span>$</p>

    <p class="text-gray-300">We want to know if there are any two terms that are symbolically equal when x = y and not otherwise. Scanning the above, we see that the only non-unique terms are in positions 0 and 13, and in positions 15 and 26. Looking back to equation (25), we see that <em>both</em> positions 0 and 13 correspond to term vwxy, and that <em>both</em> positions 15 and 26 correspond to term vwxyz. Obviously, these terms will be the same regardless of the substitution of x for y. Since all other terms are unique, we conclude that the adversary's only chance of distinguishing comes from a lucky instantiation of these variables.</p>

    <p class="text-gray-300">Analysis of  <span class="math">\\mathcal{B}</span> 's Simulation. At this point  <span class="math">\\mathcal{B}</span>  chooses random values  <span class="math">x^*, y^*, \\{v_d^*\\}_{d \\in [1, \\tau_v]}, \\{w_d^*\\}_{d \\in [1, \\tau_w]}, \\{r_d^*\\}_{d \\in [1, \\tau_w]} \\in \\mathbb{Z}_p^*</span> .  <span class="math">\\mathcal{B}</span> 's simulation is perfect, and therefore reveals nothing to  <span class="math">\\mathcal{A}</span>  about b, provided that none</p>

    <p class="text-gray-300">of the following non-trivial equality relations hold:</p>

    <p class="text-gray-300"><span class="math">$F_{1,i}(x^*, y^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) - F_{1,j}(x^*, y^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) = 0:</span>$
for some  <span class="math">i, j</span> , such that  <span class="math">F_{1,i} \\neq F_{1,j}</span> , (27)</p>

    <p class="text-gray-300"><span class="math">$F_{1,i}(x^*, x^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) - F_{1,j}(x^*, x^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) = 0:</span>$
for some  <span class="math">i, j</span> , such that  <span class="math">F_{1,i} \\neq F_{1,j}</span> ,
<span class="math">$(28)</span>$</p>

    <p class="text-gray-300"><span class="math">$F_{2,i}(x^*, y^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) - F_{2,j}(x^*, y^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) = 0:</span>$
for some  <span class="math">i, j</span> , such that  <span class="math">F_{2,i} \\neq F_{2,j}</span> , (29)</p>

    <p class="text-gray-300"><span class="math">$F_{2,i}(x^*, x^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) - F_{2,j}(x^*, x^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) = 0:</span>$
for some  <span class="math">i, j</span> , such that  <span class="math">F_{2,i} \\neq F_{2,j}</span> , (30)</p>

    <p class="text-gray-300"><span class="math">$F_{T,i}(x^*, y^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) - F_{T,j}(x^*, y^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) = 0:</span>$
for some  <span class="math">i, j</span> , such that  <span class="math">F_{T,i} \\neq F_{T,j}</span> , (31)</p>

    <p class="text-gray-300"><span class="math">$F_{T,i}(x^*, x^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) - F_{T,j}(x^*, x^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) = 0:</span>$
for some  <span class="math">i, j</span> , such that  <span class="math">F_{T,i} \\neq F_{T,j}</span> . (32)</p>

    <p class="text-gray-300">For fixed i and j, the probability of the first and second cases occurring are no more than 2/p, where this results from the maximum degree of equation (20). For fixed i and j, the probability of the third and fourth cases occurring are no more than τ2/p, where this results from the maximum degree of equation (22). Finally, for the fifth and sixth cases, the probability is at most 2τ2/p, where this results from the maximum degree of equation (24).</p>

    <p class="text-gray-300">Therefore, by summing over all (i, j) pairs in each case, we bound A's overall success probability ε ≤ 2 τ1 2 2 p+2 τ2 2 τ2 &lt;sup&gt;p&lt;/sup&gt; +2 τT 2 2τ&lt;sup&gt;2&lt;/sup&gt; p . Since τ1+τ2+τ&lt;sup&gt;T&lt;/sup&gt; ≤ qG+3, we end with ε ≤ (qG+3)&lt;sup&gt;2&lt;/sup&gt; (2+qG+2qG)/p = O(q 3 &lt;sup&gt;G&lt;/sup&gt;/p). ✷</p>

    <p class="text-gray-300">The following corollary is immediate. Here γ = ε − 2 ; that is, γ is the adversary's advantage beyond guessing.</p>

    <p class="text-gray-300"><strong>Corollary D.4</strong> <em>Any adversary that breaks the Strong SXDH assumption with constant probability</em> γ &gt; 0 <em>in generic groups of order</em> &lt;sup&gt;p&lt;/sup&gt; <em>requires</em> Ω(√&lt;sup&gt;3&lt;/sup&gt; γp) <em>generic group operations.</em></p>

`;
---

<BaseLayout title="Practical Group Signatures without Random Oracles (2005/385)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2005 &middot; eprint 2005/385
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="practical-group-signatures-without-random-oracles-2005" />
  </article>
</BaseLayout>
