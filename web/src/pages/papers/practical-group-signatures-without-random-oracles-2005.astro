---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2005/385';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Practical Group Signatures without Random Oracles';
const AUTHORS_HTML = 'Giuseppe Ateniese, Jan Camenisch, Susan Hohenberger, Breno de Medeiros';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">We provide a construction for a
group signature scheme that is provably secure in a universally composable framework,
within the standard model with trusted parameters.
Our proposed  scheme is fairly simple and its efficiency falls
within  small  factors of the most efficient group signature schemes
with provable security in any model (including random oracles).
Security of our constructions require new
cryptographic assumptions, namely the Strong LRSW, EDH, and Strong SXDH assumptions.  Evidence for any assumption we introduce is provided by proving hardness in the generic group model.

Our second contribution is the first definition of security for group signatures based on the simulatability
of real protocol executions in an ideal setting  that captures
the basic properties of unforgeability, anonymity, unlinkability, and exculpability for
group signature schemes.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Group signatures &middot; random oracles &middot; standard model &middot; group signature security definition &middot; ideal functionality.</p>
    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Group Signature Security Definition</h2>

    <p class="text-gray-300"><strong>Notation:</strong> if P is a protocol between parties A and B, then P(A(x), B(y)) denotes that A's input is x and B's input is y.</p>

    <p class="text-gray-300">http://www.nsa.gov/ia/industry/crypto_elliptic_curve.cfm</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;2</sup>Their paper provides the value 1533 bits instead of 2163, but this does not take into account the above mentioned results about the concrete security of the q-Strong Diffie-Hellman assumption [24].</p>

    <p class="text-gray-300"><span class="math">&lt;sup&gt;^{3}&lt;/sup&gt;</span> Again, this value is larger than the one provided by the authors to account for the concrete security of q-Strong Diffie-Hellman.</p>

    <p class="text-gray-300">A group signature scheme consists of the usual types of players: a group manager GM and a user U<sup>i</sup> . These players can execute the algorithms: GroupSetup, UserKeyGen, Join, GroupSign, GroupVerify, Open, and VerifyOpen. We now specify the input-output specifications for these algorithms as well as providing some informal intuition for what they do.</p>

    <p class="text-gray-300">Let params be global parameters generated during a setup phase; ideally params is empty.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The GroupSetup(1<sup>k</sup> , params) algorithm is a key generation algorithm for the group manager GM. It takes as input the security parameter 1 k and outputs the key pair (pkGM, skGM). (Assume that skGM contains the params, so we do not have to give params explicitly to the group manager again.)</li>
      <li>The UserKeyGen(1<sup>k</sup> , params) algorithm is a key generation algorithm for a group member U, which outputs (pkU, skU). (Assume that sk<sup>U</sup> contains the params, so we do not have to give params explicitly to the user again.)</li>
      <li>In the Join(U(pkGM, skU), GM(pkU, skGM)) protocol, the user U joins the signatory group managed by GM. The user's output is a personalized group signing credential CU, or an error message. GM's output is some information T<sup>U</sup> which will allow the group manager to revoke the anonymity of any signatures produced by U. The group manager maintains a database D for this revocation information, to which it adds the record (pkU, TU).</li>
      <li>The GroupSign(skU, CU, m) algorithm allows group members to sign messages. It takes as input the user's secret key skU, the user's signing credential CU, and an arbitrary string m. The output is a group signature &sigma;.</li>
      <li>The GroupVerify(pkGM, m, &sigma;) algorithm allows to publicly verify that &sigma; is a signature on message m generated by some member of the group associated with group public key pkGM.</li>
      <li>The Open(skGM, D, m, &sigma;) algorithm allows the group manager, with skGM and database D, to identify the group member U who was responsible for creating the signature &sigma; on message m. The output is a member identity pk<sup>U</sup> or an error message.</li>
      <li>In the VerifyOpen(GM(skGM, D, m, &sigma;, pk), V(pkGM, m, &sigma;, pk)) protocol, GM convinces a verifier that the user with public key pk was responsible for creating the signature &sigma; on message m. The verifier outputs either 1 (accept) or 0 (reject).</li>
    </ul>

    <p class="text-gray-300">In addition to supporting the above algorithms, a group signature scheme must also be <em>correct</em> and <em>secure</em>. Correctness is fairly straightforward. Informally, if an honest user runs Join with an honest group manager, then neither will output an error message. If an honest user runs GroupSign, then the output will be accepted by an honest verifier running GroupVerify. If a signature passes GroupVerify and a honest manager runs Open, then the result will be accepted by an honest verifier running VerifyOpen.</p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8"><strong>2.1 The Group Signature Ideal Functionality,</strong> Fgs</h3>

    <p class="text-gray-300">Our security model uses the ideal/real world model as in multiparty computation [20, 21, 22] and reactive systems [42, 43] to capture the security properties of group signatures in a single definition.</p>

    <p class="text-gray-300">In the real world, there are a number of parties who together execute some cryptographic protocol. A number of these parties may be corrupted by the adversary A (all corrupted parties are combined into this single adversary). Each party receives its input and reports its output to the environment Z. The environment Z and the adversary A may arbitrarily interact. In the ideal world, we have the same parties. As before, each party receives its input and reports its output to the environment. However, instead of running a cryptographic protocol, the parties provide their inputs to and receive their outputs from a trusted party T . The specification for how T behaves is formalized as an ideal functionality.</p>

    <p class="text-gray-300">We say that a cryptographic protocol securely implements an ideal functionality if for every real-world adversary A and every environment Z, there exists a simulator S, which controls the same parties in the ideal world as A does in the real world, such that Z cannot distinguish whether it is interacting in the real world with A or in the ideal world with S.</p>

    <p class="text-gray-300"><strong>Group Signature Ideal Functionality.</strong> We now describe Fgs. In addition to the environment Z, we have two types of players: a group manager GM and users U<sup>i</sup> . We work in the <em>non-adaptive</em> setting.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Non-adaptive Setup: Each user U<sup>i</sup> tells the functionality Fgs whether or not it is corrupted. Optionally, in this stage the global parameters are broadcast to all parties.</li>
      <li>GroupSetup: Upon receiving (GM, &quot;group setup&quot;) from GM, send to S tuple (GM, &quot;group setup&quot;).</li>
      <li>UserKeyGen: Similarly, upon receiving (U<sup>i</sup> , &quot;keygen&quot;) from U<sup>i</sup> inform S.</li>
      <li>Join: Upon receiving (U<sup>i</sup> , &quot;enroll&quot;) from U<sup>i</sup> , ask the group manager GM if U<sup>i</sup> may join the group. The GM responds with res<sup>i</sup> &isin; {0, 1}. Record the pair (U<sup>i</sup> , resi) in database D and return res<sup>i</sup> to U<sup>i</sup> . Additionally, if the group manager is corrupted, then register a special user corrupt-GM.</li>
      <li>GroupSign: Upon receiving (U<sup>i</sup> , &quot;sign&quot;, m), where m is an arbitrary string, check that U<sup>i</sup> is a valid member of the group by checking that the entry for U<sup>i</sup> in D has res<sup>i</sup> = 1. If not, deny the command. Otherwise, tell the simulator S that GroupSign has been envoked on message m. If the GM is corrupted, also tell the simulator the identity U<sup>i</sup> . Ask S for a signature index id. Record the entry (U<sup>i</sup> , m, id) in database L and return the value id to U<sup>i</sup> .</li>
      <li>GroupVerify: Upon receiving (U<sup>i</sup> , &quot;verify&quot;, m, id) from U<sup>i</sup> (or GM), search database L for an entry containing message m, and if one exists, return 1. Otherwise, return 0.</li>
      <li>Open: This ideal operation combines both the Open and VerifyOpen cryptographic protocols. Upon receiving (U<sup>i</sup> , &quot;open&quot;, m, id) from U<sup>i</sup> , search database L for an entry (U<sup>j</sup> , m, id) for any U<sup>j</sup> . Ask GM if it will allow Fgs to open id for user U<sup>i</sup> . If GM agrees and U<sup>j</sup> 6= corrupt-GM, then output the identity U<sup>j</sup> . Otherwise, output &perp;.</li>
    </ul>

    <p class="text-gray-300">Let us provide some intuition for understanding this model. Informally, the properties that we capture are unforgeability, anonymity, and exculpability. This definition is general enough to capture unforgeability under adaptive chosen message attack [34] without <em>requiring</em> schemes to be <em>strongly</em> unforgeable [2]. In a strongly unforgeable scheme, a new signature on a previously signed message is considered a forgery; while in the standard notion, a forgery must be on a new message.</p>

    <p class="text-gray-300">The definition also captures the important exculpability property (i.e., even a rogue group manager cannot frame an honest user). Indeed, the environment Z may instruct a user to sign any messages of its choosing and may interact freely with the adversary A. Our model, however, enforces that unless an honest user U<sup>i</sup> requested a signature on m (i.e., sent (&quot;sign&quot;, m) to Fgs), then for all values of id, the Open command on (U<sup>i</sup> , m, id) will return &perp;.</p>

    <p class="text-gray-300">Furthermore, there is a strong anonymity guarantee for a user: unless the group manager is corrupted, the users remain anonymous. When the group manager is honest, the simulator must create signatures for A knowing only the message contents, but not the identity of the honest user.</p>

    <p class="text-gray-300">Finally, the definition ensures that, whenever the group manager is honest, he will be able to open all group signatures. During the Open command, Fgs only asks S for permission to execute the opening if the group manager is corrupted. Thus, if a user honestly runs the verification algorithm and accepts a signature as valid, then this user may be confident that an honest GM will later be able to open it, reveal the identity of the original signer, and prove this to the user.</p>

    <p class="text-gray-300">The above definition does not define membership revocation. However, it is not difficult to extend Fgs to address revocation, and we plan to do so in the full version of the paper.</p>

    <p class="text-gray-300">It is not hard to see that our definition implies prior many of the guarantees of the property-based definitions (e.g., [9, 11, 36, 35]). Two properties that we do not require are: (1) membership revocation, and (2) anonymity even after exposure of a user secret key (forward anonymity), as in BMW [9]. While of course both of these properties could be added easily to the model, our scheme does not statisfy them. Note, however, that our definition (and scheme) does provide anonymity to (honest) users, i.e., users of which the adversary is not privy of their secret keys. Finally, notice that our definition implies CCA anonymity, i.e., an anonymity property based definition where the adversary is allowed to query the open oracle even after having been presented the challenge signature. This is in contrast to BMW model (and to the Boyen-Waters group signature scheme) which provide only CPA anonymity, i.e., where the adversary is no longer allowed access to the open oracle after seeing the challenge signature.</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Preliminaries and Complexity Assumptions</h2>

    <p class="text-gray-300"><strong>Notation:</strong> The notation  <span class="math">G = \\langle q \\rangle</span>  means that q generates the group G.</p>

    <p class="text-gray-300"><strong>Pairings:</strong> Let BilinearSetup be an algorithm that, on input the security parameter  <span class="math">1^k</span> , outputs the parameters for a pairing as  <span class="math">\\gamma = (p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, g, \\tilde{g})</span> , where  <span class="math">\\mathbb{G}_1 = \\langle g \\rangle</span>  and  <span class="math">\\mathbb{G}_2 = \\langle \\tilde{g} \\rangle</span> . We follow the notation of Boneh, Lynn, and Shacham [14]. Let  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2</span> , and  <span class="math">\\mathbb{G}_T</span>  all be (multiplicative) groups of prime order  <span class="math">p = \\Theta(2^k)</span> , where each element of each group has a unique binary representation. Furthermore, let  <span class="math">e : \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span>  be an efficient <em>pairing</em>, i.e., a mapping with the following properties: (Bilinearity) for all  <span class="math">g \\in \\mathbb{G}_1</span> ,  <span class="math">\\tilde{g} \\in \\mathbb{G}_2</span> , and  <span class="math">a, b \\in \\mathbb{Z}_p</span> ,  <span class="math">e(g^a, \\tilde{g}^b) = e(g, \\tilde{g})^{ab}</span> ; and (Non-degeneracy) if g is a generator of  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\tilde{g}</span>  is a generator of  <span class="math">\\mathbb{G}_2</span> , then  <span class="math">e(g, \\tilde{g})</span>  generates  <span class="math">\\mathbb{G}_T</span> .</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 Complexity Assumptions</h3>

    <p class="text-gray-300">The security of our construction in Section &sect;5 is based on the following assumptions about pairing groups. In Appendix &sect;D, we provide generic group proofs for EDH and Strong SXDH. A generic group proof for Strong LRSW was previously given in [3].</p>

    <p class="text-gray-300">Two criticisms could be made of these assumptions. The first could be that they are closely related to specific security properties of the scheme. With regards to this, we point out that even if we <em>were</em> to assume a specific property, such as unforgeability (which we don't do), security in our model would not follow. Indeed, it is non-trivial to show that our assumptions imply that our scheme realizes our ideal functionality. We also point out that the generic group proofs of these assumptions are highly non-trivial and required new techniques, which may be useful elsewhere.</p>

    <p class="text-gray-300">A second criticism could be that the assumptions are interactive and thus not black-box falsifiable [39]. However, we believe that our provided generic-model hardness proofs show that these assumptions are reasonable: Violating them would result in the design of elliptic curve algorithms with better than generic efficiency, a major cryptographic breakthrough with likely wider ramifications. In addition, our proofs provide estimates for the key sizes required for particular security levels, making our security assumptions indeed very concrete: The resulting  <span class="math">\\Omega(p^{1/3})</span> -generic security of our interactive assumptions (for elliptic curve subgroups of order p) puts them on a similar footing with related falsifiable assumptions, such as the q-Strong Diffie-Hellman assumption [24].</p>

    <p class="text-gray-300">Let BilinearSetup(1<sup>k</sup>)  <span class="math">\\to</span>  (p,  <span class="math">\\mathbb{G}_1</span> ,  <span class="math">\\mathbb{G}_2</span> ,  <span class="math">\\mathbb{G}_T</span> , q,  <span class="math">\\tilde{q}</span> ), where  <span class="math">\\mathbb{G}_1 = \\langle q \\rangle</span>  and  <span class="math">\\mathbb{G}_2 = \\langle \\tilde{q} \\rangle</span> , be public.</p>

    <p class="text-gray-300">Assumption 1 (Symmetric External Diffie-Hellman (SXDH) [6, 3, 30]) The Decisional Diffie-Hellman (DDH) problem is hard in both  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span> . This implies that there do not exist efficiently computable isomorphisms  <span class="math">\\psi : \\mathbb{G}_1 \\to \\mathbb{G}_2</span>  or  <span class="math">\\psi&#x27; : \\mathbb{G}_2 \\to \\mathbb{G}_1</span> .</p>

    <p class="text-gray-300">Note that SXDH also subsumes a traditional Co-Gap assumption, i.e., the Co-CDH problem [14] is hard in the pairing groups: Given  <span class="math">(g, \\tilde{g}, g^x, \\tilde{g}^y)</span> , it is hard to compute  <span class="math">\\tilde{g}^{xy}</span>  or  <span class="math">g^{xy}</span> .</p>

    <p class="text-gray-300">Good candidates for pairing groups where SXDH is hard are certain MNT curve implementations where no efficient isomorphisms between  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  are known [6, 3, 47, 32, 30]. The asymmetric version of this assumption, simply called XDH, only requires that DDH be hard in  <span class="math">\\mathbb{G}_1</span>  [29, 45, 38, 13, 6].</p>

    <p class="text-gray-300">The LRSW assumption is a discrete-logarithm assumption introduced in 1999 by Lysyanskaya et al. [37] and used in many subsequent works. Recently, a stronger form of the LRSW assumption which <em>implies the SXDH assumption</em>, called <em>Strong LRSW</em>, was introduced by Ateniese et al. [3].</p>

    <p class="text-gray-300"><strong>Assumption 2 (Strong LRSW [3])</strong> Let  <span class="math">X, Y \\in \\mathbb{G}_2, X = \\tilde{g}^x, Y = \\tilde{g}^y</span> . Let  <span class="math">O_{X,Y}(\\cdot)</span>  be an oracle that takes as input a value  <span class="math">m \\in \\mathbb{Z}_p^*</span> , and outputs an LRSW-tuple  <span class="math">(a, a^x, a^{y+yxm})</span>  for a random  <span class="math">a \\in \\mathbb{G}_1</span> . Then for all probabilistic polynomial-time adversaries  <span class="math">\\mathcal{A}^{(\\cdot)}</span>  and all  <span class="math">m \\in \\mathbb{Z}_p^*</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[x \\stackrel{R}{\\leftarrow} \\mathbb{Z}_p, y \\stackrel{R}{\\leftarrow} \\mathbb{Z}_p, X = \\tilde{g}^x, Y = \\tilde{g}^y, (a_1, a_2, a_3, a_4, a_5) \\leftarrow \\mathcal{A}^{O_{X,Y}}(g, \\tilde{g}, X, Y) : \\\\ m \\notin Q \\land a_1 \\in \\mathbb{G}_1 \\land a_2 = a_1^x \\land a_3 = a_1^{y+yxm} \\land a_4 = a_1^m \\land a_5 = a_1^{mx}] &lt; 1/\\text{poly}(k),</span>$</p>

    <p class="text-gray-300">where Q is the set of queries A makes to  <span class="math">O_{X,Y}(\\cdot)</span> .</p>

    <p class="text-gray-300">The q-Strong Diffie-Hellman (q-SDH) assumption, as introduced by Boneh and Boyen [12], states that: for all probabilistic polynomial-time adversaries  <span class="math">\\mathcal{A}</span> , and all  <span class="math">c \\in \\mathbb{Z}_n^*</span> :</p>

    <p class="text-gray-300"><span class="math">$\\Pr[x \\stackrel{R}{\\leftarrow} \\mathbb{Z}_p : \\mathcal{A}(g, \\tilde{g}, g^x, \\dots, g^{(x^q)}, \\tilde{g}^x, \\dots, \\tilde{g}^{(x^q)}) = (c, \\tilde{g}^{1/(x+c)})] &lt; 1/\\operatorname{poly}(k).</span>$</p>

    <p class="text-gray-300">We make an interactive version of this assumption. As we mentioned in the introduction, our efficiency analysis takes into account Cheon's recent results [24] on q-SDH.</p>

    <p class="text-gray-300"><strong>Assumption 3 (Extended Diffie-Hellman (EDH))</strong> Let  <span class="math">x \\in \\mathbb{Z}_p^*</span> . Let oracle  <span class="math">O_x(\\cdot)</span>  take input  <span class="math">c_i \\in \\mathbb{Z}_p^*</span>  and produce output  <span class="math">(g^{v_i}, \\tilde{g}^{1/(x+v_i)}, \\tilde{g}^{1/(v_i+c_i)})</span> , for a random  <span class="math">v_i \\in \\mathbb{Z}_p^*</span> . For all probabilistic polynomial-time adversaries A, all  <span class="math">v, c \\in \\mathbb{Z}_p^*</span> , and all  <span class="math">a \\in \\mathbb{G}_1</span>  such that  <span class="math">a \\neq 1</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[x \\stackrel{R}{\\leftarrow} \\mathbb{Z}_p : \\mathcal{A}^{O_x}(g, g^x, \\tilde{g}, \\tilde{g}^x) = (c, a, a^x, a^v, \\tilde{g}^{1/(x+v)}, \\tilde{g}^{1/(v+c)}) \\land c \\notin Q] &lt; 1/\\operatorname{poly}(k)</span>$</p>

    <p class="text-gray-300">where Q is the set of queries A makes to oracle  <span class="math">O_x(\\cdot)</span> .</p>

    <p class="text-gray-300">The assumptions discussed so far are underlying the unforgeability of our group signature scheme. Its anonymity is based on a single assumption: that SXDH holds even when the adversary is given oracle access to additional information about the DDH instance.</p>

    <p class="text-gray-300"><strong>Assumption 4 (Strong SXDH)</strong> Let  <span class="math">g \\in \\mathbb{G}_1</span> ,  <span class="math">\\tilde{g} \\in \\mathbb{G}_2</span> , and  <span class="math">x \\in \\mathbb{Z}_p</span> . Let  <span class="math">O_x(\\cdot)</span>  be an oracle that takes as input  <span class="math">m \\in \\mathbb{Z}_p^*</span>  and outputs  <span class="math">(g^v, \\tilde{g}^{1/(x+v)}, \\tilde{g}^{1/(v+m)})</span>  for a random  <span class="math">v \\in \\mathbb{Z}_p^*</span> . Let  <span class="math">Q_y(\\cdot)</span>  be an oracle that takes the same input type and outputs  <span class="math">(g^r, g^{ry}, g^{rv}, \\tilde{g}^{1/(y+v)}, \\tilde{g}^{1/(v+m)})</span>  for a random  <span class="math">r, v \\in \\mathbb{Z}_p^*</span> . Then for all probabilistic polynomial-time adversaries  <span class="math">\\mathcal{A}^{(\\cdot)}</span> , and for randomly chosen  <span class="math">g \\in \\mathbb{G}_1</span> ,  <span class="math">\\tilde{g} \\in \\mathbb{G}_2</span> , and  <span class="math">x, y \\in \\mathbb{Z}_p</span> ,</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[\\mathcal{A}^{O_x,Q_x}(g,g^x,\\tilde{g})=1] - \\Pr[\\mathcal{A}^{O_x,Q_y}(g,g^x,\\tilde{g})=1]| &lt; 1/\\mathrm{poly}(k).</span>$</p>

    <p class="text-gray-300">In Theorem D.3, we show that Strong SXDH also has the same complexity as q-SDH for generic groups.</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Key Building Blocks: CL<sup>+</sup> and BB<sup>+</sup> Signatures</h2>

    <p class="text-gray-300">As mentioned in Section &sect;1, our group signature scheme is built out of two standard signature schemes secure without random oracles. We review the important details now.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Camenisch-Lysyanskaya Signatures</h3>

    <p class="text-gray-300">Recall the basic Pedersen commitment scheme [41], in which the public parameters are a group G of prime order p, and two generators g and h of G. To commit to the value  <span class="math">m \\in \\mathbb{Z}_p</span> , pick a random  <span class="math">r \\in \\mathbb{Z}_p</span>  and set  <span class="math">C = \\operatorname{PedCom}(m; r) = g^m h^r</span> .</p>

    <p class="text-gray-300">The Camenisch-Lysyanskaya (CL) signature scheme is secure without random oracles under the LRSW assumption [19]. CL signatures are also useful, because they support an efficient two-party protocol for obtaining a CL signature on the value (message) committed to in a Pedersen commitment. The common inputs are C = PedCom(m; r) and the verification key of the signer pk. The signer additionally knows the corresponding signing key sk, while the receiver additionally knows m and r. As a result of this protocol, the receiver obtains the signature  <span class="math">\\sigma_{sk}(m)</span> , while the signer does not learn anything about m. For our current purposes, it will not matter how this protocol actually works. Fortunately, a recent extension of the CL signatures by Ateniese et al. [3], denoted  <span class="math">CL^+</span> , inherits this protocol.</p>

    <p class="text-gray-300"><strong>CL</strong><sup>+</sup> <strong>Signatures.</strong> Let the security parameter be  <span class="math">1^k</span> . The global parameters are the description of a pairing  <span class="math">params = (p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, g, \\tilde{g})</span> , where  <span class="math">\\mathbb{G}_1 = \\langle g \\rangle</span>  and  <span class="math">\\mathbb{G}_2 = \\langle \\tilde{g} \\rangle</span> , obtained by running BilinearSetup <span class="math">(1^k)</span> . Keypairs are of the form  <span class="math">pk = (\\tilde{g}^s, \\tilde{g}^t)</span>  and  <span class="math">sk = (s, t) \\in \\mathbb{Z}_p^2</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Signing:</strong> Choose random  <span class="math">a \\in \\mathbb{G}_1</span> , output  <span class="math">(a, a^t, a^{s+stm}, a^m, a^{mt})</span>  as the signature on <em>hidden</em> message  <span class="math">m \\in \\mathbb{Z}_p^*</span> .</li>
      <li><strong>Verification:</strong> On input a purported signature (A, B, C, D, E) accept that  <span class="math">\\sigma</span>  authenticates the message hidden as  <span class="math">\\log_A(D)</span>  if and only if: (1)  <span class="math">e(B, \\tilde{g}) = e(A, \\tilde{g}^t)</span> , (2)  <span class="math">e(D, \\tilde{g}^t) = e(E, \\tilde{g})</span> , and (3)  <span class="math">e(C, \\tilde{g}) = e(A, \\tilde{g}^s)e(E, \\tilde{g}^s)</span> .</li>
      <li><strong>Re-Randomization:</strong> On input a signature (A, B, C, D, E), choose a random  <span class="math">r \\in \\mathbb{Z}_p^*</span>  and output  <span class="math">(A^r, B^r, C^r, D^r, E^r)</span> .</li>
    </ul>

    <p class="text-gray-300">CL<sup>+</sup> signatures are secure assuming SXDH and Strong LRSW. As previously observed in [3], when CL<sup>+</sup> signatures are set in pairing groups where SXDH is hard, this re-randomization is <em>unlinkable</em>. We formally argue this second point in Lemma A.2.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 Boneh-Boyen Signatures</h3>

    <p class="text-gray-300">Recall the weak Boneh-Boyen (BB) signature scheme [12]. Let the security parameter be  <span class="math">1^k</span> . The global parameters are the description of a pairing  <span class="math">params = (p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T)</span>  obtained by running BilinearSetup <span class="math">(1^k)</span>  (here, we ignore the generators output by BilinearSetup). Keypairs are of the form  <span class="math">pk = (g, g^{sk}, \\tilde{g})</span>  and  <span class="math">sk \\in \\mathbb{Z}_p^*</span> , for random generators  <span class="math">g \\in \\mathbb{G}_1</span>  and  <span class="math">\\tilde{g} \\in \\mathbb{G}_2</span> . To sign a message  <span class="math">m \\in \\mathbb{Z}_p^*</span> , output the signature  <span class="math">\\tilde{g}^{1/(sk+m)}</span> . To verify signature  <span class="math">\\sigma</span> , accept if and only if  <span class="math">e(\\sigma, g^{sk}g^m) = e(g, \\tilde{g})</span> . Note that in this work we reverse the roles of  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span>  from the original description in [12]. As in other implementation of pairing-based schemes where distortion maps are not available, one chooses the role of each pairing group to maximize the efficiency of one's protocol.</p>

    <p class="text-gray-300">This scheme was proven unforgeable only against weak chosen-message attack under the q-SDH assumption [12], where the adversary must submit all of his signature queries in advance of the public key</p>

    <p class="text-gray-300">generation. Boneh and Boyen gave one method of modifying this weak scheme into an adaptively-secure one [12]. We provide a second method, which is more suited to our purposes.</p>

    <p class="text-gray-300"><span class="math">{\\bf BB^+}</span>  Signatures. The intuition here is that to issue a signature on a message m, a weak BB signature under sk is issued on a one-time signing key v, and then another weak BB signature under v is issued on message m. The additional randomness v allows to prove adaptive security.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Key generation:</strong> Same as before. (Although, now the same bases may be used for all keys.)</li>
      <li><strong>Signing:</strong> On input a secret key sk and a message  <span class="math">m \\in \\mathbb{Z}_p^*</span> , select a random  <span class="math">r \\in \\mathbb{Z}_p^*</span> , and output the signature  <span class="math">(g^r, \\tilde{g}^{1/(sk+r)}, \\tilde{g}^{1/(r+m)})</span> .</li>
      <li><strong>Verification:</strong> On input a public key  <span class="math">(g, g^{sk}, \\tilde{g})</span> , a message m, and a purported signature (A, B, C), accept if and only if: (1)  <span class="math">e(g^{sk}A, B) = e(g, \\tilde{g})</span>  and (2)  <span class="math">e(Ag^m, C) = e(g, \\tilde{g})</span> .</li>
    </ul>

    <p class="text-gray-300"><strong>Lemma 4.1</strong> The BB<sup>+</sup> signature scheme is existentially unforgeable under adaptive chosen-message attack under the EDH assumption.</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Our Basic Group Signature Construction</h2>

    <p class="text-gray-300"><strong>Notation:</strong> BB<sup>+</sup> and CL<sup>+</sup>, respectively, denote our Section &sect;4 modifications of the Boneh-Boyen [12] and Camenisch-Lysyanskaya [19] signature schemes. When we write  <span class="math">A = Sign_{GSK}^{CL+}(m;a)</span> , we mean that A is a CL<sup>+</sup> signature under key GSK on message m using base a; that is,  <span class="math">A = (a, a^t, a^{s+stm}, a^m, a^{mt})</span>  for GSK = (s, t). Similarly, when we write  <span class="math">A = Sign_{sk}^{BB+}(m; g, \\tilde{g})</span> , we mean that A is a BB<sup>+</sup> signature under key sk on message m using bases  <span class="math">(g, \\tilde{g})</span> ; that is,  <span class="math">A = (g^v, \\tilde{g}^{1/(sk+v)}, \\tilde{g}^{1/(v+m)})</span>  for some  <span class="math">v \\in \\mathbb{Z}_p^*</span> .</p>

    <p class="text-gray-300">Let BilinearSetup(1<sup>k</sup>)  <span class="math">\\rightarrow params = (p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, q, \\tilde{q})</span> , where  <span class="math">\\mathbb{G}_1 = \\langle q \\rangle</span>  and  <span class="math">\\mathbb{G}_2 = \\langle \\tilde{q} \\rangle</span> .</p>

    <p class="text-gray-300"><strong>GroupSetup</strong>( <span class="math">1^k</span> , params): The group manager establishes the public parameters for the Pedersen commitment scheme [41] and adds those to params. Then, the group manager executes  <span class="math">Gen^{CL+}(1^k, params)</span>  to obtain  <span class="math">GPK = (params, \\mathcal{S} = \\tilde{g}^s, \\mathcal{T} = \\tilde{g}^t)</span>  and GSK = (s, t).</p>

    <p class="text-gray-300"><strong>UserKeyGen</strong>( <span class="math">1^k</span> , params): Each user  <span class="math">\\mathcal{U}</span>  selects random  <span class="math">sk \\in \\mathbb{Z}_p^*</span>  and random  <span class="math">h \\in \\mathbb{G}_1</span> , and outputs a public key  <span class="math">pk = (h, e(h, \\tilde{g})^{sk})</span> .</p>

    <p class="text-gray-300"><strong>Join</strong>( <span class="math">\\mathcal{U}_i(GPK, sk_i), \\mathcal{GM}(pk_i, GSK)</span> ): In this interactive protocol, the user's inputs are her secret key  <span class="math">sk_i</span>  and the public key of the group manager GPK. Likewise, the group manager receives as input GSK and  <span class="math">pk_i</span> . They interact as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathcal{U}_i</span>  submits her public key  <span class="math">pk_i = (p_1, p_2)</span>  and tracing information  <span class="math">Q_i = \\tilde{g}^{sk_i}</span>  to  <span class="math">\\mathcal{GM}</span> . If  <span class="math">e(p_1, Q_i) \\neq p_2</span>  or  <span class="math">sk_i</span>  was already in D,  <span class="math">\\mathcal{GM}</span>  aborts. Else,  <span class="math">\\mathcal{GM}</span>  enters  <span class="math">Q_i</span>  in database D.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The user sends a commitment  <span class="math">A = \\operatorname{PedCom}(sk_i)</span>  to  <span class="math">\\mathcal{GM}</span> . The user and  <span class="math">\\mathcal{GM}</span>  run the CL protocol (see Section 4.1) for obtaining  <span class="math">\\mathcal{GM}</span> 's signature on the committed value contained in commitment A.  <span class="math">\\mathcal{GM}</span>  picks a random  <span class="math">r \\in \\mathbb{Z}_p^*</span>  and sets  <span class="math">f_1 = g^r</span> . Then,  <span class="math">\\mathcal{GM}</span>  computes  <span class="math">\\operatorname{Sign}_{GSK}^{CL+}(sk_i; f_1) = (f_2, f_3)</span>  and sends all three values to the user. If the CL signature  <span class="math">(f_1, f_2, f_3)</span>  does not verify for message  <span class="math">sk_i</span> , the user aborts.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The user provides a zero-knowledge proof that the committed value  <span class="math">sk_i</span>  contained in commitment A is consistent with the public key  <span class="math">pk_i</span>  and a zero-knowledge proof of knowledge of  <span class="math">sk_i</span>  using any proof technique that is <em>extractable</em>. (For more on such proofs, see Appendix B.)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The group manager provides an extractable zero-knowledge proof of GSK = (s, t).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Next, the user locally computes the values  <span class="math">f_4 = f_1^{sk_i}</span>  and  <span class="math">f_5 = f_2^{sk_i}</span> .</li>
    </ol></li>
    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>At the end of this protocol, the user obtains the following membership certificate:</li>
    </ol>

    <p class="text-gray-300"><span class="math">$C_i = (f_1, \\dots, f_5) = (a, a^t, a^{s+st(sk_i)}, a^{sk_i}, a^{(sk_i)t}).</span>$</p>

    <p class="text-gray-300"><strong>GroupSign</strong> <span class="math">(sk_i, C_i, m)</span> : A user with secret key  <span class="math">sk_i</span>  and membership certificate  <span class="math">C_i = (f_1, \\ldots, f_5)</span>  may sign a message  <span class="math">m \\in \\mathbb{Z}_p^*</span>  as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Re-randomize  <span class="math">C_i</span>  using a random  <span class="math">r \\in \\mathbb{Z}_p</span> , i.e., compute  <span class="math">(a_1,\\ldots,a_5)=(f_1^r,\\ldots,f_5^r)</span> . 2. Compute  <span class="math">Sign_{sk_i}^{BB+}(m;a_5,\\tilde{g})=(a_6,a_7,a_8)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output the signature  <span class="math">(a_1, \\ldots, a_8)</span>  of the form  <span class="math">(b, b^t, b^{s+st(sk_i)}, b^{sk_i}, b^{(sk_i)t}, b^v, \\tilde{q}^{1/(sk_i+v)}, \\tilde{q}^{1/(v+m)})</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><strong>GroupVerify</strong>  <span class="math">(GPK, m, \\sigma)</span> : To verify that  <span class="math">\\sigma = (a_1, \\ldots, a_8)</span>  is a group signature on m, do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that  <span class="math">(a_1, a_2, a_3, a_4, a_5)</span>  is a valid  <span class="math">CL^+</span>  signature for public key GPK where the <em>hidden</em> message is the exponent of  <span class="math">a_4</span>  (base  <span class="math">a_1</span> ). Specifically, verify that: (1)  <span class="math">e(a_1, \\mathcal{T}) = e(a_2, \\tilde{g})</span> , (2)  <span class="math">e(a_4, \\mathcal{T}) =</span>  <span class="math">e(a_5, \\tilde{g})</span> , and (3)  <span class="math">e(a_1a_5, \\mathcal{S}) = e(a_3, \\tilde{g})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Check that  <span class="math">(a_6, a_7, a_8)</span>  is a valid BB<sup>+</sup> signature for public key  <span class="math">(a_1, a_4, \\tilde{g})</span>  on message m. Specifically, verify that: (1)  <span class="math">e(a_4a_6, a_7) = e(a_1, \\tilde{g})</span>  and (2)  <span class="math">e(a_6a_1^m, a_8) = e(a_1, \\tilde{g})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If both checks pass, accept; otherwise, reject.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><strong>Open</strong>( <span class="math">GSK, m, \\sigma</span> ): On input any valid signature  <span class="math">\\sigma = (a_1, \\ldots, a_8)</span>  and tracing database  <span class="math">D, \\mathcal{GM}</span>  may run the following algorithm to identify the signer. For each entry  <span class="math">Q_i \\in D</span> , the group manager checks whether  <span class="math">e(a_4, \\tilde{g}) = e(a_1, Q_i)</span> . If a match is found, then  <span class="math">\\mathcal{GM}</span>  outputs  <span class="math">\\mathcal{U}_i</span>  as the identity of the original signer.</p>

    <p class="text-gray-300"><strong>VerifyOpen</strong>( <span class="math">\\mathcal{GM}(GSK, m, \\sigma, pk_i, Q_i), \\mathcal{V}(GPK, m, \\sigma, pk_i)</span> ): First,  <span class="math">\\mathcal{GM}</span>  checks that  <span class="math">\\sigma</span>  is a valid group signature; that is, GroupVerify <span class="math">(GPK, \\sigma, m) = 1</span> . Next,  <span class="math">\\mathcal{GM}</span>  checks that  <span class="math">\\mathcal{U}_i</span>  is responsible for creating  <span class="math">\\sigma</span> ; that is, using tracing information  <span class="math">Q_i = \\tilde{g}^{sk_i}</span>  from database D and  <span class="math">pk_i = (p_1, p_2)</span> , test that  <span class="math">e(p_1, Q_i) = p_2</span> . If both of these conditions hold, then  <span class="math">\\mathcal{GM}</span>  proceeds to convince a verifier that  <span class="math">\\mathcal{U}_i</span>  was responsible for  <span class="math">\\sigma</span> . We call this step anonymity revocation. Here, the  <span class="math">\\mathcal{GM}</span>  provides a zero-knowledge proof of knowledge of a value  <span class="math">\\alpha \\in \\mathbb{G}_2</span>  (i.e., the tracing information for  <span class="math">\\mathcal{U}_i</span> ) such that  <span class="math">e(p_1, \\alpha) = p_2</span>  and  <span class="math">e(a_1, \\alpha) = e(a_4, \\tilde{g})</span>  [1].</p>

    <p class="text-gray-300">The revocation described above revokes the anonymity of a particular signature, however, the  <span class="math">\\mathcal{GM}</span>  could instead revoke the anonymity of all signatures belonging to user  <span class="math">U_i</span>  by publishing the tracing information  <span class="math">Q_i</span> . Then anyone can verify that the user with public key  <span class="math">pk = (p_1, p_2)</span>  must be responsible by checking that: (1)  <span class="math">e(p_1, Q_i) = p_2</span> , and (2)  <span class="math">e(a_1, Q_i) = e(a_4, \\tilde{g})</span> .</p>

    <p class="text-gray-300"><strong>Theorem 5.1</strong> In the plain model, the above group signature scheme realizes  <span class="math">\\mathcal{F}_{qs}</span>  from Section &sect;2 under the Strong LRSW, the EDH, and the Strong SXDH assumptions.</p>

    <p class="text-gray-300">Proof of Theorem 5.1 appears in Appendix A.</p>

    <h2 id="sec-misc-1" class="text-2xl font-bold"><strong>Opening Signatures in Sublinear Time</strong></h2>

    <p class="text-gray-300">The basic Open algorithm described in Section &sect;5 takes  <span class="math">O(n \\cdot k)</span>  for a signing group of n members and security parameter k. Practically, this precludes this scheme from being used for many applications with large groups. We provide several options to remedy this situation in Appendix C.</p>

    <p class="text-gray-300">First, we present an Open algorithm with complexity  <span class="math">O(\\sqrt{n} \\cdot k)</span>  which can be extended to one with complexity  <span class="math">O((\\log n) \\cdot k)</span>  at the cost of group signatures becoming of size  <span class="math">O((\\log n) \\cdot k)</span> . This improvement requires no additional assumptions, but does add two elements in  <span class="math">\\mathbb{G}_1</span>  (resp.  <span class="math">\\log n</span>  elements) to the signature length. Next, we present a  <span class="math">O((\\log n) + k)</span>  Open algorithm. This increases the basic signature by three elements in  <span class="math">\\mathbb{G}_1</span>  and requires a slightly different anonymity assumption.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>References</strong></h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">[1] B. Adida, S. Hohenberger, and R. L. Rivest. Ad-Hoc-Group Signatures from Hijacked Keypairs, 2005. At http://theory.lcs.mit.edu/<sup>&sim;</sup>rivest/publications.</p></li>
      <li><p class="text-gray-300">[2] J. H. An, Y. Dodis, and T. Rabin. On the security of joint signature and encryption. In <em>EUROCRYPT</em>, volume 2332 of LNCS, pages 83&ndash;107, 2002.</p></li>
      <li><p class="text-gray-300">[3] G. Ateniese, J. Camenisch, and B. de Medeiros. Untraceable RFID tags via insubvertible encryption. In <em>ACM CCS</em>, pages 92&ndash;101, 2005.</p></li>
      <li><p class="text-gray-300">[4] G. Ateniese, J. Camenisch, M. Joye, and G. Tsudik. A practical and provably secure coalition-resistant group signature scheme. In <em>CRYPTO</em>, volume 1880 of LNCS, pages 255&ndash;270, 2000.</p></li>
      <li><p class="text-gray-300">[5] G. Ateniese and G. Tsudik. Some open issues and new directions in group signatures. In <em>Financial Cryptography</em>, volume 1648 of LNCS, pages 196&ndash;211, 1999.</p></li>
      <li><p class="text-gray-300">[6] L. Ballard, M. Green, B. de Medeiros, and F. Monrose. Correlation-resistant storage. Technical Report TR-SP-BGMM-050705, Johns Hopkins University, CS Dept, 2005. http://spar.isi.jhu.edu/<sup>&sim;</sup>mgreen/ correlation.pdf.</p></li>
      <li><p class="text-gray-300">[7] P. S. L. M. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order, 2005. Cryptology ePrint Archive: 2005/133.</p></li>
      <li><p class="text-gray-300">[8] D. Beaver. Secure multi-party protocols and zero-knowledge proof systems tolerating a faulty minority. <em>Journal of Cryptology</em>, 4:75&ndash;122, 1991.</p></li>
      <li><p class="text-gray-300">[9] M. Bellare, D. Micciancio, and B. Warinschi. Foundations of group signatures: Formal definition, simplified requirements and a construction based on general assumptions. In <em>EUROCRYPT</em>, volume 2656 of LNCS, pages 614&ndash;629, 2003.</p></li>
      <li><p class="text-gray-300">[10] M. Bellare and A. Palacio. GQ and Schnorr Identification Schemes: Proofs of Security against Impersonation under Active and Concurrent Attacks. In <em>CRYPTO</em>, volume 2442 of LNCS, pages 162&ndash;177, 2002.</p></li>
      <li><p class="text-gray-300">[11] M. Bellare, H. Shi, and C. Zhang. Foundations of group signatures: The case of dynamic groups. In <em>CT-RSA</em>, volume 3376 of LNCS, pages 136&ndash;153, 2005.</p></li>
      <li><p class="text-gray-300">[12] D. Boneh and X. Boyen. Short signatures without random oracles. In <em>EUROCRYPT 2004</em>, volume 3027 of LNCS, pages 56&ndash;73, 2004.</p></li>
      <li><p class="text-gray-300">[13] D. Boneh, X. Boyen, and H. Shacham. Short group signatures. In <em>CRYPTO</em>, volume 3152 of <em>LNCS</em>, pages 41&ndash;55, 2004.</p></li>
      <li><p class="text-gray-300">[14] D. Boneh, B. Lynn, and H. Shacham. Short signatures from the Weil pairing. In <em>ASIACRYPT</em>, volume 2248 of LNCS, pages 514&ndash;532, 2001.</p></li>
      <li><p class="text-gray-300">[15] D. Boneh and H. Shacham. Group signatures with verifier-local revocation. In <em>Proc. of the ACM Conf. on Computer and Communications Security (ACM CSS 2004)</em>, pages 168&ndash;177. ACM Press, 2004.</p></li>
      <li><p class="text-gray-300">[16] X. Boyen and B. Waters. Compact Group Signatures Without Random Oracles. In <em>EUROCRYPT '06</em>, volume 4004 of LNCS, pages 427&ndash;444, 2006.</p></li>
      <li><p class="text-gray-300">[17] E. Brickell, J. Camenisch, and L. Chen. Direct anonymous attestation. In <em>ACM CCS</em>, pages 132&ndash;145, 2004.</p></li>
      <li><p class="text-gray-300">[18] J. Camenisch and I. Damgard. Verifiable encryption, group encryption, and their applications to group signatures &#730; and signature sharing schemes. In <em>ASIACRYPT</em>, volume 1976 of LNCS, pages 331&ndash;345, 2000.</p></li>
      <li><p class="text-gray-300">[19] J. Camenisch and A. Lysyanskaya. Signature Schemes and Anonymous Credentials from Bilinear Maps. In <em>CRYPTO</em>, volume 3152 of LNCS, pages 56&ndash;72, 2004.</p></li>
      <li><p class="text-gray-300">[20] R. Canetti. <em>Studies in Secure Multiparty Computation and Applications</em>. PhD thesis, Weizmann Institute of Science, Rehovot 76100, Israel, June 1995.</p></li>
      <li><p class="text-gray-300">[21] R. Canetti. Security and composition of multi-party cryptographic protocols. <em>Journal of Cryptology</em>, 13(1):143&ndash; 202, 2000.</p></li>
      <li><p class="text-gray-300">[22] R. Canetti. Universally composable security: A new paradigm for cryptographic protocols. In <em>FOCS</em>, pages 136&ndash;145, 2001.</p></li>
      <li><p class="text-gray-300">[23] D. Chaum and E. van Heyst. Group Signatures. In <em>EUROCRYPT</em>, volume 547 of LNCS, pages 257&ndash;265, 1991.</p></li>
      <li><p class="text-gray-300">[24] J. H. Cheon. Security Analysis of the Strong Diffie-Hellman Problem. In <em>EUROCRYPT '06</em>, volume 4004 of LNCS, pages 1&ndash;11, 2006.</p></li>
      <li><p class="text-gray-300">[25] I. Damgard. Efficient concurrent zero-knowledge in the auxiliary string model. In &#730; <em>EUROCRYPT</em>, volume 1807 of LNCS, pages 418&ndash;430, 2000.</p></li>
      <li><p class="text-gray-300">[26] A. Datta, A. Derek, J. C. Mitchell, A. Ramanathan, and A. Scedrov. Games and the impossibility of realizable ideal functionality. In <em>TCC</em>, volume 3876 of LNCS, pages 360&ndash;379, 2006.</p></li>
      <li><p class="text-gray-300">[27] A. W. Dent. Adapting the weaknesses of the random oracle model to the generic group model. In <em>ASIACRYPT '02</em>, volume 2501 of LNCS, pages 100&ndash;109, 2002.</p></li>
      <li><p class="text-gray-300">[28] M. Fischlin. Communication-Efficient Non-Interactive Proofs of Knowledge with Online Extractors. In <em>CRYPTO</em>, pages 152&ndash;168, 2005.</p></li>
      <li><p class="text-gray-300">[29] S. D. Galbraith. Supersingular curves in cryptography. In <em>ASIACRYPT</em>, volume 2248 of LNCS, pages 495&ndash;513, 2001.</p></li>
      <li><p class="text-gray-300">[30] S. D. Galbraith. Personal communication, August, 2005.</p></li>
      <li><p class="text-gray-300">[31] S. D. Galbraith, K. G. Paterson, and N. P. Smart. Pairings for cryptographers. Technical Report 2006/165, International Association for Cryptological Research, 2006.</p></li>
      <li><p class="text-gray-300">[32] S. D. Galbraith and V. Rotger. Easy decision Diffie-Hellman groups. <em>Journal of Computation and Mathematics</em>, 7:201&ndash;218, 2004.</p></li>
      <li><p class="text-gray-300">[33] S. Goldwasser and Y. T. Kalai. On the (In)security of the Fiat-Shamir Paradigm. In <em>FOCS</em>, pages 102&ndash;115, 2003.</p></li>
      <li><p class="text-gray-300">[34] S. Goldwasser, S. Micali, and R. Rivest. A digital signature scheme secure against adaptive chosen-message attacks. <em>SIAM J. of Computing</em>, 17(2):281&ndash;308, 1988.</p></li>
      <li><p class="text-gray-300">[35] A. Kiayias, Y. Tsiounis, and M. Yung. Traceable signatures. In <em>EUROCRYPT</em>, volume 3027 of <em>LNCS</em>, pages 571&ndash;589, 2004.</p></li>
      <li><p class="text-gray-300">[36] A. Kiayias and M. Yung. Group signatures: Provable security, efficient constructions and anonymity from trapdoor-holders, 2004. Cryptology ePrint Archive: 2004/076.</p></li>
      <li><p class="text-gray-300">[37] A. Lysyanskaya, R. L. Rivest, A. Sahai, and S. Wolf. Pseudonym systems. In <em>SAC</em>, volume 1758 of <em>LNCS</em>, pages 184&ndash;199, 1999.</p></li>
      <li><p class="text-gray-300">[38] N. McCullagh and P. S. L. M. Barreto. A new two-party identity-based authenticated key agreement. In <em>CT-RSA</em>, volume 3376 of LNCS, pages 262&ndash;274, 2004.</p></li>
      <li><p class="text-gray-300">[39] M. Naor. Cryptographic assumptions and challenges. In <em>Proc. Adv. in Cryptology (CRYPTO 2003)</em>, volume 2729 of <em>LNCS</em>, pages 96&ndash;109. Springer, 2003.</p></li>
      <li><p class="text-gray-300">[40] V. I. Nechaev. Complexity of a determinate algorithm for the discrete logarithm. <em>Mathematical Notes</em>, 55:165&ndash; 172, 1994.</p></li>
      <li><p class="text-gray-300">[41] T. P. Pedersen. Non-interactive and information-theoretic secure verifiable secret sharing. In <em>CRYPTO</em>, volume 576 of LNCS, pages 129&ndash;140, 1991.</p></li>
      <li><p class="text-gray-300">[42] B. Pfitzmann and M. Waidner. Composition and integrity preservation of secure reactive systems. In <em>ACM CCS</em>, pages 245&ndash;254, 2000.</p></li>
      <li><p class="text-gray-300">[43] B. Pfitzmann and M. Waidner. A model for asynchronous reactive systems and its application to secure message transmission. In <em>IEEE S&amp;P</em>, pages 184&ndash;200, 2001.</p></li>
      <li><p class="text-gray-300">[44] M. Scott. MIRACL library. Indigo Software. http://indigo.ie/<sup>&sim;</sup>mscott.</p></li>
      <li><p class="text-gray-300">[45] M. Scott. Authenticated ID-based key exchange and remote log-in with simple token and PIN number, 2002. Cryptology ePrint Archive: 2002/164.</p></li>
      <li><p class="text-gray-300">[46] V. Shoup. Lower bounds for discrete logarithms and related problems. In <em>EUROCRYPT</em>, LNCS, pages 256&ndash;266, 1997. Update: http://www.shoup.net/papers/.</p></li>
      <li><p class="text-gray-300">[47] E. R. Verheul. Evidence that XTR is more secure than supersingular elliptic curve cryptosystems. In <em>EURO-CRYPT</em>, volume 2045 of LNCS, pages 195&ndash;210, 2001.</p></li>
    </ul>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>A Security Proof of Basic Construction</strong></h2>

    <p class="text-gray-300">We now prove Theorem 5.1 on the security of our basic construction.</p>

    <p class="text-gray-300"><em>Proof.</em> Our goal is to show that for every adversary A and environment Z, there exists a simulator S such that Z cannot distinguish whether it is interacting in the real world with A or the ideal world with S. The proof is structured in two parts. First, for arbitrary fixed A and Z, we describe a simulator S. Then, we argue that S satisfies our goal.</p>

    <p class="text-gray-300">Recall that the simulator interacts with the ideal functionality  <span class="math">\\mathcal{F}_{gs}</span>  on behalf of all corrupted parties in the ideal world, and also simulates the real-world adversary  <span class="math">\\mathcal{A}</span>  towards the environment.  <span class="math">\\mathcal{S}</span>  is given black-box access to  <span class="math">\\mathcal{A}</span> . In our description,  <span class="math">\\mathcal{S}</span>  will use  <span class="math">\\mathcal{A}</span>  to simulate conversations with  <span class="math">\\mathcal{Z}</span> . Specifically,  <span class="math">\\mathcal{S}</span>  will directly forward all messages from  <span class="math">\\mathcal{A}</span>  to  <span class="math">\\mathcal{Z}</span>  and from  <span class="math">\\mathcal{Z}</span>  to  <span class="math">\\mathcal{A}</span> .</p>

    <p class="text-gray-300">The simulator will be responsible for handling several different operations within the group signature system. The operations are triggered either by messages from  <span class="math">\\mathcal{F}_{gs}</span>  to any of the corrupted parties in the ideal system (and thus these messages are sent to  <span class="math">\\mathcal{S}</span> ) or when  <span class="math">\\mathcal{A}</span>  wants to send any messages to honest parties. In our description,  <span class="math">\\mathcal{S}</span>  will simulate the (real-world) honest parties of towards  <span class="math">\\mathcal{A}</span> .</p>

    <p class="text-gray-300">Finally, we assume that when a signature is created, it becomes public information. Likewise, whenever a signature is opened, the corresponding identity is announced to all. (However, each user may still require individual proof from the  <span class="math">\\mathcal{GM}</span>  that this identity is correct.)</p>

    <p class="text-gray-300"><strong>Notation:</strong> The simulator S may need to behave differently depending on which parties are corrupted. There are two parties of interest: the group manager and a user. We adopt previous notation [17] for this: a capital letter denotes that the corresponding party is not corrupted and a small letter denotes that it is. For example, by &quot;Case (Gu)&quot; we refer to the case where the group manager is honest, but the user is corrupted.</p>

    <p class="text-gray-300">We will refer to a user as  <span class="math">\\mathcal{U}_i</span>  and a user's public key as  <span class="math">pk_i</span> . We assume throughout that a party in possession of one of these two identifiers is also in possession of the other.</p>

    <p class="text-gray-300">We now describe how the simulator S behaves. Intuitively, when the group manager is corrupt, S will sign messages for whatever user  <span class="math">\\mathcal{F}_{gs}</span>  tells it. When the group manager is honest, however, S will be asked to sign messages on behalf of unknown users and might later be asked to open them. In this case, S will sign all messages using the same secret key, which we denote  <span class="math">sk^*</span> . Then, whenever S is told to open this signature to a particular user later revealed by  <span class="math">\\mathcal{F}_{qs}</span> , it will fake the corresponding proof.</p>

    <p class="text-gray-300"><strong>Non-Adaptive Setup:</strong> Each party that  <span class="math">\\mathcal{S}</span>  corrupts reports to  <span class="math">\\mathcal{F}_{gs}</span>  that it is corrupted. The global parameters BilinearSetup <span class="math">(1^k) \\to (p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, g, \\tilde{g}) = params</span> , where  <span class="math">\\mathbb{G}_1 = \\langle g \\rangle</span>  and  <span class="math">\\mathbb{G}_2 = \\langle \\tilde{g} \\rangle</span> , are broadcast to all parties.</p>

    <p class="text-gray-300"><strong>Simulation of the Real World's Setup:</strong> The group manager has an associated key pair (GPK, GSK). Regardless of the honesty of the group manager, S sets up any public parameters needed later for the registration of a user's key in Join (e.g., the hash function used in the Fischlin transformation).</p>

    <p class="text-gray-300">Case (g): If the group manager is corrupted, then S receives the group key GPK from A.</p>

    <p class="text-gray-300">Case (G): If the group manager is honest, then S runs the GroupSetup algorithm to generate a group public key GPK which it then gives to A. Note that in this case S knows the corresponding secrets and the relation of the Pedersen commitment bases. (Although, an ideal group manager exists outside of S, the simulator will internally act as a real-world manager toward A.)</p>

    <p class="text-gray-300"><strong>Simulation of Honest Parties' Setup:</strong> Each party must have an associated key pair  <span class="math">(pk_i, sk_i)</span> .</p>

    <p class="text-gray-300">Case (u): If user  <span class="math">\\mathcal{U}_i</span>  is corrupted, then  <span class="math">\\mathcal{S}</span>  receives the user's public key  <span class="math">pk_i</span>  from  <span class="math">\\mathcal{A}</span> .</p>

    <p class="text-gray-300">Case (U): If  <span class="math">\\mathcal{U}_i</span>  is honest, then  <span class="math">\\mathcal{S}</span>  runs the UserKeyGen algorithm to generate a public key  <span class="math">pk_i</span>  which it then gives to  <span class="math">\\mathcal{A}</span> . (Although, ideal honest parties exist outside of  <span class="math">\\mathcal{S}</span> , the simulator will internally create real-world public keys for them.)</p>

    <p class="text-gray-300"><strong>Simulation of the Join Protocol:</strong> In this operation, a user asks the group manager, via  <span class="math">\\mathcal{F}_{gs}</span> , if it can join the group and receives an answer bit.</p>

    <p class="text-gray-300">Case (gu): If both the group manager and the user are corrupt, then S does nothing.</p>

    <p class="text-gray-300">Case (Gu): The group manager is honest, but the user is corrupt. Then,  <span class="math">\\mathcal{A}</span>  will start by sending  <span class="math">\\mathcal{S}</span>  the public key  <span class="math">pk = (p_1, p_2)</span>  and tracing information Q associated with some corrupt user  <span class="math">\\mathcal{U}_i</span> .  <span class="math">\\mathcal{S}</span>  will verify the tracing information by checking that  <span class="math">e(p_1, Q) = p_2</span> . If this check does not pass,  <span class="math">\\mathcal{S}</span>  returns an error message to the corrupt user and ends the Join protocol. Otherwise,  <span class="math">\\mathcal{S}</span>  stores the pair (pk, Q) in a database D. Now  <span class="math">\\mathcal{S}</span> , acting as the honest group manager with knowledge of GSK, executes the remainder of the real-world Join protocol with  <span class="math">\\mathcal{A}</span> , exiting with an error message when necessary according to the protocol. If  <span class="math">\\mathcal{S}</span>  does not output an error message, then  <span class="math">\\mathcal{S}</span>  submits  <span class="math">(\\mathcal{U}_i</span> , &quot;enroll&quot;) to  <span class="math">\\mathcal{F}_{qs}</span> .</p>

    <p class="text-gray-300">Case (gU): The group manager is corrupt, but the user is honest. S will be triggered in this case by  <span class="math">\\mathcal{F}_{gs}</span>  asking if some honest user  <span class="math">\\mathcal{U}_i</span>  may enroll. S will internally simulate a real-world version of  <span class="math">\\mathcal{U}_i</span>  towards A using the key pair S generated for  <span class="math">\\mathcal{U}_i</span>  during the user setup phase. If A stops before the end of the protocol, S returns the answer &quot;no&quot; to  <span class="math">\\mathcal{F}_{gs}</span> . If the  <span class="math">CL^+</span>  signature obtained by S during step 2 of the Join protocol verifies, then S records this certificate and returns &quot;yes&quot; to  <span class="math">\\mathcal{F}_{gs}</span> . Otherwise, it returns &quot;no&quot;.</p>

    <p class="text-gray-300">Case (GU): If both the group manager and the user are honest, then S does nothing.</p>

    <p class="text-gray-300">Simulation of the GroupSign Operation: Let id be a counter initialized to zero. In this operation, a user anonymously obtains a signature on a message via  <span class="math">\\mathcal{F}_{gs}</span> . When an honest member of the group requests to sign a message m,  <span class="math">\\mathcal{F}_{gs}</span>  will forward (&quot;sign&quot;, m) to  <span class="math">\\mathcal{S}</span> . When  <span class="math">\\mathcal{A}</span>  outputs a real-world signature,  <span class="math">\\mathcal{S}</span>  will be responsible for translating it into the ideal world.</p>

    <p class="text-gray-300">Here, we denote by  <span class="math">sk^*</span>  the special signing key that S uses to sign all messages, for <em>all</em> honest parties when the group manager is honest.</p>

    <p class="text-gray-300">Case (u): The user is corrupt. When  <span class="math">\\mathcal{A}</span>  outputs a valid signature  <span class="math">\\sigma=(a_1,\\ldots,a_8)</span>  on message  <span class="math">m,\\mathcal{S}</span>  tests if it is a (partial) re-randomization of any previous signature; that is, for all signatures  <span class="math">(b_1,\\ldots,b_8)</span>  on message m in L, test if  <span class="math">a_7=b_7</span>  (this corresponds to the value  <span class="math">\\tilde{g}^{1/(sk+v)}</span> ). If any match is found,  <span class="math">\\mathcal{S}</span>  takes no further action.</p>

    <p class="text-gray-300">However, when no match is found, S must register the signature with  <span class="math">\\mathcal{F}_{gs}</span> . To do so, S must first discover the signer of  <span class="math">\\sigma</span> . For every registered user, S uses the tracing information in database D to check if  <span class="math">e(a_1,Q_i)=e(a_4,\\tilde{g})</span> . Suppose a match is found for some  <span class="math">Q_i=\\tilde{g}^{sk_i}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">sk_i = sk^*</span> , then the simulation has failed. S aborts and outputs &quot;Failure 2&quot;.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">sk_i \\neq sk^*</span>  and  <span class="math">\\mathcal{U}_i</span>  is honest, the simulation has failed.  <span class="math">\\mathcal{S}</span>  aborts and outputs &quot;Failure 3&quot;.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">U_i</span>  is corrupted, then S records  <span class="math">(U_i, \\sigma, m, id)</span>  in L, and sends  <span class="math">(U_i, \\text{&quot;sign&quot;}, m, id)</span>  on behalf of corrupt  <span class="math">U_i</span>  to  <span class="math">\\mathcal{F}_{as}</span> . S increments the counter id.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">If no match for any registered user was found, then:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Subcase (gu): The group manager being corrupt, S records (corrupt- <span class="math">\\mathcal{GM}</span> ,  <span class="math">\\sigma</span> , m, id) in L, chooses an identity  <span class="math">\\mathcal{U}_i</span>  at random among the corrupt users, and sends ( <span class="math">\\mathcal{U}_i</span> , &quot;sign&quot;, m, id) on behalf of corrupt- <span class="math">\\mathcal{GM}</span>  to  <span class="math">\\mathcal{F}_{qs}</span> . S increments the counter id.</li>
      <li>Subcase (Gu): If the group manager is honest, the simulation has failed. S aborts and outputs &quot;Failure 4&quot;.</li>
    </ul>

    <p class="text-gray-300">Case (gU): The group manager is corrupt, but the user is honest. Since the group manager is corrupt,  <span class="math">\\mathcal{F}_{gs}</span>  additionally tells  <span class="math">\\mathcal{S}</span>  the identity  <span class="math">\\mathcal{U}_i</span>  of the honest user requesting a signature. Then  <span class="math">\\mathcal{S}</span>  generates a real-world group signature  <span class="math">\\sigma</span>  for the simulated  <span class="math">\\mathcal{U}_i</span> , using that user's certificate (obtained during</p>

    <p class="text-gray-300">Join) and that user's secret key (which S created during the user setup phase). S records this entry (U<sup>i</sup> , &sigma;, m, id) in an internal database L. Finally, S provides A with the real-world signature (&sigma;, m), and returns the &quot;ideal signature&quot; id to Fgs and increments id.</p>

    <p class="text-gray-300">Case (GU): Both the group manager and the user are honest. As stated above, S is triggered by a request (&quot;sign&quot;,m) from Fgs. This time the ideal-world identity of the honest user is not known to S. However, S still needs to provide A with <em>some</em> group signature, thus it proceeds as follows. S generates a real-world group signature &sigma; using the secret key GSK of the group manager (which S created during the group setup phase) and the secret key of the first honest group member sk <sup>&lowast;</sup> that it simulates towards A (which S also created during the user setup phase). Since all signatures are considered public information, S must forward the values (&sigma;, m) to A. As before, S records the entry (?, &sigma;, m, id) in an internal database L. Finally, S returns the &quot;ideal signature&quot; id to Fgs and increments id.</p>

    <p class="text-gray-300"><strong>Simulation of the GroupVerify Operation:</strong> The simulator does not take any action on this operation. A will be able to verify all real-world signatures within its view itself. Furthermore, Fgs verifies signatures for honest users without informing S.</p>

    <p class="text-gray-300"><strong>Simulation of the Open Operation:</strong> The simulator is triggered on this operation in a variety of ways. There are two parties to consider: the group manager and the user requesting the opening (i.e., the verifier).</p>

    <p class="text-gray-300">On the request (&quot;open&quot;, &sigma;, m) from a real-world corrupted user, S first runs its ideal-world Group-Sign algorithm for receiving (&sigma;, m) from A.</p>

    <p class="text-gray-300">Case (gu): Both the group manager and the verifier are corrupted. S does nothing.</p>

    <p class="text-gray-300">Case (gU): The group manager is corrupted, but the verifier is honest. Fgs asks S (as the corrupted group manager) if it may open the ideal-world tuple (U<sup>i</sup> , m, id). (Recall that if U<sup>i</sup> = corrupt-GM, then Fgs refuses to open the signature.) S searches its database L for an entry (U<sup>j</sup> , &sigma;, m, id), where &sigma; is a real-world signature on m for some user U<sup>j</sup> . Since the id's are unique, only one such entry will exist. Next, S, acting as an honest, real-world verifier toward A, engages A in the VerifyOpen protocol with common input (U<sup>i</sup> , m, &sigma;). If S, as an honest verifier, does not accept this proof, then S tells Fgs to refuse to open this signature. If S accepts this verification from A and U<sup>i</sup> = U<sup>j</sup> , then S tells Fgs to open the signature. Finally, if S accepts this verification and yet U<sup>i</sup> 6= U<sup>j</sup> , then our simulation has failed. S aborts and outputs &quot;Failure 1&quot;.</p>

    <p class="text-gray-300">Case (Gu): The group manager is honest, but the verifier is corrupted. Since the verifier is corrupted, it may ask about the openings of any signatures it likes. (For example, it may re-randomize a valid signature, etc.) Suppose A, acting as a corrupt verifier, requests an opening on (m, &sigma;). The first thing that S does is to check if &sigma; is a valid group signature (according to the real-world verification algorithm) on m under the group public key GPK. If it is not, then S returns an error message, &perp;, to A. Otherwise, S proceeds.</p>

    <p class="text-gray-300">Now, S must figure out which user, if any, is responsible for &sigma;. First, S uses its tracing database to test if any registered user is responsible for &sigma;. Specifically for &sigma; = (a1, . . . , a8) and tracing information Q<sup>j</sup> , S checks if e(a1, Q<sup>j</sup> ) = e(a4, g&tilde;).</p>

    <p class="text-gray-300">If &sigma; opens to some registered user U<sup>j</sup> , then there are three cases.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>U<sup>j</sup> is corrupted. This is not considered a forgery. S honestly runs the real-world VerifyOpen</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>protocol with A on common inputs (U<sup>j</sup> , m, &sigma;). This transaction can be completely simulated by S without involving Fgs.</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>U<sup>j</sup> is honest, and sk<sup>j</sup> = sk <sup>&lowast;</sup> . Here, S needs to further differentiate if &sigma; is a forgery or merely a re-randomization of a previous signature. (Observe that the first part of our signatures may be rerandomized.) To do this, S searches database L and complies a list of all entries (?, &sigma;<sup>i</sup> , m, idi) containing message m. Next, S checks whether &sigma; = (a1, . . . , a8) is derived from any &sigma;<sup>i</sup> = (b1,i, . . . , b8,i) by checking if a<sup>7</sup> = b7,i.</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) If S finds a match for some entry i, then it sends the request (&quot;open&quot;, m, idi) to Fgs. Suppose Fgs returns the identity Ux. Now, S must prove this opening to A. S did not know who the ideal-world signer was at the time it created &sigma; under sk <sup>&lowast;</sup> (recall that our simulator creates all signatures using sk <sup>&lowast;</sup> ), thus it must now fake a real-world VerifyOpen opening towards A. That is, S must open &sigma; = (a1, . . . , a8) to user U<sup>x</sup> with pk<sup>x</sup> = (hx, e(hx, g&tilde;) skx). S simulates the interactive VerifyOpen proof as follows [1]. Let pk<sup>x</sup> = (p1, p2). Recall that this is proof of knowledge of a value &alpha; &isin; G<sup>2</sup> such that e(p1, &alpha;) = p<sup>2</sup> and e(a1, &alpha;) = e(a4, g&tilde;).    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>i. A selects a random challenge c &isin; Z<sup>p</sup> and sends C = PedCom(c) to S.</li>
      <li>ii. S selects a random r &isin; Z<sup>p</sup> and sends (t1, t2) = (e(p r 1 , g&tilde;), e(a r 1 , g&tilde;)) to A.</li>
      <li>iii. A sends c along with the opening of commitment C.</li>
      <li>iv. S verifies that C opens to c and, if so, sends s = (&tilde;g skx) c g&tilde; r to A.</li>
      <li>v. A accepts if and only if: (1) e(p1, s) = (p2) c t<sup>1</sup> and (2) e(a1, s) = e(a4, g&tilde;) c t2.</li>
    </ul></li>
      <li>(b) If S does not find a match for any entry i, then A has succeeded in a forgery against user U<sup>j</sup> with sk<sup>j</sup> = sk <sup>&lowast;</sup> . The simulation fails. S aborts and outputs &quot;Failure 2&quot;.</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>U<sup>j</sup> is honest, and sk<sup>j</sup> 6= sk <sup>&lowast;</sup> . S immediately knows &sigma; is a forgery, because S signs for all honest users with the key sk <sup>&lowast;</sup> . The simulation fails. S aborts and outputs &quot;Failure 3&quot;.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">If &sigma; does not open to any registered user, then A has succeeded in creating a valid group signature for a non-registered user. That is, for all tracing information Q<sup>i</sup> known to S and letting &sigma; = (a1, . . . , a8), we have e(a1, Qi) 6= e(a4, g&tilde;). In this case, S aborts and outputs &quot;Failure 4&quot;.</p>

    <p class="text-gray-300">Case (GU): Both the group manager and the verifier are honest. S does nothing. S will not even know that this transaction has taken place.</p>

    <p class="text-gray-300">This ends our description of simulator S. It remains to show that S works; that is, under the Strong LRSW, the EDH, and the Strong SXDH assumptions, the simulator will not abort, except with negligible probability, and that the environment will not be able to distinguish between the real and ideal worlds.</p>

    <p class="text-gray-300"><strong>Claim A.1</strong> <em>Conditioned on the fact that</em> S <em>never aborts,</em> Z <em>cannot distinguish between the real world and the ideal world under the Strong LRSW, the EDH, and the Strong SXDH assumptions.</em></p>

    <p class="text-gray-300"><em>Proof.</em> To see this, let us explore each operation. First, we observe that in GroupSetup and UserKeyGen, the simulator S performs all key generation operations as the respective players in the real world would do. The simulator never deviates from the actions of any honest player during Join and it need not take any action during GroupVerify. In the real world, anyone may verify a signature autonomously. The remaining operations to consider are GroupSign and VerifyOpen.</p>

    <p class="text-gray-300">Let us begin with GroupSign. In this operation, S only needs to take action when it must translate an honest party ideal-world signature into a real-world signature, or a corrupted party real-world signature into an ideal-world one. When the user is corrupted, S submits &quot;sign&quot; requests for A whenever it outputs a new signature. There is nothing here for A to observe.</p>

    <p class="text-gray-300">When the user is honest, however, then S must generate real-world signatures towards A. When the group manager is corrupted, then  <span class="math">\\mathcal{F}_{gs}</span>  tells S which user is signing the message, and thus S may perfectly generate a real-world signature for A. S is only forced to deviate in case (GU) when it must simulate both the honest group manager and honest signer towards A. The problem is that S does not know which user is requesting a signature on some message m; thus S always signs with the same honest user key  <span class="math">sk^*</span> . By Lemma A.2, we know that neither A nor Z can distinguish between this homogeneous, ideal-world distribution of signatures and the heterogeneous, real-world distribution.</p>

    <p class="text-gray-300">Now, it remains to consider VerifyOpen. In this operation, S only takes action when one of the two parties is corrupted. In the case (gU), S behaves exactly as an honest verifier would towards A; that is, S finds the (single)  <span class="math">\\sigma</span>  associated with id, and acts as an honest verifier towards A. We will later argue that it does not abort, due to Failure 1, in this step.</p>

    <p class="text-gray-300">The case (Gu), however, is more complicated. Suppose  <span class="math">\\mathcal{S}</span>  is being asked by  <span class="math">\\mathcal{A}</span>  to open  <span class="math">(m,\\sigma)</span> . If  <span class="math">\\sigma</span>  opens to a corrupted user or does not open to any registered user, then  <span class="math">\\mathcal{S}</span>  behaves exactly as an honest  <span class="math">\\mathcal{GM}</span>  would. However, what happens when  <span class="math">\\sigma</span>  opens to an honest user? We will later argue that  <span class="math">\\mathcal{S}</span>  is not forced to abort due to Failures 2, 3, or 4. Even conditioned on this fact,  <span class="math">\\mathcal{S}</span>  will almost always be forced to deviate since it signed using key  <span class="math">sk^*</span>  for all honest users and now must open the signatures to whichever honest party  <span class="math">\\mathcal{F}_{gs}</span>  dictates. Suppose  <span class="math">\\mathcal{S}</span>  is told to open  <span class="math">\\sigma=(a_1,\\ldots,a_8)</span>  to some honest user  <span class="math">\\mathcal{U}_i</span> , where  <span class="math">sk_i\\neq sk^*</span> , then  <span class="math">\\mathcal{S}</span>  must fake the VerifyOpen protocol toward  <span class="math">\\mathcal{A}</span> .  <span class="math">\\mathcal{S}</span>  succeeds in doing this, in the usual way, by requiring  <span class="math">\\mathcal{A}</span>  to commit to his challenge and then resetting  <span class="math">\\mathcal{A}</span>  after seeing the challenge. That is, after seeing  <span class="math">c\\in\\mathbb{Z}_p</span> ,  <span class="math">\\mathcal{S}</span>  chooses a random value  <span class="math">s\\in\\mathbb{G}_2</span>  and computes  <span class="math">sk_1=e(p_1,s)/p_2^c</span>  and  <span class="math">sk_2=e(a_1,s)/e(a_4,\\tilde{g})^c</span> , where  <span class="math">sk_3=e(p_1,p_2)</span> . Now  <span class="math">\\mathcal{S}</span>  rewinds  <span class="math">\\mathcal{A}</span>  to right after it sent a commitment to  <span class="math">sk_2=e(a_1,s)/e(a_4,\\tilde{g})^c</span> , where  <span class="math">sk_3=e(a_1,s)/e(a_4,\\tilde{g})^c</span>  with a valid opening, and returns the response  <span class="math">sk_3=e(a_1,s)/e(a_1,s_2)</span> , receives  <span class="math">sk_3=e(a_1,s_2)</span> . Now  <span class="math">sk_3=e(a_1,s_2)</span>  in the unlikely event that  <span class="math">sk_3=e(a_1,s_2)</span>  is able to break the binding property of the Pedersen commitments (i.e., CDH in  <span class="math">sk_3=e(a_1,s_2)</span> ).</p>

    <p class="text-gray-300">This concludes our proof of Claim A.1. It remains to show that, except with negligible probability, S will not abort. Recall that S may abort under the following conditions:</p>

    <p class="text-gray-300">&bull; Failure 1:  <span class="math">\\mathcal{A}</span>  breaks exculpability. We argue that it is not possible for a dishonest group manager to falsely open a signature; i.e.,  <span class="math">\\mathcal{A}</span>  is not able to successfully complete the VerifyOpen protocol with  <span class="math">\\mathcal{S}</span>  on common input  <span class="math">(\\mathcal{U}_i, m, \\sigma)</span>  where  <span class="math">\\mathcal{U}_i</span>  is not the real signer. Here, the simulation fails, because  <span class="math">\\mathcal{F}_{gs}</span>  will only open signatures honestly.</p>

    <p class="text-gray-300">We now argue that, for a given VerifyOpen instance  <span class="math">(\\mathcal{U}_i, m, \\sigma)</span> , an adversary that can cause Failure 1 with probability  <span class="math">\\varepsilon</span>  can be used to break the Co-CDH assumption with probability  <span class="math">\\geq (\\varepsilon - 1/p)^2</span> . (Recall from Section 3.1 that Co-CDH is implied by the Strong SXDH assumption.) On Co-CDH input  <span class="math">(g, \\tilde{g}, g^x, \\tilde{g}^y)</span> , the goal is to compute  <span class="math">\\tilde{g}^{xy}</span>  and the simulator proceeds as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Step 1: S initiates the VerifyOpen protocol with A on input  <span class="math">(U_i, m, \\sigma)</span> , setting  <span class="math">pk_i = (g^z, e(g^{zx}, \\tilde{g}^y))</span> , for random  <span class="math">z \\in \\mathbb{Z}_p</span> , and computing  <span class="math">\\sigma</span>  as a valid signature on m for the user with  <span class="math">sk^*</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Step 2: S commits to all zeros, as  <span class="math">C = \\text{PedCom}(0^{|p|})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Step 3: After receiving  <span class="math">(t_1, t_2)</span>  from  <span class="math">\\mathcal{A}</span> ,  <span class="math">\\mathcal{S}</span>  using its knowledge of the relation of the Pedersen public parameters to fake the openings as:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>selects a random challenge  <span class="math">c_1 \\in \\mathbb{Z}_p</span> , opens C to  <span class="math">c_1</span> , and obtains A's response  <span class="math">s_1</span> .</li>
    </ul></li>
      <li><p class="text-gray-300">rewinds A, selects a different random challenge  <span class="math">c_2 \\in \\mathbb{Z}_p</span> , opens C to  <span class="math">c_2</span> , and obtains A's response  <span class="math">s_2</span> .</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Step 4: S computes and outputs  <span class="math">(s_1/s_2)^{1/(c_1-c_2)}</span>  (which hopefully corresponds to  <span class="math">\\tilde{g}^{xy}</span> ).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">In Step 1, the adversary cannot tell that it was given a signature under  <span class="math">sk^*</span>  instead of  <span class="math">sk_i</span>  due to Lemma A.2. The fake openings in Step 4 are perfectly indistinguishable from an honest opening due to the perfect hiding property of Pedersen commitments. If both  <span class="math">((t_1,t_2),c_1,s_1)</span>  and  <span class="math">((t_1,t_2),c_2,s_2)</span>  are valid transcripts, then  <span class="math">\\mathcal S</span>  outputs  <span class="math">\\tilde g^{xy}</span>  in Step 4 with probability  <span class="math">\\geq (\\varepsilon-1/p)^2</span> . Our bound of  <span class="math">(\\varepsilon-1/p)^2</span>  comes from the well-known Reset Lemma [10], where the advantage of  <span class="math">\\mathcal A</span>  was given as  <span class="math">\\varepsilon</span>  and the size of the challenge set is p.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Failure 2:  <span class="math">\\mathcal{A}</span>  creates a forgery against the honest user with  <span class="math">sk^*</span> .  <span class="math">\\mathcal{A}</span>  produces signature  <span class="math">\\sigma=(a_1,\\ldots,a_8)</span>  and message m s.t. GroupVerify <span class="math">(GPK,\\sigma,m)=1</span> ,  <span class="math">\\sigma</span>  opens to  <span class="math">\\mathcal{U}^*</span>  (i.e.,  <span class="math">e(a_1,Q^*)=e(a_4,\\tilde{g})</span> ), and yet  <span class="math">\\mathcal{S}</span>  never gave  <span class="math">\\mathcal{A}</span>  this user's signature on m. This scenario occurs with only negligible probability under the EDH assumption, regardless of whether the group manager is corrupted.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Recall that EDH takes as input  <span class="math">(g, g^x, \\tilde{g}, \\tilde{g}^x)</span>  together with access to oracle  <span class="math">O_x(\\cdot)</span>  that takes input  <span class="math">c \\in \\mathbb{Z}_p^*</span>  and produces output  <span class="math">(g^x, \\tilde{g}^{1/(x+v)}, \\tilde{g}^{1/(v+c)})</span>  for a random  <span class="math">v \\in \\mathbb{Z}_p^*</span> . The goal is to produce a tuple  <span class="math">(c, a, a^v, \\tilde{g}^{\\frac{1}{x+v}}, \\tilde{g}^{\\frac{1}{v+c}})</span>  for any  <span class="math">a \\in \\mathbb{G}_1</span>  and any  <span class="math">v, c \\in \\mathbb{Z}_p^*</span>  such that c was not queried to the oracle. Let  <span class="math">\\tau</span>  be the number of honest users in the system. When A succeeds with probability  <span class="math">\\varepsilon</span> , then B solves</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Let  <span class="math">\\tau</span>  be the number of honest users in the system. When  <span class="math">\\mathcal{A}</span>  succeeds with probability  <span class="math">\\varepsilon</span> , then  <span class="math">\\mathcal{B}</span>  solves the EDH problem with probability  <span class="math">\\varepsilon/\\tau</span> .  <span class="math">\\mathcal{B}</span>  proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Setup:  <span class="math">\\mathcal{B}</span>  must establish the global parameters and key generation.</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Output  <span class="math">(g, \\tilde{g})</span>  as the public parameters for the group signature scheme, and  <span class="math">GPK = (\\tilde{S}, \\tilde{T}) = (\\tilde{g}^s, \\tilde{g}^t)</span>  on behalf of the group manager. If  <span class="math">\\mathcal{GM}</span>  is corrupt, GPK is given to  <span class="math">\\mathcal{S}</span>  by  <span class="math">\\mathcal{A}</span> . Setup all remaining keys and parameters as  <span class="math">\\mathcal{S}</span>  would normally do.</li>
      <li>(b) Guess which of the  <span class="math">\\tau</span>  honest users  <span class="math">\\mathcal{A}</span>  will attack. Give this user  <span class="math">\\mathcal{U}^*</span>  the public key  <span class="math">pk^* = (g^r, e(g^r, \\tilde{g}^x))</span> , for random  <span class="math">r \\in \\mathbb{Z}_p</span> . (Logically this assigns the user's secret key as  <span class="math">sk^* = x</span> .)</li>
      <li>(c) Obtain group certificates for all honest users;  <span class="math">\\mathcal{B}</span>  fakes the proof of knowledge of  <span class="math">sk^*</span>  using any of the techniques discussed in Section 5 (Join). Finally,  <span class="math">\\mathcal{B}</span>  submits the <em>correct</em> tracing information,  <span class="math">Q^* = \\tilde{g}^{sk^*} = \\tilde{g}^x</span> , for this user.</li>
      <li>(d) If the group manager is corrupt, extract the group key GSK = (s,t) during the proof of knowledge.</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Signing: When  <span class="math">\\mathcal{A}</span>  requests a signature from a user not associated with  <span class="math">sk^* = x</span> , sign as normal. Now, when  <span class="math">\\mathcal{A}</span>  asks for a group signature on  <span class="math">m \\in \\mathbb{Z}_p^*</span>  from the honest user associated with secret key  <span class="math">sk^* = x</span> , do:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Query oracle  <span class="math">O_x(m)</span>  to get output  <span class="math">(f_1, f_2, f_3)</span> .</li>
      <li>(b) Select a random  <span class="math">r \\in \\mathbb{Z}_p</span> . Use GSK = (s, t), to output the group signature on m as</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$(g^r, g^{tr}, g^{sr}(g^x)^{str}, (g^x)^r, (g^x)^{tr}, f_1^r, f_2, f_3).</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Opening:  <span class="math">\\mathcal{B}</span>  honestly executes the VerifyOpen protocol with  <span class="math">\\mathcal{A}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Output: Suppose  <span class="math">\\mathcal{A}</span>  produces a valid signature  <span class="math">\\sigma&#x27; = (a_1, \\ldots, a_8)</span>  for a new message  <span class="math">m&#x27; \\in \\mathbb{Z}_p^*</span>  for the user with key  <span class="math">sk^* = x</span> . Then  <span class="math">\\mathcal{B}</span>  outputs  <span class="math">(m&#x27;, a_1, a_4, a_6, a_7, a_8)</span>  to solve the EDH problem.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">It is easy to observe that  <span class="math">\\mathcal{B}</span>  perfectly simulates the group signature world for  <span class="math">\\mathcal{A}</span> .  <span class="math">\\mathcal{B}</span>  has probability  <span class="math">1/\\tau</span>  of choosing which honest user  <span class="math">\\mathcal{A}</span>  will forge against. Thus, when  <span class="math">\\mathcal{A}</span>  succeeds with probability  <span class="math">\\varepsilon</span> , then  <span class="math">\\mathcal{B}</span>  solves the EDH problem with probability  <span class="math">\\varepsilon/\\tau</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Failure 3:  <span class="math">\\mathcal{A}</span>  creates a forgery against a user with  <span class="math">sk_j \\neq sk^*</span> . Proof that this failure occurs with only negligible probability follows directly from that of Failure 2. Indeed,  <span class="math">\\mathcal{A}</span>  has strictly less information at its disposal; that is,  <span class="math">\\mathcal{A}</span>  never sees real signatures under key  <span class="math">sk_j</span> .</li>
      <li>Failure 4:  <span class="math">\\mathcal{A}</span>  creates a valid signature for a non-registered user. In this case,  <span class="math">\\mathcal{A}</span>  produces a signature-message pair  <span class="math">(\\sigma, m)</span>  such that GroupVerify <span class="math">(GPK, \\sigma, m) = 1</span>  and yet it cannot be opened by  <span class="math">\\mathcal{S}</span>  to any registered user. We now argue that this is not possible under the Strong LRSW assumption, except with negligible probability. Suppose we are given  <span class="math">(g, \\tilde{g}, \\tilde{g}^s, \\tilde{g}^t)</span>  as the Strong LRSW input.</li>
    </ul>

    <p class="text-gray-300">Instead of running GroupSetup, let the public parameters  <span class="math">g, \\tilde{g} \\in params</span>  and the public key  <span class="math">GPK = (\\tilde{S}, \\tilde{T}) = (\\tilde{g}^s, \\tilde{g}^t)</span> . During the UserKeyGen operation, for any honest users, S queries the Strong LRSW oracle  <span class="math">O_{\\tilde{S},\\tilde{T}}</span>  on a random  <span class="math">sk_i \\in \\mathbb{Z}_p</span>  to obtain a membership certificate  <span class="math">(a, a^t, a^{s+st(sk_i)})</span> , for any  <span class="math">a \\in \\mathbb{G}_1</span> . (This tuple is, in fact, a CL signature on  <span class="math">sk_i</span>  [19].) S now uses  <span class="math">sk_i</span>  as the secret key for this honest user.</p>

    <p class="text-gray-300">When S is asked to execute Join with an <em>honest</em> user, S simply finds the corresponding CL signature and uses it to output the certificate  <span class="math">(a, a^t, a^{s+st(sk_i)}, a^{sk_i}, a^{t(sk_i)})</span> . When S is asked to execute Join with a <em>corrupted</em> user, S extracts the user's secret key  <span class="math">sk_j</span>  using any of the techniques discussed in Section 5 (Join), queries the Strong LRSW oracle on input  <span class="math">sk_j</span> , and uses the oracle's output to create a valid certificate for this corrupt user. Now, the adversary can sign any message for a corrupt user, and S can honestly respond to any GroupSign call for an honest user.</p>

    <p class="text-gray-300">Suppose that Failure 1 has occurred during VerifyOpen, meaning that  <span class="math">\\mathcal{A}</span>  output a signature  <span class="math">\\sigma = (a_1, \\ldots, a_8)</span>  such that the following relations hold:</p>

    <p class="text-gray-300"><span class="math">$e(a_1, \\tilde{T}) = e(a_2, \\tilde{g}), \\quad e(a_4, \\tilde{T}) = e(a_5, \\tilde{g}), \\quad e(a_1 a_5, \\tilde{S}) = e(a_3, \\tilde{g})</span>$</p>

    <p class="text-gray-300">and yet S did <em>not</em> query  <span class="math">O_{\\tilde{S},\\tilde{T}}</span>  on the corresponding secret key; that is, for all  <span class="math">sk_i</span>  known to S, we have  <span class="math">a_1^{sk_i} \\neq a_4</span> . Then, S may output  <span class="math">(a_1, a_2, a_3, a_4, a_5)</span>  to break the Strong LRSW assumption.</p>

    <p class="text-gray-300">Combining Claim A.1 with the above arguments that S will not abort, except with negligible probability, concludes our main proof.</p>

    <p class="text-gray-300">We end by proving a Lemma used in the above proof. Intuitively, this Lemma captures the anonymity of our signatures. In the below, the values  <span class="math">u_1, \\ldots, u_{\\tau}</span>  may be thought of as the secret keys of  <span class="math">\\tau</span>  different honest users.</p>

    <p class="text-gray-300"><strong>Lemma A.2</strong> (Anonymity of Signatures) Suppose we have the group signature parameters from Section 5; that is, security parameter  <span class="math">1^k</span> , params, and GPK. Suppose  <span class="math">u_1, \\ldots, u_{\\tau}</span>  are random elements of  <span class="math">\\mathbb{Z}_p</span> . Let  <span class="math">O_{u_1,\\ldots,u_{\\tau}}(\\cdot,\\cdot)</span>  be an oracle that takes as input a message  <span class="math">m \\in \\mathbb{Z}_p^*</span>  and an index  <span class="math">1 \\leq i \\leq \\tau</span> , and outputs a group signature  <span class="math">(a_1,\\ldots,a_8)</span>  on m with user secret key  <span class="math">u_i</span> . Then, under the Strong SXDH assumptions, for all probabilistic polynomial-time adversaries A, the following value is negligible in k:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathcal{A}^{O_{u_1,u_2,...,u_{\\tau}}}(params, GPK, \\{pk_i\\}_{i \\in [1,\\tau]}) = 1\\right] - \\Pr\\left[\\mathcal{A}^{O_{u_1,u_1,...,u_1}}(params, GPK, \\{pk_i\\}_{i \\in [1,\\tau]}) = 1\\right].</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> First, if  <span class="math">\\mathcal{A}</span>  can distinguish between oracles  <span class="math">O_{u_1,u_2,...,u_{\\tau}}</span>  and  <span class="math">O_{u_1,u_1,...,u_1}</span> , then we can create an adversary  <span class="math">\\mathcal{B}</span>  that can distinguish between oracles  <span class="math">O_{u_1,u_2}</span>  and  <span class="math">O_{u_1,u_1}</span> . Next, we show that adversary  <span class="math">\\mathcal{B}</span>  can be used to break the Strong SXDH assumption. Overall, if  <span class="math">\\mathcal{A}</span>  succeeds with probability  <span class="math">\\varepsilon</span> , then we can break Strong SXDH with probability  <span class="math">\\geq \\varepsilon/\\tau</span> .</p>

    <p class="text-gray-300">Stage One. First, we make the simple hybrid argument that given  <span class="math">\\mathcal{A}</span> , which can distinguish the signatures of  <span class="math">\\tau</span>  distinct honest users from those of a single user, we can create an adversary  <span class="math">\\mathcal{B}</span>  that can distinguish the signatures of only 2 distinct users from those of a single user. Indeed, by the hybrid argument, we know that if  <span class="math">\\mathcal{A}</span>  distinguishes with probability  <span class="math">\\varepsilon</span> , then for some  <span class="math">1 \\leq \\ell \\leq \\tau</span> ,  <span class="math">\\mathcal{A}</span>  can distinguish with probability  <span class="math">\\geq \\varepsilon/\\tau</span>  between the oracle instantiated with  <span class="math">\\ell</span>   <span class="math">u_1</span> 's followed by  <span class="math">\\tau - \\ell</span>  different seeds and the oracle instantiated with  <span class="math">\\ell + 1</span>   <span class="math">u_1</span> 's followed by  <span class="math">\\tau - \\ell - 1</span>  different values. The obvious reduction follows; that is, the two oracles of  <span class="math">\\mathcal{B}</span>  will be applied to this hybrid point for  <span class="math">\\mathcal{A}</span> .  <span class="math">\\mathcal{B}</span>  will then return whatever answer  <span class="math">\\mathcal{A}</span>  does.</p>

    <p class="text-gray-300">Stage Two. Now, we show that  <span class="math">\\mathcal{B}</span>  can be used to create another adversary  <span class="math">\\mathcal{C}</span>  that breaks Strong SXDH. On Strong SXDH input  <span class="math">(g, g^x, \\tilde{g})</span> , the adversary  <span class="math">\\mathcal{C}</span>  proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate group public key GPK as  <span class="math">(\\tilde{S}, \\tilde{T}) = (\\tilde{g}^s, \\tilde{g}^t)</span>  for random  <span class="math">s, t \\in \\mathbb{Z}_p</span> . Give GPK to  <span class="math">\\mathcal{B}</span> ; store GSK = (s, t). (Remember, anonymity only makes sense when the group manager is honest, so the adversary does not get to set these keys.)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Query  <span class="math">Q_y</span>  on a random input, disregard all output except  <span class="math">(h, h^y)</span>  for some  <span class="math">h \\in \\mathbb{G}_1</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Generate the two user keys as  <span class="math">pk_1=(g,e(g^x,\\tilde{g}))</span>  for user  <span class="math">\\mathcal{U}_1</span>  and  <span class="math">pk_2=(h,e(h^y,\\tilde{g}))</span>  for user  <span class="math">\\mathcal{U}_2</span> . Give  <span class="math">pk_1,pk_2</span>  to  <span class="math">\\mathcal{B}</span> . (This first key could be re-randomized away from the public parameters by choosing a random  <span class="math">r\\in\\mathbb{Z}_p</span>  and setting  <span class="math">pk_1=(g^r,e(g^x,\\tilde{g})^r)</span> . This has no effect on the remainder, and for clarity we omit it.)</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>When  <span class="math">\\mathcal{B}</span>  requests a signature for index  <span class="math">i \\in \\{1,2\\}</span>  on  <span class="math">m \\in \\mathbb{Z}_p^*</span> , if i=1, use  <span class="math">O_x(\\cdot)</span>  to do:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Query  <span class="math">O_x(m)</span>  to obtain the output  <span class="math">(g^v, \\tilde{g}^{1/(x+v)}, \\tilde{g}^{1/(v+m)})</span> , where  <span class="math">v \\in \\mathbb{Z}_p^*</span>  is a fresh random value chosen by the oracle. Denote this output as  <span class="math">(f_6, \\ldots, f_8)</span> .</li>
      <li>(b) Using GSK = (s, t), compute the remaining parts of the group signature:  <span class="math">f_2 = g^t</span> ,  <span class="math">f_3 = g^s(g^x)^{st}</span> ,  <span class="math">f_4 = g^x</span> , and  <span class="math">f_5 = (g^x)^t</span> .</li>
      <li>(c) Select a random  <span class="math">r \\in \\mathbb{Z}_p^*</span> , and return the signature  <span class="math">(g^r, f_2^r, f_3^r, f_4^r, f_5^r, f_6^r, f_7, f_8)</span> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">If i = 2, use oracle  <span class="math">O_u(\\cdot)</span>  to do:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Query  <span class="math">Q_y(m)</span>  to obtain the output  <span class="math">(a, a^y, a^v, \\tilde{g}^{1/(y+v)}, \\tilde{g}^{1/(v+m)})</span> , where  <span class="math">a \\in \\mathbb{G}_1</span>  and  <span class="math">v \\in \\mathbb{Z}_p^*</span>  are fresh random values chosen by the oracle. Denote this output as  <span class="math">(f_1, f_4, f_6, \\ldots, f_8)</span> .</li>
      <li>(b) Using GSK = (s,t), compute the remaining parts of the group signature:  <span class="math">f_2 = a^t</span> ,  <span class="math">f_3 = a^s(a^x)^{st}</span> , and  <span class="math">f_5 = (a^y)^t</span> .</li>
      <li>(c) Return the signature  <span class="math">(f_1, \\ldots, f_8)</span> .</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Eventually,  <span class="math">\\mathcal{B}</span>  will attempt to distinguish whether he's been talking to oracle  <span class="math">O_{x,x}</span>  or oracle  <span class="math">O_{x,y}</span> . If  <span class="math">\\mathcal{B}</span>  says that he's been talking to oracle  <span class="math">O_{x,x}</span> , then output 1 corresponding to &quot;x = y&quot;. Otherwise, output 0 corresponding to &quot; <span class="math">x \\neq y</span> &quot;.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">It is easy to see that the stage 2 simulation is perfect; the output is always correct and perfectly distributed. Indeed, C and B will succeed with identical probabilities. This concludes our proof. We find that if any A can break the anonymity of our signatures with probability &epsilon;, then A can be used to break Strong SXDH with probability at least &epsilon;/&tau; , where &tau; is the number of honest users in the system. &#10039;</p>

    </section>

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>B Towards a Concurrent Join Protocol</strong></h2>

    <p class="text-gray-300">In Section 5, we specified that the group manager runs the Join protocol sequentially with the different users. The reason for this is technical, i.e., to prove security we require that the users' secrets keys sk<sup>i</sup> are <em>extractable</em>. To this end we require the users to commit to their secret key and then prove knowledge of them. If one uses the standard proof of knowledge protocol for the latter, extracting the users' secret keys requires rewinding of the users. It is well known that if these proofs of knowledge protocols are run concurrently with many users, then extracting all the secret keys can take time exponential in the number of users. There are, however, alternatives which allow for concurrent execution of these proofs and thus also of the Join protocol.</p>

    <p class="text-gray-300">First of all, one could require the group manager to run the protocol concurrently only with a limited numbers of users, i.e., by defining time intervals within which the group manager runs the protocol concurrently with a logarithmic number of users and enforcing a time-out if a protocol does not finish within this time interval. This solution would not give a group signature scheme that can be concurrently composed with other schemes.</p>

    <p class="text-gray-300">Solutions that would allow for concurrent executions come from applying one of the various transformations of a standard proof of knowledge protocol (or &Sigma;-protocol) into one that can be executed concurrently.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>Common random reference string.</em> Assuming that the parties have a common random reference string available, one can interpret this as the key for an encryption scheme such that the corresponding secret key is not know to any party. Alternatively, one could have a (distributed) trusted third party generate such a public key (cf. [25]). Then, the users would be required to verifiably encrypt their secret key sk<sup>i</sup> under this reference public key (e.g., using the techniques of Camenisch and Damgard [18]). For &#730; extraction of the secret keys in the security proof, the reference string would need to be patched such that the simulator knows the reference decryption key and thus can extract the users' secret keys by simple decryption.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>Non-concurrent setup phase.</em> When having a common random reference string or a trusted third party is impractical, each user can instead generate their own public key and then prove knowledge of the corresponding secret key in a setup phase where non-concurrent execution can be guaranteed (e.g, because the user's part is run by an isolated smart card). Then, during the Join protocol, the user would verifiably encrypt her secret key sk<sup>i</sup> under <em>her own</em> public key pk<sup>i</sup> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>Assuming random oracles for</em> Join <em>only.</em> A third alternative that comes to mind, in the random oracle model, is to apply Fischlin's results [28]. Fischlin recently presented a transformation for turning any standard proof of knowledge (or &Sigma;-protocol) into a non-interactive proof in the random oracle model that supports an online extractor (i.e., no rewinding).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The parameters required for any of these options (e.g., the hash function for option (c)) are assumed to be global information outside the control of the group manager.</p>

    </section>

    <section id="app-c" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>C</strong> Open Algorithm with <span class="math">O(\\sqrt{n} \\cdot k)</span> Complexity from Trees.</h2>

    <p class="text-gray-300">As before, let  <span class="math">(p, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, g, \\tilde{g})</span> , where  <span class="math">\\mathbb{G}_1 = \\langle g \\rangle</span>  and  <span class="math">\\mathbb{G}_2 = \\langle \\tilde{g} \\rangle</span> , be the global parameters for the bilinear groups.</p>

    <p class="text-gray-300">The intuition here is that group members are logically divided into a 2-level tree; then to revoke the anonymity of a signature, the group manager first locates the correct branch and then the correct leaf (user) for that branch. For a balanced tree, this results in a search time of  <span class="math">2k\\sqrt{n}</span> . Now we present the details. During the Join protocol, the group manager secretly assigns each user to one of  <span class="math">\\sqrt{n}k</span>  logical branches. Each branch is associated with a unique ID as a value  <span class="math">ID \\in \\mathbb{Z}_p^*</span> . Now, the group manager and the user run a protocol such that at the end the user obtains a  <span class="math">\\mathrm{CL}^+</span>  signature on the pair of messages (sk,ID) without learning its branch identity ID and the group manager does not learn the user's secret key sk. Following Camenisch and Lysyanskaya [19] this  <span class="math">\\mathrm{CL}^+</span>  signature would be of the following form for  <span class="math">GPK = (\\tilde{g}^s, \\tilde{g}^t, \\tilde{g}^z, \\tilde{g}^{tz})</span> , GSK = (s,t,z), and some  <span class="math">a \\in \\mathbb{G}_1</span> :</p>

    <p class="text-gray-300"><span class="math">$(a_1, \\ldots, a_7) = (a, a^t, a^{s+st(sk)+stz(ID)}, a^{sk}, a^{t(sk)}, a^{ID}, a^{tz(ID)})</span>$</p>

    <p class="text-gray-300">This  <span class="math">\\operatorname{CL}^+</span>  signature would be used as the user's certificate. Let the user submit tracing information  <span class="math">Q_j = \\tilde{g}^{sk_j}</span>  during the Join protocol as before. Then to open a group signature, the group manager now does: For each branch identity  <span class="math">ID_i</span> , check if  <span class="math">e(a_6, \\tilde{g}) = e(a_1, \\tilde{g})^{ID_i}</span> ; then for each member of the matching branch, check if  <span class="math">e(a_4, \\tilde{g}) = e(a_1, Q_j)</span> . Under the DDH assumption in  <span class="math">\\mathbb{G}_1</span> , a user's branch identity remains hidden from everyone except the group manager, so full anonymity is preserved. By the Strong LRSW assumption, a user cannot change which branch he is associated with, and thus the group manager will be able to find him (i.e., open the signature).</p>

    <p class="text-gray-300"><strong>Theorem C.1</strong> In the plain model, the above extension to the Section &sect;5 scheme realizes  <span class="math">\\mathcal{F}_{gs}</span>  from Section &sect;2 under the the Strong LRSW, the EDH, and the Strong SXDH assumptions.</p>

    <p class="text-gray-300">In practice, one can achieve a &quot;constant time&quot; open algorithm by having less branches per node but more levels. Assume we want to be able to handle  <span class="math">2^{40}</span>  members. Then we could have  <span class="math">2^{10}</span>  branches and a tree depth of 4. This would result is a scheme where signature would have an additional 8 elements (i.e., this would double the length of the signature) the group manager would need to do at most 3072 exponentations (to walk through the first three levels) and 1024 pairings (to find the group member) to open a signature. Furthermore, the 3072 exponentations could be considerably sped-up by giving all branches of the same node the same (but random) ID except the last 10 bits. Given that opening signatures is an exceptional event, we believe such a scheme would be practical.</p>

    <p class="text-gray-300"><strong>Open Algorithm with</strong>  <span class="math">O((\\log n) + k)</span>  <strong>Complexity from Encryption.</strong> The intuition here is to have the signer include an encryption of her identity under the group manager's encryption key as part of every signature. The trick is to do this in such a way that the <em>correctness</em> of the encryption is publicly-verifiable, and yet, the <em>anonymity</em> of the signer is preserved.</p>

    <p class="text-gray-300">Let (eGPK, eGSK) be Elgamal encryption keys generated by the group manager, where  <span class="math">eGSK \\in \\mathbb{Z}_p</span>  and  <span class="math">eGPK = \\tilde{g}^{eGSK}</span> . Then in addition to a regular signature from Section &sect;5, a user would add a version of Elgamal encryption of their identity as the last three items:</p>

    <p class="text-gray-300">To verify the signature  <span class="math">\\sigma=(a_1,\\ldots,a_{11})</span> , in addition to the usual  <span class="math">CL^+</span>  and  <span class="math">BB^+</span>  checks, a verifier must be sure that the ciphertext is correctly formed by checking that: (1)  <span class="math">e(a_1,a_{10})=e(a_4,\\tilde{g})e(a_9,\\tilde{g})</span>  and (2)  <span class="math">e(a_9,eGPK)=e(a_1,a_{11})</span> .</p>

    <p class="text-gray-300">Now, to the key point: the group manager may, at any time, open the signature by simply decrypting the last portion as  <span class="math">a_{10}/(a_{11})^{1/eGSK} = \\tilde{g}^{sk}</span> , which reveals the user's identity. Recall that the group manager obtains this same <em>tracing information</em> from the user during the Join protocol.</p>

    <p class="text-gray-300"><strong>Theorem C.2</strong> In the plain model, the above extension to the Section &sect;5 scheme realizes  <span class="math">\\mathcal{F}_{gs}</span>  from Section &sect;2 under the Strong LRSW, the EDH, and (an extension of) the Strong SXDH assumptions.</p>

    <p class="text-gray-300">The extension of the Strong SXDH assumption mentioned above requires changes to oracles O and Q, from Definition 4 in Section &sect;3. Specifically, we change the oracles as follows: Select a value  <span class="math">eGPK \\in \\mathbb{G}_2</span>  at random and give as input the adversary. Let  <span class="math">O&#x27;_x(\\cdot)</span>  be an oracle that takes as input  <span class="math">m \\in \\mathbb{Z}_p^*</span>  and outputs  <span class="math">(g^r, g^{rx}, g^{rv}, \\tilde{g}^{1/(x+v)}, \\tilde{g}^{1/(v+m)}, g^{rc}, \\tilde{g}^{sk+c}, eGPK^c)</span>  for a random  <span class="math">r, v, c \\in \\mathbb{Z}_p^*</span> . Then, we say that on input  <span class="math">(g, g^x, \\tilde{g}, eGPK)</span> , the adversary cannot distinguish access to oracles  <span class="math">(O&#x27;_x(\\cdot), O&#x27;_y(\\cdot))</span>  from  <span class="math">(O&#x27;_x(\\cdot), O&#x27;_x(\\cdot))</span> .</p>

    <p class="text-gray-300">The proof of Theorem D.3 that Strong SXDH is hard in generic groups can be modified to cover this extended version as well.</p>

    </section>

    <section id="app-d" class="mb-10">
      <h2 class="text-2xl font-bold">D Generic Security of the New Assumptions</h2>

    <p class="text-gray-300">To provide more confidence in our scheme, we prove lower bounds on the complexity of our assumptions for generic groups [40, 46].</p>

    <p class="text-gray-300">Let us begin by recalling the basics. We follow the notation and general outline of Boneh and Boyen [12]. In the generic group model, elements of the bilinear groups  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2</span> , and  <span class="math">\\mathbb{G}_T</span>  are encoded as unique random strings. Thus, the adversary cannot directly test any property other than equality. Oracles are assumed to perform operations between group elements, such as performing the group operations in  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2</span> , and  <span class="math">\\mathbb{G}_T</span> . The opaque encoding of the elements of  <span class="math">\\mathbb{G}_1</span>  is defined as the function  <span class="math">\\xi_1: \\mathbb{Z}_p \\to \\{0,1\\}^*</span> , which maps all  <span class="math">a \\in \\mathbb{Z}_p</span>  to the string representation  <span class="math">\\xi_1(a)</span>  of  <span class="math">g^a \\in \\mathbb{G}_1</span> . Likewise, we have  <span class="math">\\xi_2: \\mathbb{Z}_p \\to \\{0,1\\}^*</span>  for  <span class="math">\\mathbb{G}_2</span>  and  <span class="math">\\xi_T: \\mathbb{Z}_p \\to \\{0,1\\}^*</span>  for  <span class="math">\\mathbb{G}_T</span> . The adversary  <span class="math">\\mathcal{A}</span>  communicates with the oracles using the  <span class="math">\\xi</span> -representations of the group elements only.</p>

    <p class="text-gray-300">We achieve the same asymptotic complexity bound for EDH as was shown for q-SDH.</p>

    <p class="text-gray-300"><strong>Theorem D.1 (EDH is Hard in Generic Groups)</strong> Let  <span class="math">\\mathcal{A}</span>  be an algorithm that solves the EDH problem in the generic group model, making a total of  <span class="math">q_G</span>  queries to the oracles computing the group action in  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T</span> , the oracle computing the bilinear pairing e, and oracle  <span class="math">O_x(\\cdot)</span> . If  <span class="math">x \\in \\mathbb{Z}_p^*</span>  and  <span class="math">\\xi_1, \\xi_2, \\xi_T</span>  are chosen at random, then the probability  <span class="math">\\varepsilon</span>  that  <span class="math">\\mathcal{A}^{O_x}(p, \\xi_1(1), \\xi_1(x), \\xi_2(1), \\xi_2(x))</span>  outputs  <span class="math">(c, \\xi_1(r), \\xi_1(r \\cdot x), \\xi_1(r \\cdot v), \\xi_2(\\frac{1}{x+v}), \\xi_2(\\frac{1}{v+c}))</span>  with  <span class="math">c \\in \\mathbb{Z}_p^*</span>  not previously queried to  <span class="math">O_x</span> , is bounded by</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon \\le \\frac{(q_G + 4)^2 (8q + 8)}{p} = O\\left(\\frac{q_G^3}{p}\\right).</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Consider an algorithm  <span class="math">\\mathcal{B}</span>  that interacts with  <span class="math">\\mathcal{A}</span>  in the following game.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span>  maintains three lists of pairs  <span class="math">L_1 = \\{(F_{1,i}, \\xi_{1,i}) : i = 0, \\dots, \\tau_1 - 1\\}</span> ,  <span class="math">L_2 = \\{(F_{2,i}, \\xi_{2,i}) : i = 0, \\dots, \\tau_2 - 1\\}</span> ,  <span class="math">L_T = \\{(F_{T,i}, \\xi_{T,i}) : i = 0, \\dots, \\tau_T - 1\\}</span> , such that, at step  <span class="math">\\tau</span>  in the game, we have  <span class="math">\\tau_1 + \\tau_2 + \\tau_T = \\tau + 4</span> . The only twist between our setup and that of Boneh and Boyen is that we will let the  <span class="math">F_{1,i}, F_{2,i}</span>  and  <span class="math">F_{T,i}</span> 's be rational functions (i.e, fractions whose numerators and denominators are polynomials); and</p>

    <p class="text-gray-300">all polynomials are multivariate polynomials in  <span class="math">\\mathbb{Z}_p[x,\\ldots]</span>  where additional variables will be dynamically added. The  <span class="math">\\xi_{1,i}</span> ,  <span class="math">\\xi_{2,i}</span> , and  <span class="math">\\xi_{T,i}</span>  are set to unique random strings in  <span class="math">\\{0,1\\}^*</span> . Of course, we start the EDH game at step  <span class="math">\\tau=0</span>  with  <span class="math">\\tau_1=2</span> ,  <span class="math">\\tau_2=2</span> , and  <span class="math">\\tau_T=0</span> . These correspond to the polynomials  <span class="math">F_{1,0}=F_{2,0}=1</span>  and  <span class="math">F_{1,1}=F_{2,1}=x</span> , and the random strings  <span class="math">\\xi_{1,0}</span> ,  <span class="math">\\xi_{1,1}</span> ,  <span class="math">\\xi_{2,0}</span> ,  <span class="math">\\xi_{2,1}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span>  begins the game with  <span class="math">\\mathcal{A}</span>  by providing it with the 4 strings  <span class="math">\\xi_{1,0}, \\xi_{1,1}, \\xi_{2,0}, \\xi_{2,1}</span> . Now, we describe the oracles  <span class="math">\\mathcal{A}</span>  may query.</p>

    <p class="text-gray-300"><strong>Group action:</strong>  <span class="math">\\mathcal{A}</span>  inputs two group elements  <span class="math">\\xi_{1,i}</span>  and  <span class="math">\\xi_{1,j}</span> , where  <span class="math">0 \\leq i,j &lt; \\tau_1</span> , and a request to multiply/divide.  <span class="math">\\mathcal{B}</span>  sets  <span class="math">F_{1,\\tau_1} \\leftarrow F_{1,i} \\pm F_{1,j}</span> . If  <span class="math">F_{1,\\tau_1} = F_{1,u}</span>  for some  <span class="math">u \\in \\{0,\\ldots,\\tau_1-1\\}</span> , then  <span class="math">\\mathcal{B}</span>  sets  <span class="math">\\xi_{1,\\tau_1} = \\xi_{1,u}</span> ; otherwise, it sets  <span class="math">\\xi_{1,\\tau_1}</span>  to a random string in  <span class="math">\\{0,1\\}^* \\setminus \\{\\xi_{1,0},\\ldots,\\xi_{1,\\tau_1-1}\\}</span> . Finally,  <span class="math">\\mathcal{B}</span>  returns  <span class="math">\\xi_{1,\\tau_1}</span>  to  <span class="math">\\mathcal{A}</span> , adds  <span class="math">(F_{1,\\tau_1},\\xi_{1,\\tau_1})</span>  to  <span class="math">L_1</span> , and increments  <span class="math">\\tau_1</span> . Group actions for  <span class="math">\\mathbb{G}_2</span>  and  <span class="math">\\mathbb{G}_T</span>  are handled the same way.</p>

    <p class="text-gray-300"><strong>Pairing:</strong>  <span class="math">\\mathcal{A}</span>  inputs two group elements  <span class="math">\\xi_{1,i}</span>  and  <span class="math">\\xi_{2,j}</span> , where  <span class="math">0 \\leq i &lt; \\tau_1</span>  and  <span class="math">0 \\leq j &lt; \\tau_2</span> .  <span class="math">\\mathcal{B}</span>  sets  <span class="math">F_{T,\\tau_T} \\leftarrow F_{1,i} \\cdot F_{2,j}</span> . If  <span class="math">F_{T,\\tau_T} = F_{T,u}</span>  for some  <span class="math">u \\in \\{0,\\ldots,\\tau_T-1\\}</span> , then  <span class="math">\\mathcal{B}</span>  sets  <span class="math">\\xi_{T,\\tau_T} = \\xi_{T,u}</span> ; otherwise, it sets  <span class="math">\\xi_{T,\\tau_T}</span>  to a random string in  <span class="math">\\{0,1\\}^* \\setminus \\{\\xi_{T,0},\\ldots,\\xi_{T,\\tau_T-1}\\}</span> . Finally,  <span class="math">\\mathcal{B}</span>  returns  <span class="math">\\xi_{T,\\tau_T}</span>  to  <span class="math">\\mathcal{A}</span> , adds  <span class="math">(F_{T,\\tau_T},\\xi_{T,\\tau_T})</span>  to  <span class="math">L_T</span> , and increments  <span class="math">\\tau_T</span> .</p>

    <p class="text-gray-300"><strong>Oracle</strong>  <span class="math">O_x(\\cdot)</span> : Let  <span class="math">\\tau_v</span>  be a counter initialized to 1.  <span class="math">\\mathcal{A}</span>  inputs c in  <span class="math">\\mathbb{Z}_p^*</span> , followed by  <span class="math">\\mathcal{B}</span>  choosing a new <em>variable</em>  <span class="math">v_{\\tau_v}</span>  and setting  <span class="math">F_{1,\\tau_1} \\leftarrow v_{\\tau_v}</span> . If  <span class="math">F_{1,\\tau_1} = F_{1,u}</span>  for some  <span class="math">u \\in \\{0,\\ldots,\\tau_1-1\\}</span> , then  <span class="math">\\mathcal{B}</span>  sets  <span class="math">\\xi_{1,\\tau_1} = \\xi_{1,u}</span> ; otherwise, it sets  <span class="math">\\xi_{1,\\tau_1}</span>  to a random string in  <span class="math">\\{0,1\\}^* \\setminus \\{\\xi_{1,0},\\ldots,\\xi_{1,\\tau_1-1}\\}</span> .  <span class="math">\\mathcal{B}</span>  sends  <span class="math">\\xi_{1,\\tau_1}</span>  to  <span class="math">\\mathcal{A}</span> , adding  <span class="math">(F_{1,\\tau_1},\\xi_{1,\\tau_1})</span>  to  <span class="math">L_1</span> .</p>

    <p class="text-gray-300">Next,  <span class="math">\\mathcal{B}</span>  set  <span class="math">F_{2,\\tau_2} \\leftarrow 1/(x+v_{\\tau_v})</span>  and  <span class="math">F_{2,\\tau_2+1} \\leftarrow 1/(v_{\\tau_v}+m)</span> . For  <span class="math">j \\in \\{0,1\\}</span> , if  <span class="math">F_{2,\\tau_2+j} = F_{2,u}</span>  for some  <span class="math">u \\in \\{0,\\dots,\\tau_2-1+j\\}</span> , then  <span class="math">\\mathcal{B}</span>  sets  <span class="math">\\xi_{2,\\tau_2+j} = \\xi_{2,u}</span> ; otherwise, it sets  <span class="math">\\xi_{2,\\tau_2+j}</span>  to a random string in  <span class="math">\\{0,1\\}^* \\setminus \\{\\xi_{2,0},\\dots,\\xi_{2,\\tau_2-1+j}\\}</span> .  <span class="math">\\mathcal{B}</span>  sends  <span class="math">(\\xi_{2,\\tau_2},\\xi_{2,\\tau_2+1})</span>  to  <span class="math">\\mathcal{A}</span> , adding  <span class="math">(F_{2,\\tau_2},\\xi_{2,\\tau_2})</span>  and  <span class="math">(F_{2,\\tau_2+1},\\xi_{2,\\tau_2+1})</span>  to  <span class="math">L_2</span> .</p>

    <p class="text-gray-300">Finally,  <span class="math">\\mathcal{B}</span>  adds one to  <span class="math">\\tau_1</span> , two to  <span class="math">\\tau_2</span> , and one to  <span class="math">\\tau_v</span> .</p>

    <p class="text-gray-300">We assume SXDH holds in  <span class="math">(\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T)</span>  and therefore no ismorphism oracles exist.</p>

    <p class="text-gray-300">Eventually  <span class="math">\\mathcal{A}</span>  stops and outputs a tuple of elements  <span class="math">(c, \\xi_{1,a}, \\xi_{1,b}, \\xi_{1,k}, \\xi_{2,d}, \\xi_{2,f})</span> , where  <span class="math">0 \\leq a, b, k &lt; \\tau_1</span>  and  <span class="math">0 \\leq d, f &lt; \\tau_2</span> . To later test the correctness of  <span class="math">\\mathcal{A}</span> 's output within the framework of this game,  <span class="math">\\mathcal{B}</span>  computes the polynomials:</p>

    <p class="text-gray-300"><span class="math">$F_{T,*} = \\left(\\frac{F_{1,k}}{F_{1,a}} + x\\right) \\cdot F_{2,d} - 1.</span>$
(1)</p>

    <p class="text-gray-300"><span class="math">$F_{T,\\circ} = \\left(\\frac{F_{1,k}}{F_{1,a}} + c\\right) \\cdot F_{2,f} - 1.</span>$
(2)</p>

    <p class="text-gray-300">Intuitively, this correspond to the equalities &quot; <span class="math">e(h^xh^v, \\tilde{g}^{1/(x+v)}) = e(h, \\tilde{g}) = e(h^vh^c, \\tilde{g}^{1/(v+c)})</span> &quot;, where h denotes the element of  <span class="math">\\mathbb{G}_1</span>  represented by  <span class="math">\\xi_{1,a}</span> ,  <span class="math">h^v</span>  denotes the element of  <span class="math">\\mathbb{G}_1</span>  represented by  <span class="math">\\xi_{1,k}</span> ,  <span class="math">\\tilde{g}^{1/(x+v)}</span>  denotes the element of  <span class="math">\\mathbb{G}_2</span>  represented by  <span class="math">\\xi_{2,d}</span> , and  <span class="math">\\tilde{g}^{1/(v+c)}</span>  denotes the element of  <span class="math">\\mathbb{G}_2</span>  represented by  <span class="math">\\xi_{2,f}</span> .</p>

    <p class="text-gray-300">Analysis of  <span class="math">\\mathcal{A}</span> 's Output. For  <span class="math">\\mathcal{A}</span> 's response to always be correct, then it must be the case that  <span class="math">F_{T,*}(x) = F_{T,\\circ}(x) = 0</span>  for any value of x. We now argue that it is <em>impossible</em> for  <span class="math">\\mathcal{A}</span>  to achieve this. Each output polynomial must be some linear combination of polynomials corresponding to elements available to  <span class="math">\\mathcal{A}</span>  in</p>

    <p class="text-gray-300">the respective groups:</p>

    <p class="text-gray-300"><span class="math">$F_{1,a} = a_0 + a_1 x + \\sum_{i=1}^{q} a_{2,i} v_i</span>$
(3)</p>

    <p class="text-gray-300"><span class="math">$F_{1,b} = b_0 + b_1 x + \\sum_{i=1}^{q} b_{2,i} v_i \\tag{4}</span>$</p>

    <p class="text-gray-300"><span class="math">$F_{1,k} = k_0 + k_1 x + \\sum_{i=1}^{q} k_{2,i} v_i</span>$
(5)</p>

    <p class="text-gray-300"><span class="math">$F_{2,d} = d_0 + d_1 x + \\sum_{i=1}^{q} \\frac{d_{2,i}}{x + v_i} + \\sum_{i=1}^{q} \\frac{d_{3,i}}{v_i + c_i}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\tag{6}</span>$</p>

    <p class="text-gray-300"><span class="math">$F_{2,f} = f_0 + f_1 x + \\sum_{i=1}^{q} \\frac{f_{2,i}}{x + v_i} + \\sum_{i=1}^{q} \\frac{f_{3,i}}{v_i + c_i}</span>$</p>

    <p class="text-gray-300"><span class="math">$(7)</span>$</p>

    <p class="text-gray-300">where q is the number of queries to oracle Qx. Now, we know, by definition, that F1,b/F1,a = x, thus one can verify, using equations (3) and (4), that a<sup>1</sup> = a2,i = 0 and F1,a = a<sup>0</sup> is a constant.</p>

    <p class="text-gray-300"><strong>Notation</strong>: For readability of our later analysis, we denote the following values, where <em>constant</em> values y<sup>0</sup> = b0/a0, y<sup>1</sup> = b1/a<sup>0</sup> + 1, y2,i = b2,i/a0:</p>

    <p class="text-gray-300"><span class="math">$Y = (F_{1,k}/a_0 + x) = y_0 + y_1 x + \\sum_{i=1}^{q} y_{2,i} v_i</span>$
(8)</p>

    <p class="text-gray-300"><span class="math">$Z = (F_{1,k}/a_0 + c) = c + y_0 + (y_1 - 1)x + \\sum_{i=1}^{q} y_{2,i}v_i</span>$
(9)</p>

    <p class="text-gray-300">We also give names to the following frequently-used products:</p>

    <p class="text-gray-300"><span class="math">$P = \\prod_{j=1}^{q} (x + v_j) \\quad \\text{and} \\quad P_{i \\neq j} = \\prod_{i \\neq j}^{q} (x + v_j)</span>$
(10)</p>

    <p class="text-gray-300"><span class="math">$Q = \\prod_{j=1}^{q} (v_j + c_j) \\quad \\text{and} \\quad Q_{i \\neq j} = \\prod_{i \\neq j}^{q} (v_j + c_j)</span>$
(11)</p>

    <p class="text-gray-300">(12)</p>

    <p class="text-gray-300">Using our above notation, consider the polynomials F2,<sup>&lowast;</sup> and FT,&#9702; from equations (1) and (2) when both sides are multiplied by P Q and we substitute in equations (6), (7), (8), and (9). For some <em>constants</em> d<sup>i</sup> and fi , the new polynomials:</p>

    <p class="text-gray-300"><span class="math">$PQF_{T,*} = 0 = d_0YPQ + d_1xYPQ + \\sum_{i=1}^{q} d_{2,i}YP_{i\\neq j}Q + \\sum_{i=1}^{q} d_{3,i}YPQ_{i\\neq j} - PQ</span>$
(13)</p>

    <p class="text-gray-300"><span class="math">$PQF_{T,\\circ} = 0 = f_0 ZPQ + f_1 x ZPQ + \\sum_{i=1}^{q} f_{2,i} ZP_{i \\neq j} Q + \\sum_{i=1}^{q} f_{3,i} ZPQ_{i \\neq j} - PQ</span>$
(14)</p>

    <p class="text-gray-300">Now, we inspect equations (13) and (14). We consider two cases.</p>

    <p class="text-gray-300">Case 1:  <span class="math">y_1 = 0</span> . Then we have  <span class="math">Z = c + y_0 - x + \\sum_{i=1}^q y_{2,i} v_i</span> . Now, we inspect the terms of equation (14). We deduce that  <span class="math">f_1 = 0</span> , because it is the only term containing  <span class="math">x^{q+2} \\prod_{i=1}^q v_i</span> . Then,  <span class="math">f_0 = 0</span> , because it is the only term containing  <span class="math">x^{q+1} \\prod_{i=1}^q v_i</span> . Next, each  <span class="math">f_{3,i} = 0</span> , because they have unique terms  <span class="math">x^{q+1} \\prod_{i \\neq j} v_j</span> . We are left with  <span class="math">0 = \\sum_{i=1}^q f_{2,i} Z P_{i \\neq j} Q - PQ</span> . We divide by Q, and the result is  <span class="math">0 = \\sum_{i=1}^q f_{2,i} Z P_{i \\neq j} - P</span> . It follows then that at least one  <span class="math">f_{2,i}</span>  must be non-zero for the equation to be solvable; denote the first non-zero  <span class="math">f_{2,i}</span>  as  <span class="math">f_{2,\\beta}</span> .</p>

    <p class="text-gray-300">Now, suppose some constant  <span class="math">y_{2,i} \\neq 0</span>  in Z, meaning that Z contains a  <span class="math">v_i</span>  term. If  <span class="math">\\beta \\neq i</span> , then  <span class="math">y_{2,i}ZP_{i\\neq j}</span>  contains a unique term  <span class="math">v_i^2\\prod_{i\\neq j\\neq \\alpha}v_j</span>  that cannot be canceled. Thus,  <span class="math">y_{2,i}=0</span> , and furthermore  <span class="math">f_{2,i}</span> , for all  <span class="math">i\\neq \\beta</span> . Now we are left with the equation  <span class="math">0=f_{2,\\beta}(c+y_0-x+y_{2,\\beta}v_\\beta)P_{\\beta\\neq j}-P</span> , we divide out  <span class="math">P_{\\beta\\neq j}</span>  and observe that  <span class="math">f_{2,\\beta}=-1</span> , to get  <span class="math">0=-(c+y_0-x+y_{2,\\beta}v_\\beta)-(x+v_\\beta)</span> .</p>

    <p class="text-gray-300">Now, since  <span class="math">c, y_0, y_{2,\\beta}</span>  are all constants and  <span class="math">v_\\beta</span>  is a variable, we conclude that  <span class="math">y_{2,\\beta}=1</span>  and  <span class="math">c=-y_0</span> . That means that  <span class="math">Y=y_0+v_\\beta</span> , where  <span class="math">y_0\\neq 0</span> . Plugging back into equation (13), we have  <span class="math">d_1=0</span>  due to unique  <span class="math">x^{q+1}</span>  term, then it must be the case that  <span class="math">d_0=0</span>  due to  <span class="math">x^qv_\\beta\\prod_{i=1}^q v_i</span> . Next, it must be that  <span class="math">d_{3,i}=0</span>  for all  <span class="math">i\\neq \\beta</span>  due to unique  <span class="math">x^qv_\\beta^2\\prod_{j\\neq i\\neq \\beta}v_j</span> . Next, we see that terms corresponding to  <span class="math">d_{3,\\beta}YPQ_{\\beta\\neq j}=d_{3,\\beta}(y_0+v_\\beta)PQ_{\\beta\\neq j}</span>  and PQ are the only two left with a  <span class="math">x^q</span>  term; thus,  <span class="math">d_{3,\\beta}\\neq 0</span> . Further, cancelling the term  <span class="math">x^q\\prod_{i=1}^q v_i</span>  from PQ requires that  <span class="math">d_{3,1}=1</span> . Thus, we find that to cancel all related  <span class="math">x^q</span>  terms, it must be that  <span class="math">c=c_\\beta</span> . Since c, which represents the message corresponding to  <span class="math">\\mathcal{A}</span> 's signature, is an old value, this is not a valid forgery.</p>

    <p class="text-gray-300">Case 2:  <span class="math">y_1 \\neq 0</span> . Now Y contains an x term, and we inspect equation (13). We deduce that  <span class="math">d_1 = 0</span> , because it is the only term containing  <span class="math">x^{q+2} \\prod_{i=1}^q v_i</span> . Then,  <span class="math">d_0 = 0</span> , because it is the only term containing  <span class="math">x^{q+1} \\prod_{i=1}^q v_i</span> . Next, each  <span class="math">d_{3,i} = 0</span> , because they have unique terms  <span class="math">x^{q+1} \\prod_{i \\neq j} v_j</span> . We are left with  <span class="math">0 = \\sum_{i=1}^q d_{2,i} Y P_{i \\neq j} Q - PQ</span> . We divide by Q, and the result is  <span class="math">0 = \\sum_{i=1}^q d_{2,i} Y P_{i \\neq j} - P</span> . To satisfy this equation, for some  <span class="math">d_{2,i}</span> , we must have  <span class="math">d_{2,i} \\neq 0</span> . We denote this value  <span class="math">d_{2,\\beta}</span> .</p>

    <p class="text-gray-300">From this point, we proceed in a fashion similar to case 1. By inspecting the above equation, we find that  <span class="math">y_0=0</span> , and for all  <span class="math">i\\neq \\beta, \\ y_{2,i}=0</span> , otherwise there exist unique terms: e.g.,  <span class="math">v_\\beta\\prod_{\\beta\\neq j}^q v_j</span> . Furthermore,  <span class="math">d_{2,\\beta}y_1=1</span> , since the  <span class="math">x^q</span>  term of P has coefficient 1. And,  <span class="math">d_{2,\\beta}y_{2,\\beta}=1</span> , since the  <span class="math">\\prod_{i=1}^q v_i</span>  term of P has coefficient 1. So,  <span class="math">y_1=y_{2,\\beta}=1/d_{2,\\beta}</span>  and we plug into Z as  <span class="math">Z=c+(1/d_{2,\\beta}-1)x+v_\\beta/d_{2,\\beta}</span> .</p>

    <p class="text-gray-300">From equation (14), we have that  <span class="math">f_1=0</span>  due to  <span class="math">x^{q+1}\\prod_{i=1}^q v_i</span> ,  <span class="math">f_0=0</span>  due to  <span class="math">v_\\beta x^q\\prod_{i=1}^q v_i</span> . For all  <span class="math">i\\neq \\beta</span> ,  <span class="math">f_{3,i}=0</span> , otherwise unique terms  <span class="math">v_\\beta^2 x^q\\prod_{i\\neq j\\neq \\beta} v_j</span>  appear. Given that all  <span class="math">f_{3,i}=0</span>  except for  <span class="math">f_{3,\\beta}</span> , it follows all  <span class="math">f_{2,i}=0</span>  except for  <span class="math">f_{2,\\beta}</span>  due to unique terms containing  <span class="math">v_i^3</span>  for  <span class="math">i\\neq \\beta</span> . Thus, we now have the equation  <span class="math">0=f_{2,\\beta}ZP_{\\beta\\neq j}Q+f_{3,\\beta}ZPQ_{\\beta\\neq j}-PQ</span> . We divide by  <span class="math">P_{\\beta\\neq j}Q_{\\beta\\neq j}</span>  to obtain  <span class="math">0=f_{2,\\beta}Z(v_\\beta+c_\\beta)+f_{3,\\beta}Z(x+v_\\beta)-(x+v_\\beta)(v_\\beta+c_\\beta)</span> .</p>

    <p class="text-gray-300">Now, suppose  <span class="math">d_{2,\\beta}=1</span>  and thus  <span class="math">Z=(c+v_{\\beta})</span> . Then we know that  <span class="math">f_{3,\\beta}=1</span>  to cancel the term  <span class="math">xv_{\\beta}</span> ; this forces  <span class="math">f_{2,\\beta}=0</span>  because the  <span class="math">v_{\\beta}^2</span>  term is already canceled in whole by the  <span class="math">f_{3,\\beta}</span>  component. Thus, it is immediate that  <span class="math">c=c_{\\beta}</span> , which is not a valid forgery.</p>

    <p class="text-gray-300">On the other hand, suppose  <span class="math">d_{2,\\beta} \\neq 1</span>  and thus Z contains an x term. Then, we know that  <span class="math">f_{3,\\beta} = 0</span> , because its  <span class="math">x^2</span>  term would be unique. This forces c = 0 because otherwise the constant term  <span class="math">f_{2,\\beta}cc_{\\beta}</span>  would be unique. However, c must be an element in  <span class="math">\\mathbb{Z}_p^*</span> , and thus this is also not a valid forgery.</p>

    <p class="text-gray-300">Thus, we conclude that A's success depends <em>solely</em> on his luck when the variables are instantiated.</p>

    <p class="text-gray-300"><strong>Analysis of</strong>  <span class="math">\\mathcal{B}</span> 's <strong>Simulation.</strong> At this point  <span class="math">\\mathcal{B}</span>  chooses a random  <span class="math">x^* \\in \\mathbb{Z}_p^*</span> .  <span class="math">\\mathcal{B}</span>  now tests (in equations 15,16,17) if its simulation was perfect; that is, if the instantiation of x by  <span class="math">x^*</span>  does <em>not</em> create any</p>

    <p class="text-gray-300">equality relation among the polynomials that was not revealed by the random strings provided to  <span class="math">\\mathcal{A}</span> .  <span class="math">\\mathcal{B}</span>  also tests (in equations 18, 19) whether or not A's output was correct. Thus, A's overall success is bounded by the probability that any of the following holds:</p>

    <p class="text-gray-300"><span class="math">$F_{1,i}(x^*) - F_{1,j}(x^*) = 0</span>$
, for some  <span class="math">i, j</span>  such that  <span class="math">F_{1,i} \\neq F_{1,j}</span> , (15)</p>

    <p class="text-gray-300"><span class="math">$F_{1,i}(x^*) - F_{1,j}(x^*) = 0</span>$
, for some  <span class="math">i, j</span>  such that  <span class="math">F_{1,i} \\neq F_{1,j}</span> , (15)
<span class="math">F_{2,i}(x^*) - F_{2,j}(x^*) = 0</span> , for some  <span class="math">i, j</span>  such that  <span class="math">F_{2,i} \\neq F_{2,j}</span> , (16)</p>

    <p class="text-gray-300"><span class="math">$F_{T,i}(x^*) - F_{T,j}(x^*) = 0</span>$
, for some  <span class="math">i, j</span>  such that  <span class="math">F_{T,i} \\neq F_{T,j}</span> , (17)</p>

    <p class="text-gray-300"><span class="math">$F_{T,*}(x^*) = 0, (18)</span>$</p>

    <p class="text-gray-300"><span class="math">$F_{T,o}(x^*) = 0.</span>$
(19)</p>

    <p class="text-gray-300">We observe that  <span class="math">F_{T,*}</span>  and  <span class="math">F_{T,\\circ}</span>  are non-trivial polynomials of degree at most  <span class="math">\\leq 2q+2</span> . Each polynomial  <span class="math">F_{1,i}</span>  and  <span class="math">F_{2,i}</span>  has degree at most 1 and 2q + 1, respectively.</p>

    <p class="text-gray-300">For fixed i and j, the first case occurs with probability  <span class="math">\\leq 1/p</span> ; the second occurs with probability  <span class="math">\\leq (2q+1)/p</span> ; and the third occurs with probability  <span class="math">\\leq (2q+2)/p</span> . (We already take into account multiplying out the denominators of any rational polynomials.) Finally, the fourth and fifth cases happen with probability  <span class="math">\\leq (2q+2)/p</span> . Now summing over all (i,j) pairs in each case, we bound A's overall success probability  <span class="math">\\varepsilon \\le {\\tau_1 \\choose 2} \\frac{1}{p} + {\\tau_2 \\choose 2} \\frac{2q+1}{p} + {\\tau_T \\choose 2} \\frac{2q+2}{p} + \\frac{2(2q+2)}{p}</span> . Since  <span class="math">\\tau_1 + \\tau_2 + \\tau_T \\le q_G + 4</span> , we end with  <span class="math">\\varepsilon \\le (q_G + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8q + 4)^2 (8</span>  <span class="math">(8)/p = O(q_G^3/p).</span></p>

    <p class="text-gray-300">The following corollary is immediate.</p>

    <p class="text-gray-300"><strong>Corollary D.2</strong> Any adversary that breaks the EDH assumption with constant probability  <span class="math">\\varepsilon &gt; 0</span>  in generic groups of order p such that  <span class="math">q &lt; o(\\sqrt[3]{p})</span>  requires  <span class="math">\\Omega(\\sqrt{\\varepsilon p/q})</span>  generic group operations.</p>

    <p class="text-gray-300">We now turn our attention from a computational to a decisional problem. Recall from Section 2 that the Strong SXDH assumption involves oracle  <span class="math">O_x(\\cdot)</span>  that take as input a value  <span class="math">m \\in \\mathbb{Z}_p^*</span>  and returns  <span class="math">(g^v, \\tilde{g}^{1/(x+v)}, \\tilde{g}^{1/(v+m)})</span>  for  <span class="math">v \\in \\mathbb{Z}_p^*</span>  randomly chosen by the oracle, and an oracle  <span class="math">Q_y(\\cdot)</span>  that takes the same type of input and returns  <span class="math">(a, a^y, \\dot{\\tilde{g}}^{1/(y+v)}, \\tilde{g}^{1/(v+m)})</span> , for  <span class="math">a \\in \\mathbb{G}_1</span>  and  <span class="math">v \\in \\mathbb{Z}_p^*</span>  chosen randomly by the oracle. These random values are freshly chosen at each invocation of the oracle.</p>

    <p class="text-gray-300"><strong>Theorem D.3</strong> (Strong SXDH is Hard in Generic Groups) Let  <span class="math">x \\in \\mathbb{Z}_p^*</span> ,  <span class="math">b \\in \\{0,1\\}</span> , and  <span class="math">\\xi_1, \\xi_2, \\xi_T</span>  be chosen at random. Also, if b = 1, set y = x, but if b = 0, then set y to be a value selected randomly from  <span class="math">\\mathbb{Z}_p^* \\setminus x</span> . Let  <span class="math">\\mathcal{A}</span>  be an algorithm that solves the Strong SXDH problem in the generic group model, making a total of  <span class="math">q_G</span>  queries to the oracles computing the group action in  <span class="math">\\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T</span> , the oracle computing the bilinear pairing e, and the two oracles  <span class="math">O_x(\\cdot)</span>  and  <span class="math">Q_y(\\cdot)</span>  as described above. Then the probability  <span class="math">\\varepsilon</span>  that  <span class="math">A(p, \\xi_1(1), \\xi_1(x), \\xi_2(1)) = b</span>  is bounded by</p>

    <p class="text-gray-300"><span class="math">$\\varepsilon \\le \\frac{1}{2} + \\frac{(q_G + 3)^2 (3q_G)}{p} = \\frac{1}{2} + O\\left(\\frac{q_G^3}{p}\\right).</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> B maintains the lists  <span class="math">L_1</span> ,  <span class="math">L_2</span> , and  <span class="math">L_T</span>  as in the proof of Theorem D.1. (Consider the bit b as not yet set.) At step  <span class="math">\\tau</span>  in the game, we now have  <span class="math">\\tau_1 + \\tau_2 + \\tau_T = \\tau + 3</span> , where at  <span class="math">\\tau = 0</span> , we set  <span class="math">\\tau_1 = 2</span> ,  <span class="math">\\tau_2 = 1</span> , and  <span class="math">\\tau_T = 0</span> . These correspond to the polynomials  <span class="math">F_{1,0} = F_{2,0} = 1</span>  and  <span class="math">F_{1,1} = x</span> .  <span class="math">\\mathcal{B}</span>  also selects unique, random strings  <span class="math">\\xi_{1,0}, \\xi_{1,1}</span> , and  <span class="math">\\xi_{2,0}</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span>  begins the game with  <span class="math">\\mathcal{A}</span>  by providing it with the strings  <span class="math">\\xi_{1,0}, \\xi_{1,1}</span> , and  <span class="math">\\xi_{2,0}</span> .  <span class="math">\\mathcal{A}</span>  may, at any time, make the group action or pairing queries as in the proof of Theorem D.1. A may additionally query the following two oracles. Let  <span class="math">\\tau_v = 1</span>  and  <span class="math">\\tau_w = 1</span>  be counters.</p>

    <p class="text-gray-300"><strong>Oracle</strong>  <span class="math">O_x(\\cdot)</span> :  <span class="math">\\mathcal{A}</span>  inputs m in  <span class="math">\\mathbb{Z}_p^*</span> , followed by  <span class="math">\\mathcal{B}</span>  choosing a new <em>variable</em>  <span class="math">v_{\\tau_v}</span>  and setting  <span class="math">F_{1,\\tau_1} \\leftarrow v_{\\tau_v}</span> . If  <span class="math">F_{1,\\tau_1} = F_{1,u}</span>  for some  <span class="math">u \\in \\{0,\\ldots,\\tau_1-1\\}</span> , then  <span class="math">\\mathcal{B}</span>  sets  <span class="math">\\xi_{1,\\tau_1} = \\xi_{1,u}</span> ; otherwise, it sets  <span class="math">\\xi_{1,\\tau_1}</span>  to a random string in  <span class="math">\\{0,1\\}^* \\setminus \\{\\xi_{1,0},\\ldots,\\xi_{1,\\tau_1-1}\\}</span> .  <span class="math">\\mathcal{B}</span>  sends  <span class="math">\\xi_{1,\\tau_1}</span>  to  <span class="math">\\mathcal{A}</span> , adding  <span class="math">(F_{1,\\tau_1},\\xi_{1,\\tau_1})</span>  to  <span class="math">L_1</span> .</p>

    <p class="text-gray-300">Next,  <span class="math">\\mathcal{B}</span>  set  <span class="math">F_{2,\\tau_2} \\leftarrow 1/(x+v_{\\tau_v})</span>  and  <span class="math">F_{2,\\tau_2+1} \\leftarrow 1/(v_{\\tau_v}+m)</span> . For  <span class="math">j \\in \\{0,1\\}</span> , if  <span class="math">F_{2,\\tau_2+j} = F_{2,u}</span>  for some  <span class="math">u \\in \\{0,\\dots,\\tau_2-1+j\\}</span> , then  <span class="math">\\mathcal{B}</span>  sets  <span class="math">\\xi_{2,\\tau_2+j} = \\xi_{2,u}</span> ; otherwise, it sets  <span class="math">\\xi_{2,\\tau_2+j}</span>  to a random string in  <span class="math">\\{0,1\\}^* \\setminus \\{\\xi_{2,0},\\dots,\\xi_{2,\\tau_2-1+j}\\}</span> .  <span class="math">\\mathcal{B}</span>  sends  <span class="math">(\\xi_{2,\\tau_2},\\xi_{2,\\tau_2+1})</span>  to  <span class="math">\\mathcal{A}</span> , adding  <span class="math">(F_{2,\\tau_2},\\xi_{2,\\tau_2})</span>  and  <span class="math">(F_{2,\\tau_2+1},\\xi_{2,\\tau_2+1})</span>  to  <span class="math">L_2</span> .</p>

    <p class="text-gray-300">Finally,  <span class="math">\\mathcal{B}</span>  adds one to  <span class="math">\\tau_1</span> , two to  <span class="math">\\tau_2</span> , and one to  <span class="math">\\tau_v</span> .</p>

    <p class="text-gray-300"><strong>Oracle</strong>  <span class="math">Q_y(\\cdot)</span> :  <span class="math">\\mathcal{B}</span>  responds similarly, except that it chooses new <em>variables</em>  <span class="math">r_{\\tau_w}</span>  and  <span class="math">w_{\\tau_w}</span> , and sets  <span class="math">F_{1,\\tau_1} \\leftarrow r_{\\tau_w}</span> ,  <span class="math">F_{1,\\tau_1+1} \\leftarrow r_{\\tau_w} \\cdot y</span> ,  <span class="math">F_{1,\\tau_1+2} \\leftarrow r_{\\tau_w} \\cdot w_{\\tau_w}</span> ,  <span class="math">F_{2,\\tau_2} \\leftarrow 1/(y+w_{\\tau_w})</span> , and  <span class="math">F_{2,\\tau_2+1} \\leftarrow 1/(w_{\\tau_w}+m)</span> . At the end,  <span class="math">\\mathcal{B}</span>  adds three to  <span class="math">\\tau_1</span> , two to  <span class="math">\\tau_2</span> , and one to  <span class="math">\\tau_w</span> .</p>

    <p class="text-gray-300">Eventually  <span class="math">\\mathcal{A}</span>  stops and outputs a guess  <span class="math">b&#x27; \\in \\{0, 1\\}</span> .</p>

    <p class="text-gray-300">Analysis of  <span class="math">\\mathcal{A}</span> 's Output. First, we argue that, provided  <span class="math">\\mathcal{B}</span> 's simulation is perfect, the bit b' is independent of b; that is,  <span class="math">\\mathcal{A}</span>  cannot output a string such that the corresponding polynomial is always equal when x=y (b=1) and non-zero otherwise (b=0). We show this for each group  <span class="math">\\mathbb{G}_1</span> ,  <span class="math">\\mathbb{G}_2</span> , and  <span class="math">\\mathbb{G}_T</span> . Showing this for  <span class="math">\\mathbb{G}_T</span>  is the hardest case. Here, we sum over all expressions containing i or j.</p>

    <p class="text-gray-300"><strong>Group</strong>  <span class="math">\\mathbb{G}_1</span> : The polynomials corresponding to elements in  <span class="math">\\mathbb{G}_1</span>  that the adversary can compute as a linear combination of elements in its view are:</p>

    <p class="text-gray-300"><span class="math">$F_{1,a} = a_0 + a_1 \\cdot x + a_{2,i} \\cdot v_i + a_{3,i} \\cdot r_i + a_{4,i} \\cdot r_i \\cdot y + a_{5,i} \\cdot r_i \\cdot w_i \\tag{20}</span>$</p>

    <p class="text-gray-300">where i=1 to  <span class="math">\\tau_v</span>  and j=1 to  <span class="math">\\tau_w</span> . For  <span class="math">F_{1,a}=0</span> , both  <span class="math">a_1</span>  and  <span class="math">a_{4,j}</span>  must be zero whether y is replaced by x or not; otherwise those terms cannot be canceled. The remaining polynomial does not contain the variables x or y.</p>

    <p class="text-gray-300"><strong>Group</strong>  <span class="math">\\mathbb{G}_2</span> : The polynomials corresponding to elements in  <span class="math">\\mathbb{G}_2</span>  that the adversary can compute as a linear combination of elements in its view are:</p>

    <p class="text-gray-300"><span class="math">$F_{2,b} = b_0 + \\frac{b_{1,i}}{x + v_i} + \\frac{b_{2,i}}{v_i + m_i} + \\frac{b_{3,j}}{y + w_j} + \\frac{b_{4,j}}{w_j + m_j}</span>$
(21)</p>

    <p class="text-gray-300">where i=1 to  <span class="math">\\tau_v</span> , j=1 to  <span class="math">\\tau_w</span> , and each  <span class="math">m_i, m_j \\in \\mathbb{Z}_p^*</span>  was chosen by the adversary. Suppose  <span class="math">F_{2,b}=0</span> . We multiply out the denominators in equation (21) to obtain:</p>

    <p class="text-gray-300"><span class="math">$F&#x27;_{2,b} = b_0(x+v_i)(v_i+m_i)(y+w_j)(w_j+m_j) + b_{1,i}(v_i+m_i)(y+w_j)(w_j+m_j) + b_{2,i}(x+v_i)(y+w_j)(w_j+m_j) + b_{3,j}(x+v_i)(v_i+m_i)(w_i+m_j) + b_{4,j}(x+v_i)(v_i+m_i)(y+w_j)</span>$
(22)</p>

    <p class="text-gray-300">Now, for  <span class="math">F_{b,2}&#x27;=0</span> , regardless of whether we substitute x for y, we see that  <span class="math">b_0=0</span> , otherwise the term  <span class="math">xv_iyw_j</span>  (or  <span class="math">x^2v_iw_j</span> ) cannot be canceled. Similarly,  <span class="math">b_{1,i}=0</span>  because of the unique summand  <span class="math">xv_iy</span>  (or  <span class="math">x^2v_i</span> ), which makes  <span class="math">b_{2,i}=0</span>  because of the summand  <span class="math">v_i^2w_j</span> . Then,  <span class="math">b_{3,j}=0</span>  because of the summand  <span class="math">xyw_j</span>  (or  <span class="math">x^2w_j</span> ), which makes  <span class="math">b_{4,j}=0</span>  because of the summand  <span class="math">v_iw_j^2</span> . We are left with the constant zero.</p>

    <p class="text-gray-300"><strong>Group</strong>  <span class="math">\\mathbb{G}_T</span> : The polynomials corresponding to elements in  <span class="math">\\mathbb{G}_T</span>  that the adversary can compute as a linear combination of elements in its view are:</p>

    <p class="text-gray-300"><span class="math">$F_{T,c} = \\sum F_{1,a} \\cdot F_{2,b}.</span>$
(23)</p>

    <p class="text-gray-300">Now, a simple expansion of  <span class="math">F_{T,c}</span>  has thirty terms. Suppose we clear the denominators in  <span class="math">F_{T,c} = 0</span>  by multiplying out by  <span class="math">(x + v_i)(v_i + m_i)(y + w_j)(w_j + m_j)</span> , then we have</p>

    <p class="text-gray-300"><span class="math">$F&#x27;_{T,c} = \\sum F_{1,a} \\cdot F&#x27;_{2,b}. \\tag{24}</span>$</p>

    <p class="text-gray-300">Now, each of the terms in  <span class="math">F_{1,a}</span>  is unique and  <span class="math">F&#x27;_{2,b}</span>  contains the following unique summands  <span class="math">(xv_iyw_j, xv_iy, v_i^2w_j, xyw_j, v_iw_j^2)</span> . (Here, the summands  <span class="math">v_i^2w_j</span>  and  <span class="math">v_iw_j^2</span>  are actually not unique, but since they also do not contain x or y, it will not matter.) Multiplying these key components out and dropping the subscript for clarity, we obtain:</p>

    <p class="text-gray-300"><span class="math">$F_{T,c}&#x27;&#x27; = c_0(vwxy) + c_1(vxy) + c_2(v^2w) + c_3(wxy) + c_4(vw^2) + c_5(vwx^2y) + c_6(vx^2y) + c_7(v^2wx) + c_8(wx^2y) + c_9(vw^2x) + c_{10}(v^2wxy) + c_{11}(v^2x^2y) + c_{12}(v^3w) + c_{13}(vwxy) + c_{14}(v^2w^2) + c_{15}(vwxyz) + c_{16}(vxyz) + c_{17}(v^2wz) + c_{18}(wxyz) + c_{19}(vw^2z) + c_{20}(vwxy^2z) + c_{21}(vxy^2z) + c_{22}(v^2wyz) + c_{23}(wxy^2z) + c_{24}(vw^2yz) + c_{25}(vw^2xyz) + c_{26}(vwxyz) + c_{27}(v^2w^2z) + c_{28}(w^2xyz) + c_{29}(vw^3z)</span>$</p>

    <p class="text-gray-300"><span class="math">$(25)</span>$</p>

    <p class="text-gray-300">Now, we are only interested in differences in the polynomial  <span class="math">F&#x27;&#x27;_{T,c}</span>  when y is replaced by x or not. For clarity, we drop all terms containing neither x nor y, resulting in  <span class="math">c_2 = c_4 = c_{12} = c_{14} = c_{17} = c_{19} = c_{27} = c_{29} = 0</span> . We substitute x = y to obtain.</p>

    <p class="text-gray-300"><span class="math">$F_{T,c}^{&quot;&quot;} = c_{0}(vwx^{2}) + c_{1}(vx^{2}) + c_{0}(vx^{2}) + c_{3}(wx^{2}) + c_{1}(vx^{2}) + c_{1}(vx^{2}) + c_{2}(vx^{2}) + c_{1}(v^{2}x^{3}) + c_{1}(v^{2}x^{3}) + c_{1}(vx^{2}x^{2}) + c_{1}(vx^{2}x^{2}) + c_{1}(vx^{2}x^{2}) + c_{1}(vx^{2}x^{2}) + c_{1}(vx^{2}x^{2}) + c_{2}(vx^{2}x^{2}) + c_{2}(vx^{2}x^{2}) + c_{2}(vx^{2}x^{2}) + c_{2}(vx^{2}x^{2}) + c_{2}(vx^{2}x^{2}) + c_{2}(vx^{2}x^{2}) + c_{2}(vx^{2}x^{2}x^{2})</span>$</p>

    <p class="text-gray-300"><span class="math">$(26)</span>$</p>

    <p class="text-gray-300">We want to know if there are any two terms that are symbolically equal when x = y and not otherwise. Scanning the above, we see that the only non-unique terms are in positions 0 and 13, and in positions 15 and 26. Looking back to equation (25), we see that <em>both</em> positions 0 and 13 correspond to term vwxy, and that <em>both</em> positions 15 and 26 correspond to term vwxyz. Obviously, these terms will be the same regardless of the substitution of x for y. Since all other terms are unique, we conclude that the adversary's only chance of distinguishing comes from a lucky instantiation of these variables.</p>

    <p class="text-gray-300">Analysis of  <span class="math">\\mathcal{B}</span> 's Simulation. At this point  <span class="math">\\mathcal{B}</span>  chooses random values  <span class="math">x^*, y^*, \\{v_d^*\\}_{d \\in [1, \\tau_v]}, \\{w_d^*\\}_{d \\in [1, \\tau_w]}, \\{r_d^*\\}_{d \\in [1, \\tau_w]} \\in \\mathbb{Z}_p^*</span> .  <span class="math">\\mathcal{B}</span> 's simulation is perfect, and therefore reveals nothing to  <span class="math">\\mathcal{A}</span>  about b, provided that none</p>

    <p class="text-gray-300">of the following non-trivial equality relations hold:</p>

    <p class="text-gray-300"><span class="math">$F_{1,i}(x^*, y^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) - F_{1,j}(x^*, y^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) = 0:</span>$
for some  <span class="math">i, j</span> , such that  <span class="math">F_{1,i} \\neq F_{1,j}</span> , (27)</p>

    <p class="text-gray-300"><span class="math">$F_{1,i}(x^*, x^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) - F_{1,j}(x^*, x^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) = 0:</span>$
for some  <span class="math">i, j</span> , such that  <span class="math">F_{1,i} \\neq F_{1,j}</span> ,
<span class="math">$(28)</span>$</p>

    <p class="text-gray-300"><span class="math">$F_{2,i}(x^*, y^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) - F_{2,j}(x^*, y^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) = 0:</span>$
for some  <span class="math">i, j</span> , such that  <span class="math">F_{2,i} \\neq F_{2,j}</span> , (29)</p>

    <p class="text-gray-300"><span class="math">$F_{2,i}(x^*, x^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) - F_{2,j}(x^*, x^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) = 0:</span>$
for some  <span class="math">i, j</span> , such that  <span class="math">F_{2,i} \\neq F_{2,j}</span> , (30)</p>

    <p class="text-gray-300"><span class="math">$F_{T,i}(x^*, y^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) - F_{T,j}(x^*, y^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) = 0:</span>$
for some  <span class="math">i, j</span> , such that  <span class="math">F_{T,i} \\neq F_{T,j}</span> , (31)</p>

    <p class="text-gray-300"><span class="math">$F_{T,i}(x^*, x^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) - F_{T,j}(x^*, x^*, \\{v_d^*\\}, \\{w_d^*\\}, \\{r_d^*\\}) = 0:</span>$
for some  <span class="math">i, j</span> , such that  <span class="math">F_{T,i} \\neq F_{T,j}</span> . (32)</p>

    <p class="text-gray-300">For fixed i and j, the probability of the first and second cases occurring are no more than 2/p, where this results from the maximum degree of equation (20). For fixed i and j, the probability of the third and fourth cases occurring are no more than &tau;2/p, where this results from the maximum degree of equation (22). Finally, for the fifth and sixth cases, the probability is at most 2&tau;2/p, where this results from the maximum degree of equation (24).</p>

    <p class="text-gray-300">Therefore, by summing over all (i, j) pairs in each case, we bound A's overall success probability &epsilon; &le; 2 &tau;1 2 2 p+2 &tau;2 2 &tau;2 <sup>p</sup> +2 &tau;T 2 2&tau;<sup>2</sup> p . Since &tau;1+&tau;2+&tau;<sup>T</sup> &le; qG+3, we end with &epsilon; &le; (qG+3)<sup>2</sup> (2+qG+2qG)/p = O(q 3 <sup>G</sup>/p). &#10039;</p>

    <p class="text-gray-300">The following corollary is immediate. Here &gamma; = &epsilon; &minus; 2 ; that is, &gamma; is the adversary's advantage beyond guessing.</p>

    <p class="text-gray-300"><strong>Corollary D.4</strong> <em>Any adversary that breaks the Strong SXDH assumption with constant probability</em> &gamma; &gt; 0 <em>in generic groups of order</em> <sup>p</sup> <em>requires</em> &Omega;(&radic;<sup>3</sup> &gamma;p) <em>generic group operations.</em></p>

    </section>
`;
---

<BaseLayout title="Practical Group Signatures without Random Oracles (2005/385)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2005 &middot; eprint 2005/385
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="practical-group-signatures-without-random-oracles-2005" />
  </article>
</BaseLayout>
