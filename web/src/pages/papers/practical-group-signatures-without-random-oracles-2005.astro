---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2005/385';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Practical Group Signatures without Random Oracles';
const AUTHORS_HTML = 'Giuseppe Ateniese, Jan Camenisch, Susan Hohenberger, Breno de Medeiros';

const CONTENT = `    <p class="text-gray-300">Practical Group Signatures without Random Oracles</p>

    <p class="text-gray-300">Giuseppe Ateniese* Jan Camenisch† Susan Hohenberger† Breno de Medeiros‡</p>

    <p class="text-gray-300">Abstract</p>

    <p class="text-gray-300">We provide a construction for a group signature scheme that is provably secure in a universally composable framework, within the standard model with trusted parameters. Our proposed scheme is fairly simple and its efficiency falls within small factors of the most efficient group signature schemes with provable security in any model (including random oracles). Security of our constructions require new cryptographic assumptions, namely the Strong LRSW, EDH, and Strong SXDH assumptions. Evidence for any assumption we introduce is provided by proving hardness in the generic group model.</p>

    <p class="text-gray-300">Our second contribution is the first definition of security for group signatures based on the simulatability of real protocol executions in an ideal setting that captures the basic properties of unforgeability, anonymity, unlinkability, and exculpability for group signature schemes.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Group signature schemes, introduced by Chaum and van Heyst [23], allow a member of a user group to sign anonymously on behalf of the group, where a user's anonymity may be revoked by a designated group manager, in case of disputes.</p>

    <p class="text-gray-300">The motivation of this paper is twofold. Our first motivation is to build a practical group signature scheme provably secure under standard assumptions, in particular without resorting to the random oracle model. Prior to this work, there was no group signature scheme known achieving this (with the exception of the recent scheme by Boyen-Waters [16] which, however, fails to meet all required properties—we will later discuss their scheme in more detail).</p>

    <p class="text-gray-300">In this paper, we present a full group signature scheme provably secure under new number-theoretic assumptions. Now, one might say that we trade the "assumption" that the Fiat-Shamir heuristic works with proof of knowledge protocols for discrete logarithms (e.g., such as the Schnorr signature scheme) with other possibly false assumptions. However, while one will probably never be able to prove that the Fiat-Shamir heuristic is reasonable for some cases (on the contrary, many cases are known for which it is unreasonable [33]), our new assumptions are algebraic and hence naturally much easier to analyze. Indeed, as a first step towards their justification, we prove that they hold in the generic group model [40, 46]. We hasten to point out that one can of course prove assumptions hard in the generic group model that are not hard against an algebraically unrestricted adversary, and that the generic group model has some of the same faults as random oracles [27]. Rather, a proof in the generic model should be considered a sanity check for an complexity assumption.</p>

    <p class="text-gray-300">In the light of the quest for a group signature scheme provably secure in the standard model, one can view both schemes, the Boyen-Waters one and ours, as first steps in this direction. The Boyen-Waters scheme uses</p>

    <p class="text-gray-300">*Dept. of Computer Science; The Johns Hopkins University; 3400 N. Charles Street; Baltimore, MD 21218, USA. †IBM Research; Zurich Research Laboratory; Säumerstrasse 4, CH-8803 Rüschlikon, Switzerland. ‡Dept of Computer Science; Florida State University; 105-D James Love Bldg Tallahassee; FL 32306-4530 USA.</p>

    <p class="text-gray-300">somewhat less complicated assumptions, but sacrifies some desirable properties while our scheme captures these properties but makes more involved assumptions.</p>

    <p class="text-gray-300">The second motivation of this paper is the definition of security in the reactive security or universally composablility model <em>[8, 42, 22, 43]</em>. Let us expand here. The security of early schemes was defined in terms of whether they satisfied a number of independent properties, and lacked a comprehensive view of adversarial behavior. Indeed, as initially the set of features considered was insufficient, some proposed schemes were subsequently broken. An important realization was the requirement that membership certificates be the equivalent of group manager signatures, in order to prevent against attacks by arbitrary group member coalitions <em>[5]</em>. Later, Bellare, Micciancio, and Warinschi <em>[9]</em> (BMW) introduced a security formalism based on adversarial games that combined the several requirements of previous works into fewer ones (namely, traceability and anonymity). However, the BMW formalization relies on the existence of a (trusted) key-issuing entity that generates all keys in the system and distributes them to the group manager and group members. As argued by Kiayias and Yung <em>[36]</em>, BMW models a weaker primitive than the group signatures proposed by Chaum and van Heyst, since assuming a “tamper-proof” key setup conflicts with the goals of many practical schemes. The BMW model has been extensively adapted (via incorporating exculpability, changing the proof model to the random oracle setting and/or to dynamic groups) to allow for security proofs of recently proposed group signature schemes, e.g., works by Boneh et al. <em>[13]</em> and Camenisch and Lysyanskaya <em>[19]</em>.</p>

    <p class="text-gray-300">The first formal model to apply to the case of dynamic groups was introduced by Kiayias et al. <em>[36, 35]</em>. The formalization works in the random oracle model, not the standard model, but it captures closely the security requirements of practical group signatures, and it can be readily applied to formally prove the security of practical schemes. Indeed, <em>[36]</em> includes a security proof of a variant of the Ateniese et al. scheme <em>[4]</em>. More recently, Bellare, Shi, and Zhang <em>[11]</em> have proposed a standard-model formalism for dynamic groups, and constructed theoretical schemes based on black-box zero-knowledge primitives.</p>

    <p class="text-gray-300">Simultaneously with this evolution of understanding in group signatures was the development of the universally composable (UC)/reactive framework <em>[8, 42, 22, 43]</em>. The UC/reactive framework enables proofs of security of protocols that are valid under concurrent execution and in composition with other arbitrary protocols. It has been shown that this framework is more powerful than a property based definitional approach as it captures all properties at the same time. Indeed, examples are known of schemes that satisfy a property based defintion (i.e., each property individually) but not a UC/reactive framework definition that requires the fullfilment of all the properties at the same time <em>[22]</em>.</p>

    <p class="text-gray-300">To date, it remained an open problem to introduce a UC/reactive security model for group signatures. We introduce this definition in Section 2. It was carefully constructed to incorporate the original vision of Chaum and van Heyst and its subsequent developments. Our definition implies many of the guarantees of prior property-based definitions (e.g., <em>[9, 11, 36, 35]</em>). Two properties that we do not require are: (1) membership revocation, and (2) anonymity even after exposure of a user’s secret key (forward anonymity), as in BMW <em>[9]</em>. Regarding point (2), we mean that we provide anonymity only to honest users, i.e., users of which the adversary does not know the secret key of which we believe is sufficient in practise. We emphasize that our model does not require any trusted key-issuing entity and group member secrets are known only to group members.</p>

    <p class="text-gray-300">Note that our results are not in contradiction with the work of Datta et al. <em>[26]</em> on the impossibility of realizing an ideal functionality for group signatures with perfect anonymity (i.e., the probability of guessing the identity of one of two signers is exactly 1/2) and perfect traceability (i.e., the probability of a dishonest group manager violating exculpability is exactly zero). Datta et al. admit that they only consider a strong form of group signature, and indeed, their formulation of group signatures has a single entity generating all</p>

    <p class="text-gray-300">signing keys. They also require that the scheme remain secure even when all public parameters are chosen by a potentially malicious group manager, i.e., they consider UC security in the <em>plain model</em>. In contrast, our definition (and scheme) does not have a key issuing entity and will allow some global parameters to be given to the group manager—e.g., bilinear map parameters. This is sometimes referred to as a UC model with <em>trusted parameters</em>.</p>

    <p class="text-gray-300">We now summarize the contributions of our paper.</p>

    <h3 id="sec-1" class="text-xl font-semibold mt-8">1.1 Our Contribution and Comparison with Previous Work</h3>

    <p class="text-gray-300">Strong security model: We provide the first definition of security for group signature schemes as an ideal functionality, and provide a construction of a practical and provably secure scheme within the new framework. Static-membership versions of our group signature schemes are secure in the context of composition and concurrent executions. The dynamic-membership version of our group signature scheme is similarly secure, if the join protocol is restricted to sequential execution.</p>

    <p class="text-gray-300">Better Efficiency: Our construction is the first in the standard model to provide <em>constant</em> time and space efficiency with respect to the security parameter. Concurrently, and independently from us, Boyen and Waters <em>[16]</em> proposed a scheme provably secure the standard model (under a different definition of security). However, in their scheme the bit length of the signatures and the complexity of the signature and verification algorithms are <span class="math">O((\\log n)\\cdot k)</span>, where <span class="math">n</span> is the number of group members and <span class="math">k</span> is the security parameter. In our scheme, all of these complexities will be <span class="math">O((\\log n)+k)</span>, where the <span class="math">(\\log n)</span> term is there to guarantee that there are enough unique secret keys for each user in the algebraic group. In practice, <span class="math">\\log n</span> is smaller than <span class="math">k</span>, so our scheme is an <span class="math">O(k)</span> scheme (i.e., constant in the security parameter).</p>

    <p class="text-gray-300">CCA-anonymity: Our scheme achieves CCA anonymity, i.e., anonymity holds even when the adversary continually has access to an open oracle (which, when queried on a signature, returns the signer’s identity). In constrast, the Boyen-Waters scheme achieves only CPA anonymity, where the adversary is not allowed access to the oracle after receiving the challenge signature. Similarly as CCA security is the de facto requirement for encryption schemes, we believe this is a vital property for group signatures.</p>

    <p class="text-gray-300">Strong exculpability: We achieve exculpability, an important property originally proposed by Chaum and van Heyst. In our scheme, a user’s secret key is chosen by the user, and we prove that group managers cannot sign on behalf of honest users. The Boyen-Waters scheme lacks (strong) exculpability of users: In their scheme, a trusted key-issuing entity generates and distributes users’ secret keys. Thus, this entity can sign messages on behalf of the user, and thus holding users <em>accountable</em> for any misbehavior is difficult.</p>

    <p class="text-gray-300">Forward security: Our scheme does not achieve forward anonymity as defined in BMW <em>[9]</em> under the full anonymity property where members remain untraceable even if their secret keys are exposed, but only ordinary anonymity. The Boyen and Waters scheme does achieve forward anonymity.</p>

    <p class="text-gray-300">General setting for bilinear mappings: We use curves with isomorphism-free paired groups, arguably the most efficient, secure, and versatile setting for pairings-based cryptography (e.g., see Galbraith et. al. <em>[31]</em>). In contrast, the Boyen-Waters scheme is restricted to symmetric bilinear mapping settings (supersingular curves). Even more significantly, their scheme uses elliptic curve groups of composite order, and they require that this order be hard to factor, implying it must be large (1024 bits or larger). Consequently, the representation of every elliptic curve point is similarly large, which heavily impacts the performance of cryptographic operations in these curves, as well as their bandwidth requirements.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">1.2 Overview of the Construction</p>

    <p class="text-gray-300">We now provide intuition for understanding our construction, described in detail in Section 5. Our group signature scheme has the standard protocols: Setup, Join, GroupSign, GroupVerify, and Open. Let <span class="math">S=(Gen,Sign,\\,Verify)</span> be an efficient signature scheme secure in the standard model. Let the group manager have keypair <span class="math">(GPK,GSK)</span> and a user have keypair <span class="math">(pk,sk)</span>, generated according to <span class="math">Gen</span>. Consider the following scheme. During the Join protocol, the group manager gives the user a certificate on her public key: <span class="math">Sign_{GSK}(pk)</span>. To sign message <span class="math">m</span> as a group member, the user prepends her certificate and public key to her signature: (<span class="math">Sign_{GSK}(pk)</span>, <span class="math">pk</span>, <span class="math">Sign_{sk}(m)</span>). This scheme is clearly unforgeable, but not anonymous. In order to achieve anonymity, the certificate and user’s public key must be made unlinkably randomizable, while the signature element must be instantiated using a key-private signature scheme. We actually have the manager and user employ different signature schemes, <span class="math">S_{1}</span> and <span class="math">S_{2}</span>.</p>

    <p class="text-gray-300"><span class="math">S_{1}</span> is based on the pairing-based signature scheme of <em>Camenisch and Lysyanskaya [19]</em> (CL); Specifically it uses the extension of this scheme (CL^{+}) by <em>Ateniese et al. [3]</em>. Consider a bilinear map (pairing) <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\rightarrow\\mathbb{G}_{T}</span>, defined on groups of prime order <span class="math">p</span>, with generators <span class="math">g</span>, <span class="math">\\tilde{g}</span>, <span class="math">\\hat{g}</span>, respectively. Select random <span class="math">s,t\\in\\mathbb{Z}_{p}</span> and set <span class="math">sk=(s,t)</span> and <span class="math">pk=(\\tilde{g}^{s},\\tilde{g}^{t})</span>. To sign a message <span class="math">m\\in\\mathbb{Z}_{p}^{*}</span>, choose random <span class="math">a\\in\\mathbb{G}_{1}</span> and output the tuple <span class="math">(a,a^{t},a^{s+stm},a^{m},a^{mt})</span>. Verify signature <span class="math">(A,B,C,D,E)</span> by checking that: (1) <span class="math">e(A,\\tilde{g}^{t})=e(B,\\tilde{g})</span>, (2) <span class="math">e(D,\\tilde{g}^{t})=e(E,\\tilde{g})</span>, and (3) <span class="math">e(AE,\\tilde{g}^{s})=e(C,\\tilde{g})</span>.</p>

    <p class="text-gray-300">The user’s certificate is nothing more than a blind CL^{+} signature from the group manager on the user’s secret key <span class="math">sk</span>, i.e., the group member signs <span class="math">sk</span> without learning its value, a necessary condition for our scheme to provide exculpability. Fortunately, the CL^{+} signature inherits an efficient blind-signature protocol from the original CL scheme. In the above, we instantiate the elements <span class="math">(Sign_{GSK}(pk),pk)</span> with <span class="math">CL^{+}_{GSK}(sk)=(a,a^{t},a^{s+st(sk)},a^{sk},a^{t(sk)})</span>, which is the group manager’s signature on <span class="math">sk</span> which can be thought of as including an obfuscated version of the user’s public key <span class="math">(a,a^{sk})</span>. As observed in <em>[3]</em>, these signatures can be unlinkably re-randomized by choosing a random <span class="math">r\\in\\mathbb{Z}_{p}</span> and computing <span class="math">(a^{r},a^{tr},a^{\\{s+st(sk)\\}r}</span>, <span class="math">a^{skr}</span>, <span class="math">a^{t(sk)r})</span>, assuming DDH is hard in <span class="math">\\mathbb{G}_{1}</span>. The user may therefore release a random-looking copy of her certificate with each group signature.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We implement <span class="math">S_{2}</span> with a new signature scheme (secure in the standard model) which is based on the weak signatures of <em>Boneh and Boyen [13]</em> (BB). By weak, we mean the Boneh-Boyen signature scheme proven weak message attack secure, where the adversary must submit all challenge messages in advance of learning the public key. The scheme works in a similar pairing setting as the <em>CL^{+} signature</em>. Select a random <span class="math">sk\\in\\mathbb{Z}_{p}</span> and a random generator <span class="math">g\\in\\mathbb{G}_{1}</span> and output <span class="math">pk=(g,g^{sk})</span>. To sign a message $m\\in\\{0,1\\}^{\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, output </span>A=\\tilde{g}^{1/(sk+m)}<span class="math">. Verify by checking that </span>e(g^{m}pk,A)=e(g,\\tilde{g})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As a thought experiment, consider our group signature structure using weak BB signatures to implement <span class="math">S_{2}</span>. The construction is <span class="math">(CL^{+}_{GSK}(sk);\\,BB_{sk}(m))=(a,\\,a^{t},\\,a^{s+st(sk)},\\,a^{sk},\\,a^{t(sk)};\\,\\tilde{g}^{1/(sk+m)})=(A,\\,B,\\,C,\\,D,\\,E,\\,F)</span>, verifiable by checking the *CL^{+} signature first and then testing if <span class="math">e(DA^{m},F)=e(A,\\tilde{g})</span>. Unfortunately, as the BB signatures are deterministic, it will be obvious when the same user signs the same message a second time. This violates our privacy definition, so we modify this basic scheme to provide more privacy and enable longer messages.</p>

    <p class="text-gray-300">In their paper <em>[13]</em>, Boneh and Boyen present one method for adapting the weak scheme to longer messages. In this paper, we present another method, which we denote <span class="math">BB^{+}</span>, that is more suited to our purposes. To sign a message <span class="math">m\\in\\mathbb{Z}_{p}^{<em>}</span>, select a random <span class="math">v\\in\\mathbb{Z}_{p}</span> and output the tuple <span class="math">(g^{v},\\,\\tilde{g}^{1/(sk+v)},\\,\\tilde{g}^{1/(v+m)})</span>. Verify signature triple <span class="math">(A,\\,B,\\,C)</span> by checking that <span class="math">e(A\\,pk,B)=e(g,\\tilde{g})</span> and <span class="math">e(A\\,g^{m},C)=e(g,\\tilde{g})</span>. We arrive at the construction <span class="math">(CL^{+}_{GSK}(sk);\\,BB^{+}_{sk}(m))</span>, or more exactly <span class="math">(a,\\,a^{t},\\,a^{s+st(sk)},\\,a^{sk},\\,a^{t(sk)};\\,a^{v},\\,\\tilde{g}^{1/(sk+v)},\\,\\tilde{g}^{1/(v+m)})</span> for message <span class="math">m\\in\\mathbb{Z}_{p}^{</em>}</span>, where <span class="math">a\\in\\mathbb{G}_{1}</span> and <span class="math">v\\in\\mathbb{Z}_{p}</span> are randomly chosen for each new signature.</p>

    <p class="text-gray-300">At this point, we have described the entire construction, except for how the Open algorithm works. The</p>

    <p class="text-gray-300">simplest method is for the user to give the group manager a tracing value <span class="math">\\tilde{g}^{sk}</span> during the Join protocol. Later, the group manager can open a signature <span class="math">(a</span>, <span class="math">a^{t}</span>, <span class="math">a^{s+st(sk)}</span>, <span class="math">a^{sk}</span>, <span class="math">a^{t(sk)}</span>; <span class="math">a^{v}</span>, <span class="math">\\tilde{g}^{1/(sk+v)}</span>, <span class="math">\\tilde{g}^{1/(v+m)})=(A</span>, <span class="math">B</span>, <span class="math">C</span>, <span class="math">D</span>, <span class="math">E</span>; <span class="math">F</span>, <span class="math">G</span>, <span class="math">H)</span> by testing if <span class="math">e(A,\\tilde{g}^{sk})=e(D,\\tilde{g})</span> for each user. Obviously, this algorithm runs linearly in the number of group members. We improve on this result in Section 6, providing two alternative Open algorithms. The first has <span class="math">O(\\sqrt{n}\\cdot k)</span> complexity, for membership groups of size <span class="math">n</span> and security parameter <span class="math">k</span>, under the same cryptographic assumptions as the basic scheme. The second reduces to <span class="math">((\\log n)+k)</span> under an additional assumption.</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Remark 1.1 (Security under concurrent executions.)</h6>

    <p class="text-gray-300">The join protocol is the only protocol in our scheme that requires sequential composition for security, because it involves a zero-knowledge proof of knowledge. In Appendix B, we discuss some techniques for securely achieving limited forms of concurrency.</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">Remark 1.2 (Revocation.)</h6>

    <p class="text-gray-300">Finding an elegant revocation mechanism is a pervasive problem among group signature schemes. To revoke a user in our scheme, the group manager could publish that user’s tracing information obtained during the join protocol. We explore more efficient alternatives in the full version.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Length of Signatures.</h4>

    <p class="text-gray-300">The signatures produced by this scheme are short. In the following comparisons we are going use the NIST suggested equivalence of 80-bit symmetric security with RSA-1024 and 128-bit symmetric security with RSA-3072. For our schemes, we estimate the key sizes from our generic-model security reductions to be 1/3 of the equivalent symmetric key size, i.e., 240 bits for 80-bit symmetric security and 384 bits for 128-bit symmetric security. This 3:1 ratio should be also used to compare schemes based on the <span class="math">q</span>-Strong Diffie Hellman assumption, due to recent results by Cheon <em>[24]</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assuming that the bitlength of elements in <span class="math">\\mathbb{G}_{1}</span> is 241 (an extra bit is needed to indicate the <span class="math">y</span>-coordinate among two options), and that the curves implemented in the MIRACL library are used <em>[44]</em>, the basic scheme achieves roughly the same level of security as a 1024-bit RSA signature <em>[13]</em>. For these curves, the bitlengths of elements in <span class="math">\\mathbb{G}_{2}</span> are roughly three times that of <span class="math">\\mathbb{G}_{1}</span> (more precisely 721 bits), and our scheme would take approximately 2888 bits to represent a group signature, comprised of six elements in <span class="math">\\mathbb{G}_{1}</span> and two elements in <span class="math">\\mathbb{G}_{2}</span>. If the newer curves of embedding degree 12 are used <em>[7]</em>, one could employ 385-bit groups (for 128-bit generic security) to achieve RSA-3072 security equivalence. These new curves have better ratios, with $\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2<span class="math">. In this case, our signatures would take 3848 bits to be represented, about </span>25\\%$ larger than a plain RSA signature with the same security level. As mentioned before, this efficiency is incomparable with that of Boyen and Waters <em>[16]</em>, which (1) grow logarithmically with the number of system members and (2) require elliptic curve group orders over a 1000 bits long.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our scheme can be compared with the most efficient short group signatures secure in the random oracle setting. For instance, the scheme by Boneh, Boyen, and Shacham <em>[13]</em>, which achieves only CPA-anonymity, would require about 2163 bits for the RSA-1024 security level (or about 1442 in the MNT setting). A shorter scheme by Boneh and Shacham <em>[15]</em> requires <span class="math">1682</span> bits to achieve RSA-<span class="math">1024</span> comparable security.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 Group Signature Security Definition</h2>

    <p class="text-gray-300">Notation: if <span class="math">P</span> is a protocol between parties <span class="math">A</span> and <span class="math">B</span>, then <span class="math">P(A(x),B(y))</span> denotes that <span class="math">A</span>’s input is <span class="math">x</span> and <span class="math">B</span>’s input is <span class="math">y</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">A group signature scheme consists of the usual types of players: a group manager <span class="math">\\mathcal{GM}</span> and a user <span class="math">\\mathcal{U}_{i}</span>. These players can execute the algorithms: GroupSetup, UserKeyGen, Join, GroupSign, GroupVerify, Open, and VerifyOpen. We now specify the input-output specifications for these algorithms as well as providing some informal intuition for what they do.</p>

    <p class="text-gray-300">Let <span class="math">params</span> be global parameters generated during a setup phase; ideally <span class="math">params</span> is empty.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The GroupSetup(<span class="math">1^{k},params</span>) algorithm is a key generation algorithm for the group manager <span class="math">\\mathcal{GM}</span>. It takes as input the security parameter <span class="math">1^{k}</span> and outputs the key pair <span class="math">(pk_{\\mathcal{GM}},sk_{\\mathcal{GM}})</span>. (Assume that <span class="math">sk_{\\mathcal{GM}}</span> contains the <span class="math">params</span>, so we do not have to give <span class="math">params</span> explicitly to the group manager again.)</li>

      <li>The UserKeyGen(<span class="math">1^{k},params</span>) algorithm is a key generation algorithm for a group member <span class="math">\\mathcal{U}</span>, which outputs <span class="math">(pk_{\\mathcal{U}},sk_{\\mathcal{U}})</span>. (Assume that <span class="math">sk_{\\mathcal{U}}</span> contains the <span class="math">params</span>, so we do not have to give <span class="math">params</span> explicitly to the user again.)</li>

      <li>In the Join(<span class="math">\\mathcal{U}(pk_{\\mathcal{GM}},sk_{\\mathcal{U}}),\\mathcal{GM}(pk_{\\mathcal{U}},sk_{\\mathcal{GM}})</span>) protocol, the user <span class="math">\\mathcal{U}</span> joins the signatory group managed by <span class="math">\\mathcal{GM}</span>. The user’s output is a personalized group signing credential <span class="math">C_{\\mathcal{U}}</span>, or an error message. <span class="math">\\mathcal{GM}</span>’s output is some information <span class="math">T_{\\mathcal{U}}</span> which will allow the group manager to revoke the anonymity of any signatures produced by <span class="math">\\mathcal{U}</span>. The group manager maintains a database <span class="math">D</span> for this revocation information, to which it adds the record <span class="math">(pk_{\\mathcal{U}},T_{\\mathcal{U}})</span>.</li>

      <li>The GroupSign(<span class="math">sk_{\\mathcal{U}},C_{\\mathcal{U}},m</span>) algorithm allows group members to sign messages. It takes as input the user’s secret key <span class="math">sk_{\\mathcal{U}}</span>, the user’s signing credential <span class="math">C_{\\mathcal{U}}</span>, and an arbitrary string <span class="math">m</span>. The output is a group signature <span class="math">\\sigma</span>.</li>

      <li>The GroupVerify(<span class="math">pk_{\\mathcal{GM}},m,\\sigma</span>) algorithm allows to publicly verify that <span class="math">\\sigma</span> is a signature on message <span class="math">m</span> generated by some member of the group associated with group public key <span class="math">pk_{\\mathcal{GM}}</span>.</li>

      <li>The Open(<span class="math">sk_{\\mathcal{GM}},D,m,\\sigma</span>) algorithm allows the group manager, with <span class="math">sk_{\\mathcal{GM}}</span> and database <span class="math">D</span>, to identify the group member <span class="math">\\mathcal{U}</span> who was responsible for creating the signature <span class="math">\\sigma</span> on message <span class="math">m</span>. The output is a member identity <span class="math">pk_{\\mathcal{U}}</span> or an error message.</li>

      <li>In the VerifyOpen(<span class="math">\\mathcal{GM}(sk_{\\mathcal{GM}},D,m,\\sigma,pk),\\mathcal{V}(pk_{\\mathcal{GM}},m,\\sigma,pk)</span>) protocol, <span class="math">\\mathcal{GM}</span> convinces a verifier that the user with public key <span class="math">pk</span> was responsible for creating the signature <span class="math">\\sigma</span> on message <span class="math">m</span>. The verifier outputs either 1 (accept) or 0 (reject).</li>

    </ul>

    <p class="text-gray-300">In addition to supporting the above algorithms, a group signature scheme must also be correct and secure. Correctness is fairly straightforward. Informally, if an honest user runs Join with an honest group manager, then neither will output an error message. If an honest user runs GroupSign, then the output will be accepted by an honest verifier running GroupVerify. If a signature passes GroupVerify and a honest manager runs Open, then the result will be accepted by an honest verifier running VerifyOpen.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.1 The Group Signature Ideal Functionality, <span class="math">\\mathcal{F}_{gs}</span></h3>

    <p class="text-gray-300">Our security model uses the ideal/real world model as in multiparty computation <em>[20, 21, 22]</em> and reactive systems <em>[42, 43]</em> to capture the security properties of group signatures in a single definition.</p>

    <p class="text-gray-300">In the real world, there are a number of parties who together execute some cryptographic protocol. A number of these parties may be corrupted by the adversary <span class="math">\\mathcal{A}</span> (all corrupted parties are combined into this single adversary). Each party receives its input and reports its output to the environment <span class="math">\\mathcal{Z}</span>. The environment <span class="math">\\mathcal{Z}</span> and the adversary <span class="math">\\mathcal{A}</span> may arbitrarily interact. In the ideal world, we have the same parties. As before, each party receives its input and reports its output to the environment. However, instead of running a cryptographic protocol, the parties provide their inputs to and receive their outputs from a trusted party <span class="math">\\mathcal{T}</span>. The specification for how <span class="math">\\mathcal{T}</span> behaves is formalized as an ideal functionality.</p>

    <p class="text-gray-300">We say that a cryptographic protocol securely implements an ideal functionality if for every real-world adversary <span class="math">\\mathcal{A}</span> and every environment <span class="math">\\mathcal{Z}</span>, there exists a simulator <span class="math">\\mathcal{S}</span>, which controls the same parties in the ideal world as <span class="math">\\mathcal{A}</span> does in the real world, such that <span class="math">\\mathcal{Z}</span> cannot distinguish whether it is interacting in the real world with <span class="math">\\mathcal{A}</span> or in the ideal world with <span class="math">\\mathcal{S}</span>.</p>

    <p class="text-gray-300">Group Signature Ideal Functionality. We now describe <span class="math">\\mathcal{F}_{gs}</span>. In addition to the environment <span class="math">\\mathcal{Z}</span>, we have two types of players: a group manager <span class="math">\\mathcal{GM}</span> and users <span class="math">\\mathcal{U}_{i}</span>. We work in the <em>non-adaptive</em> setting.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Non-adaptive Setup: Each user <span class="math">\\mathcal{U}_{i}</span> tells the functionality <span class="math">\\mathcal{F}_{gs}</span> whether or not it is corrupted. Optionally, in this stage the global parameters are broadcast to all parties.</li>

      <li>GroupSetup: Upon receiving <span class="math">(\\mathcal{GM},\\text{\`<code>group setup&amp;#x27;&amp;#x27;})&lt;/span&gt; from &lt;span class=&quot;math&quot;&gt;\\mathcal{GM}&lt;/span&gt;, send to &lt;span class=&quot;math&quot;&gt;\\mathcal{S}&lt;/span&gt; tuple &lt;span class=&quot;math&quot;&gt;(\\mathcal{GM},\\text{</code>\`group setup&#x27;&#x27;})</span>.</li>

      <li>UserKeyGen: Similarly, upon receiving <span class="math">(\\mathcal{U}_{i},\\text{\`\`keygen&#x27;&#x27;})</span> from <span class="math">\\mathcal{U}_{i}</span> inform <span class="math">\\mathcal{S}</span>.</li>

      <li>Join: Upon receiving <span class="math">(\\mathcal{U}_{i},\\text{\`\`enroll&#x27;&#x27;})</span> from <span class="math">\\mathcal{U}_{i}</span>, ask the group manager <span class="math">\\mathcal{GM}</span> if <span class="math">\\mathcal{U}_{i}</span> may join the group. The <span class="math">\\mathcal{GM}</span> responds with <span class="math">res_{i}\\in\\{0,1\\}</span>. Record the pair <span class="math">(\\mathcal{U}_{i},res_{i})</span> in database <span class="math">D</span> and return <span class="math">res_{i}</span> to <span class="math">\\mathcal{U}_{i}</span>. Additionally, if the group manager is corrupted, then register a special user corrupt-<span class="math">\\mathcal{GM}</span>.</li>

      <li>GroupSign: Upon receiving <span class="math">(\\mathcal{U}_{i},\\text{\`\`sign&#x27;&#x27;},m)</span>, where <span class="math">m</span> is an arbitrary string, check that <span class="math">\\mathcal{U}_{i}</span> is a valid member of the group by checking that the entry for <span class="math">\\mathcal{U}_{i}</span> in <span class="math">D</span> has <span class="math">res_{i}=1</span>. If not, deny the command. Otherwise, tell the simulator <span class="math">\\mathcal{S}</span> that GroupSign has been envoked on message <span class="math">m</span>. If the <span class="math">\\mathcal{GM}</span> is corrupted, also tell the simulator the identity <span class="math">\\mathcal{U}_{i}</span>. Ask <span class="math">\\mathcal{S}</span> for a signature index <span class="math">id</span>. Record the entry <span class="math">(\\mathcal{U}_{i},m,id)</span> in database <span class="math">L</span> and return the value <span class="math">id</span> to <span class="math">\\mathcal{U}_{i}</span>.</li>

      <li>GroupVerify: Upon receiving <span class="math">(\\mathcal{U}_{i},\\text{\`\`verify&#x27;&#x27;},m,id)</span> from <span class="math">\\mathcal{U}_{i}</span> (or <span class="math">\\mathcal{GM}</span>), search database <span class="math">L</span> for an entry containing message <span class="math">m</span>, and if one exists, return 1. Otherwise, return 0.</li>

      <li>Open: This ideal operation combines both the Open and VerifyOpen cryptographic protocols. Upon receiving <span class="math">(\\mathcal{U}_{i},\\text{\`\`open&#x27;&#x27;},m,id)</span> from <span class="math">\\mathcal{U}_{i}</span>, search database <span class="math">L</span> for an entry <span class="math">(\\mathcal{U}_{j},m,id)</span> for any <span class="math">\\mathcal{U}_{j}</span>. Ask <span class="math">\\mathcal{GM}</span> if it will allow <span class="math">\\mathcal{F}_{gs}</span> to open <span class="math">id</span> for user <span class="math">\\mathcal{U}_{i}</span>. If <span class="math">\\mathcal{GM}</span> agrees and <span class="math">\\mathcal{U}_{j}\\neq\\text{corrupt-}\\mathcal{GM}</span>, then output the identity <span class="math">\\mathcal{U}_{j}</span>. Otherwise, output <span class="math">\\bot</span>.</li>

    </ul>

    <p class="text-gray-300">Let us provide some intuition for understanding this model. Informally, the properties that we capture are unforgeability, anonymity, and exculpability. This definition is general enough to capture unforgeability under adaptive chosen message attack <em>[34]</em> without <em>requiring</em> schemes to be <em>strongly</em> unforgeable <em>[2]</em>. In a strongly unforgeable scheme, a new signature on a previously signed message is considered a forgery; while in the standard notion, a forgery must be on a new message.</p>

    <p class="text-gray-300">The definition also captures the important exculpability property (i.e., even a rogue group manager cannot frame an honest user). Indeed, the environment <span class="math">\\mathcal{Z}</span> may instruct a user to sign any messages of its choosing and may interact freely with the adversary <span class="math">\\mathcal{A}</span>. Our model, however, enforces that unless an honest user <span class="math">\\mathcal{U}_{i}</span> requested a signature on <span class="math">m</span> (i.e., sent <span class="math">(\\text{\`\`sign&#x27;&#x27;},m)</span> to <span class="math">\\mathcal{F}_{gs}</span>), then for all values of <span class="math">id</span>, the Open command on <span class="math">(\\mathcal{U}_{i},m,id)</span> will return <span class="math">\\bot</span>.</p>

    <p class="text-gray-300">Furthermore, there is a strong anonymity guarantee for a user: unless the group manager is corrupted, the users remain anonymous. When the group manager is honest, the simulator must create signatures for <span class="math">\\mathcal{A}</span> knowing only the message contents, but not the identity of the honest user.</p>

    <p class="text-gray-300">Finally, the definition ensures that, whenever the group manager is honest, he will be able to open all group signatures. During the Open command, <span class="math">\\mathcal{F}_{gs}</span> only asks <span class="math">\\mathcal{S}</span> for permission to execute the opening if the group manager is corrupted. Thus, if a user honestly runs the verification algorithm and accepts a signature as valid, then this user may be confident that an honest <span class="math">\\mathcal{GM}</span> will later be able to open it, reveal the identity of the original signer, and prove this to the user.</p>

    <p class="text-gray-300">The above definition does not define membership revocation. However, it is not difficult to extend <span class="math">\\mathcal{F}_{gs}</span> to address revocation, and we plan to do so in the full version of the paper.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">It is not hard to see that our definition implies prior many of the guarantees of the property-based definitions (e.g., <em>[9, 11, 36, 35]</em>). Two properties that we do not require are: (1) membership revocation, and (2) anonymity even after exposure of a user secret key (forward anonymity), as in BMW <em>[9]</em>. While of course both of these properties could be added easily to the model, our scheme does not statisfy them. Note, however, that our definition (and scheme) does provide anonymity to (honest) users, i.e., users of which the adversary is not privy of their secret keys. Finally, notice that our definition implies CCA anonymity, i.e., an anonymity property based definition where the adversary is allowed to query the open oracle even after having been presented the challenge signature. This is in contrast to BMW model (and to the Boyen-Waters group signature scheme) which provide only CPA anonymity, i.e., where the adversary is no longer allowed access to the open oracle after seeing the challenge signature.</p>

    <h2 id="sec-7" class="text-2xl font-bold">3 Preliminaries and Complexity Assumptions</h2>

    <p class="text-gray-300">Notation: The notation <span class="math">G=\\langle g\\rangle</span> means that <span class="math">g</span> generates the group <span class="math">G</span>.</p>

    <p class="text-gray-300">Pairings: Let <span class="math">\\mathsf{BilinearSetup}</span> be an algorithm that, on input the security parameter <span class="math">1^{k}</span>, outputs the parameters for a pairing as <span class="math">\\gamma=(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},g,\\tilde{g})</span>, where <span class="math">\\mathbb{G}_{1}=\\langle g\\rangle</span> and <span class="math">\\mathbb{G}_{2}=\\langle\\tilde{g}\\rangle</span>. We follow the notation of Boneh, Lynn, and Shacham <em>[14]</em>. Let <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span>, and <span class="math">\\mathbb{G}_{T}</span> all be (multiplicative) groups of prime order <span class="math">p=\\Theta(2^{k})</span>, where each element of each group has a unique binary representation. Furthermore, let <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\rightarrow\\mathbb{G}_{T}</span> be an efficient pairing, i.e., a mapping with the following properties: (Bilinearity) for all <span class="math">g\\in\\mathbb{G}_{1}</span>, <span class="math">\\tilde{g}\\in\\mathbb{G}_{2}</span>, and <span class="math">a,b\\in\\mathbb{Z}_{p}</span>, <span class="math">e(g^{a},\\tilde{g}^{b})=e(g,\\tilde{g})^{ab}</span>; and (Non-degeneracy) if <span class="math">g</span> is a generator of <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\tilde{g}</span> is a generator of <span class="math">\\mathbb{G}_{2}</span>, then <span class="math">e(g,\\tilde{g})</span> generates <span class="math">\\mathbb{G}_{T}</span>.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">3.1 Complexity Assumptions</h3>

    <p class="text-gray-300">The security of our construction in Section §5 is based on the following assumptions about pairing groups. In Appendix §D, we provide generic group proofs for EDH and Strong SXDH. A generic group proof for Strong LRSW was previously given in <em>[3]</em>.</p>

    <p class="text-gray-300">Two criticisms could be made of these assumptions. The first could be that they are closely related to specific security properties of the scheme. With regards to this, we point out that even if we were to assume a specific property, such as unforgeability (which we don’t do), security in our model would not follow. Indeed, it is non-trivial to show that our assumptions imply that our scheme realizes our ideal functionality. We also point out that the generic group proofs of these assumptions are highly non-trivial and required new techniques, which may be useful elsewhere.</p>

    <p class="text-gray-300">A second criticism could be that the assumptions are interactive and thus not black-box falsifiable <em>[39]</em>. However, we believe that our provided generic-model hardness proofs show that these assumptions are reasonable: Violating them would result in the design of elliptic curve algorithms with better than generic efficiency, a major cryptographic breakthrough with likely wider ramifications. In addition, our proofs provide estimates for the key sizes required for particular security levels, making our security assumptions indeed very concrete: The resulting <span class="math">\\Omega(p^{1/3})</span>-generic security of our interactive assumptions (for elliptic curve subgroups of order <span class="math">p</span>) puts them on a similar footing with related falsifiable assumptions, such as the <span class="math">q</span>-Strong Diffie-Hellman assumption <em>[24]</em>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{BilinearSetup}(1^{k})\\rightarrow(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},g,\\tilde{g})</span>, where <span class="math">\\mathbb{G}_{1}=\\langle g\\rangle</span> and <span class="math">\\mathbb{G}_{2}=\\langle\\tilde{g}\\rangle</span>, be public.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Assumption 1 (Symmetric External Diffie-Hellman (SXDH) <em>[6, 3, 30]</em>)</h6>

    <p class="text-gray-300">The Decisional Diffie-Hellman (DDH) problem is hard in both <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>. This implies that there do <em>not</em> exist efficiently computable isomorphisms <span class="math">\\psi:\\mathbb{G}_{1}\\rightarrow\\mathbb{G}_{2}</span> or <span class="math">\\psi^{\\prime}:\\mathbb{G}_{2}\\rightarrow\\mathbb{G}_{1}</span>.</p>

    <p class="text-gray-300">Note that SXDH also subsumes a traditional Co-Gap assumption, i.e., the Co-CDH problem <em>[14]</em> is hard in the pairing groups: Given <span class="math">(g,\\tilde{g},g^{x},\\tilde{g}^{y})</span>, it is hard to compute <span class="math">\\tilde{g}^{xy}</span> or <span class="math">g^{xy}</span>.</p>

    <p class="text-gray-300">Good candidates for pairing groups where SXDH is hard are certain MNT curve implementations where no efficient isomorphisms between <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> are known <em>[6, 3, 47, 32, 30]</em>. The asymmetric version of this assumption, simply called XDH, only requires that DDH be hard in <span class="math">\\mathbb{G}_{1}</span> <em>[29, 45, 38, 13, 6]</em>.</p>

    <p class="text-gray-300">The LRSW assumption is a discrete-logarithm assumption introduced in 1999 by Lysyanskaya et al. <em>[37]</em> and used in many subsequent works. Recently, a stronger form of the LRSW assumption which implies the SXDH assumption, called Strong LRSW, was introduced by Ateniese et al. <em>[3]</em>.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Assumption 2 (Strong LRSW <em>[3]</em>)</h6>

    <p class="text-gray-300">Let <span class="math">X,Y\\in\\mathbb{G}_{2},X=\\tilde{g}^{x},Y=\\tilde{g}^{y}.</span> Let <span class="math">O_{X,Y}(\\cdot)</span> be an oracle that takes as input a value <span class="math">m\\in\\mathbb{Z}_{p}^{<em>}</span> and outputs an LRSW-tuple <span class="math">(a,a^{x},a^{y+yxm})</span> for a random <span class="math">a\\in\\mathbb{G}_{1}</span>. Then for all probabilistic polynomial-time adversaries <span class="math">\\mathcal{A}^{(\\cdot)}</span> and all <span class="math">m\\in\\mathbb{Z}_{p}^{</em>}</span>.</p>

    <p class="text-gray-300"><span class="math">\\Pr[x\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}\\mathbb{Z}_{p},y\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}\\mathbb{Z}_{p},X=\\tilde{g}^{x},Y=\\tilde{g}^{y},(a_{1},a_{2},a_{3},a_{4},a_{5})\\leftarrow\\mathcal{A}^{O_{X,Y}}(g,\\tilde{g},X,Y):</span> <span class="math">m\\not\\in Q\\ \\wedge\\ a_{1}\\in\\mathbb{G}_{1}\\ \\wedge\\ a_{2}=a_{1}^{x}\\ \\wedge\\ a_{3}=a_{1}^{y+yxm}\\ \\wedge\\ a_{4}=a_{1}^{m}\\ \\wedge\\ a_{5}=a_{1}^{mx}]&lt;1/\\mathrm{poly}(k),</span></p>

    <p class="text-gray-300">where <span class="math">Q</span> is the set of queries <span class="math">\\mathcal{A}</span> makes to <span class="math">O_{X,Y}(\\cdot)</span>.</p>

    <p class="text-gray-300">The <span class="math">q</span>-Strong Diffie-Hellman (<span class="math">q</span>-SDH) assumption, as introduced by Boneh and Boyen <em>[12]</em>, states that: for all probabilistic polynomial-time adversaries <span class="math">\\mathcal{A}</span>, and all <span class="math">c\\in\\mathbb{Z}_{p}^{*}</span>:</p>

    <p class="text-gray-300"><span class="math">\\Pr[x\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}\\mathbb{Z}_{p}:\\mathcal{A}(g,\\tilde{g},g^{x},\\ldots,g^{(x^{q})},\\tilde{g}^{x},\\ldots,\\tilde{g}^{(x^{q})})=(c,\\tilde{g}^{1/(x+c)})]&lt;1/\\mathrm{poly}(k).</span></p>

    <p class="text-gray-300">We make an interactive version of this assumption. As we mentioned in the introduction, our efficiency analysis takes into account Cheon’s recent results <em>[24]</em> on <span class="math">q</span>-SDH.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Assumption 3 (Extended Diffie-Hellman (EDH))</h6>

    <p class="text-gray-300">Let <span class="math">x\\in\\mathbb{Z}_{p}^{<em>}</span>. Let oracle <span class="math">O_{x}(\\cdot)</span> take input <span class="math">c_{i}\\in\\mathbb{Z}_{p}^{</em>}</span> and produce output <span class="math">(g^{v_{i}},\\tilde{g}^{1/(x+v_{i})},\\tilde{g}^{1/(v_{i}+c_{i})})</span>, for a random <span class="math">v_{i}\\in\\mathbb{Z}_{p}^{<em>}</span>. For all probabilistic polynomial-time adversaries <span class="math">\\mathcal{A}</span>, all <span class="math">v,c\\in\\mathbb{Z}_{p}^{</em>}</span> and all <span class="math">a\\in\\mathbb{G}_{1}</span> such that <span class="math">a\\neq 1</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr[x\\stackrel{{\\scriptstyle R}}{{\\leftarrow}}\\mathbb{Z}_{p}:\\mathcal{A}^{O_{x}}(g,g^{x},\\tilde{g},\\tilde{g}^{x})=(c,a,a^{x},a^{v},\\tilde{g}^{1/(x+v)},\\tilde{g}^{1/(v+c)})\\wedge c\\not\\in Q]&lt;1/\\mathrm{poly}(k)</span></p>

    <p class="text-gray-300">where <span class="math">Q</span> is the set of queries <span class="math">\\mathcal{A}</span> makes to oracle <span class="math">O_{x}(\\cdot)</span>.</p>

    <p class="text-gray-300">The assumptions discussed so far are underlying the unforgeability of our group signature scheme. Its anonymity is based on a single assumption: that SXDH holds even when the adversary is given oracle access to additional information about the DDH instance.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Assumption 4 (Strong SXDH)</h6>

    <p class="text-gray-300">Let <span class="math">g\\in\\mathbb{G}_{1}</span>, <span class="math">\\tilde{g}\\in\\mathbb{G}_{2}</span>, and <span class="math">x\\in\\mathbb{Z}_{p}</span>. Let <span class="math">O_{x}(\\cdot)</span> be an oracle that takes as input <span class="math">m\\in\\mathbb{Z}_{p}^{<em>}</span> and outputs <span class="math">(g^{v},\\tilde{g}^{1/(x+v)},\\tilde{g}^{1/(v+m)})</span> for a random <span class="math">v\\in\\mathbb{Z}_{p}^{</em>}</span>. Let <span class="math">Q_{y}(\\cdot)</span> be an oracle that takes the same input type and outputs <span class="math">(g^{r},g^{ry},g^{rv},\\tilde{g}^{1/(y+v)},\\tilde{g}^{1/(v+m)})</span> for a random <span class="math">r,v\\in\\mathbb{Z}_{p}^{*}</span>. Then for all probabilistic polynomial-time adversaries <span class="math">\\mathcal{A}^{(\\cdot)}</span>, and for randomly chosen <span class="math">g\\in\\mathbb{G}_{1}</span>, <span class="math">\\tilde{g}\\in\\mathbb{G}_{2}</span>, and <span class="math">x,y\\in\\mathbb{Z}_{p}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\mathcal{A}^{O_{x},Q_{x}}(g,g^{x},\\tilde{g})=1]-\\Pr[\\mathcal{A}^{O_{x},Q_{y}}(g,g^{x},\\tilde{g})=1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><1/\\mathrm{poly}(k).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Theorem D.3, we show that Strong SXDH also has the same complexity as <span class="math">q</span>-SDH for generic groups.</p>

    <h2 id="sec-13" class="text-2xl font-bold">4 Key Building Blocks: CL^{+} and BB^{+} Signatures</h2>

    <p class="text-gray-300">As mentioned in Section §1, our group signature scheme is built out of two standard signature schemes secure without random oracles. We review the important details now.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">4.1 Camenisch-Lysyanskaya Signatures</h3>

    <p class="text-gray-300">Recall the basic Pedersen commitment scheme <em>[41]</em>, in which the public parameters are a group <span class="math">G</span> of prime order <span class="math">p</span>, and two generators <span class="math">g</span> and <span class="math">h</span> of <span class="math">G</span>. To commit to the value <span class="math">m\\in\\mathbb{Z}_{p}</span>, pick a random <span class="math">r\\in\\mathbb{Z}_{p}</span> and set <span class="math">C=\\mathrm{PedCom}(m;r)=g^{m}h^{r}</span>.</p>

    <p class="text-gray-300">The Camenisch-Lysyanskaya (CL) signature scheme is secure without random oracles under the LRSW assumption <em>[19]</em>. CL signatures are also useful, because they support an efficient two-party protocol for obtaining a CL signature on the value (message) committed to in a Pedersen commitment. The common inputs are <span class="math">C=\\mathrm{PedCom}(m;r)</span> and the verification key of the signer <span class="math">pk</span>. The signer additionally knows the corresponding signing key <span class="math">sk</span>, while the receiver additionally knows <span class="math">m</span> and <span class="math">r</span>. As a result of this protocol, the receiver obtains the signature <span class="math">\\sigma_{sk}(m)</span>, while the signer does not learn anything about <span class="math">m</span>. For our current purposes, it will not matter how this protocol actually works. Fortunately, a recent extension of the CL signatures by Ateniese et al. <em>[3]</em>, denoted CL^{+}, inherits this protocol.</p>

    <p class="text-gray-300">CL^{+} Signatures. Let the security parameter be <span class="math">1^{k}</span>. The global parameters are the description of a pairing <span class="math">params=(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},g,\\tilde{g})</span>, where <span class="math">\\mathbb{G}_{1}=\\langle g\\rangle</span> and <span class="math">\\mathbb{G}_{2}=\\langle\\tilde{g}\\rangle</span>, obtained by running <span class="math">\\mathsf{BilinearSetup}(1^{k})</span>. Keypairs are of the form <span class="math">pk=(\\tilde{g}^{s},\\tilde{g}^{t})</span> and <span class="math">sk=(s,t)\\in\\mathbb{Z}_{p}^{2}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Signing: Choose random <span class="math">a\\in\\mathbb{G}_{1}</span>, output <span class="math">(a,a^{t},a^{s+stm},a^{m},a^{mt})</span> as the signature on hidden message <span class="math">m\\in\\mathbb{Z}_{p}^{*}</span>.</li>

      <li>Verification: On input a purported signature <span class="math">(A,B,C,D,E)</span> accept that <span class="math">\\sigma</span> authenticates the message hidden as <span class="math">\\log_{A}(D)</span> if and only if: (1) <span class="math">e(B,\\tilde{g})=e(A,\\tilde{g}^{t})</span>, (2) <span class="math">e(D,\\tilde{g}^{t})=e(E,\\tilde{g})</span>, and (3) <span class="math">e(C,\\tilde{g})=e(A,\\tilde{g}^{s})e(E,\\tilde{g}^{s})</span>.</li>

      <li>Re-Randomization: On input a signature <span class="math">(A,B,C,D,E)</span>, choose a random <span class="math">r\\in\\mathbb{Z}_{p}^{*}</span> and output <span class="math">(A^{r},B^{r},C^{r},D^{r},E^{r})</span>.</li>

    </ul>

    <p class="text-gray-300">CL^{+} signatures are secure assuming SXDH and Strong LRSW. As previously observed in <em>[3]</em>, when CL^{+} signatures are set in pairing groups where SXDH is hard, this re-randomization is unlinkable. We formally argue this second point in Lemma A.2.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">4.2 Boneh-Boyen Signatures</h3>

    <p class="text-gray-300">Recall the weak Boneh-Boyen (BB) signature scheme <em>[12]</em>. Let the security parameter be <span class="math">1^{k}</span>. The global parameters are the description of a pairing <span class="math">params=(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T})</span> obtained by running <span class="math">\\mathsf{BilinearSetup}(1^{k})</span> (here, we ignore the generators output by <span class="math">\\mathsf{BilinearSetup}</span>). Keypairs are of the form <span class="math">pk=(g,g^{sk},\\tilde{g})</span> and <span class="math">sk\\in\\mathbb{Z}_{p}^{<em>}</span>, for random generators <span class="math">g\\in\\mathbb{G}_{1}</span> and <span class="math">\\tilde{g}\\in\\mathbb{G}_{2}</span>. To sign a message <span class="math">m\\in\\mathbb{Z}_{p}^{</em>}</span>, output the signature <span class="math">\\tilde{g}^{1/(sk+m)}</span>. To verify signature <span class="math">\\sigma</span>, accept if and only if <span class="math">e(\\sigma,g^{sk}g^{m})=e(g,\\tilde{g})</span>. Note that in this work we reverse the roles of <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> from the original description in <em>[12]</em>. As in other implementation of pairing-based schemes where distortion maps are not available, one chooses the role of each pairing group to maximize the efficiency of one’s protocol.</p>

    <p class="text-gray-300">This scheme was proven unforgeable only against weak chosen-message attack under the <span class="math">q</span>-SDH assumption <em>[12]</em>, where the adversary must submit all of his signature queries in advance of the public key</p>

    <p class="text-gray-300">generation. Boneh and Boyen gave one method of modifying this weak scheme into an adaptively-secure one <em>[12]</em>. We provide a second method, which is more suited to our purposes.</p>

    <p class="text-gray-300">BB^{+} Signatures. The intuition here is that to issue a signature on a message <span class="math">m</span>, a weak BB signature under <span class="math">sk</span> is issued on a one-time signing key <span class="math">v</span>, and then another weak BB signature under <span class="math">v</span> is issued on message <span class="math">m</span>. The additional randomness <span class="math">v</span> allows to prove adaptive security.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key generation: Same as before. (Although, now the same bases may be used for all keys.)</li>

      <li>Signing: On input a secret key <span class="math">sk</span> and a message <span class="math">m\\in\\mathbb{Z}_{p}^{<em>}</span>, select a random <span class="math">r\\in\\mathbb{Z}_{p}^{</em>}</span>, and output the signature <span class="math">(g^{r},\\tilde{g}^{1/(sk+r)},\\tilde{g}^{1/(r+m)})</span>.</li>

      <li>Verification: On input a public key <span class="math">(g,g^{sk},\\tilde{g})</span>, a message <span class="math">m</span>, and a purported signature <span class="math">(A,B,C)</span>, accept if and only if: (1) <span class="math">e(g^{sk}A,B)=e(g,\\tilde{g})</span> and (2) <span class="math">e(Ag^{m},C)=e(g,\\tilde{g})</span>.</li>

    </ul>

    <h6 id="sec-16" class="text-base font-medium mt-4">Lemma 4.1</h6>

    <p class="text-gray-300">The BB^{+} signature scheme is existentially unforgeable under adaptive chosen-message attack under the EDH assumption.</p>

    <h2 id="sec-17" class="text-2xl font-bold">5 Our Basic Group Signature Construction</h2>

    <p class="text-gray-300">Notation: BB^{+} and CL^{+}, respectively, denote our Section §4 modifications of the Boneh-Boyen <em>[12]</em> and Camenisch-Lysyanskaya <em>[19]</em> signature schemes. When we write <span class="math">A=\\mathit{Sign}_{GSK}^{CL+}(m;a)</span>, we mean that <span class="math">A</span> is a CL^{+} signature under key <span class="math">GSK</span> on message <span class="math">m</span> using base <span class="math">a</span>; that is, <span class="math">A=(a,a^{t},a^{s+stm},a^{m},a^{mt})</span> for <span class="math">GSK=(s,t)</span>. Similarly, when we write <span class="math">A=\\mathit{Sign}_{sk}^{BB+}(m;g,\\tilde{g})</span>, we mean that <span class="math">A</span> is a BB^{+} signature under key <span class="math">sk</span> on message <span class="math">m</span> using bases <span class="math">(g,\\tilde{g})</span>; that is, <span class="math">A=(g^{v},\\tilde{g}^{1/(sk+v)},\\tilde{g}^{1/(v+m)})</span> for some <span class="math">v\\in\\mathbb{Z}_{p}^{*}</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{BilinearSetup}(1^{k})\\rightarrow\\mathit{params}=(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},g,\\tilde{g})</span>, where <span class="math">\\mathbb{G}_{1}=\\langle g\\rangle</span> and <span class="math">\\mathbb{G}_{2}=\\langle\\tilde{g}\\rangle</span>.</p>

    <p class="text-gray-300">GroupSetup<span class="math">(1^{k},\\mathit{params})</span>: The group manager establishes the public parameters for the Pedersen commitment scheme <em>[41]</em> and adds those to <span class="math">\\mathit{params}</span>. Then, the group manager executes <span class="math">\\mathit{Gen}^{CL+}(1^{k},\\mathit{params})</span> to obtain <span class="math">\\mathit{GPK}=(\\mathit{params},\\mathcal{S}=\\tilde{g}^{s},\\mathcal{T}=\\tilde{g}^{t})</span> and <span class="math">\\mathit{GSK}=(s,t)</span>.</p>

    <p class="text-gray-300">UserKeyGen<span class="math">(1^{k},\\mathit{params})</span>: Each user <span class="math">\\mathcal{U}</span> selects random <span class="math">sk\\in\\mathbb{Z}_{p}^{*}</span> and random <span class="math">h\\in\\mathbb{G}_{1}</span>, and outputs a public key <span class="math">pk=(h,e(h,\\tilde{g})^{sk})</span>.</p>

    <p class="text-gray-300">Join<span class="math">(\\mathcal{U}_{i}(GPK,sk_{i}),\\mathcal{GM}(pk_{i},GSK))</span>: In this interactive protocol, the user’s inputs are her secret key <span class="math">sk_{i}</span> and the public key of the group manager <span class="math">GPK</span>. Likewise, the group manager receives as input <span class="math">GSK</span> and <span class="math">pk_{i}</span>. They interact as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{U}_{i}</span> submits her public key <span class="math">pk_{i}=(p_{1},p_{2})</span> and tracing information <span class="math">Q_{i}=\\tilde{g}^{sk_{i}}</span> to <span class="math">\\mathcal{GM}</span>. If <span class="math">e(p_{1},Q_{i})\\neq p_{2}</span> or <span class="math">sk_{i}</span> was already in <span class="math">D</span>, <span class="math">\\mathcal{GM}</span> aborts. Else, <span class="math">\\mathcal{GM}</span> enters <span class="math">Q_{i}</span> in database <span class="math">D</span>.</li>

      <li>The user sends a commitment <span class="math">A=\\mathrm{PedCom}(sk_{i})</span> to <span class="math">\\mathcal{GM}</span>. The user and <span class="math">\\mathcal{GM}</span> run the CL protocol (see Section 4.1) for obtaining <span class="math">\\mathcal{GM}</span>’s signature on the committed value contained in commitment <span class="math">A</span>. <span class="math">\\mathcal{GM}</span> picks a random <span class="math">r\\in\\mathbb{Z}_{p}^{*}</span> and sets <span class="math">f_{1}=g^{r}</span>. Then, <span class="math">\\mathcal{GM}</span> computes <span class="math">\\mathit{Sign}_{GSK}^{CL+}(sk_{i};f_{1})=(f_{2},f_{3})</span> and sends all three values to the user. If the CL signature <span class="math">(f_{1},f_{2},f_{3})</span> does not verify for message <span class="math">sk_{i}</span>, the user aborts.</li>

      <li>The user provides a zero-knowledge proof that the committed value <span class="math">sk_{i}</span> contained in commitment <span class="math">A</span> is consistent with the public key <span class="math">pk_{i}</span> and a zero-knowledge proof of knowledge of <span class="math">sk_{i}</span> using any proof technique that is extractable. (For more on such proofs, see Appendix B.)</li>

      <li>The group manager provides an extractable zero-knowledge proof of <span class="math">\\mathit{GSK}=(s,t)</span>.</li>

      <li>Next, the user locally computes the values <span class="math">f_{4}=f_{1}^{sk_{i}}</span> and <span class="math">f_{5}=f_{2}^{sk_{i}}</span>.</li>

    </ol>

    <p class="text-gray-300">##</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At the end of this protocol, the user obtains the following membership certificate:</li>

    </ol>

    <p class="text-gray-300"><span class="math">C_{i}=(f_{1},\\ldots,f_{5})=(a,a^{t},a^{s+st(sk_{i})},a^{sk_{i}},a^{(sk_{i})t}).</span></p>

    <p class="text-gray-300">GroupSign<span class="math">(sk_{i},C_{i},m)</span>: A user with secret key <span class="math">sk_{i}</span> and membership certificate <span class="math">C_{i}=(f_{1},\\ldots,f_{5})</span> may sign a message <span class="math">m\\in\\mathbb{Z}_{p}^{\\star}</span> as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Re-randomize <span class="math">C_{i}</span> using a random <span class="math">r\\in\\mathbb{Z}_{p}</span>, i.e., compute <span class="math">(a_{1},\\ldots,a_{5})=(f_{1}^{r},\\ldots,f_{5}^{r})</span>.</li>

      <li>Compute <span class="math">Sign_{sk_{i}}^{BB+}(m;a_{5},\\tilde{g})=(a_{6},a_{7},a_{8})</span>.</li>

      <li>Output the signature <span class="math">(a_{1},\\ldots,a_{8})</span> of the form <span class="math">(b</span>, <span class="math">b^{t}</span>, <span class="math">b^{s+st(sk_{i})}</span>, <span class="math">b^{sk_{i}}</span>, <span class="math">b^{(sk_{i})t}</span>, <span class="math">b^{v}</span>, <span class="math">\\tilde{g}^{1/(sk_{i}+v)}</span>, <span class="math">\\tilde{g}^{1/(v+m)})</span>.</li>

    </ol>

    <p class="text-gray-300">GroupVerify<span class="math">(GPK,m,\\sigma)</span>: To verify that <span class="math">\\sigma=(a_{1},\\ldots,a_{8})</span> is a group signature on <span class="math">m</span>, do:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that <span class="math">(a_{1},a_{2},a_{3},a_{4},a_{5})</span> is a valid CL^{+} signature for public key <span class="math">GPK</span> where the hidden message is the exponent of <span class="math">a_{4}</span> (base <span class="math">a_{1}</span>). Specifically, verify that: (1) <span class="math">e(a_{1},\\mathcal{T})=e(a_{2},\\tilde{g})</span>, (2) <span class="math">e(a_{4},\\mathcal{T})=e(a_{5},\\tilde{g})</span>, and (3) <span class="math">e(a_{1}a_{5},\\mathcal{S})=e(a_{3},\\tilde{g})</span>.</li>

      <li>Check that <span class="math">(a_{6},a_{7},a_{8})</span> is a valid BB^{+} signature for public key <span class="math">(a_{1},a_{4},\\tilde{g})</span> on message <span class="math">m</span>. Specifically, verify that: (1) <span class="math">e(a_{4}a_{6},a_{7})=e(a_{1},\\tilde{g})</span> and (2) <span class="math">e(a_{6}a_{1}^{m},a_{8})=e(a_{1},\\tilde{g})</span>.</li>

      <li>If both checks pass, accept; otherwise, reject.</li>

    </ol>

    <p class="text-gray-300">Open<span class="math">(GSK,m,\\sigma)</span>: On input any valid signature <span class="math">\\sigma=(a_{1},\\ldots,a_{8})</span> and tracing database <span class="math">D</span>, <span class="math">\\mathcal{GM}</span> may run the following algorithm to identify the signer. For each entry <span class="math">Q_{i}\\in D</span>, the group manager checks whether <span class="math">e(a_{4},\\tilde{g})=e(a_{1},Q_{i})</span>. If a match is found, then <span class="math">\\mathcal{GM}</span> outputs <span class="math">\\mathcal{U}_{i}</span> as the identity of the original signer.</p>

    <p class="text-gray-300">VerifyOpen<span class="math">(\\mathcal{GM}(GSK,m,\\sigma,pk_{i},Q_{i}),\\mathcal{V}(GPK,m,\\sigma,pk_{i}))</span>: First, <span class="math">\\mathcal{GM}</span> checks that <span class="math">\\sigma</span> is a valid group signature; that is, GroupVerify<span class="math">(GPK,\\sigma,m)=1</span>. Next, <span class="math">\\mathcal{GM}</span> checks that <span class="math">\\mathcal{U}_{i}</span> is responsible for creating <span class="math">\\sigma</span>; that is, using tracing information <span class="math">Q_{i}=\\tilde{g}^{sk_{i}}</span> from database <span class="math">D</span> and <span class="math">pk_{i}=(p_{1},p_{2})</span>, test that <span class="math">e(p_{1},Q_{i})=p_{2}</span>. If both of these conditions hold, then <span class="math">\\mathcal{GM}</span> proceeds to convince a verifier that <span class="math">\\mathcal{U}_{i}</span> was responsible for <span class="math">\\sigma</span>. We call this step anonymity revocation. Here, the <span class="math">\\mathcal{GM}</span> provides a zero-knowledge proof of knowledge of a value <span class="math">\\alpha\\in\\mathbb{G}_{2}</span> (i.e., the tracing information for <span class="math">\\mathcal{U}_{i}</span>) such that <span class="math">e(p_{1},\\alpha)=p_{2}</span> and <span class="math">e(a_{1},\\alpha)=e(a_{4},\\tilde{g})</span> <em>[1]</em>.</p>

    <p class="text-gray-300">The revocation described above revokes the anonymity of a particular signature, however, the <span class="math">\\mathcal{GM}</span> could instead revoke the anonymity of all signatures belonging to user <span class="math">\\mathcal{U}_{i}</span> by publishing the tracing information <span class="math">Q_{i}</span>. Then anyone can verify that the user with public key <span class="math">pk=(p_{1},p_{2})</span> must be responsible by checking that: (1) <span class="math">e(p_{1},Q_{i})=p_{2}</span>, and (2) <span class="math">e(a_{1},Q_{i})=e(a_{4},\\tilde{g})</span>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Theorem 5.1</h6>

    <p class="text-gray-300">In the plain model, the above group signature scheme realizes <span class="math">\\mathcal{F}_{gs}</span> from Section §2 under the Strong LRSW, the EDH, and the Strong SXDH assumptions.</p>

    <p class="text-gray-300">Proof of Theorem 5.1 appears in Appendix A.</p>

    <h2 id="sec-19" class="text-2xl font-bold">6 Opening Signatures in Sublinear Time</h2>

    <p class="text-gray-300">The basic Open algorithm described in Section §5 takes <span class="math">O(n\\cdot k)</span> for a signing group of <span class="math">n</span> members and security parameter <span class="math">k</span>. Practically, this precludes this scheme from being used for many applications with large groups. We provide several options to remedy this situation in Appendix C.</p>

    <p class="text-gray-300">First, we present an Open algorithm with complexity <span class="math">O(\\sqrt{n}\\cdot k)</span> which can be extended to one with complexity <span class="math">O((\\log n)\\cdot k)</span> at the cost of group signatures becoming of size <span class="math">O((\\log n)\\cdot k)</span>. This improvement requires no additional assumptions, but does add two elements in <span class="math">\\mathbb{G}_{1}</span> (resp. <span class="math">\\log n</span> elements) to the signature length. Next, we present a <span class="math">O((\\log n)+k)</span> Open algorithm. This increases the basic signature by three elements in <span class="math">\\mathbb{G}_{1}</span> and requires a slightly different anonymity assumption.</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] B. Adida, S. Hohenberger, and R. L. Rivest. Ad-Hoc-Group Signatures from Hijacked Keypairs, 2005. At http://theory.lcs.mit.edu/~rivest/publications.</li>

      <li>[2] J. H. An, Y. Dodis, and T. Rabin. On the security of joint signature and encryption. In EUROCRYPT, volume 2332 of LNCS, pages 83–107, 2002.</li>

      <li>[3] G. Ateniese, J. Camenisch, and B. de Medeiros. Untraceable RFID tags via insubvertible encryption. In ACM CCS, pages 92–101, 2005.</li>

      <li>[4] G. Ateniese, J. Camenisch, M. Joye, and G. Tsudik. A practical and provably secure coalition-resistant group signature scheme. In CRYPTO, volume 1880 of LNCS, pages 255–270, 2000.</li>

      <li>[5] G. Ateniese and G. Tsudik. Some open issues and new directions in group signatures. In Financial Cryptography, volume 1648 of LNCS, pages 196–211, 1999.</li>

      <li>[6] L. Ballard, M. Green, B. de Medeiros, and F. Monrose. Correlation-resistant storage. Technical Report TR-SP-BGMM-050705, Johns Hopkins University, CS Dept, 2005. http://spar.isi.jhu.edu/~mgreen/correlation.pdf.</li>

      <li>[7] P. S. L. M. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order, 2005. Cryptology ePrint Archive: 2005/133.</li>

      <li>[8] D. Beaver. Secure multi-party protocols and zero-knowledge proof systems tolerating a faulty minority. Journal of Cryptology, 4:75–122, 1991.</li>

      <li>[9] M. Bellare, D. Micciancio, and B. Warinschi. Foundations of group signatures: Formal definition, simplified requirements and a construction based on general assumptions. In EUROCRYPT, volume 2656 of LNCS, pages 614–629, 2003.</li>

      <li>[10] M. Bellare and A. Palacio. GQ and Schnorr Identification Schemes: Proofs of Security against Impersonation under Active and Concurrent Attacks. In CRYPTO, volume 2442 of LNCS, pages 162–177, 2002.</li>

      <li>[11] M. Bellare, H. Shi, and C. Zhang. Foundations of group signatures: The case of dynamic groups. In CT-RSA, volume 3376 of LNCS, pages 136–153, 2005.</li>

      <li>[12] D. Boneh and X. Boyen. Short signatures without random oracles. In EUROCRYPT 2004, volume 3027 of LNCS, pages 56–73, 2004.</li>

      <li>[13] D. Boneh, X. Boyen, and H. Shacham. Short group signatures. In CRYPTO, volume 3152 of LNCS, pages 41–55, 2004.</li>

      <li>[14] D. Boneh, B. Lynn, and H. Shacham. Short signatures from the Weil pairing. In ASIACRYPT, volume 2248 of LNCS, pages 514–532, 2001.</li>

      <li>[15] D. Boneh and H. Shacham. Group signatures with verifier-local revocation. In Proc. of the ACM Conf. on Computer and Communications Security (ACM CSS 2004), pages 168–177. ACM Press, 2004.</li>

      <li>[16] X. Boyen and B. Waters. Compact Group Signatures Without Random Oracles. In EUROCRYPT ’06, volume 4004 of LNCS, pages 427–444, 2006.</li>

      <li>[17] E. Brickell, J. Camenisch, and L. Chen. Direct anonymous attestation. In ACM CCS, pages 132–145, 2004.</li>

      <li>[18] J. Camenisch and I. Damgård. Verifiable encryption, group encryption, and their applications to group signatures and signature sharing schemes. In ASIACRYPT, volume 1976 of LNCS, pages 331–345, 2000.</li>

      <li>[19] J. Camenisch and A. Lysyanskaya. Signature Schemes and Anonymous Credentials from Bilinear Maps. In CRYPTO, volume 3152 of LNCS, pages 56–72, 2004.</li>

      <li>[20] R. Canetti. Studies in Secure Multiparty Computation and Applications. PhD thesis, Weizmann Institute of Science, Rehovot 76100, Israel, June 1995.</li>

      <li>[21] R. Canetti. Security and composition of multi-party cryptographic protocols. Journal of Cryptology, 13(1):143–202, 2000.</li>

      <li>[22] R. Canetti. Universally composable security: A new paradigm for cryptographic protocols. In FOCS, pages 136–145, 2001.</li>

      <li>[23] D. Chaum and E. van Heyst. Group Signatures. In EUROCRYPT, volume 547 of LNCS, pages 257–265, 1991.</li>

      <li>[24] J. H. Cheon. Security Analysis of the Strong Diffie-Hellman Problem. In EUROCRYPT ’06, volume 4004 of LNCS, pages 1–11, 2006.</li>

      <li>[25] I. Damgård. Efficient concurrent zero-knowledge in the auxiliary string model. In EUROCRYPT, volume 1807 of LNCS, pages 418–430, 2000.</li>

    </ul>

    <p class="text-gray-300">[26] A. Datta, A. Derek, J. C. Mitchell, A. Ramanathan, and A. Scedrov. Games and the impossibility of realizable ideal functionality. In TCC, volume 3876 of LNCS, pages 360–379, 2006.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[27] A. W. Dent. Adapting the weaknesses of the random oracle model to the generic group model. In ASIACRYPT ’02, volume 2501 of LNCS, pages 100–109, 2002.</li>

      <li>[28] M. Fischlin. Communication-Efficient Non-Interactive Proofs of Knowledge with Online Extractors. In CRYPTO, pages 152–168, 2005.</li>

      <li>[29] S. D. Galbraith. Supersingular curves in cryptography. In ASIACRYPT, volume 2248 of LNCS, pages 495–513, 2001.</li>

      <li>[30] S. D. Galbraith. Personal communication, August, 2005.</li>

      <li>[31] S. D. Galbraith, K. G. Paterson, and N. P. Smart. Pairings for cryptographers. Technical Report 2006/165, International Association for Cryptological Research, 2006.</li>

      <li>[32] S. D. Galbraith and V. Rotger. Easy decision Diffie-Hellman groups. Journal of Computation and Mathematics, 7:201–218, 2004.</li>

      <li>[33] S. Goldwasser and Y. T. Kalai. On the (In)security of the Fiat-Shamir Paradigm. In FOCS, pages 102–115, 2003.</li>

      <li>[34] S. Goldwasser, S. Micali, and R. Rivest. A digital signature scheme secure against adaptive chosen-message attacks. SIAM J. of Computing, 17(2):281–308, 1988.</li>

      <li>[35] A. Kiayias, Y. Tsiounis, and M. Yung. Traceable signatures. In EUROCRYPT, volume 3027 of LNCS, pages 571–589, 2004.</li>

      <li>[36] A. Kiayias and M. Yung. Group signatures: Provable security, efficient constructions and anonymity from trapdoor-holders, 2004. Cryptology ePrint Archive: 2004/076.</li>

      <li>[37] A. Lysyanskaya, R. L. Rivest, A. Sahai, and S. Wolf. Pseudonym systems. In SAC, volume 1758 of LNCS, pages 184–199, 1999.</li>

      <li>[38] N. McCullagh and P. S. L. M. Barreto. A new two-party identity-based authenticated key agreement. In CT-RSA, volume 3376 of LNCS, pages 262–274, 2004.</li>

      <li>[39] M. Naor. Cryptographic assumptions and challenges. In Proc. Adv. in Cryptology (CRYPTO 2003), volume 2729 of LNCS, pages 96–109. Springer, 2003.</li>

      <li>[40] V. I. Nechaev. Complexity of a determinate algorithm for the discrete logarithm. Mathematical Notes, 55:165–172, 1994.</li>

      <li>[41] T. P. Pedersen. Non-interactive and information-theoretic secure verifiable secret sharing. In CRYPTO, volume 576 of LNCS, pages 129–140, 1991.</li>

      <li>[42] B. Pfitzmann and M. Waidner. Composition and integrity preservation of secure reactive systems. In ACM CCS, pages 245–254, 2000.</li>

      <li>[43] B. Pfitzmann and M. Waidner. A model for asynchronous reactive systems and its application to secure message transmission. In IEEE S&P, pages 184–200, 2001.</li>

      <li>[44] M. Scott. MIRACL library. Indigo Software. http://indigo.ie/~mscott.</li>

      <li>[45] M. Scott. Authenticated ID-based key exchange and remote log-in with simple token and PIN number, 2002. Cryptology ePrint Archive: 2002/164.</li>

      <li>[46] V. Shoup. Lower bounds for discrete logarithms and related problems. In EUROCRYPT, LNCS, pages 256–266, 1997. Update: http://www.shoup.net/papers/.</li>

      <li>[47] E. R. Verheul. Evidence that XTR is more secure than supersingular elliptic curve cryptosystems. In EUROCRYPT, volume 2045 of LNCS, pages 195–210, 2001.</li>

    </ul>

    <h2 id="sec-20" class="text-2xl font-bold">Appendix A Security Proof of Basic Construction</h2>

    <p class="text-gray-300">We now prove Theorem 5.1 on the security of our basic construction.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Our goal is to show that for every adversary <span class="math">\\mathcal{A}</span> and environment <span class="math">\\mathcal{Z}</span>, there exists a simulator <span class="math">\\mathcal{S}</span> such that <span class="math">\\mathcal{Z}</span> cannot distinguish whether it is interacting in the real world with <span class="math">\\mathcal{A}</span> or the ideal world with <span class="math">\\mathcal{S}</span>. The proof is structured in two parts. First, for arbitrary fixed <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{Z}</span>, we describe a simulator <span class="math">\\mathcal{S}</span>. Then, we argue that <span class="math">\\mathcal{S}</span> satisfies our goal.</p>

    <p class="text-gray-300">Recall that the simulator interacts with the ideal functionality <span class="math">\\mathcal{F}_{gs}</span> on behalf of all corrupted parties in the ideal world, and also simulates the real-world adversary <span class="math">\\mathcal{A}</span> towards the environment. <span class="math">\\mathcal{S}</span> is given black-box access to <span class="math">\\mathcal{A}</span>. In our description, <span class="math">\\mathcal{S}</span> will use <span class="math">\\mathcal{A}</span> to simulate conversations with <span class="math">\\mathcal{Z}</span>. Specifically, <span class="math">\\mathcal{S}</span> will directly forward all messages from <span class="math">\\mathcal{A}</span> to <span class="math">\\mathcal{Z}</span> and from <span class="math">\\mathcal{Z}</span> to <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">The simulator will be responsible for handling several different operations within the group signature system. The operations are triggered either by messages from <span class="math">\\mathcal{F}_{gs}</span> to any of the corrupted parties in the ideal system (and thus these messages are sent to <span class="math">\\mathcal{S}</span>) or when <span class="math">\\mathcal{A}</span> wants to send any messages to honest parties. In our description, <span class="math">\\mathcal{S}</span> will simulate the (real-world) honest parties of towards <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">Finally, we assume that when a signature is created, it becomes public information. Likewise, whenever a signature is opened, the corresponding identity is announced to all. (However, each user may still require individual proof from the <span class="math">\\mathcal{GM}</span> that this identity is correct.)</p>

    <p class="text-gray-300">Notation: The simulator <span class="math">\\mathcal{S}</span> may need to behave differently depending on which parties are corrupted. There are two parties of interest: the group manager and a user. We adopt previous notation <em>[17]</em> for this: a capital letter denotes that the corresponding party is not corrupted and a small letter denotes that it is. For example, by “Case (Gu)” we refer to the case where the group manager is honest, but the user is corrupted.</p>

    <p class="text-gray-300">We will refer to a user as <span class="math">\\mathcal{U}_{i}</span> and a user’s public key as <span class="math">pk_{i}</span>. We assume throughout that a party in possession of one of these two identifiers is also in possession of the other.</p>

    <p class="text-gray-300">We now describe how the simulator <span class="math">\\mathcal{S}</span> behaves. Intuitively, when the group manager is corrupt, <span class="math">\\mathcal{S}</span> will sign messages for whatever user <span class="math">\\mathcal{F}_{gs}</span> tells it. When the group manager is honest, however, <span class="math">\\mathcal{S}</span> will be asked to sign messages on behalf of unknown users and might later be asked to open them. In this case, <span class="math">\\mathcal{S}</span> will sign all messages using the same secret key, which we denote <span class="math">sk^{*}</span>. Then, whenever <span class="math">\\mathcal{S}</span> is told to open this signature to a particular user later revealed by <span class="math">\\mathcal{F}_{gs}</span>, it will fake the corresponding proof.</p>

    <p class="text-gray-300">Each party that <span class="math">\\mathcal{S}</span> corrupts reports to <span class="math">\\mathcal{F}_{gs}</span> that it is corrupted. The global parameters <span class="math">\\mathsf{BilinearSetup}(1^{k})\\rightarrow(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},g,\\tilde{g})=\\mathit{params}</span>, where <span class="math">\\mathbb{G}_{1}=\\langle g\\rangle</span> and <span class="math">\\mathbb{G}_{2}=\\langle\\tilde{g}\\rangle</span>, are broadcast to all parties. The group manager has an associated key pair <span class="math">(GPK</span>, <span class="math">GSK)</span>. Regardless of the honesty of the group manager, <span class="math">\\mathcal{S}</span> sets up any public parameters needed later for the registration of a user’s key in Join (e.g., the hash function used in the Fischlin transformation).</p>

    <p class="text-gray-300">Case (g): If the group manager is corrupted, then <span class="math">\\mathcal{S}</span> receives the group key <span class="math">GPK</span> from <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">Case (G): If the group manager is honest, then <span class="math">\\mathcal{S}</span> runs the GroupSetup algorithm to generate a group public key <span class="math">GPK</span> which it then gives to <span class="math">\\mathcal{A}</span>. Note that in this case <span class="math">\\mathcal{S}</span> knows the corresponding secrets and the relation of the Pedersen commitment bases. (Although, an ideal group manager exists outside of <span class="math">\\mathcal{S}</span>, the simulator will internally act as a real-world manager toward <span class="math">\\mathcal{A}</span>.) Each party must have an associated key pair <span class="math">(pk_{i},sk_{i})</span>.</p>

    <p class="text-gray-300">Case (u): If user <span class="math">\\mathcal{U}_{i}</span> is corrupted, then <span class="math">\\mathcal{S}</span> receives the user’s public key <span class="math">pk_{i}</span> from <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">Case (U): If <span class="math">\\mathcal{U}_{i}</span> is honest, then <span class="math">\\mathcal{S}</span> runs the UserKeyGen algorithm to generate a public key <span class="math">pk_{i}</span> which it then gives to <span class="math">\\mathcal{A}</span>. (Although, ideal honest parties exist outside of <span class="math">\\mathcal{S}</span>, the simulator will internally create real-world public keys for them.) In this operation, a user asks the group manager, via <span class="math">\\mathcal{F}_{gs}</span>, if it can join the group and receives an answer bit.</p>

    <p class="text-gray-300">Case (gu): If both the group manager and the user are corrupt, then <span class="math">\\mathcal{S}</span> does nothing.</p>

    <p class="text-gray-300">Case (Gu): The group manager is honest, but the user is corrupt. Then, <span class="math">\\mathcal{A}</span> will start by sending <span class="math">\\mathcal{S}</span> the public key <span class="math">pk=(p_{1},p_{2})</span> and tracing information <span class="math">Q</span> associated with some corrupt user <span class="math">\\mathcal{U}_{i}</span>. <span class="math">\\mathcal{S}</span> will verify the tracing information by checking that <span class="math">e(p_{1},Q)=p_{2}</span>. If this check does not pass, <span class="math">\\mathcal{S}</span> returns an error message to the corrupt user and ends the Join protocol. Otherwise, <span class="math">\\mathcal{S}</span> stores the pair <span class="math">(pk,Q)</span> in a database <span class="math">D</span>. Now <span class="math">\\mathcal{S}</span>, acting as the honest group manager with knowledge of <span class="math">GSK</span>, executes the remainder of the real-world Join protocol with <span class="math">\\mathcal{A}</span>, exiting with an error message when necessary according to the protocol. If <span class="math">\\mathcal{S}</span> does not output an error message, then <span class="math">\\mathcal{S}</span> submits (<span class="math">\\mathcal{U}_{i}</span>,“enroll”) to <span class="math">\\mathcal{F}_{gs}</span>.</p>

    <p class="text-gray-300">Case (gU): The group manager is corrupt, but the user is honest. <span class="math">\\mathcal{S}</span> will be triggered in this case by <span class="math">\\mathcal{F}_{gs}</span> asking if some honest user <span class="math">\\mathcal{U}_{i}</span> may enroll. <span class="math">\\mathcal{S}</span> will internally simulate a real-world version of <span class="math">\\mathcal{U}_{i}</span> towards <span class="math">\\mathcal{A}</span> using the key pair <span class="math">\\mathcal{S}</span> generated for <span class="math">\\mathcal{U}_{i}</span> during the user setup phase. If <span class="math">\\mathcal{A}</span> stops before the end of the protocol, <span class="math">\\mathcal{S}</span> returns the answer “no” to <span class="math">\\mathcal{F}_{gs}</span>. If the CL^{+} signature obtained by <span class="math">\\mathcal{S}</span> during step 2 of the Join protocol verifies, then <span class="math">\\mathcal{S}</span> records this certificate and returns “yes” to <span class="math">\\mathcal{F}_{gs}</span>. Otherwise, it returns “no”.</p>

    <p class="text-gray-300">Case (GU): If both the group manager and the user are honest, then <span class="math">\\mathcal{S}</span> does nothing.</p>

    <p class="text-gray-300">Simulation of the GroupSign Operation: Let <span class="math">id</span> be a counter initialized to zero. In this operation, a user anonymously obtains a signature on a message via <span class="math">\\mathcal{F}_{gs}</span>. When an honest member of the group requests to sign a message <span class="math">m</span>, <span class="math">\\mathcal{F}_{gs}</span> will forward (“sign”, <span class="math">m</span>) to <span class="math">\\mathcal{S}</span>. When <span class="math">\\mathcal{A}</span> outputs a real-world signature, <span class="math">\\mathcal{S}</span> will be responsible for translating it into the ideal world.</p>

    <p class="text-gray-300">Here, we denote by <span class="math">sk^{*}</span> the special signing key that <span class="math">\\mathcal{S}</span> uses to sign all messages, for all honest parties when the group manager is honest.</p>

    <p class="text-gray-300">Case (u): The user is corrupt. When <span class="math">\\mathcal{A}</span> outputs a valid signature <span class="math">\\sigma=(a_{1},\\ldots,a_{8})</span> on message <span class="math">m</span>, <span class="math">\\mathcal{S}</span> tests if it is a (partial) re-randomization of any previous signature; that is, for all signatures <span class="math">(b_{1},\\ldots,b_{8})</span> on message <span class="math">m</span> in <span class="math">L</span>, test if <span class="math">a_{7}=b_{7}</span> (this corresponds to the value <span class="math">\\tilde{g}^{1/(sk+v)}</span>). If any match is found, <span class="math">\\mathcal{S}</span> takes no further action.</p>

    <p class="text-gray-300">However, when no match is found, <span class="math">\\mathcal{S}</span> must register the signature with <span class="math">\\mathcal{F}_{gs}</span>. To do so, <span class="math">\\mathcal{S}</span> must first discover the signer of <span class="math">\\sigma</span>. For every registered user, <span class="math">\\mathcal{S}</span> uses the tracing information in database <span class="math">D</span> to check if <span class="math">e(a_{1},Q_{i})=e(a_{4},\\tilde{g})</span>. Suppose a match is found for some <span class="math">Q_{i}=\\tilde{g}^{sk_{i}}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">sk_{i}=sk^{*}</span>, then the simulation has failed. <span class="math">\\mathcal{S}</span> aborts and outputs “Failure 2”.</li>

      <li>If <span class="math">sk_{i}\\neq sk^{*}</span> and <span class="math">\\mathcal{U}_{i}</span> is honest, the simulation has failed. <span class="math">\\mathcal{S}</span> aborts and outputs “Failure 3”.</li>

      <li>If <span class="math">\\mathcal{U}_{i}</span> is corrupted, then <span class="math">\\mathcal{S}</span> records <span class="math">(\\mathcal{U}_{i},\\sigma,m,id)</span> in <span class="math">L</span>, and sends (<span class="math">\\mathcal{U}_{i}</span>, “sign”, <span class="math">m</span>, <span class="math">id</span>) on behalf of corrupt <span class="math">\\mathcal{U}_{i}</span> to <span class="math">\\mathcal{F}_{gs}</span>. <span class="math">\\mathcal{S}</span> increments the counter <span class="math">id</span>.</li>

    </ol>

    <p class="text-gray-300">If no match for any registered user was found, then:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Subcase (gu): The group manager being corrupt, <span class="math">\\mathcal{S}</span> records (corrupt-<span class="math">\\mathcal{GM}</span>, <span class="math">\\sigma</span>, <span class="math">m</span>, <span class="math">id</span>) in <span class="math">L</span>, chooses an identity <span class="math">\\mathcal{U}_{i}</span> at random among the corrupt users, and sends (<span class="math">\\mathcal{U}_{i}</span>, “sign”, <span class="math">m</span>, <span class="math">id</span>) on behalf of corrupt-<span class="math">\\mathcal{GM}</span> to <span class="math">\\mathcal{F}_{gs}</span>. <span class="math">\\mathcal{S}</span> increments the counter <span class="math">id</span>.</li>

      <li>Subcase (Gu): If the group manager is honest, the simulation has failed. <span class="math">\\mathcal{S}</span> aborts and outputs “Failure 4”.</li>

    </ul>

    <p class="text-gray-300">Case (gU): The group manager is corrupt, but the user is honest. Since the group manager is corrupt, <span class="math">\\mathcal{F}_{gs}</span> additionally tells <span class="math">\\mathcal{S}</span> the identity <span class="math">\\mathcal{U}_{i}</span> of the honest user requesting a signature. Then <span class="math">\\mathcal{S}</span> generates a real-world group signature <span class="math">\\sigma</span> for the simulated <span class="math">\\mathcal{U}_{i}</span>, using that user’s certificate (obtained during</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Join}</span>) and that user’s secret key (which <span class="math">\\mathcal{S}</span> created during the user setup phase). <span class="math">\\mathcal{S}</span> records this entry <span class="math">(\\mathcal{U}_{i},\\sigma,m,id)</span> in an internal database <span class="math">L</span>. Finally, <span class="math">\\mathcal{S}</span> provides <span class="math">\\mathcal{A}</span> with the real-world signature <span class="math">(\\sigma,m)</span>, and returns the “ideal signature” <span class="math">id</span> to <span class="math">\\mathcal{F}_{gs}</span> and increments <span class="math">id</span>.</p>

    <p class="text-gray-300">Case (GU): Both the group manager and the user are honest. As stated above, <span class="math">\\mathcal{S}</span> is triggered by a request (“sign”,<span class="math">m</span>) from <span class="math">\\mathcal{F}_{gs}</span>. This time the ideal-world identity of the honest user is not known to <span class="math">\\mathcal{S}</span>. However, <span class="math">\\mathcal{S}</span> still needs to provide <span class="math">\\mathcal{A}</span> with <em>some</em> group signature, thus it proceeds as follows. <span class="math">\\mathcal{S}</span> generates a real-world group signature <span class="math">\\sigma</span> using the secret key <span class="math">GSK</span> of the group manager (which <span class="math">\\mathcal{S}</span> created during the group setup phase) and the secret key of the first honest group member <span class="math">sk^{*}</span> that it simulates towards <span class="math">\\mathcal{A}</span> (which <span class="math">\\mathcal{S}</span> also created during the user setup phase). Since all signatures are considered public information, <span class="math">\\mathcal{S}</span> must forward the values <span class="math">(\\sigma,m)</span> to <span class="math">\\mathcal{A}</span>. As before, <span class="math">\\mathcal{S}</span> records the entry <span class="math">(?,\\sigma,m,id)</span> in an internal database <span class="math">L</span>. Finally, <span class="math">\\mathcal{S}</span> returns the “ideal signature” <span class="math">id</span> to <span class="math">\\mathcal{F}_{gs}</span> and increments <span class="math">id</span>. The simulator does not take any action on this operation. <span class="math">\\mathcal{A}</span> will be able to verify all real-world signatures within its view itself. Furthermore, <span class="math">\\mathcal{F}_{gs}</span> verifies signatures for honest users without informing <span class="math">\\mathcal{S}</span>. The simulator is triggered on this operation in a variety of ways. There are two parties to consider: the group manager and the user requesting the opening (i.e., the verifier).</p>

    <p class="text-gray-300">On the request (“open”, <span class="math">\\sigma</span>, <span class="math">m</span>) from a real-world corrupted user, <span class="math">\\mathcal{S}</span> first runs its ideal-world GroupSign algorithm for receiving <span class="math">(\\sigma,m)</span> from <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">Case (gu): Both the group manager and the verifier are corrupted. <span class="math">\\mathcal{S}</span> does nothing.</p>

    <p class="text-gray-300">Case (gU): The group manager is corrupted, but the verifier is honest. <span class="math">\\mathcal{F}_{gs}</span> asks <span class="math">\\mathcal{S}</span> (as the corrupted group manager) if it may open the ideal-world tuple <span class="math">(\\mathcal{U}_{i},m,id)</span>. (Recall that if <span class="math">\\mathcal{U}_{i}=\\text{corrupt-}\\mathcal{GM}</span>, then <span class="math">\\mathcal{F}_{gs}</span> refuses to open the signature.) <span class="math">\\mathcal{S}</span> searches its database <span class="math">L</span> for an entry <span class="math">(\\mathcal{U}_{j},\\sigma,m,id)</span>, where <span class="math">\\sigma</span> is a real-world signature on <span class="math">m</span> for some user <span class="math">\\mathcal{U}_{j}</span>. Since the <span class="math">id</span>’s are unique, only one such entry will exist. Next, <span class="math">\\mathcal{S}</span>, acting as an honest, real-world verifier toward <span class="math">\\mathcal{A}</span>, engages <span class="math">\\mathcal{A}</span> in the VerifyOpen protocol with common input (<span class="math">\\mathcal{U}_{i},m,\\sigma</span>). If <span class="math">\\mathcal{S}</span>, as an honest verifier, does not accept this proof, then <span class="math">\\mathcal{S}</span> tells <span class="math">\\mathcal{F}_{gs}</span> to refuse to open this signature. If <span class="math">\\mathcal{S}</span> accepts this verification from <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{U}_{i}=\\mathcal{U}_{j}</span>, then <span class="math">\\mathcal{S}</span> tells <span class="math">\\mathcal{F}_{gs}</span> to open the signature. Finally, if <span class="math">\\mathcal{S}</span> accepts this verification and yet <span class="math">\\mathcal{U}_{i}\\neq\\mathcal{U}_{j}</span>, then our simulation has failed. <span class="math">\\mathcal{S}</span> aborts and outputs “Failure 1”.</p>

    <p class="text-gray-300">Case (Gu): The group manager is honest, but the verifier is corrupted. Since the verifier is corrupted, it may ask about the openings of any signatures it likes. (For example, it may re-randomize a valid signature, etc.) Suppose <span class="math">\\mathcal{A}</span>, acting as a corrupt verifier, requests an opening on (<span class="math">m,\\sigma</span>). The first thing that <span class="math">\\mathcal{S}</span> does is to check if <span class="math">\\sigma</span> is a valid group signature (according to the real-world verification algorithm) on <span class="math">m</span> under the group public key <span class="math">GPK</span>. If it is not, then <span class="math">\\mathcal{S}</span> returns an error message, <span class="math">\\bot</span>, to <span class="math">\\mathcal{A}</span>. Otherwise, <span class="math">\\mathcal{S}</span> proceeds.</p>

    <p class="text-gray-300">Now, <span class="math">\\mathcal{S}</span> must figure out which user, if any, is responsible for <span class="math">\\sigma</span>. First, <span class="math">\\mathcal{S}</span> uses its tracing database to test if any registered user is responsible for <span class="math">\\sigma</span>. Specifically for <span class="math">\\sigma=(a_{1},\\ldots,a_{8})</span> and tracing information <span class="math">Q_{j}</span>, <span class="math">\\mathcal{S}</span> checks if <span class="math">e(a_{1},Q_{j})=e(a_{4},\\tilde{g})</span>.</p>

    <p class="text-gray-300">If <span class="math">\\sigma</span> opens to some registered user <span class="math">\\mathcal{U}_{j}</span>, then there are three cases.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{U}_{j}</span> is corrupted. This is not considered a forgery. <span class="math">\\mathcal{S}</span> honestly runs the real-world VerifyOpen</li>

    </ol>

    <p class="text-gray-300">protocol with <span class="math">\\mathcal{A}</span> on common inputs <span class="math">(\\mathcal{U}_{j},m,\\sigma)</span>. This transaction can be completely simulated by <span class="math">\\mathcal{S}</span> without involving <span class="math">\\mathcal{F}_{gs}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{U}_{j}</span> is honest, and <span class="math">sk_{j}=sk^{*}</span>. Here, <span class="math">\\mathcal{S}</span> needs to further differentiate if <span class="math">\\sigma</span> is a forgery or merely a re-randomization of a previous signature. (Observe that the first part of our signatures may be re-randomized.) To do this, <span class="math">\\mathcal{S}</span> searches database <span class="math">L</span> and complies a list of all entries <span class="math">(?,\\sigma_{i},m,id_{i})</span> containing message <span class="math">m</span>. Next, <span class="math">\\mathcal{S}</span> checks whether <span class="math">\\sigma=(a_{1},\\ldots,a_{8})</span> is derived from any <span class="math">\\sigma_{i}=(b_{1,i},\\ldots,b_{8,i})</span> by checking if <span class="math">a_{7}=b_{7,i}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathcal{S}</span> finds a match for some entry <span class="math">i</span>, then it sends the request (“open”, <span class="math">m,id_{i})</span> to <span class="math">\\mathcal{F}_{gs}</span>. Suppose <span class="math">\\mathcal{F}_{gs}</span> returns the identity <span class="math">\\mathcal{U}_{x}</span>. Now, <span class="math">\\mathcal{S}</span> must prove this opening to <span class="math">\\mathcal{A}</span>. <span class="math">\\mathcal{S}</span> did not know who the ideal-world signer was at the time it created <span class="math">\\sigma</span> under <span class="math">sk^{<em>}</span> (recall that our simulator creates all signatures using <span class="math">sk^{</em>}</span>), thus it must now fake a real-world VerifyOpen opening towards <span class="math">\\mathcal{A}</span>. That is, <span class="math">\\mathcal{S}</span> must open <span class="math">\\sigma=(a_{1},\\ldots,a_{8})</span> to user <span class="math">\\mathcal{U}_{x}</span> with <span class="math">pk_{x}=(h_{x},e(h_{x},\\tilde{g})^{sk_{x}})</span>. <span class="math">\\mathcal{S}</span> simulates the interactive VerifyOpen proof as follows <em>[1]</em>. Let <span class="math">pk_{x}=(p_{1},p_{2})</span>. Recall that this is proof of knowledge of a value <span class="math">\\alpha\\in\\mathbb{G}_{2}</span> such that <span class="math">e(p_{1},\\alpha)=p_{2}</span> and <span class="math">e(a_{1},\\alpha)=e(a_{4},\\tilde{g})</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span> selects a random challenge <span class="math">c\\in\\mathbb{Z}_{p}</span> and sends <span class="math">C=\\mathrm{PedCom}(c)</span> to <span class="math">\\mathcal{S}</span>.</li>

      <li><span class="math">\\mathcal{S}</span> selects a random <span class="math">r\\in\\mathbb{Z}_{p}</span> and sends <span class="math">(t_{1},t_{2})=(e(p_{1}^{r},\\tilde{g}),e(a_{1}^{r},\\tilde{g}))</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> sends <span class="math">c</span> along with the opening of commitment <span class="math">C</span>.</li>

      <li><span class="math">\\mathcal{S}</span> verifies that <span class="math">C</span> opens to <span class="math">c</span> and, if so, sends <span class="math">s=(\\tilde{g}^{sk_{x}})^{c}\\tilde{g}^{r}</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> accepts if and only if: (1) <span class="math">e(p_{1},s)=(p_{2})^{c}t_{1}</span> and (2) <span class="math">e(a_{1},s)=e(a_{4},\\tilde{g})^{c}t_{2}</span>.</li>

      <li>If <span class="math">\\mathcal{S}</span> does not find a match for any entry <span class="math">i</span>, then <span class="math">\\mathcal{A}</span> has succeeded in a forgery against user <span class="math">\\mathcal{U}_{j}</span> with <span class="math">sk_{j}=sk^{*}</span>. The simulation fails. <span class="math">\\mathcal{S}</span> aborts and outputs “Failure 2”.</li>

      <li><span class="math">\\mathcal{U}_{j}</span> is honest, and <span class="math">sk_{j}\\neq sk^{<em>}</span>. <span class="math">\\mathcal{S}</span> immediately knows <span class="math">\\sigma</span> is a forgery, because <span class="math">\\mathcal{S}</span> signs for all honest users with the key <span class="math">sk^{</em>}</span>. The simulation fails. <span class="math">\\mathcal{S}</span> aborts and outputs “Failure 3”.</li>

    </ol>

    <p class="text-gray-300">If <span class="math">\\sigma</span> does not open to any registered user, then <span class="math">\\mathcal{A}</span> has succeeded in creating a valid group signature for a non-registered user. That is, for all tracing information <span class="math">Q_{i}</span> known to <span class="math">\\mathcal{S}</span> and letting <span class="math">\\sigma=(a_{1},\\ldots,a_{8})</span>, we have <span class="math">e(a_{1},Q_{i})\\neq e(a_{4},\\tilde{g})</span>. In this case, <span class="math">\\mathcal{S}</span> aborts and outputs “Failure 4”.</p>

    <p class="text-gray-300">Case (GU): Both the group manager and the verifier are honest. <span class="math">\\mathcal{S}</span> does nothing. <span class="math">\\mathcal{S}</span> will not even know that this transaction has taken place.</p>

    <p class="text-gray-300">This ends our description of simulator <span class="math">\\mathcal{S}</span>. It remains to show that <span class="math">\\mathcal{S}</span> works; that is, under the Strong LRSW, the EDH, and the Strong SXDH assumptions, the simulator will not abort, except with negligible probability, and that the environment will not be able to distinguish between the real and ideal worlds.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Claim A.1</h6>

    <p class="text-gray-300">Conditioned on the fact that <span class="math">\\mathcal{S}</span> never aborts, <span class="math">\\mathcal{Z}</span> cannot distinguish between the real world and the ideal world under the Strong LRSW, the EDH, and the Strong SXDH assumptions.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">To see this, let us explore each operation. First, we observe that in GroupSetup and UserKeyGen, the simulator <span class="math">\\mathcal{S}</span> performs all key generation operations as the respective players in the real world would do. The simulator never deviates from the actions of any honest player during Join and it need not take any action during GroupVerify. In the real world, anyone may verify a signature autonomously. The remaining operations to consider are GroupSign and VerifyOpen.</p>

    <p class="text-gray-300">Let us begin with GroupSign. In this operation, <span class="math">\\mathcal{S}</span> only needs to take action when it must translate an honest party ideal-world signature into a real-world signature, or a corrupted party real-world signature into</p>

    <p class="text-gray-300">an ideal-world one. When the user is corrupted, <span class="math">\\mathcal{S}</span> submits “sign” requests for <span class="math">\\mathcal{A}</span> whenever it outputs a new signature. There is nothing here for <span class="math">\\mathcal{A}</span> to observe.</p>

    <p class="text-gray-300">When the user is honest, however, then <span class="math">\\mathcal{S}</span> must generate real-world signatures towards <span class="math">\\mathcal{A}</span>. When the group manager is corrupted, then <span class="math">\\mathcal{F}_{gs}</span> tells <span class="math">\\mathcal{S}</span> which user is signing the message, and thus <span class="math">\\mathcal{S}</span> may perfectly generate a real-world signature for <span class="math">\\mathcal{A}</span>. <span class="math">\\mathcal{S}</span> is only forced to deviate in case (GU) when it must simulate both the honest group manager and honest signer towards <span class="math">\\mathcal{A}</span>. The problem is that <span class="math">\\mathcal{S}</span> does not know which user is requesting a signature on some message <span class="math">m</span>; thus <span class="math">\\mathcal{S}</span> always signs with the same honest user key <span class="math">sk^{*}</span>. By Lemma A.2, we know that neither <span class="math">\\mathcal{A}</span> nor <span class="math">\\mathcal{Z}</span> can distinguish between this homogeneous, ideal-world distribution of signatures and the heterogeneous, real-world distribution.</p>

    <p class="text-gray-300">Now, it remains to consider VerifyOpen. In this operation, <span class="math">\\mathcal{S}</span> only takes action when one of the two parties is corrupted. In the case (gU), <span class="math">\\mathcal{S}</span> behaves exactly as an honest verifier would towards <span class="math">\\mathcal{A}</span>; that is, <span class="math">\\mathcal{S}</span> finds the (single) <span class="math">\\sigma</span> associated with <span class="math">id</span>, and acts as an honest verifier towards <span class="math">\\mathcal{A}</span>. We will later argue that it does not abort, due to Failure 1, in this step.</p>

    <p class="text-gray-300">The case (Gu), however, is more complicated. Suppose <span class="math">\\mathcal{S}</span> is being asked by <span class="math">\\mathcal{A}</span> to open <span class="math">(m,\\sigma)</span>. If <span class="math">\\sigma</span> opens to a corrupted user or does not open to any registered user, then <span class="math">\\mathcal{S}</span> behaves exactly as an honest <span class="math">\\mathcal{GM}</span> would. However, what happens when <span class="math">\\sigma</span> opens to an honest user? We will later argue that <span class="math">\\mathcal{S}</span> is not forced to abort due to Failures 2, 3, or 4. Even conditioned on this fact, <span class="math">\\mathcal{S}</span> will almost always be forced to deviate since it signed using key <span class="math">sk^{<em>}</span> for all honest users and now must open the signatures to whichever honest party <span class="math">\\mathcal{F}_{gs}</span> dictates. Suppose <span class="math">\\mathcal{S}</span> is told to open <span class="math">\\sigma=(a_{1},\\ldots,a_{8})</span> to some honest user <span class="math">\\mathcal{U}_{i}</span>, where <span class="math">sk_{i}\\neq sk^{</em>}</span>, then <span class="math">\\mathcal{S}</span> must fake the VerifyOpen protocol toward <span class="math">\\mathcal{A}</span>. <span class="math">\\mathcal{S}</span> succeeds in doing this, in the usual way, by requiring <span class="math">\\mathcal{A}</span> to commit to his challenge and then resetting <span class="math">\\mathcal{A}</span> after seeing the challenge. That is, after seeing <span class="math">c\\in\\mathbb{Z}_{p}</span>, <span class="math">\\mathcal{S}</span> chooses a random value <span class="math">s\\in\\mathbb{G}_{2}</span> and computes <span class="math">t_{1}=e(p_{1},s)/p_{2}^{c}</span> and <span class="math">t_{2}=e(a_{1},s)/e(a_{4},\\tilde{g})^{c}</span>, where <span class="math">pk_{i}=(p_{1},p_{2})</span>. Now <span class="math">\\mathcal{S}</span> rewinds <span class="math">\\mathcal{A}</span> to right after it sent a commitment to <span class="math">c</span>, then sends <span class="math">(t_{1},t_{2})</span>, receives <span class="math">c</span> with a valid opening, and returns the response <span class="math">s</span>. Indeed, <span class="math">\\mathcal{S}</span> only fails in this step in the unlikely event that <span class="math">\\mathcal{A}</span> is able to break the binding property of the Pedersen commitments (i.e., CDH in <span class="math">\\mathbb{G}_{1}</span>).</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">This concludes our proof of Claim A.1. It remains to show that, except with negligible probability, <span class="math">\\mathcal{S}</span> will not abort. Recall that <span class="math">\\mathcal{S}</span> may abort under the following conditions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Failure 1: <span class="math">\\mathcal{A}</span> breaks exculpability. We argue that it is not possible for a dishonest group manager to falsely open a signature; i.e., <span class="math">\\mathcal{A}</span> is not able to successfully complete the VerifyOpen protocol with <span class="math">\\mathcal{S}</span> on common input <span class="math">(\\mathcal{U}_{i},m,\\sigma)</span> where <span class="math">\\mathcal{U}_{i}</span> is not the real signer. Here, the simulation fails, because <span class="math">\\mathcal{F}_{gs}</span> will only open signatures honestly.</li>

    </ul>

    <p class="text-gray-300">We now argue that, for a given VerifyOpen instance <span class="math">(\\mathcal{U}_{i},m,\\sigma)</span>, an adversary that can cause Failure 1 with probability <span class="math">\\varepsilon</span> can be used to break the Co-CDH assumption with probability <span class="math">\\geq(\\varepsilon-1/p)^{2}</span>. (Recall from Section 3.1 that Co-CDH is implied by the Strong SXDH assumption.) On Co-CDH input <span class="math">(g,\\tilde{g},g^{x},\\tilde{g}^{y})</span>, the goal is to compute <span class="math">\\tilde{g}^{xy}</span> and the simulator proceeds as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Step 1: <span class="math">\\mathcal{S}</span> initiates the VerifyOpen protocol with <span class="math">\\mathcal{A}</span> on input <span class="math">(\\mathcal{U}_{i},m,\\sigma)</span>, setting <span class="math">pk_{i}=(g^{z},e(g^{zx},\\tilde{g}^{y}))</span>, for random <span class="math">z\\in\\mathbb{Z}_{p}</span>, and computing <span class="math">\\sigma</span> as a valid signature on <span class="math">m</span> for the user with <span class="math">sk^{*}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Step 2: <span class="math">\\mathcal{S}</span> commits to all zeros, as $C=\\mathrm{PedCom}(0^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Step 3: After receiving <span class="math">(t_{1},t_{2})</span> from <span class="math">\\mathcal{A}</span>, <span class="math">\\mathcal{S}</span> using its knowledge of the relation of the Pedersen public parameters to fake the openings as:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>selects a random challenge <span class="math">c_{1}\\in\\mathbb{Z}_{p}</span>, opens <span class="math">C</span> to <span class="math">c_{1}</span>, and obtains <span class="math">\\mathcal{A}</span>’s response <span class="math">s_{1}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>rewinds <span class="math">\\mathcal{A}</span>, selects a different random challenge <span class="math">c_2 \\in \\mathbb{Z}_p</span>, opens <span class="math">C</span> to <span class="math">c_2</span>, and obtains <span class="math">\\mathcal{A}</span>'s response <span class="math">s_2</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Step 4: <span class="math">\\mathcal{S}</span> computes and outputs <span class="math">(s_1 / s_2)^{1 / (c_1 - c_2)}</span> (which hopefully corresponds to <span class="math">\\tilde{g}^{xy}</span>).</li>

    </ol>

    <p class="text-gray-300">In Step 1, the adversary cannot tell that it was given a signature under <span class="math">sk^*</span> instead of <span class="math">sk_i</span> due to Lemma A.2. The fake openings in Step 4 are perfectly indistinguishable from an honest opening due to the perfect hiding property of Pedersen commitments. If both <span class="math">((t_1, t_2), c_1, s_1)</span> and <span class="math">((t_1, t_2), c_2, s_2)</span> are valid transcripts, then <span class="math">\\mathcal{S}</span> outputs <span class="math">\\tilde{g}^{xy}</span> in Step 4 with probability <span class="math">\\geq (\\varepsilon - 1/p)^2</span>. Our bound of <span class="math">(\\varepsilon - 1/p)^2</span> comes from the well-known Reset Lemma [10], where the advantage of <span class="math">\\mathcal{A}</span> was given as <span class="math">\\varepsilon</span> and the size of the challenge set is <span class="math">p</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Failure 2: <span class="math">\\mathcal{A}</span> creates a forgery against the honest user with <span class="math">sk^<em></span>. <span class="math">\\mathcal{A}</span> produces signature <span class="math">\\sigma = (a_1, \\ldots, a_8)</span> and message <span class="math">m</span> s.t. GroupVerify <span class="math">(GPK, \\sigma, m) = 1</span>, <span class="math">\\sigma</span> opens to <span class="math">\\mathcal{U}^</em></span> (i.e., <span class="math">e(a_1, Q^*) = e(a_4, \\tilde{g})</span>), and yet <span class="math">\\mathcal{S}</span> never gave <span class="math">\\mathcal{A}</span> this user's signature on <span class="math">m</span>. This scenario occurs with only negligible probability under the EDH assumption, regardless of whether the group manager is corrupted.</li>

    </ul>

    <p class="text-gray-300">Recall that EDH takes as input <span class="math">(g, g^x, \\tilde{g}, \\tilde{g}^x)</span> together with access to oracle <span class="math">O_x(\\cdot)</span> that takes input <span class="math">c \\in \\mathbb{Z}_p^<em></span> and produces output <span class="math">(g^x, \\tilde{g}^{1/(x+v)}, \\tilde{g}^{1/(v+c)})</span> for a random <span class="math">v \\in \\mathbb{Z}_p^</em></span>. The goal is to produce a tuple <span class="math">(c, a, a^v, \\tilde{g}^{\\frac{1}{x+v}}, \\tilde{g}^{\\frac{1}{v+c}})</span> for any <span class="math">a \\in \\mathbb{G}_1</span> and any <span class="math">v, c \\in \\mathbb{Z}_p^*</span> such that <span class="math">c</span> was not queried to the oracle.</p>

    <p class="text-gray-300">Let <span class="math">\\tau</span> be the number of honest users in the system. When <span class="math">\\mathcal{A}</span> succeeds with probability <span class="math">\\varepsilon</span>, then <span class="math">\\mathcal{B}</span> solves the EDH problem with probability <span class="math">\\varepsilon / \\tau</span>. <span class="math">\\mathcal{B}</span> proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup: <span class="math">\\mathcal{B}</span> must establish the global parameters and key generation.</li>

    </ol>

    <p class="text-gray-300">(a) Output <span class="math">(g, \\tilde{g})</span> as the public parameters for the group signature scheme, and <span class="math">GPK = (\\tilde{S}, \\tilde{T}) = (\\tilde{g}^s, \\tilde{g}^t)</span> on behalf of the group manager. If <span class="math">\\mathcal{GM}</span> is corrupt, <span class="math">GPK</span> is given to <span class="math">\\mathcal{S}</span> by <span class="math">\\mathcal{A}</span>. Setup all remaining keys and parameters as <span class="math">\\mathcal{S}</span> would normally do. (b) Guess which of the <span class="math">\\tau</span> honest users <span class="math">\\mathcal{A}</span> will attack. Give this user <span class="math">\\mathcal{U}^<em></span> the public key <span class="math">pk^</em> = (g^r, e(g^r, \\tilde{g}^x))</span>, for random <span class="math">r \\in \\mathbb{Z}_p</span>. (Logically this assigns the user's secret key as <span class="math">sk^<em> = x</span>.) (c) Obtain group certificates for all honest users; <span class="math">\\mathcal{B}</span> fakes the proof of knowledge of <span class="math">sk^</em></span> using any of the techniques discussed in Section 5 (Join). Finally, <span class="math">\\mathcal{B}</span> submits the correct tracing information, <span class="math">Q^{<em>} = \\tilde{g}^{sk^{</em>}} = \\tilde{g}^{x}</span>, for this user. (d) If the group manager is corrupt, extract the group key <span class="math">GSK = (s,t)</span> during the proof of knowledge.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Signing: When <span class="math">\\mathcal{A}</span> requests a signature from a user not associated with <span class="math">sk^<em> = x</span>, sign as normal. Now, when <span class="math">\\mathcal{A}</span> asks for a group signature on <span class="math">m \\in \\mathbb{Z}_p^</em></span> from the honest user associated with secret key <span class="math">sk^* = x</span>, do:</li>

    </ol>

    <p class="text-gray-300">(a) Query oracle <span class="math">O_{x}(m)</span> to get output <span class="math">(f_{1}, f_{2}, f_{3})</span>. (b) Select a random <span class="math">r \\in \\mathbb{Z}_p</span>. Use <span class="math">GSK = (s, t)</span>, to output the group signature on <span class="math">m</span> as</p>

    <div class="my-4 text-center"><span class="math-block">(g ^ {r}, g ^ {t r}, g ^ {s r} (g ^ {x}) ^ {s t r}, (g ^ {x}) ^ {r}, (g ^ {x}) ^ {t r}, f _ {1} ^ {r}, f _ {2}, f _ {3}).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Opening: <span class="math">\\mathcal{B}</span> honestly executes the VerifyOpen protocol with <span class="math">\\mathcal{A}</span>.</li>

      <li>Output: Suppose <span class="math">\\mathcal{A}</span> produces a valid signature <span class="math">\\sigma&#x27; = (a_1, \\ldots, a_8)</span> for a new message <span class="math">m&#x27; \\in \\mathbb{Z}_p^<em></span> for the user with key <span class="math">sk^</em> = x</span>. Then <span class="math">\\mathcal{B}</span> outputs <span class="math">(m&#x27;, a_1, a_4, a_6, a_7, a_8)</span> to solve the EDH problem.</li>

    </ol>

    <p class="text-gray-300">20</p>

    <p class="text-gray-300">It is easy to observe that <span class="math">\\mathcal{B}</span> perfectly simulates the group signature world for <span class="math">\\mathcal{A}</span>. <span class="math">\\mathcal{B}</span> has probability <span class="math">1/\\tau</span> of choosing which honest user <span class="math">\\mathcal{A}</span> will forge against. Thus, when <span class="math">\\mathcal{A}</span> succeeds with probability <span class="math">\\varepsilon</span>, then <span class="math">\\mathcal{B}</span> solves the EDH problem with probability <span class="math">\\varepsilon/\\tau</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Failure 3: <span class="math">\\mathcal{A}</span> creates a forgery against a user with <span class="math">sk_{j}\\neq sk^{*}</span>. Proof that this failure occurs with only negligible probability follows directly from that of Failure 2. Indeed, <span class="math">\\mathcal{A}</span> has strictly less information at its disposal; that is, <span class="math">\\mathcal{A}</span> never sees real signatures under key <span class="math">sk_{j}</span>.</li>

      <li>Failure 4: <span class="math">\\mathcal{A}</span> creates a valid signature for a non-registered user. In this case, <span class="math">\\mathcal{A}</span> produces a signature-message pair <span class="math">(\\sigma,m)</span> such that <span class="math">\\textsf{GroupVerify}(GPK,\\,\\sigma,m)=1</span> and yet it cannot be opened by <span class="math">\\mathcal{S}</span> to any registered user. We now argue that this is not possible under the Strong LRSW assumption, except with negligible probability. Suppose we are given <span class="math">(g,\\tilde{g},\\tilde{g}^{s},\\tilde{g}^{t})</span> as the Strong LRSW input.</li>

    </ul>

    <p class="text-gray-300">Instead of running <span class="math">\\textsf{GroupSetup}</span>, let the public parameters <span class="math">g,\\tilde{g}\\in\\textsf{params}</span> and the public key <span class="math">GPK=(\\tilde{S},\\tilde{T})=(\\tilde{g}^{s},\\tilde{g}^{t})</span>. During the <span class="math">\\textsf{UserKeyGen}</span> operation, for any honest users, <span class="math">\\mathcal{S}</span> queries the Strong LRSW oracle <span class="math">O_{\\tilde{S},\\tilde{T}}</span> on a random <span class="math">sk_{i}\\in\\mathbb{Z}_{p}</span> to obtain a membership certificate <span class="math">(a,a^{t},a^{s+st(sk_{i})})</span>, for any <span class="math">a\\in\\mathbb{G}_{1}</span>. (This tuple is, in fact, a CL signature on <span class="math">sk_{i}</span> <em>[19]</em>.) <span class="math">\\mathcal{S}</span> now uses <span class="math">sk_{i}</span> as the secret key for this honest user.</p>

    <p class="text-gray-300">When <span class="math">\\mathcal{S}</span> is asked to execute <span class="math">\\textsf{Join}</span> with an honest user, <span class="math">\\mathcal{S}</span> simply finds the corresponding CL signature and uses it to output the certificate <span class="math">(a,\\,a^{t},\\,a^{s+st(sk_{i})},\\,a^{sk_{i}},\\,a^{t(sk_{i})})</span>. When <span class="math">\\mathcal{S}</span> is asked to execute <span class="math">\\textsf{Join}</span> with a corrupted user, <span class="math">\\mathcal{S}</span> extracts the user’s secret key <span class="math">sk_{j}</span> using any of the techniques discussed in Section 5 (<span class="math">\\textsf{Join}</span>), queries the Strong LRSW oracle on input <span class="math">sk_{j}</span>, and uses the oracle’s output to create a valid certificate for this corrupt user. Now, the adversary can sign any message for a corrupt user, and <span class="math">\\mathcal{S}</span> can honestly respond to any <span class="math">\\textsf{GroupSign}</span> call for an honest user.</p>

    <p class="text-gray-300">Suppose that Failure 1 has occurred during <span class="math">\\textsf{VerifyOpen}</span>, meaning that <span class="math">\\mathcal{A}</span> output a signature <span class="math">\\sigma=(a_{1},\\ldots,a_{8})</span> such that the following relations hold:</p>

    <p class="text-gray-300"><span class="math">e(a_{1},\\tilde{T})=e(a_{2},\\tilde{g}),\\ \\ \\ e(a_{4},\\tilde{T})=e(a_{5},\\tilde{g}),\\ \\ \\ e(a_{1}a_{5},\\tilde{S})=e(a_{3},\\tilde{g})</span></p>

    <p class="text-gray-300">and yet <span class="math">\\mathcal{S}</span> did not query <span class="math">O_{\\tilde{S},\\tilde{T}}</span> on the corresponding secret key; that is, for all <span class="math">sk_{i}</span> known to <span class="math">\\mathcal{S}</span>, we have <span class="math">a_{1}^{sk_{i}}\\neq a_{4}</span>. Then, <span class="math">\\mathcal{S}</span> may output <span class="math">(a_{1},a_{2},a_{3},a_{4},a_{5})</span> to break the Strong LRSW assumption.</p>

    <p class="text-gray-300">Combining Claim A.1 with the above arguments that <span class="math">\\mathcal{S}</span> will not abort, except with negligible probability, concludes our main proof.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">We end by proving a Lemma used in the above proof. Intuitively, this Lemma captures the anonymity of our signatures. In the below, the values <span class="math">u_{1},\\ldots,u_{\\tau}</span> may be thought of as the secret keys of <span class="math">\\tau</span> different honest users.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Lemma A.2 (Anonymity of Signatures)</h6>

    <p class="text-gray-300">Suppose we have the group signature parameters from Section 5; that is, security parameter <span class="math">1^{k}</span>, <span class="math">\\textsf{params}</span>, and <span class="math">GPK</span>. Suppose <span class="math">u_{1},\\ldots,u_{\\tau}</span> are random elements of <span class="math">\\mathbb{Z}_{p}</span>. Let <span class="math">O_{u_{1},\\ldots,u_{\\tau}}(\\cdot,\\cdot)</span> be an oracle that takes as input a message <span class="math">m\\in\\mathbb{Z}_{p}^{*}</span> and an index <span class="math">1\\leq i\\leq\\tau</span>, and outputs a group signature <span class="math">(a_{1},\\ldots,a_{8})</span> on <span class="math">m</span> with user secret key <span class="math">u_{i}</span>. Then, under the Strong SXDH assumptions, for all probabilistic polynomial-time adversaries <span class="math">\\mathcal{A}</span>, the following value is negligible in <span class="math">k</span>:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathcal{A}^{O_{u_{1},u_{2},\\ldots,u_{\\tau}}}(\\textsf{params},\\,GPK,\\{pk_{i}\\}_{i\\in[1,\\tau]})=1\\right]-\\vskip 14.22636pt</span> <span class="math">\\Pr[\\mathcal{A}^{O_{u_{1},u_{1},\\ldots,u_{1}}}(\\textsf{params},\\,GPK,\\{pk_{i}\\}_{i\\in[1,\\tau]})=1\\right].</span></p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">First, if <span class="math">\\mathcal{A}</span> can distinguish between oracles <span class="math">O_{u_{1},u_{2},\\ldots,u_{\\tau}}</span> and <span class="math">O_{u_{1},u_{1},\\ldots,u_{1}}</span>, then we can create an adversary <span class="math">\\mathcal{B}</span> that can distinguish between oracles <span class="math">O_{u_{1},u_{2}}</span> and <span class="math">O_{u_{1},u_{1}}</span>. Next, we show that adversary <span class="math">\\mathcal{B}</span> can be used to break the Strong SXDH assumption. Overall, if <span class="math">\\mathcal{A}</span> succeeds with probability <span class="math">\\varepsilon</span>, then we can break Strong SXDH with probability <span class="math">\\geq\\varepsilon/\\tau</span>.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">Stage One.</h4>

    <p class="text-gray-300">First, we make the simple hybrid argument that given <span class="math">\\mathcal{A}</span>, which can distinguish the signatures of <span class="math">\\tau</span> distinct honest users from those of a single user, we can create an adversary <span class="math">\\mathcal{B}</span> that can distinguish the signatures of only 2 distinct users from those of a single user. Indeed, by the hybrid argument, we know that if <span class="math">\\mathcal{A}</span> distinguishes with probability <span class="math">\\varepsilon</span>, then for some <span class="math">1\\leq\\ell\\leq\\tau</span>, <span class="math">\\mathcal{A}</span> can distinguish with probability <span class="math">\\geq\\varepsilon/\\tau</span> between the oracle instantiated with <span class="math">\\ell</span> <span class="math">u_{1}</span>’s followed by <span class="math">\\tau-\\ell-1</span> different values. The obvious reduction follows; that is, the two oracles of <span class="math">\\mathcal{B}</span> will be applied to this hybrid point for <span class="math">\\mathcal{A}</span>. <span class="math">\\mathcal{B}</span> will then return whatever answer <span class="math">\\mathcal{A}</span> does.</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">Stage Two.</h4>

    <p class="text-gray-300">Now, we show that <span class="math">\\mathcal{B}</span> can be used to create another adversary <span class="math">\\mathcal{C}</span> that breaks Strong SXDH. On Strong SXDH input <span class="math">(g,g^{x},\\tilde{g})</span>, the adversary <span class="math">\\mathcal{C}</span> proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Generate group public key <span class="math">GPK</span> as <span class="math">(\\tilde{S},\\tilde{T})=(\\tilde{g}^{s},\\tilde{g}^{t})</span> for random <span class="math">s,t\\in\\mathbb{Z}_{p}</span>. Give <span class="math">GPK</span> to <span class="math">\\mathcal{B}</span>; store <span class="math">GSK=(s,t)</span>. (Remember, anonymity only makes sense when the group manager is honest, so the adversary does not get to set these keys.)</li>

      <li>Query <span class="math">Q_{y}</span> on a random input, disregard all output except <span class="math">(h,h^{y})</span> for some <span class="math">h\\in\\mathbb{G}_{1}</span>.</li>

      <li>Generate the two user keys as <span class="math">pk_{1}=(g,e(g^{x},\\tilde{g}))</span> for user <span class="math">\\mathcal{U}_{1}</span> and <span class="math">pk_{2}=(h,e(h^{y},\\tilde{g}))</span> for user <span class="math">\\mathcal{U}_{2}</span>. Give <span class="math">pk_{1},pk_{2}</span> to <span class="math">\\mathcal{B}</span>. (This first key could be re-randomized away from the public parameters by choosing a random <span class="math">r\\in\\mathbb{Z}_{p}</span> and setting <span class="math">pk_{1}=(g^{r},e(g^{x},\\tilde{g})^{r})</span>. This has no effect on the remainder, and for clarity we omit it.)</li>

      <li>When <span class="math">\\mathcal{B}</span> requests a signature for index <span class="math">i\\in\\{1,2\\}</span> on <span class="math">m\\in\\mathbb{Z}_{p}^{*}</span>, if <span class="math">i=1</span>, use <span class="math">O_{x}(\\cdot)</span> to do:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Query <span class="math">O_{x}(m)</span> to obtain the output <span class="math">(g^{v},\\tilde{g}^{1/(x+v)},\\tilde{g}^{1/(v+m)})</span>, where <span class="math">v\\in\\mathbb{Z}_{p}^{*}</span> is a fresh random value chosen by the oracle. Denote this output as <span class="math">(f_{6},\\ldots,f_{8})</span>.</li>

      <li>Using <span class="math">GSK=(s,t)</span>, compute the remaining parts of the group signature: <span class="math">f_{2}=g^{t}</span>, <span class="math">f_{3}=g^{s}(g^{x})^{st}</span>, <span class="math">f_{4}=g^{x}</span>, and <span class="math">f_{5}=(g^{x})^{t}</span>.</li>

      <li>Select a random <span class="math">r\\in\\mathbb{Z}_{p}^{*}</span>, and return the signature <span class="math">(g^{r}</span>, <span class="math">f_{2}^{r}</span>, <span class="math">f_{3}^{r}</span>, <span class="math">f_{4}^{r}</span>, <span class="math">f_{5}^{r}</span>, <span class="math">f_{6}^{r}</span>, <span class="math">f_{7}</span>, <span class="math">f_{8})</span>.</li>

    </ol>

    <p class="text-gray-300">If <span class="math">i=2</span>, use oracle <span class="math">O_{y}(\\cdot)</span> to do:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Query <span class="math">Q_{y}(m)</span> to obtain the output <span class="math">(a,a^{y},a^{v},\\tilde{g}^{1/(y+v)},\\tilde{g}^{1/(v+m)})</span>, where <span class="math">a\\in\\mathbb{G}_{1}</span> and <span class="math">v\\in\\mathbb{Z}_{p}^{*}</span> are fresh random values chosen by the oracle. Denote this output as <span class="math">(f_{1},f_{4},f_{6},\\ldots,f_{8})</span>.</li>

      <li>Using <span class="math">GSK=(s,t)</span>, compute the remaining parts of the group signature: <span class="math">f_{2}=a^{t}</span>, <span class="math">f_{3}=a^{s}(a^{x})^{st}</span>, and <span class="math">f_{5}=(a^{y})^{t}</span>.</li>

      <li>Return the signature <span class="math">(f_{1},\\ldots,f_{8})</span>.</li>

      <li>Eventually, <span class="math">\\mathcal{B}</span> will attempt to distinguish whether he’s been talking to oracle <span class="math">O_{x,x}</span> or oracle <span class="math">O_{x,y}</span>. If <span class="math">\\mathcal{B}</span> says that he’s been talking to oracle <span class="math">O_{x,x}</span>, then output 1 corresponding to “<span class="math">x=y</span>”. Otherwise, output 0 corresponding to “<span class="math">x\\neq y</span>”.</li>

    </ol>

    <p class="text-gray-300">It is easy to see that the stage 2 simulation is perfect; the output is always correct and perfectly distributed. Indeed, <span class="math">\\mathcal{C}</span> and <span class="math">\\mathcal{B}</span> will succeed with identical probabilities. This concludes our proof. We find that if any <span class="math">\\mathcal{A}</span> can break the anonymity of our signatures with probability <span class="math">\\varepsilon</span>, then <span class="math">\\mathcal{A}</span> can be used to break Strong SXDH with probability at least <span class="math">\\varepsilon/\\tau</span>, where <span class="math">\\tau</span> is the number of honest users in the system. ∎</p>

    <h2 id="sec-27" class="text-2xl font-bold">Appendix B Towards a Concurrent Join Protocol</h2>

    <p class="text-gray-300">In Section 5, we specified that the group manager runs the Join protocol sequentially with the different users. The reason for this is technical, i.e., to prove security we require that the users’ secrets keys <span class="math">sk_{i}</span> are <em>extractable</em>. To this end we require the users to commit to their secret key and then prove knowledge of them. If one uses the standard proof of knowledge protocol for the latter, extracting the users’ secret keys requires rewinding of the users. It is well known that if these proofs of knowledge protocols are run concurrently with many users, then extracting all the secret keys can take time exponential in the number of users. There are, however, alternatives which allow for concurrent execution of these proofs and thus also of the Join protocol.</p>

    <p class="text-gray-300">First of all, one could require the group manager to run the protocol concurrently only with a limited numbers of users, i.e., by defining time intervals within which the group manager runs the protocol concurrently with a logarithmic number of users and enforcing a time-out if a protocol does not finish within this time interval. This solution would not give a group signature scheme that can be concurrently composed with other schemes.</p>

    <p class="text-gray-300">Solutions that would allow for concurrent executions come from applying one of the various transformations of a standard proof of knowledge protocol (or <span class="math">\\Sigma</span>-protocol) into one that can be executed concurrently.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Common random reference string.</em> Assuming that the parties have a common random reference string available, one can interpret this as the key for an encryption scheme such that the corresponding secret key is not know to any party. Alternatively, one could have a (distributed) trusted third party generate such a public key (cf. <em>[25]</em>). Then, the users would be required to verifiably encrypt their secret key <span class="math">sk_{i}</span> under this reference public key (e.g., using the techniques of <em>Camenisch and Damgård [18]</em>). For extraction of the secret keys in the security proof, the reference string would need to be patched such that the simulator knows the reference decryption key and thus can extract the users’ secret keys by simple decryption.</li>

      <li><em>Non-concurrent setup phase.</em> When having a common random reference string or a trusted third party is impractical, each user can instead generate their own public key and then prove knowledge of the corresponding secret key in a setup phase where non-concurrent execution can be guaranteed (e.g, because the user’s part is run by an isolated smart card). Then, during the Join protocol, the user would verifiably encrypt her secret key <span class="math">sk_{i}</span> under <em>her own</em> public key <span class="math">pk_{i}</span>.</li>

      <li><em>Assuming random oracles for Join only.</em> A third alternative that comes to mind, in the random oracle model, is to apply Fischlin’s results <em>[28]</em>. Fischlin recently presented a transformation for turning any standard proof of knowledge (or <span class="math">\\Sigma</span>-protocol) into a non-interactive proof in the random oracle model that supports an online extractor (i.e., no rewinding).</li>

    </ol>

    <p class="text-gray-300">The parameters required for any of these options (e.g., the hash function for option (c)) are assumed to be global information outside the control of the group manager.</p>

    <h2 id="sec-28" class="text-2xl font-bold">Appendix C Open Algorithm with <span class="math">O(\\sqrt{n}\\cdot k)</span> Complexity from Trees.</h2>

    <p class="text-gray-300">As before, let <span class="math">(p,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},g,\\tilde{g})</span>, where <span class="math">\\mathbb{G}_{1}=\\langle g\\rangle</span> and <span class="math">\\mathbb{G}_{2}=\\langle\\tilde{g}\\rangle</span>, be the global parameters for the bilinear groups.</p>

    <p class="text-gray-300">The intuition here is that group members are logically divided into a 2-level tree; then to revoke the anonymity of a signature, the group manager first locates the correct branch and then the correct leaf (user) for that branch. For a balanced tree, this results in a search time of <span class="math">2k\\sqrt{n}</span>. Now we present the details. During the Join protocol, the group manager secretly assigns each user to one of <span class="math">\\sqrt{n}k</span> logical branches. Each branch is associated with a unique ID as a value <span class="math">ID\\in\\mathbb{Z}_{p}^{<em>}</span>. Now, the group manager and the user run a protocol such that at the end the user obtains a CL^{+} signature on the pair of messages <span class="math">(sk,ID)</span> without learning its branch identity <span class="math">ID</span> and the group manager does not learn the user’s secret key <span class="math">sk</span>. Following </em>Camenisch and Lysyanskaya [19]* this CL^{+} signature would be of the following form for <span class="math">GPK=(\\tilde{g}^{s},\\tilde{g}^{t},\\tilde{g}^{z},\\tilde{g}^{tz})</span>, <span class="math">GSK=(s,t,z)</span>, and some <span class="math">a\\in\\mathbb{G}_{1}</span>:</p>

    <p class="text-gray-300"><span class="math">(a_{1},\\ldots,a_{7})=(a,a^{t},a^{s+st(sk)+stz(ID)},a^{sk},a^{t(sk)},a^{ID},a^{tz(ID)})</span></p>

    <p class="text-gray-300">This CL^{+} signature would be used as the user’s certificate. Let the user submit tracing information <span class="math">Q_{j}=\\tilde{g}^{sk_{j}}</span> during the Join protocol as before. Then to open a group signature, the group manager now does: For each branch identity <span class="math">ID_{i}</span>, check if <span class="math">e(a_{6},\\tilde{g})=e(a_{1},\\tilde{g})^{ID_{i}}</span>; then for each member of the matching branch, check if <span class="math">e(a_{4},\\tilde{g})=e(a_{1},Q_{j})</span>. Under the DDH assumption in <span class="math">\\mathbb{G}_{1}</span>, a user’s branch identity remains hidden from everyone except the group manager, so full anonymity is preserved. By the Strong LRSW assumption, a user cannot change which branch he is associated with, and thus the group manager will be able to find him (i.e., open the signature).</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Theorem C.1</h6>

    <p class="text-gray-300">In the plain model, the above extension to the Section §5 scheme realizes <span class="math">\\mathcal{F}_{gs}</span> from Section §2 under the the Strong LRSW, the EDH, and the Strong SXDH assumptions.</p>

    <p class="text-gray-300">In practice, one can achieve a “constant time” open algorithm by having less branches per node but more levels. Assume we want to be able to handle <span class="math">2^{40}</span> members. Then we could have <span class="math">2^{10}</span> branches and a tree depth of <span class="math">4</span>. This would result is a scheme where signature would have an additional <span class="math">8</span> elements (i.e., this would double the length of the signature) the group manager would need to do at most <span class="math">3072</span> exponentations (to walk through the first three levels) and <span class="math">1024</span> pairings (to find the group member) to open a signature. Furthermore, the <span class="math">3072</span> exponentations could be considerably sped-up by giving all branches of the same node the same (but random) ID except the last <span class="math">10</span> bits. Given that opening signatures is an exceptional event, we believe such a scheme would be practical.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">Open Algorithm with <span class="math">O((\\log n)+k)</span> Complexity from Encryption.</h4>

    <p class="text-gray-300">The intuition here is to have the signer include an encryption of her identity under the group manager’s encryption key as part of every signature. The trick is to do this in such a way that the correctness of the encryption is publicly-verifiable, and yet, the anonymity of the signer is preserved.</p>

    <p class="text-gray-300">Let <span class="math">(eGPK,\\,eGSK)</span> be Elgamal encryption keys generated by the group manager, where <span class="math">eGSK\\in\\mathbb{Z}_{p}</span> and <span class="math">eGPK=\\tilde{g}^{eGSK}</span>. Then in addition to a regular signature from Section §5, a user would add a version of Elgamal encryption of their identity as the last three items:</p>

    <p class="text-gray-300"><span class="math">\\big{(}Sign_{GSK}^{CL+}(sk;a),\\qquad Sign_{sk}^{BB+}(m;a,\\tilde{g}),\\qquad Enc_{eGPK}^{Elgamal+}(sk;a,\\tilde{g})\\big{)}</span> <span class="math">=\\big{(}a,a^{t},a^{s+st(sk)},a^{sk},a^{t(sk)},\\qquad a^{v},\\tilde{g}^{1/(sk+v)},\\tilde{g}^{1/(v+m)},\\qquad a^{c},\\tilde{g}^{sk+c},(eGPK)^{c}\\big{)}.</span></p>

    <p class="text-gray-300">To verify the signature <span class="math">\\sigma=(a_{1},\\ldots,a_{11})</span>, in addition to the usual <span class="math">\\text{CL}^{+}</span> and <span class="math">\\text{BB}^{+}</span> checks, a verifier must be sure that the ciphertext is correctly formed by checking that: (1) <span class="math">e(a_{1},a_{10})=e(a_{4},\\tilde{g})e(a_{9},\\tilde{g})</span> and (2) <span class="math">e(a_{9},eGPK)=e(a_{1},a_{11})</span>.</p>

    <p class="text-gray-300">Now, to the key point: the group manager may, at any time, open the signature by simply decrypting the last portion as <span class="math">a_{10}/(a_{11})^{1/eGSK}=\\tilde{g}^{sk}</span>, which reveals the user’s identity. Recall that the group manager obtains this same <em>tracing information</em> from the user during the Join protocol.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Theorem C.2</h6>

    <p class="text-gray-300">In the plain model, the above extension to the Section §5 scheme realizes <span class="math">\\mathcal{F}_{gs}</span> from Section §2 under the Strong LRSW, the EDH, and (an extension of) the Strong SXDH assumptions.</p>

    <p class="text-gray-300">The extension of the Strong SXDH assumption mentioned above requires changes to oracles <span class="math">O</span> and <span class="math">Q</span>, from Definition 4 in Section §3. Specifically, we change the oracles as follows: Select a value <span class="math">eGPK\\in\\mathbb{G}_{2}</span> at random and give as input the adversary. Let <span class="math">O^{\\prime}_{x}(\\cdot)</span> be an oracle that takes as input <span class="math">m\\in\\mathbb{Z}_{p}^{<em>}</span> and outputs <span class="math">(g^{r},g^{rx},g^{rv},\\tilde{g}^{1/(x+v)},\\tilde{g}^{1/(v+m)},g^{rc},\\tilde{g}^{sk+c},eGPK^{c})</span> for a random <span class="math">r,v,c\\in\\mathbb{Z}_{p}^{</em>}</span>. Then, we say that on input <span class="math">(g,g^{x},\\tilde{g},eGPK)</span>, the adversary cannot distinguish access to oracles <span class="math">(O^{\\prime}_{x}(\\cdot),O^{\\prime}_{y}(\\cdot))</span> from <span class="math">(O^{\\prime}_{x}(\\cdot),O^{\\prime}_{x}(\\cdot))</span>.</p>

    <p class="text-gray-300">The proof of Theorem D.3 that Strong SXDH is hard in generic groups can be modified to cover this extended version as well.</p>

    <h2 id="sec-32" class="text-2xl font-bold">Appendix D Generic Security of the New Assumptions</h2>

    <p class="text-gray-300">To provide more confidence in our scheme, we prove lower bounds on the complexity of our assumptions for generic groups <em>[40, 46]</em>.</p>

    <p class="text-gray-300">Let us begin by recalling the basics. We follow the notation and general outline of Boneh and Boyen <em>[12]</em>. In the generic group model, elements of the bilinear groups <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span>, and <span class="math">\\mathbb{G}_{T}</span> are encoded as unique random strings. Thus, the adversary cannot directly test any property other than equality. Oracles are assumed to perform operations between group elements, such as performing the group operations in <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span>, and <span class="math">\\mathbb{G}_{T}</span>. The opaque encoding of the elements of <span class="math">\\mathbb{G}_{1}</span> is defined as the function <span class="math">\\xi_{1}:\\mathbb{Z}_{p}\\to\\{0,1\\}^{<em>}</span>, which maps all <span class="math">a\\in\\mathbb{Z}_{p}</span> to the string representation <span class="math">\\xi_{1}(a)</span> of <span class="math">g^{a}\\in\\mathbb{G}_{1}</span>. Likewise, we have <span class="math">\\xi_{2}:\\mathbb{Z}_{p}\\to\\{0,1\\}^{</em>}</span> for <span class="math">\\mathbb{G}_{2}</span> and <span class="math">\\xi_{T}:\\mathbb{Z}_{p}\\to\\{0,1\\}^{*}</span> for <span class="math">\\mathbb{G}_{T}</span>. The adversary <span class="math">\\mathcal{A}</span> communicates with the oracles using the <span class="math">\\xi</span>-representations of the group elements only.</p>

    <p class="text-gray-300">We achieve the same asymptotic complexity bound for EDH as was shown for <span class="math">q</span>-SDH.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Theorem D.1 (EDH is Hard in Generic Groups)</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be an algorithm that solves the EDH problem in the generic group model, making a total of <span class="math">q_{G}</span> queries to the oracles computing the group action in <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T}</span>, the oracle computing the bilinear pairing <span class="math">e</span>, and oracle <span class="math">O_{x}(\\cdot)</span>. If <span class="math">x\\in\\mathbb{Z}_{p}^{<em>}</span> and <span class="math">\\xi_{1},\\xi_{2},\\xi_{T}</span> are chosen at random, then the probability <span class="math">\\varepsilon</span> that <span class="math">\\mathcal{A}^{O_{x}}(p,\\xi_{1}(1),\\xi_{1}(x),\\xi_{2}(1),\\xi_{2}(x))</span> outputs <span class="math">(c,\\xi_{1}(r),\\xi_{1}(r\\cdot x),\\xi_{1}(r\\cdot v),\\xi_{2}(\\frac{1}{x+v}),\\xi_{2}(\\frac{1}{v+c}))</span> with <span class="math">c\\in\\mathbb{Z}_{p}^{</em>}</span> not previously queried to <span class="math">O_{x}</span>, is bounded by</p>

    <p class="text-gray-300"><span class="math">\\varepsilon\\leq\\frac{(q_{G}+4)^{2}(8q+8)}{p}=O\\left(\\frac{q_{G}^{3}}{p}\\right).</span></p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider an algorithm <span class="math">\\mathcal{B}</span> that interacts with <span class="math">\\mathcal{A}</span> in the following game.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span> maintains three lists of pairs <span class="math">L_{1}=\\{(F_{1,i},\\xi_{1,i}):i=0,\\ldots,\\tau_{1}-1\\}</span>, <span class="math">L_{2}=\\{(F_{2,i},\\xi_{2,i}):i=0,\\ldots,\\tau_{2}-1\\}</span>, <span class="math">L_{T}=\\{(F_{T,i},\\xi_{T,i}):i=0,\\ldots,\\tau_{T}-1\\}</span>, such that, at step <span class="math">\\tau</span> in the game, we have <span class="math">\\tau_{1}+\\tau_{2}+\\tau_{T}=\\tau+4</span>. The only twist between our setup and that of Boneh and Boyen is that we will let the <span class="math">F_{1,i},F_{2,i}</span> and <span class="math">F_{T,i}</span>’s be <em>rational functions</em> (i.e, fractions whose numerators and denominators are polynomials); and</p>

    <p class="text-gray-300">all polynomials are multivariate polynomials in <span class="math">\\mathbb{Z}_p[x,\\ldots]</span> where additional variables will be dynamically added. The <span class="math">\\xi_{1,i}</span>, <span class="math">\\xi_{2,i}</span>, and <span class="math">\\xi_{T,i}</span> are set to unique random strings in <span class="math">\\{0,1\\}^*</span>. Of course, we start the EDH game at step <span class="math">\\tau = 0</span> with <span class="math">\\tau_1 = 2</span>, <span class="math">\\tau_2 = 2</span>, and <span class="math">\\tau_T = 0</span>. These correspond to the polynomials <span class="math">F_{1,0} = F_{2,0} = 1</span> and <span class="math">F_{1,1} = F_{2,1} = x</span>, and the random strings <span class="math">\\xi_{1,0}, \\xi_{1,1}, \\xi_{2,0}, \\xi_{2,1}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span> begins the game with <span class="math">\\mathcal{A}</span> by providing it with the 4 strings <span class="math">\\xi_{1,0}, \\xi_{1,1}, \\xi_{2,0}, \\xi_{2,1}</span>. Now, we describe the oracles <span class="math">\\mathcal{A}</span> may query.</p>

    <p class="text-gray-300"><strong>Group action:</strong> <span class="math">\\mathcal{A}</span> inputs two group elements <span class="math">\\xi_{1,i}</span> and <span class="math">\\xi_{1,j}</span>, where <span class="math">0 \\leq i,j &amp;lt; \\tau_1</span>, and a request to multiply/divide. <span class="math">\\mathcal{B}</span> sets <span class="math">F_{1,\\tau_1} \\gets F_{1,i} \\pm F_{1,j}</span>. If <span class="math">F_{1,\\tau_1} = F_{1,u}</span> for some <span class="math">u \\in \\{0,\\dots,\\tau_1 - 1\\}</span>, then <span class="math">\\mathcal{B}</span> sets <span class="math">\\xi_{1,\\tau_1} = \\xi_{1,u}</span>; otherwise, it sets <span class="math">\\xi_{1,\\tau_1}</span> to a random string in <span class="math">\\{0,1\\}^* \\setminus \\{\\xi_{1,0},\\dots,\\xi_{1,\\tau_1 - 1}\\}</span>. Finally, <span class="math">\\mathcal{B}</span> returns <span class="math">\\xi_{1,\\tau_1}</span> to <span class="math">\\mathcal{A}</span>, adds <span class="math">(F_{1,\\tau_1},\\xi_{1,\\tau_1})</span> to <span class="math">L_1</span>, and increments <span class="math">\\tau_1</span>. Group actions for <span class="math">\\mathbb{G}_2</span> and <span class="math">\\mathbb{G}_T</span> are handled the same way.</p>

    <p class="text-gray-300"><strong>Pairing:</strong> <span class="math">\\mathcal{A}</span> inputs two group elements <span class="math">\\xi_{1,i}</span> and <span class="math">\\xi_{2,j}</span>, where <span class="math">0 \\leq i &amp;lt; \\tau_1</span> and <span class="math">0 \\leq j &amp;lt; \\tau_2</span>. <span class="math">\\mathcal{B}</span> sets <span class="math">F_{T,\\tau_T} \\gets F_{1,i} \\cdot F_{2,j}</span>. If <span class="math">F_{T,\\tau_T} = F_{T,u}</span> for some <span class="math">u \\in \\{0,\\dots,\\tau_T - 1\\}</span>, then <span class="math">\\mathcal{B}</span> sets <span class="math">\\xi_{T,\\tau_T} = \\xi_{T,u}</span>; otherwise, it sets <span class="math">\\xi_{T,\\tau_T}</span> to a random string in <span class="math">\\{0,1\\}^* \\setminus \\{\\xi_{T,0},\\dots,\\xi_{T,\\tau_T - 1}\\}</span>. Finally, <span class="math">\\mathcal{B}</span> returns <span class="math">\\xi_{T,\\tau_T}</span> to <span class="math">\\mathcal{A}</span>, adds <span class="math">(F_{T,\\tau_T},\\xi_{T,\\tau_T})</span> to <span class="math">L_T</span>, and increments <span class="math">\\tau_T</span>.</p>

    <p class="text-gray-300"><strong>Oracle <span class="math">O_x(\\cdot)</span>:</strong> Let <span class="math">\\tau_v</span> be a counter initialized to 1. <span class="math">\\mathcal{A}</span> inputs <span class="math">c</span> in <span class="math">\\mathbb{Z}_p^<em></span>, followed by <span class="math">\\mathcal{B}</span> choosing a new variable <span class="math">v_{\\tau_v}</span> and setting <span class="math">F_{1,\\tau_1} \\gets v_{\\tau_v}</span>. If <span class="math">F_{1,\\tau_1} = F_{1,u}</span> for some <span class="math">u \\in \\{0, \\dots, \\tau_1 - 1\\}</span>, then <span class="math">\\mathcal{B}</span> sets <span class="math">\\xi_{1,\\tau_1} = \\xi_{1,u}</span>; otherwise, it sets <span class="math">\\xi_{1,\\tau_1}</span> to a random string in <span class="math">\\{0,1\\}^</em> \\setminus \\{\\xi_{1,0}, \\dots, \\xi_{1,\\tau_1 - 1}\\}</span>. <span class="math">\\mathcal{B}</span> sends <span class="math">\\xi_{1,\\tau_1}</span> to <span class="math">\\mathcal{A}</span>, adding <span class="math">(F_{1,\\tau_1}, \\xi_{1,\\tau_1})</span> to <span class="math">L_1</span>.</p>

    <p class="text-gray-300">Next, <span class="math">\\mathcal{B}</span> set <span class="math">F_{2,\\tau_2} \\gets 1 / (x + v_{\\tau_v})</span> and <span class="math">F_{2,\\tau_2 + 1} \\gets 1 / (v_{\\tau_v} + m)</span>. For <span class="math">j \\in \\{0,1\\}</span>, if <span class="math">F_{2,\\tau_2 + j} = F_{2,u}</span> for some <span class="math">u \\in \\{0,\\dots,\\tau_2 - 1 + j\\}</span>, then <span class="math">\\mathcal{B}</span> sets <span class="math">\\xi_{2,\\tau_2 + j} = \\xi_{2,u}</span>; otherwise, it sets <span class="math">\\xi_{2,\\tau_2 + j}</span> to a random string in <span class="math">\\{0,1\\}^* \\setminus \\{\\xi_{2,0},\\dots,\\xi_{2,\\tau_2 - 1 + j}\\}</span>. <span class="math">\\mathcal{B}</span> sends <span class="math">(\\xi_{2,\\tau_2},\\xi_{2,\\tau_2 + 1})</span> to <span class="math">\\mathcal{A}</span>, adding <span class="math">(F_{2,\\tau_2},\\xi_{2,\\tau_2})</span> and <span class="math">(F_{2,\\tau_2 + 1},\\xi_{2,\\tau_2 + 1})</span> to <span class="math">L_2</span>.</p>

    <p class="text-gray-300">Finally, <span class="math">\\mathcal{B}</span> adds one to <span class="math">\\tau_{1}</span>, two to <span class="math">\\tau_{2}</span>, and one to <span class="math">\\tau_{v}</span>.</p>

    <p class="text-gray-300">We assume SXDH holds in <span class="math">(\\mathbb{G}_1,\\mathbb{G}_2,\\mathbb{G}_T)</span> and therefore no isomorphism oracles exist.</p>

    <p class="text-gray-300">Eventually <span class="math">\\mathcal{A}</span> stops and outputs a tuple of elements <span class="math">(c, \\xi_{1,a}, \\xi_{1,b}, \\xi_{1,k}, \\xi_{2,d}, \\xi_{2,f})</span>, where <span class="math">0 \\leq a, b, k &amp;lt; \\tau_1</span> and <span class="math">0 \\leq d, f &amp;lt; \\tau_2</span>. To later test the correctness of <span class="math">\\mathcal{A}</span>'s output within the framework of this game, <span class="math">\\mathcal{B}</span> computes the polynomials:</p>

    <div class="my-4 text-center"><span class="math-block">F_{T,*} = \\left(\\frac{F_{1,k}}{F_{1,a}} + x\\right) \\cdot F_{2,d} - 1. \\tag{1}</span></div>

    <div class="my-4 text-center"><span class="math-block">F_{T,\\circ} = \\left(\\frac{F_{1,k}}{F_{1,a}} + c\\right) \\cdot F_{2,f} - 1. \\tag{2}</span></div>

    <p class="text-gray-300">Intuitively, this correspond to the equalities “<span class="math">e(h^x h^v, \\tilde{g}^{1/(x+v)}) = e(h, \\tilde{g}) = e(h^v h^c, \\tilde{g}^{1/(v+c)})</span>”, where <span class="math">h</span> denotes the element of <span class="math">\\mathbb{G}_1</span> represented by <span class="math">\\xi_{1,a}</span>, <span class="math">h^v</span> denotes the element of <span class="math">\\mathbb{G}_1</span> represented by <span class="math">\\xi_{1,k}</span>, <span class="math">\\tilde{g}^{1/(x+v)}</span> denotes the element of <span class="math">\\mathbb{G}_2</span> represented by <span class="math">\\xi_{2,d}</span>, and <span class="math">\\tilde{g}^{1/(v+c)}</span> denotes the element of <span class="math">\\mathbb{G}_2</span> represented by <span class="math">\\xi_{2,f}</span>.</p>

    <p class="text-gray-300"><strong>Analysis of <span class="math">\\mathcal{A}</span>'s Output.</strong> For <span class="math">\\mathcal{A}</span>'s response to always be correct, then it must be the case that <span class="math">F_{T,*}(x) = F_{T,\\circ}(x) = 0</span> for any value of <span class="math">x</span>. We now argue that it is impossible for <span class="math">\\mathcal{A}</span> to achieve this. Each output polynomial must be some linear combination of polynomials corresponding to elements available to <span class="math">\\mathcal{A}</span> in</p>

    <p class="text-gray-300">26</p>

    <p class="text-gray-300">the respective groups:</p>

    <p class="text-gray-300"><span class="math">F_{1,a}=a_{0}+a_{1}x+\\sum_{i=1}^{q}a_{2,i}v_{i}</span> (3) <span class="math">F_{1,b}=b_{0}+b_{1}x+\\sum_{i=1}^{q}b_{2,i}v_{i}</span> (4) <span class="math">F_{1,k}=k_{0}+k_{1}x+\\sum_{i=1}^{q}k_{2,i}v_{i}</span> (5) <span class="math">F_{2,d}=d_{0}+d_{1}x+\\sum_{i=1}^{q}\\frac{d_{2,i}}{x+v_{i}}+\\sum_{i=1}^{q}\\frac{d_{3,i}}{v_{i}+c_{i}}</span> (6) <span class="math">F_{2,f}=f_{0}+f_{1}x+\\sum_{i=1}^{q}\\frac{f_{2,i}}{x+v_{i}}+\\sum_{i=1}^{q}\\frac{f_{3,i}}{v_{i}+c_{i}}</span> (7)</p>

    <p class="text-gray-300">where <span class="math">q</span> is the number of queries to oracle <span class="math">Q_{x}</span>. Now, we know, by definition, that <span class="math">F_{1,b}/F_{1,a}=x</span>, thus one can verify, using equations (3) and (4), that <span class="math">a_{1}=a_{2,i}=0</span> and <span class="math">F_{1,a}=a_{0}</span> is a constant.</p>

    <p class="text-gray-300">Notation: For readability of our later analysis, we denote the following values, where constant values <span class="math">y_{0}=b_{0}/a_{0},y_{1}=b_{1}/a_{0}+1,y_{2,i}=b_{2,i}/a_{0}</span>:</p>

    <p class="text-gray-300"><span class="math">Y=(F_{1,k}/a_{0}+x)=y_{0}+y_{1}x+\\sum_{i=1}^{q}y_{2,i}v_{i}</span> (8) <span class="math">Z=(F_{1,k}/a_{0}+c)=c+y_{0}+(y_{1}-1)x+\\sum_{i=1}^{q}y_{2,i}v_{i}</span> (9)</p>

    <p class="text-gray-300">We also give names to the following frequently-used products:</p>

    <p class="text-gray-300"><span class="math">P=\\prod_{j=1}^{q}(x+v_{j})\\quad\\text{and}\\quad P_{i\\neq j}=\\prod_{i\\neq j}^{q}(x+v_{j})</span> (10) <span class="math">Q=\\prod_{j=1}^{q}(v_{j}+c_{j})\\quad\\text{and}\\quad Q_{i\\neq j}=\\prod_{i\\neq j}^{q}(v_{j}+c_{j})</span> (11)</p>

    <p class="text-gray-300">Using our above notation, consider the polynomials <span class="math">F_{2,*}</span> and <span class="math">F_{T,\\circ}</span> from equations (1) and (2) when both sides are multiplied by <span class="math">PQ</span> and we substitute in equations (6), (7), (8), and (9). For some constants <span class="math">d_{i}</span> and <span class="math">f_{i}</span>, the new polynomials:</p>

    <p class="text-gray-300"><span class="math">PQF_{T,*}=0=d_{0}YPQ+d_{1}xYPQ+\\sum_{i=1}^{q}d_{2,i}YP_{i\\neq j}Q+\\sum_{i=1}^{q}d_{3,i}YPQ_{i\\neq j}-PQ</span> (13) <span class="math">PQF_{T,\\circ}=0=f_{0}ZPQ+f_{1}xZPQ+\\sum_{i=1}^{q}f_{2,i}ZP_{i\\neq j}Q+\\sum_{i=1}^{q}f_{3,i}ZPQ_{i\\neq j}-PQ</span> (14)</p>

    <p class="text-gray-300">Now, we inspect equations (13) and (14). We consider two cases.</p>

    <p class="text-gray-300"><span class="math">y_{1}=0</span>. Then we have <span class="math">Z=c+y_{0}-x+\\sum_{i=1}^{q}y_{2,i}v_{i}</span>. Now, we inspect the terms of equation (14). We deduce that <span class="math">f_{1}=0</span>, because it is the only term containing <span class="math">x^{q+2}\\prod_{i=1}^{q}v_{i}</span>. Then, <span class="math">f_{0}=0</span>, because it is the only term containing <span class="math">x^{q+1}\\prod_{i=1}^{q}v_{i}</span>. Next, each <span class="math">f_{3,i}=0</span>, because they have unique terms <span class="math">x^{q+1}\\prod_{i\\neq j}v_{j}</span>. We are left with <span class="math">0=\\sum_{i=1}^{q}f_{2,i}ZP_{i\\neq j}Q-PQ</span>. We divide by <span class="math">Q</span>, and the result is <span class="math">0=\\sum_{i=1}^{q}f_{2,i}ZP_{i\\neq j}-P</span>. It follows then that at least one <span class="math">f_{2,i}</span> must be non-zero for the equation to be solvable; denote the first non-zero <span class="math">f_{2,i}</span> as <span class="math">f_{2,\\beta}</span>.</p>

    <p class="text-gray-300">Now, suppose some constant <span class="math">y_{2,i}\\neq 0</span> in <span class="math">Z</span>, meaning that <span class="math">Z</span> contains a <span class="math">v_{i}</span> term. If <span class="math">\\beta\\neq i</span>, then <span class="math">y_{2,i}ZP_{i\\neq j}</span> contains a unique term <span class="math">v_{i}^{2}\\prod_{i\\neq j\\neq\\alpha}v_{j}</span> that cannot be canceled. Thus, <span class="math">y_{2,i}=0</span>, and furthermore <span class="math">f_{2,i}</span>, for all <span class="math">i\\neq\\beta</span>. Now we are left with the equation <span class="math">0=f_{2,\\beta}(c+y_{0}-x+y_{2,\\beta}v_{\\beta})P_{\\beta\\neq j}-P</span>, we divide out <span class="math">P_{\\beta\\neq j}</span> and observe that <span class="math">f_{2,\\beta}=-1</span>, to get <span class="math">0=-(c+y_{0}-x+y_{2,\\beta}v_{\\beta})-(x+v_{\\beta})</span>.</p>

    <p class="text-gray-300">Now, since <span class="math">c,y_{0},y_{2,\\beta}</span> are all constants and <span class="math">v_{\\beta}</span> is a variable, we conclude that <span class="math">y_{2,\\beta}=1</span> and <span class="math">c=-y_{0}</span>. That means that <span class="math">Y=y_{0}+v_{\\beta}</span>, where <span class="math">y_{0}\\neq 0</span>. Plugging back into equation (13), we have <span class="math">d_{1}=0</span> due to unique <span class="math">x^{q+1}</span> term, then it must be the case that <span class="math">d_{0}=0</span> due to <span class="math">x^{q}v_{\\beta}\\prod_{i=1}^{q}v_{i}</span>. Next, it must be that <span class="math">d_{3,i}=0</span> for all <span class="math">i\\neq\\beta</span> due to unique <span class="math">x^{q}v_{\\beta}^{2}\\prod_{j\\neq i\\neq\\beta}v_{j}</span>. Next, we see that terms corresponding to <span class="math">d_{3,\\beta}YPQ_{\\beta\\neq j}=d_{3,\\beta}(y_{0}+v_{\\beta})PQ_{\\beta\\neq j}</span> and <span class="math">PQ</span> are the only two left with a <span class="math">x^{q}</span> term; thus, <span class="math">d_{3,\\beta}\\neq 0</span>. Further, cancelling the term <span class="math">x^{q}\\prod_{i=1}^{q}v_{i}</span> from <span class="math">PQ</span> requires that <span class="math">d_{3,1}=1</span>. Thus, we find that to cancel all related <span class="math">x^{q}</span> terms, it must be that <span class="math">c=c_{\\beta}</span>. Since <span class="math">c</span>, which represents the message corresponding to <span class="math">\\mathcal{A}</span>’s signature, is an old value, this is not a valid forgery. <span class="math">y_{1}\\neq 0</span>. Now <span class="math">Y</span> contains an <span class="math">x</span> term, and we inspect equation (13). We deduce that <span class="math">d_{1}=0</span>, because it is the only term containing <span class="math">x^{q+2}\\prod_{i=1}^{q}v_{i}</span>. Then, <span class="math">d_{0}=0</span>, because it is the only term containing <span class="math">x^{q+1}\\prod_{i=1}^{q}v_{i}</span>. Next, each <span class="math">d_{3,i}=0</span>, because they have unique terms <span class="math">x^{q+1}\\prod_{i\\neq j}v_{j}</span>. We are left with <span class="math">0=\\sum_{i=1}^{q}d_{2,i}YP_{i\\neq j}Q-PQ</span>. We divide by <span class="math">Q</span>, and the result is <span class="math">0=\\sum_{i=1}^{q}d_{2,i}YP_{i\\neq j}-P</span>. To satisfy this equation, for some <span class="math">d_{2,i}</span>, we must have <span class="math">d_{2,i}\\neq 0</span>. We denote this value <span class="math">d_{2,\\beta}</span>.</p>

    <p class="text-gray-300">From this point, we proceed in a fashion similar to case 1. By inspecting the above equation, we find that <span class="math">y_{0}=0</span>, and for all <span class="math">i\\neq\\beta</span>, <span class="math">y_{2,i}=0</span>, otherwise there exist unique terms: e.g., <span class="math">v_{\\beta}\\prod_{\\beta\\neq j}^{q}v_{j}</span>. Furthermore, <span class="math">d_{2,\\beta}y_{1}=1</span>, since the <span class="math">x^{q}</span> term of <span class="math">P</span> has coefficient 1. And, <span class="math">d_{2,\\beta}y_{2,\\beta}=1</span>, since the <span class="math">\\prod_{i=1}^{q}v_{i}</span> term of <span class="math">P</span> has coefficient 1. So, <span class="math">y_{1}=y_{2,\\beta}=1/d_{2,\\beta}</span> and we plug into <span class="math">Z</span> as <span class="math">Z=c+(1/d_{2,\\beta}-1)x+v_{\\beta}/d_{2,\\beta}</span>.</p>

    <p class="text-gray-300">From equation (14), we have that <span class="math">f_{1}=0</span> due to <span class="math">x^{q+1}\\prod_{i=1}^{q}v_{i}</span>, <span class="math">f_{0}=0</span> due to <span class="math">v_{\\beta}x^{q}\\prod_{i=1}^{q}v_{i}</span>. For all <span class="math">i\\neq\\beta</span>, <span class="math">f_{3,i}=0</span>, otherwise unique terms <span class="math">v_{\\beta}^{2}x^{q}\\prod_{i\\neq j\\neq\\beta}v_{j}</span> appear. Given that all <span class="math">f_{3,i}=0</span> except for <span class="math">f_{3,\\beta}</span>, it follows all <span class="math">f_{2,i}=0</span> except for <span class="math">f_{2,\\beta}</span> due to unique terms containing <span class="math">v_{i}^{3}</span> for <span class="math">i\\neq\\beta</span>. Thus, we now have the equation <span class="math">0=f_{2,\\beta}ZP_{\\beta\\neq j}Q+f_{3,\\beta}ZPQ_{\\beta\\neq j}-PQ</span>. We divide by <span class="math">P_{\\beta\\neq j}Q_{\\beta\\neq j}</span> to obtain <span class="math">0=f_{2,\\beta}Z(v_{\\beta}+c_{\\beta})+f_{3,\\beta}Z(x+v_{\\beta})-(x+v_{\\beta})(v_{\\beta}+c_{\\beta})</span>.</p>

    <p class="text-gray-300">Now, suppose <span class="math">d_{2,\\beta}=1</span> and thus <span class="math">Z=(c+v_{\\beta})</span>. Then we know that <span class="math">f_{3,\\beta}=1</span> to cancel the term <span class="math">xv_{\\beta}</span>; this forces <span class="math">f_{2,\\beta}=0</span> because the <span class="math">v_{\\beta}^{2}</span> term is already canceled in whole by the <span class="math">f_{3,\\beta}</span> component. Thus, it is immediate that <span class="math">c=c_{\\beta}</span>, which is not a valid forgery.</p>

    <p class="text-gray-300">On the other hand, suppose <span class="math">d_{2,\\beta}\\neq 1</span> and thus <span class="math">Z</span> contains an <span class="math">x</span> term. Then, we know that <span class="math">f_{3,\\beta}=0</span>, because its <span class="math">x^{2}</span> term would be unique. This forces <span class="math">c=0</span> because otherwise the constant term <span class="math">f_{2,\\beta}cc_{\\beta}</span> would be unique. However, <span class="math">c</span> must be an element in <span class="math">\\mathbb{Z}_{p}^{*}</span>, and thus this is also not a valid forgery.</p>

    <p class="text-gray-300">Thus, we conclude that <span class="math">\\mathcal{A}</span>’s success depends solely on his luck when the variables are instantiated.</p>

    <p class="text-gray-300">Analysis of <span class="math">\\mathcal{B}</span>’s Simulation. At this point <span class="math">\\mathcal{B}</span> chooses a random <span class="math">x^{<em>}\\in\\mathbb{Z}_{p}^{</em>}</span>. <span class="math">\\mathcal{B}</span> now tests (in equations 15,16,17) if its simulation was perfect; that is, if the instantiation of <span class="math">x</span> by <span class="math">x^{*}</span> does not create any</p>

    <p class="text-gray-300">equality relation among the polynomials that was not revealed by the random strings provided to <span class="math">\\mathcal{A}</span>. <span class="math">\\mathcal{B}</span> also tests (in equations 18, 19) whether or not <span class="math">\\mathcal{A}</span>’s output was correct. Thus, <span class="math">\\mathcal{A}</span>’s overall success is bounded by the probability that any of the following holds:</p>

    <p class="text-gray-300"><span class="math">F_{1,i}(x^{<em>})-F_{1,j}(x^{</em>})</span> <span class="math">=0,\\quad\\text{for some </span>i,j<span class="math"> such that </span>F_{1,i}\\neq F_{1,j}<span class="math">},</span> (15) <span class="math">F_{2,i}(x^{<em>})-F_{2,j}(x^{</em>})</span> <span class="math">=0,\\quad\\text{for some </span>i,j<span class="math"> such that </span>F_{2,i}\\neq F_{2,j}<span class="math">},</span> (16) <span class="math">F_{T,i}(x^{<em>})-F_{T,j}(x^{</em>})</span> <span class="math">=0,\\quad\\text{for some </span>i,j<span class="math"> such that </span>F_{T,i}\\neq F_{T,j}<span class="math">},</span> (17) <span class="math">F_{T,<em>}(x^{</em>})</span> <span class="math">=0,</span> (18) <span class="math">F_{T,\\circ}(x^{*})</span> <span class="math">=0.</span> (19)</p>

    <p class="text-gray-300">We observe that <span class="math">F_{T,*}</span> and <span class="math">F_{T,\\circ}</span> are non-trivial polynomials of degree at most <span class="math">\\leq 2q+2</span>. Each polynomial <span class="math">F_{1,i}</span> and <span class="math">F_{2,i}</span> has degree at most <span class="math">1</span> and <span class="math">2q+1</span>, respectively.</p>

    <p class="text-gray-300">For fixed <span class="math">i</span> and <span class="math">j</span>, the first case occurs with probability <span class="math">\\leq 1/p</span>; the second occurs with probability <span class="math">\\leq(2q+1)/p</span>; and the third occurs with probability <span class="math">\\leq(2q+2)/p</span>. (We already take into account multiplying out the denominators of any rational polynomials.) Finally, the fourth and fifth cases happen with probability <span class="math">\\leq(2q+2)/p</span>. Now summing over all <span class="math">(i,j)</span> pairs in each case, we bound <span class="math">\\mathcal{A}</span>’s overall success probability <span class="math">\\varepsilon\\leq\\binom{\\tau_{1}}{2}\\frac{1}{p}+\\binom{\\tau_{2}}{2}\\frac{2q+1}{p}+\\binom{\\tau_{T}}{2}\\frac{2q+2}{p}+\\frac{2(2q+2)}{p}</span>. Since <span class="math">\\tau_{1}+\\tau_{2}+\\tau_{T}\\leq q_{G}+4</span>, we end with <span class="math">\\varepsilon\\leq(q_{G}+4)^{2}(8q+8)/p)=O(q_{G}^{3}/p)</span>. ∎</p>

    <p class="text-gray-300">The following corollary is immediate.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Corollary D.2</h6>

    <p class="text-gray-300">Any adversary that breaks the EDH assumption with constant probability <span class="math">\\varepsilon&gt;0</span> in generic groups of order <span class="math">p</span> such that <span class="math">q&lt;o(\\sqrt[3]{p})</span> requires <span class="math">\\Omega(\\sqrt{\\varepsilon p/q})</span> generic group operations.</p>

    <p class="text-gray-300">We now turn our attention from a computational to a decisional problem. Recall from Section 2 that the Strong SXDH assumption involves oracle <span class="math">O_{x}(\\cdot)</span> that take as input a value <span class="math">m\\in\\mathbb{Z}_{p}^{<em>}</span> and returns <span class="math">(g^{v},\\tilde{g}^{1/(x+v)},\\tilde{g}^{1/(v+m)})</span> for <span class="math">v\\in\\mathbb{Z}_{p}^{</em>}</span> randomly chosen by the oracle, and an oracle <span class="math">Q_{y}(\\cdot)</span> that takes the same type of input and returns <span class="math">(a,a^{y},a^{v},\\tilde{g}^{1/(y+v)},\\tilde{g}^{1/(v+m)})</span>, for <span class="math">a\\in\\mathbb{G}_{1}</span> and <span class="math">v\\in\\mathbb{Z}_{p}^{*}</span> chosen randomly by the oracle. These random values are freshly chosen at each invocation of the oracle.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Theorem D.3 (Strong SXDH is Hard in Generic Groups)</h6>

    <p class="text-gray-300">Let <span class="math">x\\in\\mathbb{Z}_{p^{<em>}}^{</em>}~{}b\\in\\{0,1\\}</span>, and <span class="math">\\xi_{1},\\xi_{2}</span>, <span class="math">\\xi_{T}</span> be chosen at random. Also, if <span class="math">b=1</span>, set <span class="math">y=x</span>, but if <span class="math">b=0</span>, then set <span class="math">y</span> to be a value selected randomly from <span class="math">\\mathbb{Z}_{p}^{*}\\setminus x</span>. Let <span class="math">\\mathcal{A}</span> be an algorithm that solves the Strong SXDH problem in the generic group model, making a total of <span class="math">q_{G}</span> queries to the oracles computing the group action in <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T}</span>, the oracle computing the bilinear pairing <span class="math">e</span>, and the two oracles <span class="math">O_{x}(\\cdot)</span> and <span class="math">Q_{y}(\\cdot)</span> as described above. Then the probability <span class="math">\\varepsilon</span> that <span class="math">\\mathcal{A}(p,\\xi_{1}(1),\\xi_{1}(x),\\xi_{2}(1))=b</span> is bounded by</p>

    <p class="text-gray-300"><span class="math">\\varepsilon\\leq\\frac{1}{2}+\\frac{(q_{G}+3)^{2}(3q_{G})}{p}=\\frac{1}{2}+O\\left(\\frac{q_{G}^{3}}{p}\\right).</span></p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span> maintains the lists <span class="math">L_{1}</span>, <span class="math">L_{2}</span>, and <span class="math">L_{T}</span> as in the proof of Theorem D.1. (Consider the bit <span class="math">b</span> as not yet set.) At step <span class="math">\\tau</span> in the game, we now have <span class="math">\\tau_{1}+\\tau_{2}+\\tau_{T}=\\tau+3</span>, where at <span class="math">\\tau=0</span>, we set <span class="math">\\tau_{1}=2</span>, <span class="math">\\tau_{2}=1</span>, and <span class="math">\\tau_{T}=0</span>. These correspond to the polynomials <span class="math">F_{1,0}=F_{2,0}=1</span> and <span class="math">F_{1,1}=x</span>. <span class="math">\\mathcal{B}</span> also selects unique, random strings <span class="math">\\xi_{1,0},\\xi_{1,1}</span>, and <span class="math">\\xi_{2,0}</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span> begins the game with <span class="math">\\mathcal{A}</span> by providing it with the strings <span class="math">\\xi_{1,0},\\xi_{1,1}</span>, and <span class="math">\\xi_{2,0}</span>. <span class="math">\\mathcal{A}</span> may, at any time, make the group action or pairing queries as in the proof of Theorem D.1. <span class="math">\\mathcal{A}</span> may additionally query the following two oracles. Let <span class="math">\\tau_{v}=1</span> and <span class="math">\\tau_{w}=1</span> be counters.</p>

    <p class="text-gray-300">Oracle <span class="math">O_{x}(\\cdot)</span>: <span class="math">\\mathcal{A}</span> inputs <span class="math">m</span> in <span class="math">\\mathbb{Z}_{p}^{<em>}</span>, followed by <span class="math">\\mathcal{B}</span> choosing a new variable <span class="math">v_{\\tau_{v}}</span> and setting <span class="math">F_{1,\\tau_{1}}\\leftarrow v_{\\tau_{v}}</span>. If <span class="math">F_{1,\\tau_{1}}=F_{1,u}</span> for some <span class="math">u\\in\\{0,\\ldots,\\tau_{1}-1\\}</span>, then <span class="math">\\mathcal{B}</span> sets <span class="math">\\xi_{1,\\tau_{1}}=\\xi_{1,u}</span>; otherwise, it sets <span class="math">\\xi_{1,\\tau_{1}}</span> to a random string in <span class="math">\\{0,1\\}^{</em>}\\setminus\\{\\xi_{1,0},\\ldots,\\xi_{1,\\tau_{1}-1}\\}</span>. <span class="math">\\mathcal{B}</span> sends <span class="math">\\xi_{1,\\tau_{1}}</span> to <span class="math">\\mathcal{A}</span>, adding <span class="math">(F_{1,\\tau_{1}},\\xi_{1,\\tau_{1}})</span> to <span class="math">L_{1}</span>.</p>

    <p class="text-gray-300">Next, <span class="math">\\mathcal{B}</span> set <span class="math">F_{2,\\tau_{2}}\\leftarrow 1/(x+v_{\\tau_{v}})</span> and <span class="math">F_{2,\\tau_{2}+1}\\leftarrow 1/(v_{\\tau_{v}}+m)</span>. For <span class="math">j\\in\\{0,1\\}</span>, if <span class="math">F_{2,\\tau_{2}+j}=F_{2,u}</span> for some <span class="math">u\\in\\{0,\\ldots,\\tau_{2}-1+j\\}</span>, then <span class="math">\\mathcal{B}</span> sets <span class="math">\\xi_{2,\\tau_{2}+j}=\\xi_{2,u}</span>; otherwise, it sets <span class="math">\\xi_{2,\\tau_{2}+j}</span> to a random string in <span class="math">\\{0,1\\}^{*}\\setminus\\{\\xi_{2,0},\\ldots,\\xi_{2,\\tau_{2}-1+j}\\}</span>. <span class="math">\\mathcal{B}</span> sends <span class="math">(\\xi_{2,\\tau_{2}},\\xi_{2,\\tau_{2}+1})</span> to <span class="math">\\mathcal{A}</span>, adding <span class="math">(F_{2,\\tau_{2}},\\xi_{2,\\tau_{2}})</span> and <span class="math">(F_{2,\\tau_{2}+1},\\xi_{2,\\tau_{2}+1})</span> to <span class="math">L_{2}</span>.</p>

    <p class="text-gray-300">Finally, <span class="math">\\mathcal{B}</span> adds one to <span class="math">\\tau_{1}</span>, two to <span class="math">\\tau_{2}</span>, and one to <span class="math">\\tau_{v}</span>.</p>

    <p class="text-gray-300">Oracle <span class="math">Q_{y}(\\cdot)</span>: <span class="math">\\mathcal{B}</span> responds similarly, except that it chooses new variables <span class="math">r_{\\tau_{w}}</span> and <span class="math">w_{\\tau_{w}}</span>, and sets <span class="math">F_{1,\\tau_{1}}\\leftarrow r_{\\tau_{w}}</span>, <span class="math">F_{1,\\tau_{1}+1}\\leftarrow r_{\\tau_{w}}\\cdot y</span>, <span class="math">F_{1,\\tau_{1}+2}\\leftarrow r_{\\tau_{w}}\\cdot w_{\\tau_{w}}</span>, <span class="math">F_{2,\\tau_{2}}\\leftarrow 1/(y+w_{\\tau_{w}})</span>, and <span class="math">F_{2,\\tau_{2}+1}\\leftarrow 1/(w_{\\tau_{w}}+m)</span>. At the end, <span class="math">\\mathcal{B}</span> adds three to <span class="math">\\tau_{1}</span>, two to <span class="math">\\tau_{2}</span>, and one to <span class="math">\\tau_{w}</span>.</p>

    <p class="text-gray-300">Eventually <span class="math">\\mathcal{A}</span> stops and outputs a guess <span class="math">b^{\\prime}\\in\\{0,1\\}</span>.</p>

    <p class="text-gray-300">Analysis of <span class="math">\\mathcal{A}</span>’s Output. First, we argue that, provided <span class="math">\\mathcal{B}</span>’s simulation is perfect, the bit <span class="math">b^{\\prime}</span> is independent of <span class="math">b</span>; that is, <span class="math">\\mathcal{A}</span> cannot output a string such that the corresponding polynomial is always equal when <span class="math">x=y</span> (<span class="math">b=1</span>) and non-zero otherwise (<span class="math">b=0</span>). We show this for each group <span class="math">\\mathbb{G}_{1}</span>, <span class="math">\\mathbb{G}_{2}</span>, and <span class="math">\\mathbb{G}_{T}</span>. Showing this for <span class="math">\\mathbb{G}_{T}</span> is the hardest case. Here, we sum over all expressions containing <span class="math">i</span> or <span class="math">j</span>.</p>

    <p class="text-gray-300">Group <span class="math">\\mathbb{G}_{1}</span>: The polynomials corresponding to elements in <span class="math">\\mathbb{G}_{1}</span> that the adversary can compute as a linear combination of elements in its view are:</p>

    <p class="text-gray-300"><span class="math">F_{1,a}=a_{0}+a_{1}\\cdot x+a_{2,i}\\cdot v_{i}+a_{3,j}\\cdot r_{j}+a_{4,j}\\cdot r_{j}\\cdot y+a_{5,j}\\cdot r_{j}\\cdot w_{j}</span> (20)</p>

    <p class="text-gray-300">where <span class="math">i=1</span> to <span class="math">\\tau_{v}</span> and <span class="math">j=1</span> to <span class="math">\\tau_{w}</span>. For <span class="math">F_{1,a}=0</span>, both <span class="math">a_{1}</span> and <span class="math">a_{4,j}</span> must be zero whether <span class="math">y</span> is replaced by <span class="math">x</span> or not; otherwise those terms cannot be canceled. The remaining polynomial does not contain the variables <span class="math">x</span> or <span class="math">y</span>.</p>

    <p class="text-gray-300">Group <span class="math">\\mathbb{G}_{2}</span>: The polynomials corresponding to elements in <span class="math">\\mathbb{G}_{2}</span> that the adversary can compute as a linear combination of elements in its view are:</p>

    <p class="text-gray-300"><span class="math">F_{2,b}=b_{0}+\\frac{b_{1,i}}{x+v_{i}}+\\frac{b_{2,i}}{v_{i}+m_{i}}+\\frac{b_{3,j}}{y+w_{j}}+\\frac{b_{4,j}}{w_{j}+m_{j}}</span> (21)</p>

    <p class="text-gray-300">where <span class="math">i=1</span> to <span class="math">\\tau_{v}</span>, <span class="math">j=1</span> to <span class="math">\\tau_{w}</span>, and each <span class="math">m_{i},m_{j}\\in\\mathbb{Z}_{p}^{*}</span> was chosen by the adversary. Suppose <span class="math">F_{2,b}=0</span>. We multiply out the denominators in equation (21) to obtain:</p>

    <p class="text-gray-300"><span class="math">F_{2,b}^{\\prime}</span> <span class="math">=</span> <span class="math">b_{0}(x+v_{i})(v_{i}+m_{i})(y+w_{j})(w_{j}+m_{j})+</span> (22) <span class="math">b_{1,i}(v_{i}+m_{i})(y+w_{j})(w_{j}+m_{j})+b_{2,i}(x+v_{i})(y+w_{j})(w_{j}+m_{j})+</span> <span class="math">b_{3,j}(x+v_{i})(v_{i}+m_{i})(w_{j}+m_{j})+b_{4,j}(x+v_{i})(v_{i}+m_{i})(y+w_{j})</span></p>

    <p class="text-gray-300">Now, for <span class="math">F_{b,2}^{\\prime}=0</span>, regardless of whether we substitute <span class="math">x</span> for <span class="math">y</span>, we see that <span class="math">b_{0}=0</span>, otherwise the term <span class="math">xv_{i}yw_{j}</span> (or <span class="math">x^{2}v_{i}w_{j}</span>) cannot be canceled. Similarly, <span class="math">b_{1,i}=0</span> because of the unique summand <span class="math">xv_{i}y</span> (or <span class="math">x^{2}v_{i}</span>), which makes <span class="math">b_{2,i}=0</span> because of the summand <span class="math">v_{i}^{2}w_{j}</span>. Then, <span class="math">b_{3,j}=0</span> because of the summand <span class="math">xyw_{j}</span> (or <span class="math">x^{2}w_{j}</span>), which makes <span class="math">b_{4,j}=0</span> because of the summand <span class="math">v_{i}w_{j}^{2}</span>. We are left with the constant zero.</p>

    <p class="text-gray-300">Group  <span class="math">\\mathbb{G}_T</span> : The polynomials corresponding to elements in  <span class="math">\\mathbb{G}_T</span>  that the adversary can compute as a linear combination of elements in its view are:</p>

    <div class="my-4 text-center"><span class="math-block">F _ {T, c} = \\sum F _ {1, a} \\cdot F _ {2, b}. \\tag {23}</span></div>

    <p class="text-gray-300">Now, a simple expansion of  <span class="math">F_{T,c}</span>  has thirty terms. Suppose we clear the denominators in  <span class="math">F_{T,c} = 0</span>  by multiplying out by  <span class="math">(x + v_i)(v_i + m_i)(y + w_j)(w_j + m_j)</span> , then we have</p>

    <div class="my-4 text-center"><span class="math-block">F _ {T, c} ^ {\\prime} = \\sum F _ {1, a} \\cdot F _ {2, b} ^ {\\prime}. \\tag {24}</span></div>

    <p class="text-gray-300">Now, each of the terms in  <span class="math">F_{1,a}</span>  is unique and  <span class="math">F_{2,b}&#x27;</span>  contains the following unique summands ( <span class="math">xv_i yw_j</span> ,  <span class="math">xv_i y</span> ,  <span class="math">v_i^2 w_j</span> ,  <span class="math">xyw_j</span> ,  <span class="math">v_i w_j^2</span> ). (Here, the summands  <span class="math">v_i^2 w_j</span>  and  <span class="math">v_i w_j^2</span>  are actually not unique, but since they also do not contain  <span class="math">x</span>  or  <span class="math">y</span> , it will not matter.) Multiplying these key components out and dropping the subscript for clarity, we obtain:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} F _ {T, c} ^ {\\prime \\prime} = c _ {0} (v w x y) + c _ {1} (v x y) + c _ {2} (v ^ {2} w) + c _ {3} (w x y) + c _ {4} (v w ^ {2}) \\\\ + c _ {5} \\left(v w x ^ {2} y\\right) + c _ {6} \\left(v x ^ {2} y\\right) + c _ {7} \\left(v ^ {2} w x\\right) + c _ {8} \\left(w x ^ {2} y\\right) + c _ {9} \\left(v w ^ {2} x\\right) \\\\ + c _ {1 0} \\left(v ^ {2} w x y\\right) + c _ {1 1} \\left(v ^ {2} x ^ {2} y\\right) + c _ {1 2} \\left(v ^ {3} w\\right) + c _ {1 3} \\left(v w x y\\right) + c _ {1 4} \\left(v ^ {2} w ^ {2}\\right) \\\\ + c _ {1 5} \\left(v w x y z\\right) + c _ {1 6} \\left(v x y z\\right) + c _ {1 7} \\left(v ^ {2} w z\\right) + c _ {1 8} \\left(w x y z\\right) + c _ {1 9} \\left(v w ^ {2} z\\right) \\\\ + c _ {2 0} \\left(v w x y ^ {2} z\\right) + c _ {2 1} \\left(v x y ^ {2} z\\right) + c _ {2 2} \\left(v ^ {2} w y z\\right) + c _ {2 3} \\left(w x y ^ {2} z\\right) + c _ {2 4} \\left(v w ^ {2} y z\\right) \\\\ + c _ {2 5} \\left(v w ^ {2} x y z\\right) + c _ {2 6} \\left(v w x y z\\right) + c _ {2 7} \\left(v ^ {2} w ^ {2} z\\right) + c _ {2 8} \\left(w ^ {2} x y z\\right) + c _ {2 9} \\left(v w ^ {3} z\\right) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Now, we are only interested in differences in the polynomial  <span class="math">F_{T,c}^{\\prime \\prime}</span>  when  <span class="math">y</span>  is replaced by  <span class="math">x</span>  or not. For clarity, we drop all terms containing neither  <span class="math">x</span>  nor  <span class="math">y</span> , resulting in  <span class="math">c_2 = c_4 = c_{12} = c_{14} = c_{17} = c_{19} = c_{27} = c_{29} = 0</span> . We substitute  <span class="math">x = y</span>  to obtain.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} F _ {T, c} ^ {\\prime \\prime \\prime} = c _ {0} (v w x ^ {2}) + c _ {1} (v x ^ {2}) + c _ {3} (w x ^ {2}) + \\\\ + c _ {5} \\left(v w x ^ {3}\\right) + c _ {6} \\left(v x ^ {3}\\right) + c _ {7} \\left(v ^ {2} w x\\right) + c _ {8} \\left(w x ^ {3}\\right) + c _ {9} \\left(v w ^ {2} x\\right) \\\\ + c _ {1 0} \\left(v ^ {2} w x ^ {2}\\right) + c _ {1 1} \\left(v ^ {2} x ^ {3}\\right) + + c _ {1 3} \\left(v w x ^ {2}\\right) + \\\\ + c _ {1 5} \\left(v w x ^ {2} z\\right) + c _ {1 6} \\left(v x ^ {2} z\\right) + + c _ {1 8} \\left(w x ^ {2} z\\right) + \\\\ + c _ {2 0} \\left(v w x ^ {3} z\\right) + c _ {2 1} \\left(v x ^ {3} z\\right) + c _ {2 2} \\left(v ^ {2} w x z\\right) + c _ {2 3} \\left(w x ^ {3} z\\right) + c _ {2 4} \\left(v w ^ {2} x z\\right) \\\\ + c _ {2 5} \\left(v w ^ {2} x ^ {2} z\\right) + c _ {2 6} \\left(v w x ^ {2} z\\right) + + c _ {2 8} \\left(w ^ {2} x ^ {2} z\\right) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">We want to know if there are any two terms that are symbolically equal when  <span class="math">x = y</span>  and not otherwise. Scanning the above, we see that the only non-unique terms are in positions 0 and 13, and in positions 15 and 26. Looking back to equation (25), we see that both positions 0 and 13 correspond to term  <span class="math">vwx y</span> , and that both positions 15 and 26 correspond to term  <span class="math">vwxyz</span> . Obviously, these terms will be the same regardless of the substitution of  <span class="math">x</span>  for  <span class="math">y</span> . Since all other terms are unique, we conclude that the adversary's only chance of distinguishing comes from a lucky instantiation of these variables.</p>

    <p class="text-gray-300">Analysis of  <span class="math">\\mathcal{B}</span> 's Simulation. At this point  <span class="math">\\mathcal{B}</span>  chooses random values  <span class="math">x^{<em>}, y^{</em>}, \\{v_{d}^{<em>}\\}_{d \\in [1, \\tau_{v}]}</span> ,  <span class="math">\\{w_{d}^{</em>}\\}_{d \\in [1, \\tau_{w}]}</span> ,  <span class="math">\\{r_{d}^{<em>}\\}_{d \\in [1, \\tau_{w}]} \\in \\mathbb{Z}_{p^{</em>}}^{*}</span> .  <span class="math">\\mathcal{B}</span> 's simulation is perfect, and therefore reveals nothing to  <span class="math">\\mathcal{A}</span>  about  <span class="math">b</span> , provided that none</p>

    <p class="text-gray-300">of the following non-trivial equality relations hold:</p>

    <div class="my-4 text-center"><span class="math-block">F _ {1, i} \\left(x ^ {*}, y ^ {*}, \\left\\{v _ {d} ^ {*} \\right\\}, \\left\\{w _ {d} ^ {*} \\right\\}, \\left\\{r _ {d} ^ {*} \\right\\}\\right) - F _ {1, j} \\left(x ^ {*}, y ^ {*}, \\left\\{v _ {d} ^ {*} \\right\\}, \\left\\{w _ {d} ^ {*} \\right\\}, \\left\\{r _ {d} ^ {*} \\right\\}\\right) = 0: \\tag {27}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{for some } i, j, \\text{ such that } F_{1,i} \\neq F_{1,j},</span></div>

    <div class="my-4 text-center"><span class="math-block">F _ {1, i} \\left(x ^ {*}, x ^ {*}, \\left\\{v _ {d} ^ {*} \\right\\}, \\left\\{w _ {d} ^ {*} \\right\\}, \\left\\{r _ {d} ^ {*} \\right\\}\\right) - F _ {1, j} \\left(x ^ {*}, x ^ {*}, \\left\\{v _ {d} ^ {*} \\right\\}, \\left\\{w _ {d} ^ {*} \\right\\}, \\left\\{r _ {d} ^ {*} \\right\\}\\right) = 0: \\tag {28}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{for some } i, j, \\text{ such that } F_{1,i} \\neq F_{1,j},</span></div>

    <div class="my-4 text-center"><span class="math-block">F _ {2, i} \\left(x ^ {*}, y ^ {*}, \\left\\{v _ {d} ^ {*} \\right\\}, \\left\\{w _ {d} ^ {*} \\right\\}, \\left\\{r _ {d} ^ {*} \\right\\}\\right) - F _ {2, j} \\left(x ^ {*}, y ^ {*}, \\left\\{v _ {d} ^ {*} \\right\\}, \\left\\{w _ {d} ^ {*} \\right\\}, \\left\\{r _ {d} ^ {*} \\right\\}\\right) = 0: \\tag {29}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{for some } i, j, \\text{ such that } F_{2,i} \\neq F_{2,j},</span></div>

    <div class="my-4 text-center"><span class="math-block">F _ {2, i} \\left(x ^ {*}, x ^ {*}, \\left\\{v _ {d} ^ {*} \\right\\}, \\left\\{w _ {d} ^ {*} \\right\\}, \\left\\{r _ {d} ^ {*} \\right\\}\\right) - F _ {2, j} \\left(x ^ {*}, x ^ {*}, \\left\\{v _ {d} ^ {*} \\right\\}, \\left\\{w _ {d} ^ {*} \\right\\}, \\left\\{r _ {d} ^ {*} \\right\\}\\right) = 0: \\tag {30}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{for some } i, j, \\text{ such that } F_{2,i} \\neq F_{2,j},</span></div>

    <div class="my-4 text-center"><span class="math-block">F _ {T, i} \\left(x ^ {*}, y ^ {*}, \\left\\{v _ {d} ^ {*} \\right\\}, \\left\\{w _ {d} ^ {*} \\right\\}, \\left\\{r _ {d} ^ {*} \\right\\}\\right) - F _ {T, j} \\left(x ^ {*}, y ^ {*}, \\left\\{v _ {d} ^ {*} \\right\\}, \\left\\{w _ {d} ^ {*} \\right\\}, \\left\\{r _ {d} ^ {*} \\right\\}\\right) = 0: \\tag {31}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{for some } i, j, \\text{ such that } F_{T,i} \\neq F_{T,j},</span></div>

    <div class="my-4 text-center"><span class="math-block">F _ {T, i} \\left(x ^ {*}, x ^ {*}, \\left\\{v _ {d} ^ {*} \\right\\}, \\left\\{w _ {d} ^ {*} \\right\\}, \\left\\{r _ {d} ^ {*} \\right\\}\\right) - F _ {T, j} \\left(x ^ {*}, x ^ {*}, \\left\\{v _ {d} ^ {*} \\right\\}, \\left\\{w _ {d} ^ {*} \\right\\}, \\left\\{r _ {d} ^ {*} \\right\\}\\right) = 0: \\tag {32}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{for some } i, j, \\text{ such that } F_{T,i} \\neq F_{T,j}.</span></div>

    <p class="text-gray-300">For fixed <span class="math">i</span> and <span class="math">j</span>, the probability of the first and second cases occurring are no more than <span class="math">2/p</span>, where this results from the maximum degree of equation (20). For fixed <span class="math">i</span> and <span class="math">j</span>, the probability of the third and fourth cases occurring are no more than <span class="math">\\tau_2/p</span>, where this results from the maximum degree of equation (22). Finally, for the fifth and sixth cases, the probability is at most <span class="math">2\\tau_2/p</span>, where this results from the maximum degree of equation (24).</p>

    <p class="text-gray-300">Therefore, by summing over all <span class="math">(i,j)</span> pairs in each case, we bound <span class="math">\\mathcal{A}</span>'s overall success probability <span class="math">\\varepsilon \\leq 2\\left(\\frac{\\tau_1}{2}\\right)\\frac{2}{p} + 2\\left(\\frac{\\tau_2}{2}\\right)\\frac{\\tau_2}{p} + 2\\left(\\frac{\\tau_T}{2}\\right)\\frac{2\\tau_2}{p}</span>. Since <span class="math">\\tau_1 + \\tau_2 + \\tau_T \\leq q_G + 3</span>, we end with <span class="math">\\varepsilon \\leq (q_G + 3)^2(2 + q_G + 2q_G)/p = O(q_G^3/p)</span>.</p>

    <p class="text-gray-300">The following corollary is immediate. Here <span class="math">\\gamma = \\varepsilon - \\frac{1}{2}</span>; that is, <span class="math">\\gamma</span> is the adversary's advantage beyond guessing.</p>

    <p class="text-gray-300">Corollary D.4 Any adversary that breaks the Strong SXDH assumption with constant probability <span class="math">\\gamma &amp;gt; 0</span> in generic groups of order <span class="math">p</span> requires <span class="math">\\Omega\\left(\\sqrt[4]{\\gamma p}\\right)</span> generic group operations.</p>

    <p class="text-gray-300">32</p>`;
---

<BaseLayout title="Practical Group Signatures without Random Oracles (2005/385)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2005 &middot; eprint 2005/385
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
