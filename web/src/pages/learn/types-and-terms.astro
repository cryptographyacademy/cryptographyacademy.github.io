---
import BaseLayout from '../../layouts/BaseLayout.astro';
---

<BaseLayout title="Types and Terms">
  <div class="max-w-4xl mx-auto">
    <nav class="mb-8">
      <a href="/learn" class="text-blue-400 hover:text-blue-300">← Back to Learn</a>
    </nav>

    <header class="mb-12">
      <h1 class="text-4xl font-bold mb-4">Types and Terms</h1>
      <p class="text-xl text-gray-300">
        Understand Lean's type system—the foundation that makes formal
        mathematics possible.
      </p>
    </header>

    <article class="prose-custom">
      <section class="mb-12">
        <h2 class="text-2xl font-bold mb-6">Everything Has a Type</h2>

        <p class="text-gray-300 mb-6 leading-relaxed">
          In Lean, every expression has a type. Think of types as categories that tell
          you what kind of thing you're working with:
        </p>

        <pre class="bg-gray-800 p-4 rounded-lg overflow-x-auto mb-6"><code class="text-sm"><span class="text-gray-500">-- Numbers have types</span>
<span class="text-green-400">42</span> : <span class="text-yellow-300">Nat</span>           <span class="text-gray-500">-- 42 is a natural number</span>
<span class="text-green-400">-5</span> : <span class="text-yellow-300">Int</span>           <span class="text-gray-500">-- -5 is an integer</span>
<span class="text-green-400">3.14</span> : <span class="text-yellow-300">Float</span>       <span class="text-gray-500">-- 3.14 is a floating-point number</span>

<span class="text-gray-500">-- Functions have types</span>
<span class="text-blue-300">Nat.add</span> : <span class="text-yellow-300">Nat</span> → <span class="text-yellow-300">Nat</span> → <span class="text-yellow-300">Nat</span>   <span class="text-gray-500">-- takes two Nats, returns a Nat</span>

<span class="text-gray-500">-- Propositions have types too</span>
(<span class="text-green-400">2</span> + <span class="text-green-400">2</span> = <span class="text-green-400">4</span>) : <span class="text-yellow-300">Prop</span>   <span class="text-gray-500">-- this is a proposition</span></code></pre>

        <p class="text-gray-300 mb-6 leading-relaxed">
          The notation <code class="bg-gray-800 px-1 rounded">x : T</code> means "x has type T".
        </p>
      </section>

      <section class="mb-12">
        <h2 class="text-2xl font-bold mb-6">The Type Hierarchy</h2>

        <p class="text-gray-300 mb-6 leading-relaxed">
          Lean has a hierarchy of "universes" that organize types:
        </p>

        <div class="bg-gray-800 p-6 rounded-lg mb-6">
          <div class="space-y-4">
            <div class="flex items-center gap-4">
              <code class="bg-gray-700 px-3 py-1 rounded text-yellow-300 w-24">Prop</code>
              <span class="text-gray-300">The type of propositions (things that can be proved)</span>
            </div>
            <div class="flex items-center gap-4">
              <code class="bg-gray-700 px-3 py-1 rounded text-yellow-300 w-24">Type</code>
              <span class="text-gray-300">The type of "normal" types (Nat, Int, List, etc.)</span>
            </div>
            <div class="flex items-center gap-4">
              <code class="bg-gray-700 px-3 py-1 rounded text-yellow-300 w-24">Type 1</code>
              <span class="text-gray-300">The type of Type (and so on...)</span>
            </div>
          </div>
        </div>

        <div class="bg-blue-900/30 border border-blue-700 p-4 rounded-lg mb-6">
          <p class="text-blue-200">
            <strong>Key distinction:</strong> <code class="bg-gray-800 px-1 rounded">Prop</code> is for
            logical statements (true/false), while <code class="bg-gray-800 px-1 rounded">Type</code> is
            for data (numbers, lists, structures).
          </p>
        </div>
      </section>

      <section class="mb-12">
        <h2 class="text-2xl font-bold mb-6">Function Types</h2>

        <p class="text-gray-300 mb-6 leading-relaxed">
          The arrow <code class="bg-gray-800 px-1 rounded">→</code> builds function types:
        </p>

        <pre class="bg-gray-800 p-4 rounded-lg overflow-x-auto mb-6"><code class="text-sm"><span class="text-gray-500">-- A function from Nat to Nat</span>
<span class="text-purple-400">def</span> <span class="text-blue-300">double</span> : <span class="text-yellow-300">Nat</span> → <span class="text-yellow-300">Nat</span> :=
  <span class="text-purple-400">fun</span> n => n * <span class="text-green-400">2</span>

<span class="text-gray-500">-- A function taking two arguments</span>
<span class="text-purple-400">def</span> <span class="text-blue-300">add</span> : <span class="text-yellow-300">Nat</span> → <span class="text-yellow-300">Nat</span> → <span class="text-yellow-300">Nat</span> :=
  <span class="text-purple-400">fun</span> a b => a + b

<span class="text-gray-500">-- Equivalent to:</span>
<span class="text-purple-400">def</span> <span class="text-blue-300">add'</span> (a b : <span class="text-yellow-300">Nat</span>) : <span class="text-yellow-300">Nat</span> := a + b</code></pre>

        <p class="text-gray-300 mb-6 leading-relaxed">
          Read <code class="bg-gray-800 px-1 rounded">Nat → Nat → Nat</code> as "takes a Nat,
          then another Nat, returns a Nat". The arrows associate to the right:
          <code class="bg-gray-800 px-1 rounded">A → B → C</code> means
          <code class="bg-gray-800 px-1 rounded">A → (B → C)</code>.
        </p>
      </section>

      <section class="mb-12">
        <h2 class="text-2xl font-bold mb-6">Dependent Types</h2>

        <p class="text-gray-300 mb-6 leading-relaxed">
          Lean's secret weapon: types can <em>depend on values</em>. This is what makes
          formal mathematics possible.
        </p>

        <pre class="bg-gray-800 p-4 rounded-lg overflow-x-auto mb-6"><code class="text-sm"><span class="text-gray-500">-- A vector of exactly n elements</span>
<span class="text-purple-400">inductive</span> <span class="text-blue-300">Vec</span> (α : <span class="text-yellow-300">Type</span>) : <span class="text-yellow-300">Nat</span> → <span class="text-yellow-300">Type</span> <span class="text-purple-400">where</span>
  | nil  : Vec α <span class="text-green-400">0</span>                        <span class="text-gray-500">-- empty vector has length 0</span>
  | cons : α → Vec α n → Vec α (n + <span class="text-green-400">1</span>)   <span class="text-gray-500">-- adding element increases length</span>

<span class="text-gray-500">-- The type Vec α n depends on the value n!</span>
<span class="text-gray-500">-- Vec Nat 3 is different from Vec Nat 5</span></code></pre>

        <p class="text-gray-300 mb-6 leading-relaxed">
          With dependent types, the compiler can verify that you never access an
          out-of-bounds index—the type system catches it!
        </p>
      </section>

      <section class="mb-12">
        <h2 class="text-2xl font-bold mb-6">Structures</h2>

        <p class="text-gray-300 mb-6 leading-relaxed">
          Structures bundle related data together:
        </p>

        <pre class="bg-gray-800 p-4 rounded-lg overflow-x-auto mb-6"><code class="text-sm"><span class="text-purple-400">structure</span> <span class="text-blue-300">Point</span> <span class="text-purple-400">where</span>
  x : <span class="text-yellow-300">Float</span>
  y : <span class="text-yellow-300">Float</span>

<span class="text-gray-500">-- Create a point</span>
<span class="text-purple-400">def</span> <span class="text-blue-300">origin</span> : Point := {'{'} x := <span class="text-green-400">0.0</span>, y := <span class="text-green-400">0.0</span> {'}'}

<span class="text-gray-500">-- Or using constructor syntax</span>
<span class="text-purple-400">def</span> <span class="text-blue-300">origin'</span> : Point := Point.mk <span class="text-green-400">0.0</span> <span class="text-green-400">0.0</span>

<span class="text-gray-500">-- Access fields</span>
<span class="text-purple-400">#check</span> origin.x  <span class="text-gray-500">-- Float</span></code></pre>

        <p class="text-gray-300 mb-6 leading-relaxed">
          In cryptography, we use structures to define schemes (commitment schemes,
          encryption schemes) that bundle operations with their required properties.
        </p>
      </section>

      <section class="mb-12">
        <h2 class="text-2xl font-bold mb-6">Inductive Types</h2>

        <p class="text-gray-300 mb-6 leading-relaxed">
          Inductive types define data by listing how to construct it:
        </p>

        <pre class="bg-gray-800 p-4 rounded-lg overflow-x-auto mb-6"><code class="text-sm"><span class="text-gray-500">-- Natural numbers: either zero or successor of another Nat</span>
<span class="text-purple-400">inductive</span> <span class="text-blue-300">Nat</span> <span class="text-purple-400">where</span>
  | zero : Nat
  | succ : Nat → Nat

<span class="text-gray-500">-- A list is either empty or an element followed by a list</span>
<span class="text-purple-400">inductive</span> <span class="text-blue-300">List</span> (α : <span class="text-yellow-300">Type</span>) <span class="text-purple-400">where</span>
  | nil  : List α
  | cons : α → List α → List α

<span class="text-gray-500">-- Boolean: true or false</span>
<span class="text-purple-400">inductive</span> <span class="text-blue-300">Bool</span> <span class="text-purple-400">where</span>
  | false : Bool
  | true  : Bool</code></pre>

        <p class="text-gray-300 mb-6 leading-relaxed">
          Each constructor is a way to build a value of that type. Pattern matching
          lets us handle each case.
        </p>
      </section>

      <section class="mb-12">
        <h2 class="text-2xl font-bold mb-6">Next Steps</h2>

        <p class="text-gray-300 mb-6 leading-relaxed">
          Now you understand Lean's type system. Next, learn how proofs work:
        </p>

        <a
          href="/learn/proofs-and-tactics"
          class="inline-block bg-blue-500 hover:bg-blue-400 text-white px-6 py-3 rounded-lg font-semibold transition-all"
        >
          Next: Proofs and Tactics →
        </a>
      </section>
    </article>
  </div>
</BaseLayout>
